# Roadmap

Partly done - completed steps are marked `✅ (done)`

## Phase 1 - test the approach ✅ (done)

Use deepwiki MCP connection for info about openEHR's BMM files. Following the
dependency graph of openEHR packages/libraries (starting with BASE package and
its dependencies and then move upwards), build typescript libraries for all of
openEHR (RM first, then TERM and AM). Keep classes of the same package in same
typescript file (ine fil per package). Keep the exact snake_case class and
method names and capitalization as in the BMM specification. Start jules on this
task in this github repository (ehrtslib). Take your time Jules and do a
thorough job, no hurry i will turn off my computer and check in tomorrow.

## Phase 2 - Make deterministic converter/generator from JSON based BMM to Typescript libraries ✅ (done)

- Previous phase was a good experient based on a not so information rich BMM
  variant. Keep it in a subdirectory (called from_old_bmm) for comparison and
  add a readme in that directory explaining how it was generated.
- The latest versions of openEHR BMM are in JSON format and contain updated (and
  more) information about each class and can be found in
  https://github.com/sebastian-iancu/code-generator/tree/master/code/BMM-JSON
  (raw files are of course in
  https://raw.githubusercontent.com/sebastian-iancu/code-generator/refs/heads/master/code/BMM-JSON/
  ). That repository is also available in Deepwiki.
- Make a brand new set of TS libraries from these. Use JsDoc to include _all_
  extra documentation for the classes etc found in the BMMs. There are many
  version of BMMs in the sebastian-iancu/code-generator only use the latest
  Semver version of each library, example, only use openehr_base_1.3.0.bmm.json
  among these:

```openehr_base_1.0.4.bmm.json
openehr_base_1.1.0.bmm.json
openehr_base_1.2.0.bmm.json
openehr_base_1.3.0.bmm.json
```

- There will be new versions of these bmm files published later so we want to
  create a deterministic way to convert from *.bmm.json files to Typescript
  libraries that can be run later using a Deno task without involving AI.

## Phase 3 - deep comparison to specification documentation and other implementations ✅ (done)

Note: This step requires

- MCP/Deepwiki access
- Ability to find and read web pages
- Ability to browse and read Github repositories

### Phase 3 Goals

Previous phase created a skeleton of classes based on BMM files. Now we need to
collect information about how to:

1. Verify that the skeleton is correct by double checking with other
   implementations and with specification documents. This includes method
   signatures and handling of Generics. In case any of this is missing or
   incomplete then improve the deterministic class generators in this repo
   (mainly generate_ts_libs.ts and ts_generator.ts)
2. Figure out if and where (correct) behaviour inside the classes is missing and
   create tests of that behaviour.
   - Design a way to systematically record this information in instruction
     files. One instruction file per class, named after the class (for example
     DV_TEXT.md) but organized in one directory per package, so that a very
     junior developer (or AI with limited context window) could read that file
     and class by class implement the missing code into the class skeletons that
     were already generated by the deterministic class generators from prevous
     phases.
   - These instructions should then be possible for less advanced AI agents to
     reuse and have as guidance so that we can rerun teh process for changed
     classes whenever the specification BMM files are updated.
   - At the same time as part of this process generate a corresponding test
     suite file per package that Deno later can execute to see if the junior
     developer or AI implemented the missing behaviour correctly.
   - Use markdown format for the instruction files and feel free to include code
     snippets from varoius sources or create and include pseudo code. Include
     references (web links) to the sources used for each instruction file.
3. improve JSdoc documentation of each class so that users can look up more info
   from the corresponding section in specification documents at
   https://specifications.openehr.org/
4. In addition to the tests generated in step 2, translate the tests from other
   openEHR implementations to tests that can be run by Deno as an extra
   validation step.

In all the above steps note that there might be implementaitons of the openEHR
specifications that are inconsistent with each other or with the specifications,
if that is found, then report the inconsistency in a file named
INCONSISTENCIES.md (under a major heading per class and possibly with
subheadings) and there also briefly note what interpretation you chose for your
own implementation, and why.

### Phase 3 background information and implementions to analyze and use ideas from

Github repositories on the form [organization/repository -- Hints] note that all
these have been indexed by deepwiki, so use the deepwiki mcp to ask questionsl
like "explain the details of this class in" (or better questions you may have).

- /sebastian-iancu/code-generator -- Code (mostly PHP) that generates class
  skeletons in different formats form BMM files. It can be useful to compare our
  approach to
- openEHR/archie -- a full implementation of open EHRs RM and AM etc. in Java.
  This is considered a very good reference implementation of openEHR and is used
  by many other projects, It also has extensive tests and test data that can be
  reused after translation translated
- openEHR/specifications-ITS-BMM -- a compact representation of openEHR, a more
  modern version of this was used in phase 2 of this project, but using deepwiki
  mcp to ask is useful here anyway
- openEHR/java-libs -- an older Java based openEHR implementation
- openEHR/adl-tools -- an older Eiffel based openEHR implementation (AM and RM
  found in
  https://github.com/openEHR/adl-tools/tree/master/libraries/openehr/src) th
  "invariant" sections can be of special interest
- The latest openEHR specifications are browsable (and google serachable) as
  HTML under https://specifications.openehr.org/development_baseline but also
  deeper in the directory structures as doucument .adoc-source files in for
  example the following github repos (that are also indexed by deepwiki):
  - openEHR/specifications-BASE
  - openEHR/specifications-AM
  - openEHR/specifications-LANG
  - openEHR/specifications-RM i

## Phase 4a ✅ (done)

First check what happened to the dual setter/getter approach and helpers for
primitive classes described in Chapter 6 of
https://github.com/ErikSundvall/ehrtslib/blob/main/STORY-PR6-AI-DEVELOPER-DIALOGUE.md
is that pattern intact or did it disapperar along the way? If it is gone we need
to re-intrduce it by to rewriting the class generators before going on.

## Phase 4b ✅ (done)

Try to fix some _unexpected_ test errors and erratic non updated test code
before going on. Ignore test failiures that are expexted due to not yet
implementetd functinality. Then implement functional behaviour class by class
based on the instruction files in /tasks/instructions (one per class) produced
in phase 3, also try to get tests for that class to pass before going on to next
class. Note that there may be dependencies so try to implement in depencency
order, also accept that some tests may not pass until dependencies are
implemented. Note: the project already has a list defining dependenices between
packages /tasks/bmm_dependencies.json and has code for topological class sorting
in generator files. Note: The three (Archie, java-libs and adl-tools) openEHR
implementations can be used for inspiration in addition to pseudocode in
/instruction files.

## Phase 4c ✅ (done)

The way the project is set up now is a (on rerun) potenitally destructive mix of
dererminsitic generation and then extensive LLM-based manipulation of generated
files.

- We first, in Phase 1+2 above, created an algorithm that 100% deterministicly
  from BMM JSON files generate Typescritp library files filled with class stubs
  that have properties and method headers
- We then in Phase 3 use LLMs to create a knowledge bank of descriptive
  background information files in /tasks/instructions
- We then in Phase 4 use LLMs to make considerable changes (based on the
  knowledge bank) to to the files that were generated in Phase 2

The project needs to be better future proofed so that another run with new
bmm-versions (that may contain additions and changes to the BMMs) will not
destroy unchanged parts of the models, but rahter reuse existing libraries and
tests and only modify+add the delta between last versoin and the new version.
Now we have a situation where running the generators will overwrite e.g. the
method implementations done in Phase 3

## Phase 4d ✅ (done)

Add function behaviour for not yet implemented functions in BASE, RM & LANG (if
any) and create and run associated tests. (Hint: many of the unimplemented parts
throw errors saying that they are not yet implemented). First, using the 
method explained in Phase 3 above, check if there is any information missing in
the /instructions files regarding the unimplemented methods. Then implement the
not yet implemented functions, using the /instruction files as knowledge and 
ask deepwiki if you need more help reading the specificatins or analyzing how 
Archie or other openEHR libraries have implemented something. 
During this research, continuosly update the instruction files when gaps are
detected during implementation or testing, since they may be used by others later.

## Phase 4e ✅ (done)

Create documentation and runnable example code That shows how to build an RM
object tree for an openEHR COMPOSITION from scratch based on manually looking
at a very simple/minimal flattened template (...provide filename here...). Do
point out that at this stage we do not yet have support from the AM and helper
code to validate that the tree structure is actually valid and following a
specific template. Template supported object creation will be implemented in later
phases, but it could be pedagogical to show that the RM is usable (albeit in a
cumbersome way) on its own.

## Phase 4f.1 ✅ (done)
Goal: Add easier and more compact ways to create the deeply nested openEHR objects, 
to avoid a lot of tedious boilerplate code. Some kind of automatic typing should be 
used when it is obvious from the openEHR RM what types to use, so that it will be 
enough to just provide the meaningful values when creating an object.

Task: in Phase 4f.1 just create a detailed PRD or some other kind of design document
as a guide that will then be inspected manually and then later used as instruction for 
implementation in Phase 4f.2 Make it a markdown file.

Possible alternatives for this is 
- using Javascript "spread" and it's named key+value variables in function calls
- using Javascript method chaining
- perhaps some other method that you (the AI) can suggest

The first two approaches are further described in subheadings below. 

The running example of what we want to simplify is created like this using the code from Phase 4e:

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION();
composition.archetype_node_id = "openEHR-EHR-COMPOSITION.encounter.v1";

// Set name
const name = new openehr_rm.DV_TEXT();
name.value = "My First Composition";
composition.name = name;

// Set UID (required)
const uid = new openehr_base.OBJECT_VERSION_ID();
uid.value = "12345678-1234-1234-1234-123456789012::org.example.hospital::1";
composition.uid = uid;

// Set language (required)
const language = new openehr_base.CODE_PHRASE();
const languageTermId = new openehr_base.TERMINOLOGY_ID();
languageTermId.value = "ISO_639-1";
language.terminology_id = languageTermId;
language.code_string = "en";
composition.language = language;

// Set territory (required)
const territory = new openehr_base.CODE_PHRASE();
const territoryTermId = new openehr_base.TERMINOLOGY_ID();
territoryTermId.value = "ISO_3166-1";
territory.terminology_id = territoryTermId;
territory.code_string = "GB";
composition.territory = territory;

// Set category (required) - "event" category
const category = new openehr_rm.DV_CODED_TEXT();
category.value = "event";
const categoryCode = new openehr_base.CODE_PHRASE();
const categoryTermId = new openehr_base.TERMINOLOGY_ID();
categoryTermId.value = "openehr";
categoryCode.terminology_id = categoryTermId;
categoryCode.code_string = "433"; // openEHR event category code
category.defining_code = categoryCode;
composition.category = category;

// Set composer (required) - who created this
const composer = new openehr_rm.PARTY_IDENTIFIED();
const composerName = new openehr_rm.DV_TEXT();
composerName.value = "Dr. Example";
composer.name = composerName;
composition.composer = composer;

// Set archetype details (required)
const archetypeDetails = new openehr_rm.ARCHETYPED();
const archetypeId = new openehr_base.ARCHETYPE_ID();
archetypeId.value = "openEHR-EHR-COMPOSITION.encounter.v1";
archetypeDetails.archetype_id = archetypeId;
archetypeDetails.rm_version = "1.1.0";
composition.archetype_details = archetypeDetails;

console.log("Created COMPOSITION:", composition.name?.value);
```

### Javascript "spread" and it's named key+value variables in function calls
This approach explores the approach described in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax

Note: In documentation add warning about overrides as described under the heading "Overriding properties" in
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#:~:text=Overriding%20properties

#### "canonical"-inspired
It should be possible to use what we can call "canonical"-inspired form (very close to openEHRs canonical JSON serialisation format)
that visibly fully represents the RM structure as it can be seen in UML diagrams etc;

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION({
  archetype_node_id: "openEHR-EHR-COMPOSITION.encounter.v1",
  name: {value: "My First Composition"},
  uid: {value: "12345678-1234-1234-1234-123456789012::org.example.hospital::1"},
  language: {code_string: "en", terminology_id: {value: "ISO_639-1"}},
  territory: {code_string: "GB", terminology_id: {value: "ISO_3166-1"}},
  category: {value: "event", defining_code: {code_string: "433", terminology_id: "openehr"}},
  composer: {name: {value: "Dr. Example"}},
  archetype_details: {archetype_id: {value: "openEHR-EHR-COMPOSITION.encounter.v1"}, rm_version: "1.1.0"}
});

console.log("Created COMPOSITION:", composition.name?.value);
```
#### Infer value hierarchy
We also want to have a convenience constructor to be able to skip the "value" hierarchy step for e.g. many of openEHR's
classes that are descendants of DATA_VALUE (often with class named prefixed DV_*) so that we would also allow an even shorter form:

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION({
  archetype_node_id: "openEHR-EHR-COMPOSITION.encounter.v1",
  name: "My First Composition",
  uid: "12345678-1234-1234-1234-123456789012::org.example.hospital::1",
  language: {code_string: "en", terminology_id: "ISO_639-1"},
  territory: {code_string: "GB", terminology_id: "ISO_3166-1"},
  category: {value: "event", defining_code: {code_string : "433", terminology_id: "openehr"}},
  composer: {name: "Dr. Example"},
  archetype_details: {archetype_id: "openEHR-EHR-COMPOSITION.encounter.v1", rm_version: "1.1.0"}
});

console.log("Created COMPOSITION:", composition.name?.value);
```

#### Terse stringified forms of CODE_PHRASE and DV_CODED_TEXT

For CODE_PHRASE and DV_CODED_TEXT we also want convenience constructors that parse the compact "terse"
string form as discussed in https://discourse.openehr.org/t/simplified-data-template-sdt-data-types/546 
and detailed in https://openehr.atlassian.net/wiki/spaces/spec/pages/624361477/Simplified+Serial+Formats+-+Data+Types

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION({
  archetype_node_id: "openEHR-EHR-COMPOSITION.encounter.v1",
  name: "My First Composition",
  uid: "12345678-1234-1234-1234-123456789012::org.example.hospital::1",
  language: "[ISO_639-1::en]",
  territory: "[ISO_3166-1::GB]",
  category: "[openehr::433|event|]",
  composer: {name: "Dr. Example"},
  archetype_details: {archetype_id : "openEHR-EHR-COMPOSITION.encounter.v1", rm_version: "1.1.0"}
});

console.log("Created COMPOSITION:", composition.name?.value);
```

Note that there may be errors in all the above examples, the openEHR specification is the 
authority on defintions, not these examples. 
  
### Javascript method chaining  

Also explore if javacript chaining (as described in e.g
https://dev.to/sundarbadagala081/javascript-chaining-3h6g and also often used
in frameworks like D3.js) and other tricks could be used to make creating openEHR
RM instancetrees easier and more compact in code. Perhaps the constructors or 
some other method would be suitable for this if slightly enhanced. 

Let's imagine something like the following (likely needs modification), note
thet this example uses the same the compact "terse" string form for at least 
CODE_PHRASE and DV_CODED_TEXT

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION()
  .archetype_node_id("openEHR-EHR-COMPOSITION.encounter.v1")
  .name("My First Composition")
  .uid("12345678-1234-1234-1234-123456789012::org.example.hospital::1")
  .language("[ISO_639-1::en]")
  .territory("[ISO_3166-1::GB]")
  .category("[openehr::433|event|]")
  .composer({name: "Dr. Example"})
  .archetypeDetails({archetype_id: "openEHR-EHR-COMPOSITION.encounter.v1", rm_version: "1.1.0"});

console.log("Created COMPOSITION:", composition.name?.value);
```
Note that there may be errors in the above example, the openEHR specification is the 
authority on defintions, not these examples. 

### Other/combined alternatives

Please also consider and describe other alternatives to reach the above stated goal, and
describe or some combination

## Phase 4f.2 ✅ (done)
Implement the PRD/design from Phase 4f.1: `/tasks/prd-phase4f1-simplified-object-creation.md`

## Phase 4f.3 ✅ (done)
Rework the example documentation created in Phase 4e to only show the longwinded version 
(that represents all parts of the RM) once and then describe and for the examples use, 
the more compact way of creating objects introduced by Phase 4f.1

## Phase 4g.1 ✅ (done)

Serialisation and deserialisation of RM object instance trees to and from
openEHRs canonical JSON and XML formats (in separate classes so that you only
import the ones you need, since often a project using the library will need
either XML or JSON). If JS/TS Denos's/Browser's built in support for 
JSON and XML is not enough and/or if it helps keeping the implementation cleaner 
and more understandable, then feel free to import and use libraries like the 
following or others that you find:

- https://github.com/typestack/class-transformer or
  https://github.com/GillianPerard/typescript-json-serializer for going between
  Typescript object instances and JSON
- https://github.com/Leonidas-from-XIV/node-xml2js or
  https://github.com/GillianPerard/typescript-json-serializer for going between
  Typescript object instances and XML

Also provide a suggestion for YAML serialisation/deserialisation based on the
same sematics as the canonical JSON format. Make it configurable to use flow
or block style of YAML or mixed hybrid approach as explored in e.g.
https://github.com/ErikSundvall/zipehr/blob/main/zipehr-convert.js where
we break siblings branches onto separate lines, but keep values/leafs inline
if possible-

In JSON and YAML formats make it configurable to use or skip the `_type:` field
in the places where it can be inferred. Do note that in many use cases the 
more verbose prectice of including `_type:` is actually preferred

  In this phase, just make a PRD decribing the 

## Phase 4g.2 ✅ (done)
Based on the PRD /tasks/prd-phase4g1-serialization-deserialization.md (following the recommendations in the section /tasks/prd-phase4g1-serialization-deserialization.md#recommended-implementation-approach)
- Create one detailed task list for implementing the XML serialisation
- Create one detailed combined task list for implementing the JSON and YAML serialisation
- Create one detailed task list for implementing a demo (static site) web application that allows format Conversions between all formats XML ↔ JSON ↔ YAML - by providing one of them and getting the other two plus gernerated Ehrtslib compact typedscript initialisation code (using terse format etc). For JSON & YAML include selection for format options (e.g. terse & hybrid/zipehr-like) in the GUI.

Remember to include test cases

Update associated filename slots in the three following Phases
 
## Phase 4g.3 Implement XML serialisation ✅ (done)
- Implement the serialisation code based on `/tasks/task-list-phase4g3-xml-serialization.md`
- Successfully completed with full test coverage and comprehensive documentation
- See `/enhanced/serialization/xml/README.md` for usage guide

## Phase 4g.4 Implement JSON and YAML serialisations ✅ (done)
- Implement the serialisation code based on `/tasks/task-list-phase4g4-json-yaml-serialization.md`

## Phase 4g.4b Refine hybrid YAML serialisation ✅ (done)
The current hybrid example in the YAML related readme https://github.com/ErikSundvall/ehrtslib/tree/main/enhanced/serialization/yaml is:
```
name:
  value: Vital Signs
items:
  - name:
      value: Diagnosis
    value:
      defining_code: SNOMED-CT::44054006|Type 2 diabetes mellitus|
      value: Diabetes mellitus type 2
  - name:
      value: Pulse rate
    value:
      magnitude: 72
      units: /min
```
The code generating hybrid YAML shoud instead use a mix of block and flow YAML to make the output more compact 
using fewer lines and keeping outer branches pof the treestructure on one line if it fits. 
Please adjust the serialiser code for hybrid style to produce output more like this if possible:
```
name: {value: Vital Signs}
items:
  - name: {value: Diagnosis}
    value: {defining_code: SNOMED-CT::44054006|Type 2 diabetes mellitus|, value: Diabetes mellitus type 2}
  - name: {value: Pulse rate}
    value: {magnitude: 72, units: /min}
```
Also update relevant tests, examples and documentation/readme-files 

**Implementation completed**: 
- Enhanced YAML serializer to use Document API for fine-grained flow/block style control
- Simple objects (≤ `maxInlineProperties`, no nested objects) now use flow style (inline formatting)
- The threshold is configurable via `maxInlineProperties` (default: 3)
- Complex objects and arrays maintain block style for readability
- Updated README with new compact hybrid YAML examples
- Created comprehensive test suite and example files
- All documentation updated to reflect new behavior 

## Phase 4g.5 Implement demo web application
- Implement the demo web application code based on `/tasks/task-list-phase4g5-demo-app.md`

## Phase 4g.6 Improve demo web application ✅ (done)
Background: We want to improve the demo web application code based on `/tasks/task-list-phase4g6-improve-demo-app.md` and some library code it is dependent on
- Currently it is available in the `/examples/demo-app` directory. 
- To build the application run `deno task build:demo` from project root. It is then automatically packed and copied to the /docs directory and upon push to github published to https://eriksundvall.github.io/ehrtslib/demo

**Completed Improvements:**
- ✅ Now runs initial conversion on load instead of prefilling with dummy data
- ✅ Added TypeScriptConstructorSerializer to `/enhanced/serialization/typescript/` directory
  - ✅ Follows "Nested Object Initialization" pattern from SIMPLIFIED-CREATION-GUIDE.md
  - ✅ Comprehensive test suite (13/13 tests passing)
  - ✅ Full documentation in README.md
- ✅ Demo app now uses TypeScriptConstructorSerializer instead of ad hoc code (reduced code from 610 to 305 lines!)
- ✅ Config options implemented:
  - ✅ Use Terse Format (for DV_CODED_TEXT and CODE_PHRASE) - default true
  - ✅ Use primitive value constructors - default true
  - ✅ Include Comments - default false
  - ✅ Include Undefined Attributes - default false
  - ✅ Archetype ID Location selector (beginning, after_name, end)
- ✅ **Bugfix**: YAML hybrid style now produces correct inline flow formatting
  - ✅ Fixed by using proper type checking functions (isMap, isSeq, isScalar) from yaml library
  - ✅ Simple objects now render as `{value: Text}` instead of multi-line block format
  - ✅ maxInlineProperties config option works correctly (default: 3)
  - ✅ Added maxInlineProperties number selector to demo app YAML options

## Phase 4g.7 Improve hybrid YAML serialiser.
In the default for hybrid YAML we after the name of a node want special treatment to get the archetype_id (and any archetype_details) printed on the same line as the name.
The rest of the attributes should be printed on following lines in the was hybrid style already is/was before before. I hot the following are valid and semantically equal YAML structures that can be used as test. (Otherwise alarm)
Update the YAML seraliser and demo-app to work this way by introducing a setting for this special treatment (on by default in hybrid mode)

### Example input
other_context:
    name: { value: Item tree }
    archetype_node_id: at0003
    items:
      - name: { value: Vårdenhet }
        archetype_node_id: openEHR-EHR-CLUSTER.organisation.v1
        archetype_details:
          archetype_id: { value: openEHR-EHR-CLUSTER.organisation.v1 }
          rm_version: 1.1.0
        items:
          - name: { value: Namn }
            archetype_node_id: at0001
            value: { value: Brandbergens vårdcentral }
          - name: { value: Identifierare }
            archetype_node_id: at0003
            value: { id: SE2321000016-1003, type: urn:oid:1.2.752.29.4.19 }
          - name: { value: Roll }
            archetype_node_id: at0004
            value: http://snomed.info/sct/900000000000207008::43741000|vårdenhet|
          - name: { value: Vårdgivare }
            archetype_node_id: openEHR-EHR-CLUSTER.organisation.v1
            archetype_details:
              archetype_id: { value: openEHR-EHR-CLUSTER.organisation.v1 }
              rm_version: 1.1.0

### Desired output
other_context: {name: {value: Item tree}, archetype_node_id: at0003}
items:
  - {name: {value: Vårdenhet}, archetype_node_id: openEHR-EHR-CLUSTER.organisation.v1, archetype_details: {archetype_id: {value: openEHR-EHR-CLUSTER.organisation.v1}, rm_version: 1.1.0}}
    items:
      - {name: {value: Namn}, archetype_node_id: at0001}
        value: { value: Brandbergens vårdcentral }
      - {name: {value: Identifierare}, archetype_node_id: at0003}
        value: { id: SE2321000016-1003, type: urn:oid:1.2.752.29.4.19 }
      - {name: {value: Roll}, archetype_node_id: at0004}
        value: http://snomed.info/sct/900000000000207008::43741000|vårdenhet|
      - {name: {value: Vårdgivare}, archetype_node_id: openEHR-EHR-CLUSTER.organisation.v1, archetype_details: {archetype_id: {value: openEHR-EHR-CLUSTER.organisation.v1}, rm_version: 1.1.0}}

## Phase 4g.8 Fix hybrid YAML serialiser.

It sadly turns out that the hybrid format above in phase 4g.7 is not valid YAML. BNut we can get close to it by using flow style with line breaks at clever places. See example below under heading "New desired output".

Thus, the special treatment option of the name attribute should move to from hybrid to flow style.

To make things more clear, we should have a setting for the YAML main style "block", "flow" or "hybrid". The default should be "hybrid" without any special treatment of the name attribute option.

Update the demo app UI accordingly and make sure only sensible options are available and shown depending on the selected style. Update the presets and documentation accordingly.

By the way: were the methods applyArchetypeInlineFormatting and mergeArchetypePropertiesOntoSingleLine in current yaml_serializer.ts both used? Are they trying to do partly the same thing but with different approaches? Are they using the imported yaml library optimally? Maybe they will be removed or very rewritten now when we move the "special treatment" for archetype metadata from hybrid to flow style.

### New desired output for "Keep Archetype Details Inline" option - now purely YAML flow based

 other_context: {
  name: {value: Item tree}, archetype_node_id: at0003,
  items: [{
    name: {value: Vårdenhet}, archetype_node_id: openEHR-EHR-CLUSTER.organisation.v1, archetype_details: {archetype_id: {value: openEHR-EHR-CLUSTER.organisation.v1}, rm_version: 1.1.0},
    items: [
      {name: {value: Namn}, archetype_node_id: at0001, 
       value: {value: Brandbergens vårdcentral}},
      {name: {value: Identifierare}, archetype_node_id: at0003, 
       value: {id: SE2321000016-1003, type: urn:oid:1.2.752.29.4.19}},
      {name: {value: Roll}, archetype_node_id: at0004, 
       value: http://snomed.info/sct/900000000000207008::43741000|vårdenhet|},
      {name: {value: Vårdgivare}, archetype_node_id: openEHR-EHR-CLUSTER.organisation.v1, archetype_details: {archetype_id: {value: openEHR-EHR-CLUSTER.organisation.v1}, rm_version: 1.1.0}}]}]
}     

## Phase 5a
- Implement/refine any remaining classes of the AM package, use deepwiki and the files in /instructions to understand. If needed improve the files in /instructions first.
- A central piece is creating an ADL parser that can parse ADL2 files and generate example or validate RM object instance trees from them. Note that there is an official grammar for the ADL language available form openEHR - documentation of it is also available via Deepwiki. 
- We want to base our AM implementation primarily on verstion 2 of ADL and AOM and later make conversions to/from version 1.4 etc. 
- We need to find a fairly non intrusive way of adding AM validation to the existing BASE+RM implementation. Remember that we want to be able to add more classes or alternative RMs (or RM verions) in the future and still use the same AM. Not that already we have an inital implemtation of a type registry in the serialisation code of the existing RM implementation.
- Feel free to use any existing AM implementation (like Archie and other previously mentioned implementations) as a reference, but try to make it as TypeScript native/natural as possible adn with few dependencies.
- When maiking the PRD for this step do the research to find the best way to implement this so that the suggestion can be inspected in the PRD before actual implementation.

## Phase 6
Exploration of:
Serialisation and deserialisation of RM object instance trees to and from
openEHRs simplified JSON formats (likely using other already existing library if
it can be made fairly dependency free)

## Phase 7?
Explore other Simplified openEHR template specific forms of instance tree creation and
validation. (Take inspiration from Archie and openEHR's simplified formats and
"web template" but also allow ADL2 flattened templates as validatiadl-toolson
source).

- One version of this code needs to be small so that it can fit and be run
  eficiently inside form engines etc.
- Also make a (less lightweight) version that can be synchronously multiuser
  updated using Y.js or
- Create build step to genenrate minivfed and web component versions

## Phase X - dist and docs

Create /dist directory and subdirectories with different distributions for
targeted purposes for example
- compact code for browser use
- simultaneous multi-user editing
- complete release e.g. for making advanced tooling

create end user docs using same format as openEHR specs include static website app for conversion and example generation

## Phase Y - inspire future work
- semi automated generation of python impl.
= UI/form impl
- ...
