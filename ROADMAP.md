# Roadmap

Partly done - completed steps are marked `✅ (done)`

## Phase 1 - test the approach ✅ (done)

Use deepwiki MCP connection for info about openEHR's BMM files. Following the
dependency graph of openEHR packages/libraries (starting with BASE package and
its dependencies and then move upwards), build typescript libraries for all of
openEHR (RM first, then TERM and AM). Keep classes of the same package in same
typescript file (ine fil per package). Keep the exact snake_case class and
method names and capitalization as in the BMM specification. Start jules on this
task in this github repository (ehrtslib). Take your time Jules and do a
thorough job, no hurry i will turn off my computer and check in tomorrow.

## Phase 2 - Make deterministic converter/generator from JSON based BMM to Typescript libraries ✅ (done)

- Previous phase was a good experient based on a not so information rich BMM
  variant. Keep it in a subdirectory (called from_old_bmm) for comparison and
  add a readme in that directory explaining how it was generated.
- The latest versions of openEHR BMM are in JSON format and contain updated (and
  more) information about each class and can be found in
  https://github.com/sebastian-iancu/code-generator/tree/master/code/BMM-JSON
  (raw files are of course in
  https://raw.githubusercontent.com/sebastian-iancu/code-generator/refs/heads/master/code/BMM-JSON/
  ). That repository is also available in Deepwiki.
- Make a brand new set of TS libraries from these. Use JsDoc to include _all_
  extra documentation for the classes etc found in the BMMs. There are many
  version of BMMs in the sebastian-iancu/code-generator only use the latest
  Semver version of each library, example, only use openehr_base_1.3.0.bmm.json
  among these:

```openehr_base_1.0.4.bmm.json
openehr_base_1.1.0.bmm.json
openehr_base_1.2.0.bmm.json
openehr_base_1.3.0.bmm.json
```

- There will be new versions of these bmm files published later so we want to
  create a deterministic way to convert from *.bmm.json files to Typescript
  libraries that can be run later using a Deno task without involving AI.

## Phase 3 - deep comparison to specification documentation and other implementations ✅ (done)

Note: This step requires

- MCP/Deepwiki access
- Ability to find and read web pages
- Ability to browse and read Github repositories

### Phase 3 Goals

Previous phase created a skeleton of classes based on BMM files. Now we need to
collect information about how to:

1. Verify that the skeleton is correct by double checking with other
   implementations and with specification documents. This includes method
   signatures and handling of Generics. In case any of this is missing or
   incomplete then improve the deterministic class generators in this repo
   (mainly generate_ts_libs.ts and ts_generator.ts)
2. Figure out if and where (correct) behaviour inside the classes is missing and
   create tests of that behaviour.
   - Design a way to systematically record this information in instruction
     files. One instruction file per class, named after the class (for example
     DV_TEXT.md) but organized in one directory per package, so that a very
     junior developer (or AI with limited context window) could read that file
     and class by class implement the missing code into the class skeletons that
     were already generated by the deterministic class generators from prevous
     phases.
   - These instructions should then be possible for less advanced AI agents to
     reuse and have as guidance so that we can rerun teh process for changed
     classes whenever the specification BMM files are updated.
   - At the same time as part of this process generate a corresponding test
     suite file per package that Deno later can execute to see if the junior
     developer or AI implemented the missing behaviour correctly.
   - Use markdown format for the instruction files and feel free to include code
     snippets from varoius sources or create and include pseudo code. Include
     references (web links) to the sources used for each instruction file.
3. improve JSdoc documentation of each class so that users can look up more info
   from the corresponding section in specification documents at
   https://specifications.openehr.org/
4. In addition to the tests generated in step 2, translate the tests from other
   openEHR implementations to tests that can be run by Deno as an extra
   validation step.

In all the above steps note that there might be implementaitons of the openEHR
specifications that are inconsistent with each other or with the specifications,
if that is found, then report the inconsistency in a file named
INCONSISTENCIES.md (under a major heading per class and possibly with
subheadings) and there also briefly note what interpretation you chose for your
own implementation, and why.

### Phase 3 background information and implementions to analyze and use ideas from

Github repositories on the form [organization/repository -- Hints] note that all
these have been indexed by deepwiki, so use the deepwiki mcp to ask questionsl
like "explain the details of this class in" (or better questions you may have).

- /sebastian-iancu/code-generator -- Code (mostly PHP) that generates class
  skeletons in different formats form BMM files. It can be useful to compare our
  approach to
- openEHR/archie -- a full implementation of open EHRs RM and AM etc. in Java.
  This is considered a very good reference implementation of openEHR and is used
  by many other projects, It also has extensive tests and test data that can be
  reused after translation translated
- openEHR/specifications-ITS-BMM -- a compact representation of openEHR, a more
  modern version of this was used in phase 2 of this project, but using deepwiki
  mcp to ask is useful here anyway
- openEHR/java-libs -- an older Java based openEHR implementation
- openEHR/adl-tools -- an older Eiffel based openEHR implementation (AM and RM
  found in
  https://github.com/openEHR/adl-tools/tree/master/libraries/openehr/src) th
  "invariant" sections can be of special interest
- The latest openEHR specifications are browsable (and google serachable) as
  HTML under https://specifications.openehr.org/development_baseline but also
  deeper in the directory structures as doucument .adoc-source files in for
  example the following github repos (that are also indexed by deepwiki):
  - openEHR/specifications-BASE
  - openEHR/specifications-AM
  - openEHR/specifications-LANG
  - openEHR/specifications-RM i

## Phase 4a ✅ (done)

First check what happened to the dual setter/getter approach and helpers for
primitive classes described in Chapter 6 of
https://github.com/ErikSundvall/ehrtslib/blob/main/STORY-PR6-AI-DEVELOPER-DIALOGUE.md
is that pattern intact or did it disapperar along the way? If it is gone we need
to re-intrduce it by to rewriting the class generators before going on.

## Phase 4b ✅ (done)

Try to fix some _unexpected_ test errors and erratic non updated test code
before going on. Ignore test failiures that are expexted due to not yet
implementetd functinality. Then implement functional behaviour class by class
based on the instruction files in /tasks/instructions (one per class) produced
in phase 3, also try to get tests for that class to pass before going on to next
class. Note that there may be dependencies so try to implement in depencency
order, also accept that some tests may not pass until dependencies are
implemented. Note: the project already has a list defining dependenices between
packages /tasks/bmm_dependencies.json and has code for topological class sorting
in generator files. Note: The three (Archie, java-libs and adl-tools) openEHR
implementations can be used for inspiration in addition to pseudocode in
/instruction files.

## Phase 4c ✅ (done)

The way the project is set up now is a (on rerun) potenitally destructive mix of
dererminsitic generation and then extensive LLM-based manipulation of generated
files.

- We first, in Phase 1+2 above, created an algorithm that 100% deterministicly
  from BMM JSON files generate Typescritp library files filled with class stubs
  that have properties and method headers
- We then in Phase 3 use LLMs to create a knowledge bank of descriptive
  background information files in /tasks/instructions
- We then in Phase 4 use LLMs to make considerable changes (based on the
  knowledge bank) to to the files that were generated in Phase 2

The project needs to be better future proofed so that another run with new
bmm-versions (that may contain additions and changes to the BMMs) will not
destroy unchanged parts of the models, but rahter reuse existing libraries and
tests and only modify+add the delta between last versoin and the new version.
Now we have a situation where running the generators will overwrite e.g. the
method implementations done in Phase 3

## Phase 4d ✅ (done)

Add function behaviour for not yet implemented functions in BASE, RM & LANG (if
any) and create and run associated tests. (Hint: many of the unimplemented parts
throw errors saying that they are not yet implemented). First, using the 
method explained in Phase 3 above, check if there is any information missing in
the /instructions files regarding the unimplemented methods. Then implement the
not yet implemented functions, using the /instruction files as knowledge and 
ask deepwiki if you need more help reading the specificatins or analyzing how 
Archie or other openEHR libraries have implemented something. 
During this research, continuosly update the instruction files when gaps are
detected during implementation or testing, since they may be used by others later.

## Phase 4e

Create documentation and runnable example code That shows how to build an RM
object tree for an openEHR COMPOSITION from scratch based on manually looking
at a very simple/minimal flattened template (...provide filename here...). Do
point out that at this stage we do not yet have support from the AM and helper
code to validate that the tree structure is actually valid and following a
specific template. Template supported object creation will be implemented in later
phases, but it could be pedagogical to show that the RM is usable (albeit in a
cumbersome way) on its own.

## Phase 4f.1
Goal: Add easier and more compact ways to create the deeply nested openEHR objects, 
to avoid a lot of tedious boilerplate code. Some kind of automatic typing should be 
used when it is obvious from the openEHR RM what types to use, so that it will be 
enough to just provide the meaningful values when creating an object.

Task: in Phase 4f.1 just create a detailed PRD or some other kind of design document
as a guide that will then be inspected manually and then later used as instruction for 
implementation in Phase 4f.2 Make it a markdown file.

Possible alternatives for this is 
- using Javascript "spread" and it's named key+value variables in function calls
- using Javascript method chaining
- perhaps some other method that you (the AI) can suggest

The first two approaches are further described in subheadings below. 

The running example of what we want to simplify is created like this using the code from Phase 4e:

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION();
composition.archetype_node_id = "openEHR-EHR-COMPOSITION.encounter.v1";

// Set name
const name = new openehr_rm.DV_TEXT();
name.value = "My First Composition";
composition.name = name;

// Set UID (required)
const uid = new openehr_base.OBJECT_VERSION_ID();
uid.value = "12345678-1234-1234-1234-123456789012::org.example.hospital::1";
composition.uid = uid;

// Set language (required)
const language = new openehr_base.CODE_PHRASE();
const languageTermId = new openehr_base.TERMINOLOGY_ID();
languageTermId.value = "ISO_639-1";
language.terminology_id = languageTermId;
language.code_string = "en";
composition.language = language;

// Set territory (required)
const territory = new openehr_base.CODE_PHRASE();
const territoryTermId = new openehr_base.TERMINOLOGY_ID();
territoryTermId.value = "ISO_3166-1";
territory.terminology_id = territoryTermId;
territory.code_string = "GB";
composition.territory = territory;

// Set category (required) - "event" category
const category = new openehr_rm.DV_CODED_TEXT();
category.value = "event";
const categoryCode = new openehr_base.CODE_PHRASE();
const categoryTermId = new openehr_base.TERMINOLOGY_ID();
categoryTermId.value = "openehr";
categoryCode.terminology_id = categoryTermId;
categoryCode.code_string = "433"; // openEHR event category code
category.defining_code = categoryCode;
composition.category = category;

// Set composer (required) - who created this
const composer = new openehr_rm.PARTY_IDENTIFIED();
const composerName = new openehr_rm.DV_TEXT();
composerName.value = "Dr. Example";
composer.name = composerName;
composition.composer = composer;

// Set archetype details (required)
const archetypeDetails = new openehr_rm.ARCHETYPED();
const archetypeId = new openehr_base.ARCHETYPE_ID();
archetypeId.value = "openEHR-EHR-COMPOSITION.encounter.v1";
archetypeDetails.archetype_id = archetypeId;
archetypeDetails.rm_version = "1.1.0";
composition.archetype_details = archetypeDetails;

console.log("Created COMPOSITION:", composition.name?.value);
```

### Javascript "spread" and it's named key+value variables in function calls
This approach explores the approach described in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax

Note: In documentation add warning about overrides as described under the heading "Overriding properties" in
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#:~:text=Overriding%20properties

#### "canonical"-inspired
It should be possible to use what we can call "canonical"-inspired form (very close to openEHRs canonical JSON serialisation format)
that visibly fully represents the RM structure as it can be seen in UML diagrams etc;

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION({
  archetype_node_id: "openEHR-EHR-COMPOSITION.encounter.v1",
  name: {value: "My First Composition"},
  uid: {value: "12345678-1234-1234-1234-123456789012::org.example.hospital::1"},
  language: {code_string: "en", terminology_id: {value: "ISO_639-1"}},
  territory: {code_string: "GB", terminology_id: {value: "ISO_3166-1"}},
  category: {value: "event", defining_code: {code_string: "433", terminology_id: "openehr"}},
  composer: {name: {value: "Dr. Example"}},
  archetype_details: {archetype_id: {value: "openEHR-EHR-COMPOSITION.encounter.v1"}, rm_version: "1.1.0"}
});

console.log("Created COMPOSITION:", composition.name?.value);
```

We also want to have a convenience constructor to be able to skip the "value" hierarchy step for e.g. many of openEHR's
classes that are descendants of DATA_VALUE (often with class named prefixed DV_*) so that we would also allow an even shorter form:

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION({
  archetype_node_id: "openEHR-EHR-COMPOSITION.encounter.v1",
  name: "My First Composition",
  uid: "12345678-1234-1234-1234-123456789012::org.example.hospital::1",
  language: {code_string: "en", terminology_id: "ISO_639-1"},
  territory: {code_string: "GB", terminology_id: "ISO_3166-1"},
  category: {value: "event", defining_code: {code_string : "433", terminology_id: "openehr"}},
  composer: {name: "Dr. Example"},
  archetype_details: {archetype_id: "openEHR-EHR-COMPOSITION.encounter.v1", rm_version: "1.1.0"}
});

console.log("Created COMPOSITION:", composition.name?.value);
```

For CODE_PHRASE and DV_CODED_TEXT we also want convenience constructors that parse the compact "terse"
string form as discussed in https://discourse.openehr.org/t/simplified-data-template-sdt-data-types/546 
and detailed in https://openehr.atlassian.net/wiki/spaces/spec/pages/624361477/Simplified+Serial+Formats+-+Data+Types

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION({
  archetype_node_id: "openEHR-EHR-COMPOSITION.encounter.v1",
  name: "My First Composition",
  uid: "12345678-1234-1234-1234-123456789012::org.example.hospital::1",
  language: "[ISO_639-1::en]",
  territory: "[ISO_3166-1::GB]",
  category: "[openehr::433|event|]",
  composer: {name: "Dr. Example"},
  archetype_details: {archetype_id : "openEHR-EHR-COMPOSITION.encounter.v1", rm_version: "1.1.0"}
});

console.log("Created COMPOSITION:", composition.name?.value);
```

Note that there may be errors in all the above examples, the openEHR specification is the 
authority on defintions, not these examples. 
  
## Javascript method chaining  

Also explore if javacript chaining (as described in e.g
https://dev.to/sundarbadagala081/javascript-chaining-3h6g and also often used
in frameworks like D3.js) and other tricks could be used to make creating openEHR
RM instancetrees easier and more compact in code. Perhaps the constructors or 
some other method would be suitable for this if slightly enhanced. 

Let's imagine something like the following (likely needs modification), note
thet this example uses the same the compact "terse" string form for at least 
CODE_PHRASE and DV_CODED_TEXT

```typescript
import * as openehr_rm from "./openehr_rm.ts";
import * as openehr_base from "./openehr_base.ts";

// Create a COMPOSITION
const composition = new openehr_rm.COMPOSITION()
  .archetype_node_id("openEHR-EHR-COMPOSITION.encounter.v1")
  .name("My First Composition")
  .uid("12345678-1234-1234-1234-123456789012::org.example.hospital::1")
  .language("[ISO_639-1::en]")
  .territory("[ISO_3166-1::GB]")
  .category("[openehr::433|event|]")
  .composer({name: "Dr. Example"})
  .archetypeDetails({archetype_id: "openEHR-EHR-COMPOSITION.encounter.v1", rm_version: "1.1.0"});

console.log("Created COMPOSITION:", composition.name?.value);
```
Note that there may be errors in the above example, the openEHR specification is the 
authority on defintions, not these examples. 

### Other/combined alternatives

Please also consider and describe other alternatives to reach the above stated goal, and
describe or some combination

## Phase 4f.2
IMplement the PRD/design from Phase 4f.1


## Phase 4f.3
Rework the example documentation created in Phase 4e to only show the longwinded version 
(that represents all parts of the RM) once and then describe and for the examples use, 
the more compact way of creating objects introduced by Phase 4f.1

## Phase 4g

Serialisation and deserialisation of RM object instance trees to and from
openEHRs canonical JSON and XML formats (in separate classes so that you only
import the ones you need, since often a project using the library will need
either XML or JSON). If JS/TS built in support for JSON and XML is not enough
and/or if it helps keeping the implementation cleaner and more understandable
feel free to import and use libraries like the following or others that you
find:

- https://github.com/typestack/class-transformer or
  https://github.com/GillianPerard/typescript-json-serializer for going between
  Typescript object instances and JSON
- https://github.com/Leonidas-from-XIV/node-xml2js or
  https://github.com/GillianPerard/typescript-json-serializer for going between
  Typescript object instances and XML

## Phase 5a
Implement the AM package, use deepwiki and the files in /instructions to understand
AM and the task at hand. Note that there is an official grammar for the ADL language
available form openEHR if needed.



## Pase 5b

Simplified openEHR template specific forms of instance tree creation and
validation. (Take inspiration from Archie and openEHR's simplified formats and
"web template" but also allow ADL2 flattened templates as validatiadl-toolson
source).

- One version of this code needs to be small so that it can fit and be run
  eficiently inside form engines etc.
- Also make a (less lightweight) version that can be synchronously multiuser
  updated using Y.js or
- Create build step to genenrate minivfed and web component versions

## Phase 6

Serialisation and deserialisation of RM object instance trees to and from
openEHRs simplified JSON formats (likely using other already existing library if
it can be made fairly dependency free)

## Phase X

Create /dist directory and subdirectories with different distributions for
targeted purposes
