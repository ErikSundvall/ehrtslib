var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// <define:__BUILD_INFO__>
var define_BUILD_INFO_default;
var init_define_BUILD_INFO = __esm({
  "<define:__BUILD_INFO__>"() {
    define_BUILD_INFO_default = { timestamp: "2026-01-20T11:15:32.627Z", buildId: "OT2RD8S2" };
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    init_define_BUILD_INFO();
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string2, regex) {
      const matches = [];
      let match = regex.exec(string2);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string2);
      }
      return matches;
    };
    var isName = function(string2) {
      const match = regexName.exec(string2);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v2) {
      return typeof v2 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a2, arrayMode) {
      if (a2) {
        const keys = Object.keys(a2);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          if (arrayMode === "strict") {
            target[keys[i3]] = [a2[keys[i3]]];
          } else {
            target[keys[i3]] = a2[keys[i3]];
          }
        }
      }
    };
    exports.getValue = function(v2) {
      if (exports.isExist(v2)) {
        return v2;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    init_define_BUILD_INFO();
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
          i3 += 2;
          i3 = readPI(xmlData, i3);
          if (i3.err)
            return i3;
        } else if (xmlData[i3] === "<") {
          let tagStartPos = i3;
          i3++;
          if (xmlData[i3] === "!") {
            i3 = readCommentAndCDATA(xmlData, i3);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i3] === "/") {
              closingTag = true;
              i3++;
            }
            let tagName = "";
            for (; i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "	" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
              tagName += xmlData[i3];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i3--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
            }
            const result2 = readAttributeStr(xmlData, i3);
            if (result2 === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
            }
            let attrStr = result2.value;
            i3 = result2.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i3 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result2.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else if (tags.length === 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i3++; i3 < xmlData.length; i3++) {
              if (xmlData[i3] === "<") {
                if (xmlData[i3 + 1] === "!") {
                  i3++;
                  i3 = readCommentAndCDATA(xmlData, i3);
                  continue;
                } else if (xmlData[i3 + 1] === "?") {
                  i3 = readPI(xmlData, ++i3);
                  if (i3.err)
                    return i3;
                } else {
                  break;
                }
              } else if (xmlData[i3] === "&") {
                const afterAmp = validateAmpersand(xmlData, i3);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
                i3 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
                }
              }
            }
            if (xmlData[i3] === "<") {
              i3--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i3])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t2) => t2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i3) {
      const start = i3;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] == "?" || xmlData[i3] == " ") {
          const tagname = xmlData.substr(start, i3 - start);
          if (i3 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
          } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
            i3++;
            break;
          } else {
            continue;
          }
        }
      }
      return i3;
    }
    function readCommentAndCDATA(xmlData, i3) {
      if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
        for (i3 += 3; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i3] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      }
      return i3;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i3) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i3];
          } else if (startChar !== xmlData[i3]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i3] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i3];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i3,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i3 = 0; i3 < matches.length; i3++) {
        if (matches[i3][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' has no space in starting.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] !== void 0 && matches[i3][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' is without value.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i3][2] + "' is not allowed.", getPositionFromMatch(matches[i3]));
        }
        const attrName = matches[i3][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i3]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i3]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i3) {
      let re2 = /\d/;
      if (xmlData[i3] === "x") {
        i3++;
        re2 = /[\da-fA-F]/;
      }
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === ";")
          return i3;
        if (!xmlData[i3].match(re2))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i3) {
      i3++;
      if (xmlData[i3] === ";")
        return -1;
      if (xmlData[i3] === "#") {
        i3++;
        return validateNumberAmpersand(xmlData, i3);
      }
      let count = 0;
      for (; i3 < xmlData.length; i3++, count++) {
        if (xmlData[i3].match(/\w/) && count < 20)
          continue;
        if (xmlData[i3] === ";")
          break;
        return -1;
      }
      return i3;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    init_define_BUILD_INFO();
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val) {
        return val;
      },
      attributeValueProcessor: function(attrName, val) {
        return val;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module2) {
    "use strict";
    init_define_BUILD_INFO();
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module2.exports = XmlNode;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module2) {
    init_define_BUILD_INFO();
    var util = require_util();
    function readDocType(xmlData, i3) {
      const entities = {};
      if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
        i3 = i3 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i3)) {
              i3 += 7;
              let entityName, val;
              [entityName, val, i3] = readEntityExp(xmlData, i3 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i3))
              i3 += 8;
            else if (hasBody && isAttlist(xmlData, i3))
              i3 += 8;
            else if (hasBody && isNotation(xmlData, i3))
              i3 += 9;
            else if (isComment)
              comment = true;
            else
              throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i3] === ">") {
            if (comment) {
              if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i3] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i3];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i3 };
    }
    function readEntityExp(xmlData, i3) {
      let entityName = "";
      for (; i3 < xmlData.length && (xmlData[i3] !== "'" && xmlData[i3] !== '"'); i3++) {
        entityName += xmlData[i3];
      }
      entityName = entityName.trim();
      if (entityName.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i3++];
      let val = "";
      for (; i3 < xmlData.length && xmlData[i3] !== startChar; i3++) {
        val += xmlData[i3];
      }
      return [entityName, val, i3];
    }
    function isComment(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-")
        return true;
      return false;
    }
    function isEntity(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y")
        return true;
      return false;
    }
    function isElement(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T")
        return true;
      return false;
    }
    function isAttlist(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T")
        return true;
      return false;
    }
    function isNotation(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N")
        return true;
      return false;
    }
    function validateEntityName(name) {
      if (util.isName(name))
        return name;
      else
        throw new Error(`Invalid entity name ${name}`);
    }
    module2.exports = readDocType;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/strnum@1.1.2/node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/strnum@1.1.2/node_modules/strnum/strnum.js"(exports, module2) {
    init_define_BUILD_INFO();
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
    var consider = {
      hex: true,
      // oct: false,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber2(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (str === "0")
        return 0;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return parse_int(trimmedStr, 16);
      } else if (trimmedStr.search(/[eE]/) !== -1) {
        const notation = trimmedStr.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
        if (notation) {
          if (options.leadingZeros) {
            trimmedStr = (notation[1] || "") + notation[3];
          } else {
            if (notation[2] === "0" && notation[3][0] === ".") {
            } else {
              return str;
            }
          }
          return options.eNotation ? Number(trimmedStr) : str;
        } else {
          return str;
        }
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
            return str;
          else if (options.leadingZeros && leadingZeros === str)
            return 0;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              return numTrimmedByZeros === numStr || sign + numTrimmedByZeros === numStr ? num : str;
            } else {
              return trimmedStr === numStr || trimmedStr === sign + numStr ? num : str;
            }
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    function parse_int(numStr, base) {
      if (parseInt)
        return parseInt(numStr, base);
      else if (Number.parseInt)
        return Number.parseInt(numStr, base);
      else if (window && window.parseInt)
        return window.parseInt(numStr, base);
      else
        throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
    }
    module2.exports = toNumber2;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/ignoreAttributes.js
var require_ignoreAttributes = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/ignoreAttributes.js"(exports, module2) {
    init_define_BUILD_INFO();
    function getIgnoreAttributesFn(ignoreAttributes) {
      if (typeof ignoreAttributes === "function") {
        return ignoreAttributes;
      }
      if (Array.isArray(ignoreAttributes)) {
        return (attrName) => {
          for (const pattern of ignoreAttributes) {
            if (typeof pattern === "string" && attrName === pattern) {
              return true;
            }
            if (pattern instanceof RegExp && pattern.test(attrName)) {
              return true;
            }
          }
        };
      }
      return () => false;
    }
    module2.exports = getIgnoreAttributesFn;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module2) {
    "use strict";
    init_define_BUILD_INFO();
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber2 = require_strnum();
    var getIgnoreAttributesFn = require_ignoreAttributes();
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
          "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_2, str) => String.fromCharCode(Number.parseInt(str, 10)) },
          "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_2, str) => String.fromCharCode(Number.parseInt(str, 16)) }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i3 = 0; i3 < entKeys.length; i3++) {
        const ent = entKeys[i3];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val = val.trim();
        }
        if (val.length > 0) {
          if (!escapeEntities)
            val = this.replaceEntitiesValue(val);
          const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val;
          } else if (typeof newval !== typeof val || newval !== val) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val.trim();
            if (trimmedVal === val) {
              return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i3 = 0; i3 < len; i3++) {
          const attrName = this.resolveNameSpace(matches[i3][1]);
          if (this.ignoreAttributesFn(attrName, jPath)) {
            continue;
          }
          let oldVal = matches[i3][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        const ch = xmlData[i3];
        if (ch === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            let tagData = readTagExp(xmlData, i3, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i3 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i3 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i3 = endIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "!D") {
            const result2 = readDocType(xmlData, i3);
            this.docTypeEntities = result2.entities;
            i3 = result2.i;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i3 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
            if (val == void 0)
              val = "";
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              currentNode.add(this.options.textNodeName, val);
            }
            i3 = closeIndex + 2;
          } else {
            let result2 = readTagExp(xmlData, i3, this.options.removeNSPrefix);
            let tagName = result2.tagName;
            const rawTagName = result2.rawTagName;
            let tagExp = result2.tagExp;
            let attrExpPresent = result2.attrExpPresent;
            let closeIndex = result2.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                i3 = result2.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i3 = result2.closeIndex;
              } else {
                const result3 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                if (!result3)
                  throw new Error(`Unexpected end of ${rawTagName}`);
                i3 = result3.i;
                tagContent = result3.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i3 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i3];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result2 = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result2 === false) {
      } else if (typeof result2 === "string") {
        childNode.tagname = result2;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = currentNode.child.length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i3; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary)
            attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i3, errMsg) {
      const closingIndex = xmlData.indexOf(str, i3);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
      const result2 = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
      if (!result2)
        return;
      let tagExp = result2.data;
      const closeIndex = result2.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substring(0, separatorIndex);
        tagExp = tagExp.substring(separatorIndex + 1).trimStart();
      }
      const rawTagName = tagName;
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result2.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent,
        rawTagName
      };
    }
    function readStopNodeData(xmlData, tagName, i3) {
      const startIndex = i3;
      let openTagCount = 1;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i3),
                  i: closeIndex
                };
              }
            }
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
            i3 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i3, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i3 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val, shouldParse, options) {
      if (shouldParse && typeof val === "string") {
        const newval = val.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber2(val, options);
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    module2.exports = OrderedObjParser;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    init_define_BUILD_INFO();
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val, options);
          if (tagObj[":@"]) {
            assignAttributes(val, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val = val[options.textNodeName];
          } else if (Object.keys(val).length === 0) {
            if (options.alwaysCreateTextNode)
              val[options.textNodeName] = "";
            else
              val = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val];
            } else {
              compressedObj[property] = val;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          const atrrName = keys[i3];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module2) {
    init_define_BUILD_INFO();
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser2 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result2 = validator.validate(xmlData, validationOption);
          if (result2 !== true) {
            throw Error(`${result2.err.msg}:${result2.err.line}:${result2.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module2.exports = XMLParser2;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module2) {
    init_define_BUILD_INFO();
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const tagName = propName(tagObj);
        if (tagName === void 0)
          continue;
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (!obj.hasOwnProperty(key))
          continue;
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          if (!attrMap.hasOwnProperty(attr))
            continue;
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i3 = 0; i3 < options.entities.length; i3++) {
          const entity = options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module2.exports = toXml;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module2) {
    "use strict";
    init_define_BUILD_INFO();
    var buildFromOrderedJs = require_orderedJs2Xml();
    var getIgnoreAttributesFn = require_ignoreAttributes();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a2) {
        return a2;
      },
      attributeValueProcessor: function(attrName, a2) {
        return a2;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0, []).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level, ajPath) {
      let attrStr = "";
      let val = "";
      const jPath = ajPath.join(".");
      for (let key in jObj) {
        if (!Object.prototype.hasOwnProperty.call(jObj, key))
          continue;
        if (typeof jObj[key] === "undefined") {
          if (this.isAttribute(key)) {
            val += "";
          }
        } else if (jObj[key] === null) {
          if (this.isAttribute(key)) {
            val += "";
          } else if (key === this.options.cdataPropName) {
            val += "";
          } else if (key[0] === "?") {
            val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          } else {
            val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr && !this.ignoreAttributesFn(attr, jPath)) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else if (!attr) {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val += this.replaceEntitiesValue(newval);
            } else {
              val += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          let listTagAttr = "";
          for (let j2 = 0; j2 < arrLen; j2++) {
            const item = jObj[key][j2];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                const result2 = this.j2x(item, level + 1, ajPath.concat(key));
                listTagVal += result2.val;
                if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                  listTagAttr += result2.attrStr;
                }
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level, ajPath);
              }
            } else {
              if (this.options.oneListGroup) {
                let textValue = this.options.tagValueProcessor(key, item);
                textValue = this.replaceEntitiesValue(textValue);
                listTagVal += textValue;
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
          }
          val += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L2 = Ks.length;
            for (let j2 = 0; j2 < L2; j2++) {
              attrStr += this.buildAttrPairStr(Ks[j2], "" + jObj[key][Ks[j2]]);
            }
          } else {
            val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
          }
        }
      }
      return { attrStr, val };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val) {
      val = this.options.attributeValueProcessor(attrName, "" + val);
      val = this.replaceEntitiesValue(val);
      if (this.options.suppressBooleanAttributes && val === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val + '"';
    };
    function processTextOrObjNode(object, key, level, ajPath) {
      const result2 = this.j2x(object, level + 1, ajPath.concat(key));
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result2.attrStr, level);
      } else {
        return this.buildObjectNode(result2.val, key, result2.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
      if (val === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if ((attrStr || attrStr === "") && val.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i3 = 0; i3 < this.options.entities.length; i3++) {
          const entity = this.options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module2.exports = Builder;
  }
});

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/fxp.js"(exports, module2) {
    "use strict";
    init_define_BUILD_INFO();
    var validator = require_validator();
    var XMLParser2 = require_XMLParser();
    var XMLBuilder2 = require_json2xml();
    module2.exports = {
      XMLParser: XMLParser2,
      XMLValidator: validator,
      XMLBuilder: XMLBuilder2
    };
  }
});

// src/main.ts
init_define_BUILD_INFO();

// src/examples.ts
init_define_BUILD_INFO();
var EXAMPLES = {
  "dv-text": {
    name: "Simple DV_TEXT",
    description: "A simple text value",
    json: `{
  "_type": "DV_TEXT",
  "value": "Hello, openEHR!"
}`,
    xml: `<?xml version="1.0" encoding="UTF-8"?>
<DV_TEXT xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <value>Hello, openEHR!</value>
</DV_TEXT>`,
    yaml: `_type: DV_TEXT
value: Hello, openEHR!`
  },
  "code-phrase": {
    name: "CODE_PHRASE",
    description: "A coded term reference",
    json: `{
  "_type": "CODE_PHRASE",
  "terminology_id": {
    "_type": "TERMINOLOGY_ID",
    "value": "ISO_639-1"
  },
  "code_string": "en"
}`,
    xml: `<?xml version="1.0" encoding="UTF-8"?>
<CODE_PHRASE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <terminology_id>
    <value>ISO_639-1</value>
  </terminology_id>
  <code_string>en</code_string>
</CODE_PHRASE>`,
    yaml: `_type: CODE_PHRASE
terminology_id:
  _type: TERMINOLOGY_ID
  value: ISO_639-1
code_string: en`
  },
  "dv-coded-text": {
    name: "DV_CODED_TEXT",
    description: "Text with coded terminology",
    json: `{
  "_type": "DV_CODED_TEXT",
  "value": "event",
  "defining_code": {
    "_type": "CODE_PHRASE",
    "terminology_id": {
      "_type": "TERMINOLOGY_ID",
      "value": "openehr"
    },
    "code_string": "433"
  }
}`,
    xml: `<?xml version="1.0" encoding="UTF-8"?>
<DV_CODED_TEXT xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <value>event</value>
  <defining_code>
    <terminology_id>
      <value>openehr</value>
    </terminology_id>
    <code_string>433</code_string>
  </defining_code>
</DV_CODED_TEXT>`,
    yaml: `_type: DV_CODED_TEXT
value: event
defining_code:
  _type: CODE_PHRASE
  terminology_id:
    _type: TERMINOLOGY_ID
    value: openehr
  code_string: '433'`
  },
  "basic-composition": {
    name: "Basic COMPOSITION",
    description: "Simple composition structure",
    json: `{
  "_type": "COMPOSITION",
  "name": {"_type": "DV_TEXT", "value": "Vital Signs Encounter"},
  "archetype_node_id": "openEHR-EHR-COMPOSITION.encounter.v1",
  "language": {"_type": "CODE_PHRASE", "terminology_id": {"_type": "TERMINOLOGY_ID", "value": "ISO_639-1"}, "code_string": "en"},
  "territory": {"_type": "CODE_PHRASE", "terminology_id": {"_type": "TERMINOLOGY_ID", "value": "ISO_3166-1"}, "code_string": "GB"},
  "category": {"_type": "DV_CODED_TEXT", "value": "event", "defining_code": {"_type": "CODE_PHRASE", "terminology_id": {"_type": "TERMINOLOGY_ID", "value": "openehr"}, "code_string": "433"}},
  "composer": {"_type": "PARTY_IDENTIFIED", "name": "Dr. Smith"}
}`,
    xml: `<?xml version="1.0" encoding="UTF-8"?>
<COMPOSITION xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <name xsi:type="DV_TEXT">
    <value>Vital Signs Encounter</value>
  </name>
  <archetype_node_id>openEHR-EHR-COMPOSITION.encounter.v1</archetype_node_id>
  <language>
    <terminology_id>
      <value>ISO_639-1</value>
    </terminology_id>
    <code_string>en</code_string>
  </language>
  <territory>
    <terminology_id>
      <value>ISO_3166-1</value>
    </terminology_id>
    <code_string>GB</code_string>
  </territory>
  <category xsi:type="DV_CODED_TEXT">
    <value>event</value>
    <defining_code>
      <terminology_id>
        <value>openehr</value>
      </terminology_id>
      <code_string>433</code_string>
    </defining_code>
  </category>
  <composer xsi:type="PARTY_IDENTIFIED">
    <name>Dr. Smith</name>
  </composer>
</COMPOSITION>`,
    yaml: `_type: COMPOSITION
name:
  _type: DV_TEXT
  value: Vital Signs Encounter
archetype_node_id: openEHR-EHR-COMPOSITION.encounter.v1
language:
  _type: CODE_PHRASE
  terminology_id:
    _type: TERMINOLOGY_ID
    value: ISO_639-1
  code_string: en
territory:
  _type: CODE_PHRASE
  terminology_id:
    _type: TERMINOLOGY_ID
    value: ISO_3166-1
  code_string: GB
category:
  _type: DV_CODED_TEXT
  value: event
  defining_code:
    _type: CODE_PHRASE
    terminology_id:
      _type: TERMINOLOGY_ID
      value: openehr
    code_string: '433'
composer:
  _type: PARTY_IDENTIFIED
  name: Dr. Smith`
  },
  "complex-composition": {
    name: "Complex COMPOSITION",
    description: "Composition with nested content",
    json: `{
  "_type": "COMPOSITION",
  "name": {"_type": "DV_TEXT", "value": "Vital Signs Encounter"},
  "archetype_node_id": "openEHR-EHR-COMPOSITION.encounter.v1",
  "language": {"_type": "CODE_PHRASE", "terminology_id": {"_type": "TERMINOLOGY_ID", "value": "ISO_639-1"}, "code_string": "en"},
  "territory": {"_type": "CODE_PHRASE", "terminology_id": {"_type": "TERMINOLOGY_ID", "value": "ISO_3166-1"}, "code_string": "GB"},
  "category": {"_type": "DV_CODED_TEXT", "value": "event", "defining_code": {"_type": "CODE_PHRASE", "terminology_id": {"_type": "TERMINOLOGY_ID", "value": "openehr"}, "code_string": "433"}},
  "composer": {"_type": "PARTY_IDENTIFIED", "name": "Dr. Smith"},
  "content": [{
    "_type": "SECTION",
    "name": {"_type": "DV_TEXT", "value": "Vital Signs"},
    "items": [
      {
        "_type": "ELEMENT",
        "name": {"_type": "DV_TEXT", "value": "Diagnosis"},
        "value": {
          "_type": "DV_CODED_TEXT",
          "value": "Diabetes mellitus type 2",
          "defining_code": {
            "_type": "CODE_PHRASE",
            "terminology_id": {"_type": "TERMINOLOGY_ID", "value": "SNOMED-CT"},
            "code_string": "44054006"
          }
        }
      },
      {
        "_type": "ELEMENT",
        "name": {"_type": "DV_TEXT", "value": "Pulse rate"},
        "value": {"_type": "DV_QUANTITY", "magnitude": 72, "units": "/min"}
      }
    ]
  }]
}`,
    xml: `<?xml version="1.0" encoding="UTF-8"?>
<COMPOSITION xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <name xsi:type="DV_TEXT">
    <value>Vital Signs Encounter</value>
  </name>
  <archetype_node_id>openEHR-EHR-COMPOSITION.encounter.v1</archetype_node_id>
  <language>
    <terminology_id>
      <value>ISO_639-1</value>
    </terminology_id>
    <code_string>en</code_string>
  </language>
  <territory>
    <terminology_id>
      <value>ISO_3166-1</value>
    </terminology_id>
    <code_string>GB</code_string>
  </territory>
  <category xsi:type="DV_CODED_TEXT">
    <value>event</value>
    <defining_code>
      <terminology_id>
        <value>openehr</value>
      </terminology_id>
      <code_string>433</code_string>
    </defining_code>
  </category>
  <composer xsi:type="PARTY_IDENTIFIED">
    <name>Dr. Smith</name>
  </composer>
  <content xsi:type="SECTION">
    <name xsi:type="DV_TEXT">
      <value>Vital Signs</value>
    </name>
    <items xsi:type="ELEMENT">
      <name xsi:type="DV_TEXT">
        <value>Diagnosis</value>
      </name>
      <value xsi:type="DV_CODED_TEXT">
        <value>Diabetes mellitus type 2</value>
        <defining_code>
          <terminology_id>
            <value>SNOMED-CT</value>
          </terminology_id>
          <code_string>44054006</code_string>
        </defining_code>
      </value>
    </items>
    <items xsi:type="ELEMENT">
      <name xsi:type="DV_TEXT">
        <value>Pulse rate</value>
      </name>
      <value xsi:type="DV_QUANTITY">
        <magnitude>72</magnitude>
        <units>/min</units>
      </value>
    </items>
  </content>
</COMPOSITION>`,
    yaml: `_type: COMPOSITION
name:
  _type: DV_TEXT
  value: Vital Signs Encounter
archetype_node_id: openEHR-EHR-COMPOSITION.encounter.v1
language:
  _type: CODE_PHRASE
  terminology_id:
    _type: TERMINOLOGY_ID
    value: ISO_639-1
  code_string: en
territory:
  _type: CODE_PHRASE
  terminology_id:
    _type: TERMINOLOGY_ID
    value: ISO_3166-1
  code_string: GB
category:
  _type: DV_CODED_TEXT
  value: event
  defining_code:
    _type: CODE_PHRASE
    terminology_id:
      _type: TERMINOLOGY_ID
      value: openehr
    code_string: '433'
composer:
  _type: PARTY_IDENTIFIED
  name: Dr. Smith
content:
  - _type: SECTION
    name:
      _type: DV_TEXT
      value: Vital Signs
    items:
      - _type: ELEMENT
        name:
          _type: DV_TEXT
          value: Diagnosis
        value:
          _type: DV_CODED_TEXT
          value: Diabetes mellitus type 2
          defining_code:
            _type: CODE_PHRASE
            terminology_id:
              _type: TERMINOLOGY_ID
              value: SNOMED-CT
            code_string: '44054006'
      - _type: ELEMENT
        name:
          _type: DV_TEXT
          value: Pulse rate
        value:
          _type: DV_QUANTITY
          magnitude: 72
          units: /min`
  },
  "realistic-composition": {
    name: "Realistic Template Composition",
    description: "Real-world example (ChemoForm-MBA) with Clusters and Observations",
    json: `{
  "_type": "COMPOSITION",
  "name": {
    "_type": "DV_TEXT",
    "value": "ChemoForm-MBA.v7"
  },
  "uid": {
    "_type": "OBJECT_VERSION_ID",
    "value": "573b2f9c-d267-4052-ae09-7b58dcfd6233::regionstockholm_se::1"
  },
  "archetype_details": {
    "_type": "ARCHETYPED",
    "archetype_id": {
      "_type": "ARCHETYPE_ID",
      "value": "openEHR-EHR-COMPOSITION.self_reported_data.v1"
    },
    "template_id": {
      "_type": "TEMPLATE_ID",
      "value": "ChemoForm-MBA.v7"
    },
    "rm_version": "1.1.0"
  },
  "feeder_audit": {
    "_type": "FEEDER_AUDIT",
    "original_content": {
      "_type": "DV_PARSABLE",
      "value": "{}",
      "formalism": "application/json"
    },
    "originating_system_audit": {
      "_type": "FEEDER_AUDIT_DETAILS",
      "system_id": "FormRenderer"
    }
  },
  "archetype_node_id": "openEHR-EHR-COMPOSITION.self_reported_data.v1",
  "language": {
    "_type": "CODE_PHRASE",
    "terminology_id": {
      "_type": "TERMINOLOGY_ID",
      "value": "ISO_639-1"
    },
    "code_string": "sv"
  },
  "territory": {
    "_type": "CODE_PHRASE",
    "terminology_id": {
      "_type": "TERMINOLOGY_ID",
      "value": "ISO_3166-1"
    },
    "code_string": "SI"
  },
  "category": {
    "_type": "DV_CODED_TEXT",
    "value": "event",
    "defining_code": {
      "_type": "CODE_PHRASE",
      "terminology_id": {
        "_type": "TERMINOLOGY_ID",
        "value": "openehr"
      },
      "code_string": "433"
    }
  },
  "composer": {
    "_type": "PARTY_IDENTIFIED",
    "name": "erik.sundvall@regionstockholm.se"
  },
  "context": {
    "_type": "EVENT_CONTEXT",
    "start_time": {
      "_type": "DV_DATE_TIME",
      "value": "2023-08-31T18:31:16.004+02:00"
    },
    "setting": {
      "_type": "DV_CODED_TEXT",
      "value": "other care",
      "defining_code": {
        "_type": "CODE_PHRASE",
        "terminology_id": {
          "_type": "TERMINOLOGY_ID",
          "value": "openehr"
        },
        "code_string": "238"
      }
    },
    "other_context": {
      "_type": "ITEM_TREE",
      "name": {
        "_type": "DV_TEXT",
        "value": "Item tree"
      },
      "archetype_node_id": "at0003",
      "items": [
        {
          "_type": "CLUSTER",
          "name": {
            "_type": "DV_TEXT",
            "value": "V\xE5rdenhet"
          },
          "archetype_details": {
            "_type": "ARCHETYPED",
            "archetype_id": {
              "_type": "ARCHETYPE_ID",
              "value": "openEHR-EHR-CLUSTER.organisation.v1"
            },
            "rm_version": "1.1.0"
          },
          "archetype_node_id": "openEHR-EHR-CLUSTER.organisation.v1",
          "items": [
            {
              "_type": "ELEMENT",
              "name": {
                "_type": "DV_TEXT",
                "value": "Namn"
              },
              "archetype_node_id": "at0001",
              "value": {
                "_type": "DV_TEXT",
                "value": "Brandbergens v\xE5rdcentral"
              }
            },
            {
              "_type": "ELEMENT",
              "name": {
                "_type": "DV_TEXT",
                "value": "Identifierare"
              },
              "archetype_node_id": "at0003",
              "value": {
                "_type": "DV_IDENTIFIER",
                "id": "SE2321000016-1003",
                "type": "urn:oid:1.2.752.29.4.19"
              }
            },
            {
              "_type": "ELEMENT",
              "name": {
                "_type": "DV_TEXT",
                "value": "Roll"
              },
              "archetype_node_id": "at0004",
              "value": {
                "_type": "DV_CODED_TEXT",
                "value": "v\xE5rdenhet",
                "defining_code": {
                  "_type": "CODE_PHRASE",
                  "terminology_id": {
                    "_type": "TERMINOLOGY_ID",
                    "value": "http://snomed.info/sct/900000000000207008"
                  },
                  "code_string": "43741000"
                }
              }
            },
            {
              "_type": "CLUSTER",
              "name": {
                "_type": "DV_TEXT",
                "value": "V\xE5rdgivare"
              },
              "archetype_details": {
                "_type": "ARCHETYPED",
                "archetype_id": {
                  "_type": "ARCHETYPE_ID",
                  "value": "openEHR-EHR-CLUSTER.organisation.v1"
                },
                "rm_version": "1.1.0"
              },
              "archetype_node_id": "openEHR-EHR-CLUSTER.organisation.v1",
              "items": [
                {
                  "_type": "ELEMENT",
                  "name": {
                    "_type": "DV_TEXT",
                    "value": "Namn"
                  },
                  "archetype_node_id": "at0001",
                  "value": {
                    "_type": "DV_TEXT",
                    "value": "Stockholms l\xE4ns sjukv\xE5rdsomr\xE5de"
                  }
                },
                {
                  "_type": "ELEMENT",
                  "name": {
                    "_type": "DV_TEXT",
                    "value": "Identifierare"
                  },
                  "archetype_node_id": "at0003",
                  "value": {
                    "_type": "DV_IDENTIFIER",
                    "id": "SE2321000016-2GJS",
                    "type": "urn:oid:1.2.752.29.4.19"
                  }
                },
                {
                  "_type": "ELEMENT",
                  "name": {
                    "_type": "DV_TEXT",
                    "value": "Organisationsnummer"
                  },
                  "archetype_node_id": "at0003",
                  "value": {
                    "_type": "DV_IDENTIFIER",
                    "id": "2232084",
                    "type": "urn:oid:2.5.4.97"
                  }
                },
                {
                  "_type": "ELEMENT",
                  "name": {
                    "_type": "DV_TEXT",
                    "value": "Roll"
                  },
                  "archetype_node_id": "at0004",
                  "value": {
                    "_type": "DV_CODED_TEXT",
                    "value": "v\xE5rdgivare",
                    "defining_code": {
                      "_type": "CODE_PHRASE",
                      "terminology_id": {
                        "_type": "TERMINOLOGY_ID",
                        "value": "http://snomed.info/sct/45991000052106"
                      },
                      "code_string": "143591000052106"
                    }
                  }
                }
              ]
            }
          ]
        }
      ]
    }
  },
  "content": [
    {
      "_type": "OBSERVATION",
      "name": {
        "_type": "DV_TEXT",
        "value": "Fr\xE5geformul\xE4r f\xF6r symptom och andra tecken"
      },
      "archetype_details": {
        "_type": "ARCHETYPED",
        "archetype_id": {
          "_type": "ARCHETYPE_ID",
          "value": "openEHR-EHR-OBSERVATION.symptom_sign_screening.v1"
        },
        "rm_version": "1.1.0"
      },
      "archetype_node_id": "openEHR-EHR-OBSERVATION.symptom_sign_screening.v1",
      "language": {
        "_type": "CODE_PHRASE",
        "terminology_id": {
          "_type": "TERMINOLOGY_ID",
          "value": "ISO_639-1"
        },
        "code_string": "sv"
      },
      "encoding": {
        "_type": "CODE_PHRASE",
        "terminology_id": {
          "_type": "TERMINOLOGY_ID",
          "value": "IANA_character-sets"
        },
        "code_string": "UTF-8"
      },
      "subject": {
        "_type": "PARTY_SELF"
      },
      "data": {
        "_type": "HISTORY",
        "name": {
          "_type": "DV_TEXT",
          "value": "History"
        },
        "archetype_node_id": "at0001",
        "origin": {
          "_type": "DV_DATE_TIME",
          "value": "2023-08-31T18:31:16.004+02:00"
        },
        "events": [
          {
            "_type": "POINT_EVENT",
            "name": {
              "_type": "DV_TEXT",
              "value": "Ospecificerad h\xE4ndelse"
            },
            "archetype_node_id": "at0002",
            "time": {
              "_type": "DV_DATE_TIME",
              "value": "2023-08-31T18:31:16.004+02:00"
            },
            "data": {
              "_type": "ITEM_TREE",
              "name": {
                "_type": "DV_TEXT",
                "value": "Tree"
              },
              "archetype_node_id": "at0003",
              "items": [
                {
                  "_type": "ELEMENT",
                  "name": {
                    "_type": "DV_TEXT",
                    "value": "Screeningssyfte"
                  },
                  "archetype_node_id": "at0034",
                  "value": {
                    "_type": "DV_CODED_TEXT",
                    "value": "utv\xE4rdering av cytostatikabehandling",
                    "defining_code": {
                      "_type": "CODE_PHRASE",
                      "terminology_id": {
                        "_type": "TERMINOLOGY_ID",
                        "value": "SNOMED-CT"
                      },
                      "code_string": "385785003"
                    }
                  }
                },
                {
                  "_type": "CLUSTER",
                  "name": {
                    "_type": "DV_TEXT",
                    "value": "Tr\xF6tthet"
                  },
                  "archetype_details": {
                    "_type": "ARCHETYPED",
                    "archetype_id": {
                      "_type": "ARCHETYPE_ID",
                      "value": "openEHR-EHR-CLUSTER.specific_symptom_sign_question.v0"
                    },
                    "rm_version": "1.1.0"
                  },
                  "archetype_node_id": "openEHR-EHR-CLUSTER.specific_symptom_sign_question.v0",
                  "items": [
                    {
                      "_type": "ELEMENT",
                      "name": {
                        "_type": "DV_TEXT",
                        "value": "Symptom/tecken-ben\xE4mning"
                      },
                      "archetype_node_id": "at0004",
                      "value": {
                        "_type": "DV_CODED_TEXT",
                        "value": "tr\xF6tthet (fatigue)",
                        "defining_code": {
                          "_type": "CODE_PHRASE",
                          "terminology_id": {
                            "_type": "TERMINOLOGY_ID",
                            "value": "SNOMED-CT"
                          },
                          "code_string": "84229001"
                        }
                      }
                    },
                    {
                      "_type": "ELEMENT",
                      "name": {
                        "_type": "DV_TEXT",
                        "value": "Upplever du tr\xF6tthet (fatigue) som p\xE5verkar ditt dagliga liv?"
                      },
                      "archetype_node_id": "at0005",
                      "value": {
                        "_type": "DV_CODED_TEXT",
                        "value": "Ja",
                        "defining_code": {
                          "_type": "CODE_PHRASE",
                          "terminology_id": {
                            "_type": "TERMINOLOGY_ID",
                            "value": "local"
                          },
                          "code_string": "at0023"
                        }
                      }
                    },
                    {
                      "_type": "CLUSTER",
                      "name": {
                        "_type": "DV_TEXT",
                        "value": "f\xF6ljdfr\xE5ga"
                      },
                      "archetype_details": {
                        "_type": "ARCHETYPED",
                        "archetype_id": {
                          "_type": "ARCHETYPE_ID",
                          "value": "openEHR-EHR-CLUSTER.followup_question.v0"
                        },
                        "rm_version": "1.1.0"
                      },
                      "archetype_node_id": "openEHR-EHR-CLUSTER.followup_question.v0",
                      "items": [
                        {
                          "_type": "ELEMENT",
                          "name": {
                            "_type": "DV_TEXT",
                            "value": "Hur p\xE5verkar tr\xF6ttheten ditt dagliga liv?"
                          },
                          "archetype_node_id": "at0002",
                          "value": {
                            "_type": "DV_ORDINAL",
                            "value": 2,
                            "symbol": {
                              "_type": "DV_CODED_TEXT",
                              "value": "M\xE5ttlig tr\xF6tthet, vilar mindre \xE4n 50% av vaken tid",
                              "defining_code": {
                                "_type": "CODE_PHRASE",
                                "terminology_id": {
                                  "_type": "TERMINOLOGY_ID",
                                  "value": "local"
                                },
                                "code_string": "at0.17"
                              }
                            }
                          }
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          }
        ]
      }
    }
  ]
}`
  }
};

// src/converter.ts
init_define_BUILD_INFO();

// ../../enhanced/serialization/json/mod.ts
init_define_BUILD_INFO();

// ../../enhanced/serialization/json/json_canonical_serializer.ts
init_define_BUILD_INFO();

// ../../enhanced/serialization/common/type_registry.ts
init_define_BUILD_INFO();
var TypeRegistry = class {
  static typeNameToConstructor = /* @__PURE__ */ new Map();
  static constructorToTypeName = /* @__PURE__ */ new Map();
  static instanceToTypeName = /* @__PURE__ */ new WeakMap();
  /**
   * Register a class with its openEHR type name
   * @param typeName - The openEHR type name (e.g., "COMPOSITION", "DV_TEXT")
   * @param constructor - The class constructor
   */
  static register(typeName, constructor) {
    this.typeNameToConstructor.set(typeName, constructor);
    this.constructorToTypeName.set(constructor, typeName);
  }
  /**
   * Get constructor for a type name
   * @param typeName - The openEHR type name
   * @returns The constructor function or undefined if not found
   */
  static getConstructor(typeName) {
    return this.typeNameToConstructor.get(typeName);
  }
  /**
   * Get type name for a constructor
   * @param constructor - The class constructor
   * @returns The type name or undefined if not found
   */
  static getTypeName(constructor) {
    return this.constructorToTypeName.get(constructor);
  }
  /**
   * Get type name from an object instance
   * @param obj - The object instance
   * @returns The type name or undefined if not found
   */
  static getTypeNameFromInstance(obj) {
    if (!obj || typeof obj !== "object") {
      return void 0;
    }
    const cached = this.instanceToTypeName.get(obj);
    if (cached) {
      return cached;
    }
    const typeName = this.constructorToTypeName.get(obj.constructor);
    if (typeName) {
      this.instanceToTypeName.set(obj, typeName);
      return typeName;
    }
    if (obj.constructor && obj.constructor.name) {
      return obj.constructor.name.toUpperCase();
    }
    return void 0;
  }
  /**
   * Check if a type is registered
   * @param typeName - The openEHR type name
   * @returns true if the type is registered
   */
  static hasType(typeName) {
    return this.typeNameToConstructor.has(typeName);
  }
  /**
   * Get all registered type names
   * @returns Array of all registered type names
   */
  static getAllTypeNames() {
    return Array.from(this.typeNameToConstructor.keys());
  }
  /**
   * Clear all registrations (useful for testing)
   */
  static clear() {
    this.typeNameToConstructor.clear();
    this.constructorToTypeName.clear();
  }
  /**
   * Register all classes from a module
   * Scans the module exports and registers all classes that appear to be RM types
   * @param moduleExports - The module exports object (e.g., import * as rm from './openehr_rm.ts')
   * @throws Error if moduleExports contains values that are not functions with prototypes (class constructors)
   */
  static registerModule(moduleExports) {
    for (const [name, value] of Object.entries(moduleExports)) {
      if (typeof value === "function" && value.prototype) {
        this.register(name, value);
      } else {
        throw new Error(
          `Cannot register '${name}': expected a class constructor but got ${typeof value}. Only class constructors can be registered. If importing from a module, ensure it exports only class definitions. Example: import * as rm from './openehr_rm.ts' where openehr_rm.ts exports only classes.`
        );
      }
    }
  }
};

// ../../enhanced/serialization/common/mod.ts
init_define_BUILD_INFO();

// ../../enhanced/serialization/common/type_inference.ts
init_define_BUILD_INFO();
var TypeInferenceEngine = class {
  // Cache for property type mappings
  static propertyTypeMap = /* @__PURE__ */ new Map();
  // List of known polymorphic types
  // These are types that have concrete subtypes that may appear in their place
  static polymorphicTypes = /* @__PURE__ */ new Set([
    "DATA_VALUE",
    "DV_ORDERED",
    "DV_TEXT",
    // DV_CODED_TEXT inherits from DV_TEXT
    "ITEM",
    "ITEM_STRUCTURE",
    "EVENT",
    // POINT_EVENT and INTERVAL_EVENT
    "LOCATABLE",
    "CONTENT_ITEM",
    "CARE_ENTRY",
    "ENTRY",
    "SECTION",
    "PATHABLE",
    "PARTY_IDENTIFIED",
    // PARTY_RELATED inherits from PARTY_IDENTIFIED
    "PARTY_PROXY"
    // Abstract, can be PARTY_SELF, PARTY_IDENTIFIED, or PARTY_RELATED
  ]);
  /**
   * Determine if a type field can be omitted during serialization
   * 
   * @param propertyName - Name of the property holding the value
   * @param parentType - Type name of the parent object
   * @param value - The actual value object
   * @returns true if the type can be safely omitted
   */
  static canOmitType(propertyName, parentType, value) {
    if (!value || typeof value !== "object") {
      return true;
    }
    const valueType = TypeRegistry.getTypeNameFromInstance(value);
    if (!valueType) {
      return false;
    }
    const expectedType = this.getDefaultTypeForProperty(parentType, propertyName);
    if (!expectedType) {
      return false;
    }
    if (this.isPolymorphic(expectedType)) {
      return false;
    }
    return valueType === expectedType;
  }
  /**
   * Infer the type from context during deserialization
   * 
   * @param propertyName - Name of the property
   * @param parentType - Type name of the parent object
   * @param data - The data object being deserialized
   * @returns Inferred type name or undefined if cannot infer
   */
  static inferType(propertyName, parentType, data) {
    const defaultType = this.getDefaultTypeForProperty(parentType, propertyName);
    if (defaultType && !this.isPolymorphic(defaultType)) {
      return defaultType;
    }
    const structureInferred = this.inferFromStructure(data, defaultType);
    if (structureInferred) {
      return structureInferred;
    }
    if (defaultType) {
      if (this.isPolymorphic(defaultType)) {
        if (typeof console !== "undefined" && console.debug) {
          console.debug(
            `TypeInferenceEngine: Using best guess type '${defaultType}' for polymorphic property '${propertyName}' on '${parentType}'`
          );
        }
      }
      return defaultType;
    }
  }
  /**
   * Get the expected/default type for a property on a parent type
   * 
   * @param parentType - Type name of the parent
   * @param propertyName - Name of the property
   * @returns Expected type name or undefined
   */
  static getDefaultTypeForProperty(parentType, propertyName) {
    const key = `${parentType}.${propertyName}`;
    const cached = this.propertyTypeMap.get(key);
    if (cached) {
      return cached.expectedType;
    }
    const mapping = this.buildPropertyTypeMapping(parentType, propertyName);
    if (mapping) {
      this.propertyTypeMap.set(key, mapping);
      return mapping.expectedType;
    }
    return void 0;
  }
  /**
   * Check if a type is polymorphic (has multiple possible subtypes)
   * 
   * @param typeName - The type name to check
   * @returns true if the type is polymorphic
   */
  static isPolymorphic(typeName) {
    return this.polymorphicTypes.has(typeName);
  }
  /**
   * Infer type from the structure of the data object
   * Uses property names as hints to determine type
   * 
   * @param data - The data object
   * @param expectedType - Optional hint about expected type
   * @returns Inferred type name or undefined
   */
  static inferFromStructure(data, expectedType) {
    if (!data || typeof data !== "object") {
      return void 0;
    }
    const properties = Object.keys(data);
    if (properties.includes("value") && !properties.includes("defining_code")) {
      if (!properties.includes("magnitude")) {
        return "DV_TEXT";
      }
    }
    if (properties.includes("value") && properties.includes("defining_code")) {
      return "DV_CODED_TEXT";
    }
    if (properties.includes("terminology_id") && properties.includes("code_string")) {
      return "CODE_PHRASE";
    }
    if (properties.length === 1 && properties.includes("value") && typeof data.value === "string") {
      return "TERMINOLOGY_ID";
    }
    if (properties.includes("magnitude") && properties.includes("units")) {
      return "DV_QUANTITY";
    }
    if (properties.includes("magnitude") && !properties.includes("units")) {
      return "DV_COUNT";
    }
    if (properties.includes("value") && typeof data.value === "boolean") {
      return "DV_BOOLEAN";
    }
    if (properties.includes("value") && typeof data.value === "string" && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(data.value)) {
      return "DV_DATE_TIME";
    }
    if (properties.includes("category") && properties.includes("archetype_node_id")) {
      return "COMPOSITION";
    }
    if (properties.includes("data") && properties.includes("archetype_node_id")) {
      return "OBSERVATION";
    }
    return void 0;
  }
  /**
   * Build property type mapping for a given parent type and property
   * This is a simplified version - would ideally use BMM metadata
   * 
   * @param parentType - The parent type
   * @param propertyName - The property name
   * @returns Property type information or undefined
   */
  static buildPropertyTypeMapping(parentType, propertyName) {
    const mappings = {
      "COMPOSITION": {
        "name": { type: "DV_TEXT", polymorphic: false },
        "language": { type: "CODE_PHRASE", polymorphic: false },
        "category": { type: "DV_CODED_TEXT", polymorphic: false },
        "territory": { type: "CODE_PHRASE", polymorphic: false },
        "context": { type: "EVENT_CONTEXT", polymorphic: false },
        "content": { type: "CONTENT_ITEM", polymorphic: true }
      },
      "DV_CODED_TEXT": {
        "defining_code": { type: "CODE_PHRASE", polymorphic: false }
      },
      "CODE_PHRASE": {
        "terminology_id": { type: "TERMINOLOGY_ID", polymorphic: false }
      },
      "OBSERVATION": {
        "name": { type: "DV_TEXT", polymorphic: false },
        "language": { type: "CODE_PHRASE", polymorphic: false },
        "data": { type: "HISTORY", polymorphic: false }
      },
      "ELEMENT": {
        "name": { type: "DV_TEXT", polymorphic: false },
        "value": { type: "DATA_VALUE", polymorphic: true }
      },
      "PARTY_IDENTIFIED": {
        "name": { type: "DV_TEXT", polymorphic: false }
      }
    };
    const parentMappings = mappings[parentType];
    if (!parentMappings) {
      return void 0;
    }
    const propInfo = parentMappings[propertyName];
    if (!propInfo) {
      return void 0;
    }
    return {
      parentType,
      propertyName,
      expectedType: propInfo.type,
      isPolymorphic: propInfo.polymorphic
    };
  }
  /**
   * Get the property type for a given object path
   * Useful for nested object traversal
   * 
   * @param parentType - The parent type
   * @param propertyName - The property name
   * @returns The expected type or undefined
   */
  static getPropertyType(parentType, propertyName) {
    return this.getDefaultTypeForProperty(parentType, propertyName);
  }
  /**
   * Clear cached type mappings (useful for testing)
   */
  static clearCache() {
    this.propertyTypeMap.clear();
  }
  /**
   * Register additional polymorphic types
   * 
   * @param types - Array of type names that are polymorphic
   */
  static registerPolymorphicTypes(types) {
    types.forEach((type) => this.polymorphicTypes.add(type));
  }
};

// ../../enhanced/serialization/common/hybrid_formatter.ts
init_define_BUILD_INFO();

// ../../enhanced/serialization/common/errors.ts
init_define_BUILD_INFO();
var SerializationError = class _SerializationError extends Error {
  constructor(message, object, cause) {
    super(message);
    this.object = object;
    this.cause = cause;
    this.name = "SerializationError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _SerializationError);
    }
  }
};
var DeserializationError = class _DeserializationError extends Error {
  constructor(message, data, cause) {
    super(message);
    this.data = data;
    this.cause = cause;
    this.name = "DeserializationError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _DeserializationError);
    }
  }
};
var TypeNotFoundError = class _TypeNotFoundError extends DeserializationError {
  constructor(typeName, data) {
    super(`Type not found in registry: ${typeName}`, data);
    this.typeName = typeName;
    this.name = "TypeNotFoundError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _TypeNotFoundError);
    }
  }
};

// ../../enhanced/serialization/json/json_canonical_serializer.ts
var JsonCanonicalSerializer = class {
  TYPE_PROPERTY = "_type";
  INDENT = 2;
  /**
   * Serialize an RM object to canonical JSON string
   * 
   * @param obj - The object to serialize
   * @returns Canonical JSON string with pretty printing
   * @throws SerializationError if serialization fails
   */
  serialize(obj, options) {
    const space = options?.prettyPrint ?? true ? options?.indent ?? this.INDENT : void 0;
    const archIdLocation = options?.archetypeNodeIdLocation ?? "after_name";
    try {
      const jsonObj = this.toJsonObject(obj, archIdLocation);
      return JSON.stringify(jsonObj, null, space);
    } catch (error) {
      throw new SerializationError(
        `Failed to serialize object: ${error instanceof Error ? error.message : String(error)}`,
        obj,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Convert an RM object to a plain JSON object
   * 
   * @param obj - The object to convert
   * @param archIdLocation - Where to place archetype_node_id
   * @returns Plain JSON object
   */
  toJsonObject(obj, archIdLocation = "after_name") {
    if (obj === null || obj === void 0) {
      return null;
    }
    if (typeof obj !== "object") {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.toJsonObject(item, archIdLocation));
    }
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    const result2 = {};
    if (typeName) {
      result2[this.TYPE_PROPERTY] = typeName;
    }
    const allProperties = /* @__PURE__ */ new Set();
    Object.keys(obj).forEach((key) => allProperties.add(key));
    let proto = Object.getPrototypeOf(obj);
    while (proto && proto !== Object.prototype) {
      Object.getOwnPropertyNames(proto).forEach((key) => {
        if (key !== "constructor") {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          if (descriptor && descriptor.get) {
            allProperties.add(key);
          }
        }
      });
      proto = Object.getPrototypeOf(proto);
    }
    const props = Array.from(allProperties).filter((key) => {
      if (key.startsWith("_") || key.startsWith("$"))
        return false;
      if (typeof obj[key] === "function")
        return false;
      if (obj[key] === null || obj[key] === void 0)
        return false;
      return true;
    });
    let orderedKeys = [];
    const hasArchId = props.includes("archetype_node_id");
    const hasName = props.includes("name");
    if (hasArchId) {
      const rest = props.filter((k2) => k2 !== "archetype_node_id");
      if (archIdLocation === "beginning") {
        orderedKeys = ["archetype_node_id", ...rest];
      } else if (archIdLocation === "after_name" && hasName) {
        for (const key of rest) {
          orderedKeys.push(key);
          if (key === "name")
            orderedKeys.push("archetype_node_id");
        }
      } else if (archIdLocation === "end") {
        orderedKeys = [...rest, "archetype_node_id"];
      } else {
        orderedKeys = [...rest, "archetype_node_id"];
      }
    } else {
      orderedKeys = props;
    }
    for (const key of orderedKeys) {
      const value = obj[key];
      const jsonValue = this.toJsonObject(value, archIdLocation);
      if (jsonValue !== void 0) {
        result2[key] = jsonValue;
      }
    }
    return result2;
  }
};

// ../../enhanced/serialization/json/json_canonical_deserializer.ts
init_define_BUILD_INFO();

// ../../enhanced/serialization/json/json_configurable_serializer.ts
init_define_BUILD_INFO();

// ../../enhanced/terse_format.ts
init_define_BUILD_INFO();

// ../../enhanced/openehr_base.ts
var openehr_base_exports = {};
__export(openehr_base_exports, {
  ACCESS_GROUP_REF: () => ACCESS_GROUP_REF,
  ARCHETYPE_ID: () => ARCHETYPE_ID,
  AUTHORED_RESOURCE: () => AUTHORED_RESOURCE,
  Any: () => Any,
  Array: () => Array2,
  BASIC_DEFINITIONS: () => BASIC_DEFINITIONS,
  Boolean: () => Boolean2,
  Byte: () => Byte,
  CODE_PHRASE: () => CODE_PHRASE,
  Cardinality: () => Cardinality,
  Character: () => Character,
  Comparable: () => Comparable,
  Container: () => Container,
  Double: () => Double,
  GENERIC_ID: () => GENERIC_ID,
  HIER_OBJECT_ID: () => HIER_OBJECT_ID,
  Hash: () => Hash,
  INTERNET_ID: () => INTERNET_ID,
  ISO_OID: () => ISO_OID,
  Integer: () => Integer,
  Integer64: () => Integer64,
  Interval: () => Interval,
  Iso8601_date: () => Iso8601_date,
  Iso8601_date_time: () => Iso8601_date_time,
  Iso8601_duration: () => Iso8601_duration,
  Iso8601_time: () => Iso8601_time,
  Iso8601_timezone: () => Iso8601_timezone,
  Iso8601_type: () => Iso8601_type,
  LOCATABLE_REF: () => LOCATABLE_REF,
  List: () => List,
  Multiplicity_interval: () => Multiplicity_interval,
  Numeric: () => Numeric,
  OBJECT_ID: () => OBJECT_ID,
  OBJECT_REF: () => OBJECT_REF,
  OBJECT_VERSION_ID: () => OBJECT_VERSION_ID,
  OPENEHR_DEFINITIONS: () => OPENEHR_DEFINITIONS,
  Octet: () => Octet,
  Ordered: () => Ordered,
  Ordered_Numeric: () => Ordered_Numeric,
  PARTY_REF: () => PARTY_REF,
  Point_interval: () => Point_interval,
  Proper_interval: () => Proper_interval,
  RESOURCE_ANNOTATIONS: () => RESOURCE_ANNOTATIONS,
  RESOURCE_DESCRIPTION: () => RESOURCE_DESCRIPTION,
  RESOURCE_DESCRIPTION_ITEM: () => RESOURCE_DESCRIPTION_ITEM,
  Real: () => Real,
  Set: () => Set2,
  String: () => String2,
  TEMPLATE_ID: () => TEMPLATE_ID,
  TERMINOLOGY_ID: () => TERMINOLOGY_ID,
  TRANSLATION_DETAILS: () => TRANSLATION_DETAILS,
  Temporal: () => Temporal,
  Terminology_code: () => Terminology_code,
  Terminology_term: () => Terminology_term,
  Time_Definitions: () => Time_Definitions,
  UID: () => UID,
  UID_BASED_ID: () => UID_BASED_ID,
  UUID: () => UUID,
  Uri: () => Uri,
  VALIDITY_KIND: () => VALIDITY_KIND,
  VERSION_STATUS: () => VERSION_STATUS,
  VERSION_TREE_ID: () => VERSION_TREE_ID,
  getRegisteredTypes: () => getRegisteredTypes,
  isTypeRegistered: () => isTypeRegistered,
  registerType: () => registerType
});
init_define_BUILD_INFO();

// ../../enhanced/temporal_polyfill.ts
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/temporal-polyfill@0.2.5/node_modules/temporal-polyfill/index.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/temporal-polyfill@0.2.5/node_modules/temporal-polyfill/chunks/classApi.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/temporal-polyfill@0.2.5/node_modules/temporal-polyfill/chunks/internal.js
init_define_BUILD_INFO();
function clampProp(e2, n2, t2, o2, r2) {
  return clampEntity(n2, getDefinedProp(e2, n2), t2, o2, r2);
}
function clampEntity(e2, n2, t2, o2, r2, i3) {
  const a2 = clampNumber(n2, t2, o2);
  if (r2 && n2 !== a2) {
    throw new RangeError(numberOutOfRange(e2, n2, t2, o2, i3));
  }
  return a2;
}
function getDefinedProp(e2, n2) {
  const t2 = e2[n2];
  if (void 0 === t2) {
    throw new TypeError(missingField(n2));
  }
  return t2;
}
function z(e2) {
  return null !== e2 && /object|function/.test(typeof e2);
}
function Jn(e2, n2 = Map) {
  const t2 = new n2();
  return (n3, ...o2) => {
    if (t2.has(n3)) {
      return t2.get(n3);
    }
    const r2 = e2(n3, ...o2);
    return t2.set(n3, r2), r2;
  };
}
function D(e2) {
  return p({
    name: e2
  }, 1);
}
function p(e2, n2) {
  return T((e3) => ({
    value: e3,
    configurable: 1,
    writable: !n2
  }), e2);
}
function O(e2) {
  return T((e3) => ({
    get: e3,
    configurable: 1
  }), e2);
}
function h(e2) {
  return {
    [Symbol.toStringTag]: {
      value: e2,
      configurable: 1
    }
  };
}
function zipProps(e2, n2) {
  const t2 = {};
  let o2 = e2.length;
  for (const r2 of n2) {
    t2[e2[--o2]] = r2;
  }
  return t2;
}
function T(e2, n2, t2) {
  const o2 = {};
  for (const r2 in n2) {
    o2[r2] = e2(n2[r2], r2, t2);
  }
  return o2;
}
function b(e2, n2, t2) {
  const o2 = {};
  for (let r2 = 0; r2 < n2.length; r2++) {
    const i3 = n2[r2];
    o2[i3] = e2(i3, r2, t2);
  }
  return o2;
}
function remapProps(e2, n2, t2) {
  const o2 = {};
  for (let r2 = 0; r2 < e2.length; r2++) {
    o2[n2[r2]] = t2[e2[r2]];
  }
  return o2;
}
function Vn(e2, n2) {
  const t2 = {};
  for (const o2 of e2) {
    t2[o2] = n2[o2];
  }
  return t2;
}
function V(e2, n2) {
  const t2 = {};
  for (const o2 in n2) {
    e2.has(o2) || (t2[o2] = n2[o2]);
  }
  return t2;
}
function nn(e2) {
  e2 = {
    ...e2
  };
  const n2 = Object.keys(e2);
  for (const t2 of n2) {
    void 0 === e2[t2] && delete e2[t2];
  }
  return e2;
}
function C(e2, n2) {
  for (const t2 of n2) {
    if (!(t2 in e2)) {
      return 0;
    }
  }
  return 1;
}
function allPropsEqual(e2, n2, t2) {
  for (const o2 of e2) {
    if (n2[o2] !== t2[o2]) {
      return 0;
    }
  }
  return 1;
}
function zeroOutProps(e2, n2, t2) {
  const o2 = {
    ...t2
  };
  for (let t3 = 0; t3 < n2; t3++) {
    o2[e2[t3]] = 0;
  }
  return o2;
}
function E(e2, ...n2) {
  return (...t2) => e2(...n2, ...t2);
}
function capitalize(e2) {
  return e2[0].toUpperCase() + e2.substring(1);
}
function sortStrings(e2) {
  return e2.slice().sort();
}
function padNumber(e2, n2) {
  return String(n2).padStart(e2, "0");
}
function compareNumbers(e2, n2) {
  return Math.sign(e2 - n2);
}
function clampNumber(e2, n2, t2) {
  return Math.min(Math.max(e2, n2), t2);
}
function divModFloor(e2, n2) {
  return [Math.floor(e2 / n2), modFloor(e2, n2)];
}
function modFloor(e2, n2) {
  return (e2 % n2 + n2) % n2;
}
function divModTrunc(e2, n2) {
  return [divTrunc(e2, n2), modTrunc(e2, n2)];
}
function divTrunc(e2, n2) {
  return Math.trunc(e2 / n2) || 0;
}
function modTrunc(e2, n2) {
  return e2 % n2 || 0;
}
function hasHalf(e2) {
  return 0.5 === Math.abs(e2 % 1);
}
function givenFieldsToBigNano(e2, n2, t2) {
  let o2 = 0, r2 = 0;
  for (let i4 = 0; i4 <= n2; i4++) {
    const n3 = e2[t2[i4]], a3 = Xr[i4], s2 = Qr / a3, [c2, u2] = divModTrunc(n3, s2);
    o2 += u2 * a3, r2 += c2;
  }
  const [i3, a2] = divModTrunc(o2, Qr);
  return [r2 + i3, a2];
}
function nanoToGivenFields(e2, n2, t2) {
  const o2 = {};
  for (let r2 = n2; r2 >= 0; r2--) {
    const n3 = Xr[r2];
    o2[t2[r2]] = divTrunc(e2, n3), e2 = modTrunc(e2, n3);
  }
  return o2;
}
function un(e2) {
  return e2 === X ? si : [];
}
function cn(e2) {
  return e2 === X ? li : [];
}
function ln(e2) {
  return e2 === X ? ["year", "day"] : [];
}
function l2(e2) {
  if (void 0 !== e2) {
    return m(e2);
  }
}
function S(e2) {
  if (void 0 !== e2) {
    return d(e2);
  }
}
function c(e2) {
  if (void 0 !== e2) {
    return u(e2);
  }
}
function d(e2) {
  return requireNumberIsPositive(u(e2));
}
function u(e2) {
  return requireNumberIsInteger(Mi(e2));
}
function on(e2) {
  if (null == e2) {
    throw new TypeError("Cannot be null or undefined");
  }
  return e2;
}
function requirePropDefined(e2, n2) {
  if (null == n2) {
    throw new RangeError(missingField(e2));
  }
  return n2;
}
function de(e2) {
  if (!z(e2)) {
    throw new TypeError(hr);
  }
  return e2;
}
function requireType(e2, n2, t2 = e2) {
  if (typeof n2 !== e2) {
    throw new TypeError(invalidEntity(t2, n2));
  }
  return n2;
}
function requireNumberIsInteger(e2, n2 = "number") {
  if (!Number.isInteger(e2)) {
    throw new RangeError(expectedInteger(n2, e2));
  }
  return e2 || 0;
}
function requireNumberIsPositive(e2, n2 = "number") {
  if (e2 <= 0) {
    throw new RangeError(expectedPositive(n2, e2));
  }
  return e2;
}
function toString(e2) {
  if ("symbol" == typeof e2) {
    throw new TypeError(pr);
  }
  return String(e2);
}
function toStringViaPrimitive(e2, n2) {
  return z(e2) ? String(e2) : m(e2, n2);
}
function toBigInt(e2) {
  if ("string" == typeof e2) {
    return BigInt(e2);
  }
  if ("bigint" != typeof e2) {
    throw new TypeError(invalidBigInt(e2));
  }
  return e2;
}
function toNumber(e2, n2 = "number") {
  if ("bigint" == typeof e2) {
    throw new TypeError(forbiddenBigIntToNumber(n2));
  }
  if (e2 = Number(e2), !Number.isFinite(e2)) {
    throw new RangeError(expectedFinite(n2, e2));
  }
  return e2;
}
function toInteger(e2, n2) {
  return Math.trunc(toNumber(e2, n2)) || 0;
}
function toStrictInteger(e2, n2) {
  return requireNumberIsInteger(toNumber(e2, n2), n2);
}
function toPositiveInteger(e2, n2) {
  return requireNumberIsPositive(toInteger(e2, n2), n2);
}
function createBigNano(e2, n2) {
  let [t2, o2] = divModTrunc(n2, Qr), r2 = e2 + t2;
  const i3 = Math.sign(r2);
  return i3 && i3 === -Math.sign(o2) && (r2 -= i3, o2 += i3 * Qr), [r2, o2];
}
function addBigNanos(e2, n2, t2 = 1) {
  return createBigNano(e2[0] + n2[0] * t2, e2[1] + n2[1] * t2);
}
function moveBigNano(e2, n2) {
  return createBigNano(e2[0], e2[1] + n2);
}
function re(e2, n2) {
  return addBigNanos(n2, e2, -1);
}
function te(e2, n2) {
  return compareNumbers(e2[0], n2[0]) || compareNumbers(e2[1], n2[1]);
}
function bigNanoOutside(e2, n2, t2) {
  return -1 === te(e2, n2) || 1 === te(e2, t2);
}
function bigIntToBigNano(e2, n2 = 1) {
  const t2 = BigInt(Qr / n2);
  return [Number(e2 / t2), Number(e2 % t2) * n2];
}
function he(e2, n2 = 1) {
  const t2 = Qr / n2, [o2, r2] = divModTrunc(e2, t2);
  return [o2, r2 * n2];
}
function bigNanoToBigInt(e2, n2 = 1) {
  const [t2, o2] = e2, r2 = Math.floor(o2 / n2), i3 = Qr / n2;
  return BigInt(t2) * BigInt(i3) + BigInt(r2);
}
function oe(e2, n2 = 1, t2) {
  const [o2, r2] = e2, [i3, a2] = divModTrunc(r2, n2);
  return o2 * (Qr / n2) + (i3 + (t2 ? a2 / n2 : 0));
}
function divModBigNano(e2, n2, t2 = divModFloor) {
  const [o2, r2] = e2, [i3, a2] = t2(r2, n2);
  return [o2 * (Qr / n2) + i3, a2];
}
function hashIntlFormatParts(e2, n2) {
  const t2 = e2.formatToParts(n2), o2 = {};
  for (const e3 of t2) {
    o2[e3.type] = e3.value;
  }
  return o2;
}
function checkIsoYearMonthInBounds(e2) {
  return clampProp(e2, "isoYear", Li, Ai, 1), e2.isoYear === Li ? clampProp(e2, "isoMonth", 4, 12, 1) : e2.isoYear === Ai && clampProp(e2, "isoMonth", 1, 9, 1), e2;
}
function checkIsoDateInBounds(e2) {
  return checkIsoDateTimeInBounds({
    ...e2,
    ...Dt,
    isoHour: 12
  }), e2;
}
function checkIsoDateTimeInBounds(e2) {
  const n2 = clampProp(e2, "isoYear", Li, Ai, 1), t2 = n2 === Li ? 1 : n2 === Ai ? -1 : 0;
  return t2 && checkEpochNanoInBounds(isoToEpochNano({
    ...e2,
    isoDay: e2.isoDay + t2,
    isoNanosecond: e2.isoNanosecond - t2
  })), e2;
}
function checkEpochNanoInBounds(e2) {
  if (!e2 || bigNanoOutside(e2, Ui, qi)) {
    throw new RangeError(Cr);
  }
  return e2;
}
function isoTimeFieldsToNano(e2) {
  return givenFieldsToBigNano(e2, 5, j)[1];
}
function nanoToIsoTimeAndDay(e2) {
  const [n2, t2] = divModFloor(e2, Qr);
  return [nanoToGivenFields(t2, 5, j), n2];
}
function epochNanoToSec(e2) {
  return epochNanoToSecMod(e2)[0];
}
function epochNanoToSecMod(e2) {
  return divModBigNano(e2, _r);
}
function isoToEpochMilli(e2) {
  return isoArgsToEpochMilli(e2.isoYear, e2.isoMonth, e2.isoDay, e2.isoHour, e2.isoMinute, e2.isoSecond, e2.isoMillisecond);
}
function isoToEpochNano(e2) {
  const n2 = isoToEpochMilli(e2);
  if (void 0 !== n2) {
    const [t2, o2] = divModTrunc(n2, Gr);
    return [t2, o2 * be + (e2.isoMicrosecond || 0) * Vr + (e2.isoNanosecond || 0)];
  }
}
function isoToEpochNanoWithOffset(e2, n2) {
  const [t2, o2] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(e2) - n2);
  return checkEpochNanoInBounds(isoToEpochNano({
    ...e2,
    isoDay: e2.isoDay + o2,
    ...t2
  }));
}
function isoArgsToEpochSec(...e2) {
  return isoArgsToEpochMilli(...e2) / Hr;
}
function isoArgsToEpochMilli(...e2) {
  const [n2, t2] = isoToLegacyDate(...e2), o2 = n2.valueOf();
  if (!isNaN(o2)) {
    return o2 - t2 * Gr;
  }
}
function isoToLegacyDate(e2, n2 = 1, t2 = 1, o2 = 0, r2 = 0, i3 = 0, a2 = 0) {
  const s2 = e2 === Li ? 1 : e2 === Ai ? -1 : 0, c2 = /* @__PURE__ */ new Date();
  return c2.setUTCHours(o2, r2, i3, a2), c2.setUTCFullYear(e2, n2 - 1, t2 + s2), [c2, s2];
}
function Ie(e2, n2) {
  let [t2, o2] = moveBigNano(e2, n2);
  o2 < 0 && (o2 += Qr, t2 -= 1);
  const [r2, i3] = divModFloor(o2, be), [a2, s2] = divModFloor(i3, Vr);
  return epochMilliToIso(t2 * Gr + r2, a2, s2);
}
function epochMilliToIso(e2, n2 = 0, t2 = 0) {
  const o2 = Math.ceil(Math.max(0, Math.abs(e2) - zi) / Gr) * Math.sign(e2), r2 = new Date(e2 - o2 * Gr);
  return zipProps(wi, [r2.getUTCFullYear(), r2.getUTCMonth() + 1, r2.getUTCDate() + o2, r2.getUTCHours(), r2.getUTCMinutes(), r2.getUTCSeconds(), r2.getUTCMilliseconds(), n2, t2]);
}
function computeIsoDateParts(e2) {
  return [e2.isoYear, e2.isoMonth, e2.isoDay];
}
function computeIsoMonthsInYear() {
  return xi;
}
function computeIsoDaysInMonth(e2, n2) {
  switch (n2) {
    case 2:
      return computeIsoInLeapYear(e2) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function computeIsoDaysInYear(e2) {
  return computeIsoInLeapYear(e2) ? 366 : 365;
}
function computeIsoInLeapYear(e2) {
  return e2 % 4 == 0 && (e2 % 100 != 0 || e2 % 400 == 0);
}
function computeIsoDayOfWeek(e2) {
  const [n2, t2] = isoToLegacyDate(e2.isoYear, e2.isoMonth, e2.isoDay);
  return modFloor(n2.getUTCDay() - t2, 7) || 7;
}
function computeGregoryEraParts({ isoYear: e2 }) {
  return e2 < 1 ? ["bce", 1 - e2] : ["ce", e2];
}
function computeJapaneseEraParts(e2) {
  const n2 = isoToEpochMilli(e2);
  if (n2 < $i) {
    return computeGregoryEraParts(e2);
  }
  const t2 = hashIntlFormatParts(La(Ti), n2), { era: o2, eraYear: r2 } = parseIntlYear(t2, Ti);
  return [o2, r2];
}
function checkIsoDateTimeFields(e2) {
  return checkIsoDateFields(e2), constrainIsoTimeFields(e2, 1), e2;
}
function checkIsoDateFields(e2) {
  return constrainIsoDateFields(e2, 1), e2;
}
function isIsoDateFieldsValid(e2) {
  return allPropsEqual(Oi, e2, constrainIsoDateFields(e2));
}
function constrainIsoDateFields(e2, n2) {
  const { isoYear: t2 } = e2, o2 = clampProp(e2, "isoMonth", 1, computeIsoMonthsInYear(), n2);
  return {
    isoYear: t2,
    isoMonth: o2,
    isoDay: clampProp(e2, "isoDay", 1, computeIsoDaysInMonth(t2, o2), n2)
  };
}
function constrainIsoTimeFields(e2, n2) {
  return zipProps(j, [clampProp(e2, "isoHour", 0, 23, n2), clampProp(e2, "isoMinute", 0, 59, n2), clampProp(e2, "isoSecond", 0, 59, n2), clampProp(e2, "isoMillisecond", 0, 999, n2), clampProp(e2, "isoMicrosecond", 0, 999, n2), clampProp(e2, "isoNanosecond", 0, 999, n2)]);
}
function H(e2) {
  return void 0 === e2 ? 0 : ua(de(e2));
}
function wn(e2, n2 = 0) {
  e2 = normalizeOptions(e2);
  const t2 = la(e2), o2 = fa(e2, n2);
  return [ua(e2), o2, t2];
}
function ve(e2) {
  return la(normalizeOptions(e2));
}
function _t(e2) {
  return e2 = normalizeOptions(e2), sa(e2, 9, 6, 1);
}
function refineDiffOptions(e2, n2, t2, o2 = 9, r2 = 0, i3 = 4) {
  n2 = normalizeOptions(n2);
  let a2 = sa(n2, o2, r2), s2 = parseRoundingIncInteger(n2), c2 = ha(n2, i3);
  const u2 = aa(n2, o2, r2, 1);
  return null == a2 ? a2 = Math.max(t2, u2) : checkLargestSmallestUnit(a2, u2), s2 = refineRoundingInc(s2, u2, 1), e2 && (c2 = ((e3) => e3 < 4 ? (e3 + 2) % 4 : e3)(c2)), [a2, u2, s2, c2];
}
function refineRoundingOptions(e2, n2 = 6, t2) {
  let o2 = parseRoundingIncInteger(e2 = normalizeOptionsOrString(e2, Hi));
  const r2 = ha(e2, 7);
  let i3 = aa(e2, n2);
  return i3 = requirePropDefined(Hi, i3), o2 = refineRoundingInc(o2, i3, void 0, t2), [i3, o2, r2];
}
function refineDateDisplayOptions(e2) {
  return da(normalizeOptions(e2));
}
function refineTimeDisplayOptions(e2, n2) {
  return refineTimeDisplayTuple(normalizeOptions(e2), n2);
}
function refineTimeDisplayTuple(e2, n2 = 4) {
  const t2 = refineSubsecDigits(e2);
  return [ha(e2, 4), ...refineSmallestUnitAndSubsecDigits(aa(e2, n2), t2)];
}
function refineSmallestUnitAndSubsecDigits(e2, n2) {
  return null != e2 ? [Xr[e2], e2 < 4 ? 9 - 3 * e2 : -1] : [void 0 === n2 ? 1 : 10 ** (9 - n2), n2];
}
function parseRoundingIncInteger(e2) {
  const n2 = e2[_i];
  return void 0 === n2 ? 1 : toInteger(n2, _i);
}
function refineRoundingInc(e2, n2, t2, o2) {
  const r2 = o2 ? Qr : Xr[n2 + 1];
  if (r2) {
    const t3 = Xr[n2];
    if (r2 % ((e2 = clampEntity(_i, e2, 1, r2 / t3 - (o2 ? 0 : 1), 1)) * t3)) {
      throw new RangeError(invalidEntity(_i, e2));
    }
  } else {
    e2 = clampEntity(_i, e2, 1, t2 ? 10 ** 9 : 1, 1);
  }
  return e2;
}
function refineSubsecDigits(e2) {
  let n2 = e2[Ji];
  if (void 0 !== n2) {
    if ("number" != typeof n2) {
      if ("auto" === toString(n2)) {
        return;
      }
      throw new RangeError(invalidEntity(Ji, n2));
    }
    n2 = clampEntity(Ji, Math.floor(n2), 0, 9, 1);
  }
  return n2;
}
function normalizeOptions(e2) {
  return void 0 === e2 ? {} : de(e2);
}
function normalizeOptionsOrString(e2, n2) {
  return "string" == typeof e2 ? {
    [n2]: e2
  } : de(e2);
}
function U(e2) {
  if (void 0 !== e2) {
    if (z(e2)) {
      return Object.assign(/* @__PURE__ */ Object.create(null), e2);
    }
    throw new TypeError(hr);
  }
}
function overrideOverflowOptions(e2, n2) {
  return e2 && Object.assign(/* @__PURE__ */ Object.create(null), e2, {
    overflow: Xi[n2]
  });
}
function refineUnitOption(e2, n2, t2 = 9, o2 = 0, r2) {
  let i3 = n2[e2];
  if (void 0 === i3) {
    return r2 ? o2 : void 0;
  }
  if (i3 = toString(i3), "auto" === i3) {
    return r2 ? o2 : null;
  }
  let a2 = $r[i3];
  if (void 0 === a2 && (a2 = Ei[i3]), void 0 === a2) {
    throw new RangeError(invalidChoice(e2, i3, $r));
  }
  return clampEntity(e2, a2, o2, t2, 1, Et), a2;
}
function refineChoiceOption(e2, n2, t2, o2 = 0) {
  const r2 = t2[e2];
  if (void 0 === r2) {
    return o2;
  }
  const i3 = toString(r2), a2 = n2[i3];
  if (void 0 === a2) {
    throw new RangeError(invalidChoice(e2, i3, n2));
  }
  return a2;
}
function checkLargestSmallestUnit(e2, n2) {
  if (n2 > e2) {
    throw new RangeError(Ar);
  }
}
function _(e2) {
  return {
    branding: Oe,
    epochNanoseconds: e2
  };
}
function Yn(e2, n2, t2) {
  return {
    branding: Te,
    calendar: t2,
    timeZone: n2,
    epochNanoseconds: e2
  };
}
function ee(e2, n2 = e2.calendar) {
  return {
    branding: We,
    calendar: n2,
    ...Vn(Yi, e2)
  };
}
function v(e2, n2 = e2.calendar) {
  return {
    branding: J,
    calendar: n2,
    ...Vn(Bi, e2)
  };
}
function createPlainYearMonthSlots(e2, n2 = e2.calendar) {
  return {
    branding: L,
    calendar: n2,
    ...Vn(Bi, e2)
  };
}
function createPlainMonthDaySlots(e2, n2 = e2.calendar) {
  return {
    branding: q,
    calendar: n2,
    ...Vn(Bi, e2)
  };
}
function Ge(e2) {
  return {
    branding: xe,
    ...Vn(ki, e2)
  };
}
function Vt(e2) {
  return {
    branding: qt,
    sign: computeDurationSign(e2),
    ...Vn(Ni, e2)
  };
}
function M(e2) {
  return epochNanoToSec(e2.epochNanoseconds);
}
function y(e2) {
  return divModBigNano(e2.epochNanoseconds, be)[0];
}
function N(e2) {
  return bigNanoToBigInt(e2.epochNanoseconds, Vr);
}
function B(e2) {
  return bigNanoToBigInt(e2.epochNanoseconds);
}
function extractEpochNano(e2) {
  return e2.epochNanoseconds;
}
function I(e2) {
  return "string" == typeof e2 ? e2 : m(e2.id);
}
function isIdLikeEqual(e2, n2) {
  return e2 === n2 || I(e2) === I(n2);
}
function Ut(e2, n2, t2, o2, r2) {
  const i3 = getMaxDurationUnit(o2), [a2, s2] = ((e3, n3) => {
    const t3 = n3((e3 = normalizeOptionsOrString(e3, Vi))[Ki]);
    let o3 = ca(e3);
    return o3 = requirePropDefined(Vi, o3), [o3, t3];
  })(r2, e2);
  if (isUniformUnit(Math.max(a2, i3), s2)) {
    return totalDayTimeDuration(o2, a2);
  }
  if (!s2) {
    throw new RangeError(zr);
  }
  const [c2, u2, l3] = createMarkerSystem(n2, t2, s2), f2 = createMarkerToEpochNano(l3), d2 = createMoveMarker(l3), m2 = createDiffMarkers(l3), p2 = d2(u2, c2, o2), h2 = m2(u2, c2, p2, a2);
  return isUniformUnit(a2, s2) ? totalDayTimeDuration(h2, a2) : ((e3, n3, t3, o3, r3, i4, a3) => {
    const s3 = computeDurationSign(e3), [c3, u3] = clampRelativeDuration(o3, bi(t3, e3), t3, s3, r3, i4, a3), l4 = computeEpochNanoFrac(n3, c3, u3);
    return e3[F[t3]] + l4 * s3;
  })(h2, f2(p2), a2, u2, c2, f2, d2);
}
function totalDayTimeDuration(e2, n2) {
  return oe(durationFieldsToBigNano(e2), Xr[n2], 1);
}
function clampRelativeDuration(e2, n2, t2, o2, r2, i3, a2) {
  const s2 = F[t2], c2 = {
    ...n2,
    [s2]: n2[s2] + o2
  }, u2 = a2(e2, r2, n2), l3 = a2(e2, r2, c2);
  return [i3(u2), i3(l3)];
}
function computeEpochNanoFrac(e2, n2, t2) {
  const o2 = oe(re(n2, t2));
  if (!o2) {
    throw new RangeError(vr);
  }
  return oe(re(n2, e2)) / o2;
}
function ce(e2, n2) {
  const [t2, o2, r2] = refineRoundingOptions(n2, 5, 1);
  return _(roundBigNano(e2.epochNanoseconds, t2, o2, r2, 1));
}
function Pn(e2, n2, t2) {
  let { epochNanoseconds: o2, timeZone: r2, calendar: i3 } = n2;
  const [a2, s2, c2] = refineRoundingOptions(t2);
  if (0 === a2 && 1 === s2) {
    return n2;
  }
  const u2 = e2(r2);
  if (6 === a2) {
    o2 = ((e3, n3, t3, o3) => {
      const r3 = fn(t3, n3), [i4, a3] = e3(r3), s3 = t3.epochNanoseconds, c3 = we(n3, i4), u3 = we(n3, a3);
      if (bigNanoOutside(s3, c3, u3)) {
        throw new RangeError(vr);
      }
      return roundWithMode(computeEpochNanoFrac(s3, c3, u3), o3) ? u3 : c3;
    })(computeDayInterval, u2, n2, c2);
  } else {
    const e3 = u2.getOffsetNanosecondsFor(o2);
    o2 = getMatchingInstantFor(u2, roundDateTime(Ie(o2, e3), a2, s2, c2), e3, 2, 0, 1);
  }
  return Yn(o2, r2, i3);
}
function dt(e2, n2) {
  return ee(roundDateTime(e2, ...refineRoundingOptions(n2)), e2.calendar);
}
function Ee(e2, n2) {
  const [t2, o2, r2] = refineRoundingOptions(n2, 5);
  var i3;
  return Ge((i3 = r2, roundTimeToNano(e2, computeNanoInc(t2, o2), i3)[0]));
}
function dn(e2, n2) {
  const t2 = e2(n2.timeZone), o2 = fn(n2, t2), [r2, i3] = computeDayInterval(o2), a2 = oe(re(we(t2, r2), we(t2, i3)), Kr, 1);
  if (a2 <= 0) {
    throw new RangeError(vr);
  }
  return a2;
}
function Cn(e2, n2) {
  const { timeZone: t2, calendar: o2 } = n2, r2 = ((e3, n3, t3) => we(n3, e3(fn(t3, n3))))(computeDayFloor, e2(t2), n2);
  return Yn(r2, t2, o2);
}
function roundDateTime(e2, n2, t2, o2) {
  return roundDateTimeToNano(e2, computeNanoInc(n2, t2), o2);
}
function roundDateTimeToNano(e2, n2, t2) {
  const [o2, r2] = roundTimeToNano(e2, n2, t2);
  return checkIsoDateTimeInBounds({
    ...moveByDays(e2, r2),
    ...o2
  });
}
function roundTimeToNano(e2, n2, t2) {
  return nanoToIsoTimeAndDay(roundByInc(isoTimeFieldsToNano(e2), n2, t2));
}
function roundToMinute(e2) {
  return roundByInc(e2, Jr, 7);
}
function computeNanoInc(e2, n2) {
  return Xr[e2] * n2;
}
function computeDayInterval(e2) {
  const n2 = computeDayFloor(e2);
  return [n2, moveByDays(n2, 1)];
}
function computeDayFloor(e2) {
  return Ci(6, e2);
}
function roundDayTimeDurationByInc(e2, n2, t2) {
  const o2 = Math.min(getMaxDurationUnit(e2), 6);
  return nanoToDurationDayTimeFields(roundBigNanoByInc(durationFieldsToBigNano(e2, o2), n2, t2), o2);
}
function roundRelativeDuration(e2, n2, t2, o2, r2, i3, a2, s2, c2, u2) {
  if (0 === o2 && 1 === r2) {
    return e2;
  }
  const l3 = isUniformUnit(o2, s2) ? isZonedEpochSlots(s2) && o2 < 6 && t2 >= 6 ? nudgeZonedTimeDuration : nudgeDayTimeDuration : nudgeRelativeDuration;
  let [f2, d2, m2] = l3(e2, n2, t2, o2, r2, i3, a2, s2, c2, u2);
  return m2 && 7 !== o2 && (f2 = ((e3, n3, t3, o3, r3, i4, a3, s3) => {
    const c3 = computeDurationSign(e3);
    for (let u3 = o3 + 1; u3 <= t3; u3++) {
      if (7 === u3 && 7 !== t3) {
        continue;
      }
      const o4 = bi(u3, e3);
      o4[F[u3]] += c3;
      const l4 = oe(re(a3(s3(r3, i4, o4)), n3));
      if (l4 && Math.sign(l4) !== c3) {
        break;
      }
      e3 = o4;
    }
    return e3;
  })(f2, d2, t2, Math.max(6, o2), a2, s2, c2, u2)), f2;
}
function roundBigNano(e2, n2, t2, o2, r2) {
  if (6 === n2) {
    const n3 = ((e3) => e3[0] + e3[1] / Qr)(e2);
    return [roundByInc(n3, t2, o2), 0];
  }
  return roundBigNanoByInc(e2, computeNanoInc(n2, t2), o2, r2);
}
function roundBigNanoByInc(e2, n2, t2, o2) {
  let [r2, i3] = e2;
  o2 && i3 < 0 && (i3 += Qr, r2 -= 1);
  const [a2, s2] = divModFloor(roundByInc(i3, n2, t2), Qr);
  return createBigNano(r2 + a2, s2);
}
function roundByInc(e2, n2, t2) {
  return roundWithMode(e2 / n2, t2) * n2;
}
function roundWithMode(e2, n2) {
  return ga[n2](e2);
}
function nudgeDayTimeDuration(e2, n2, t2, o2, r2, i3) {
  const a2 = computeDurationSign(e2), s2 = durationFieldsToBigNano(e2), c2 = roundBigNano(s2, o2, r2, i3), u2 = re(s2, c2), l3 = Math.sign(c2[0] - s2[0]) === a2, f2 = nanoToDurationDayTimeFields(c2, Math.min(t2, 6));
  return [{
    ...e2,
    ...f2
  }, addBigNanos(n2, u2), l3];
}
function nudgeZonedTimeDuration(e2, n2, t2, o2, r2, i3, a2, s2, c2, u2) {
  const l3 = computeDurationSign(e2), f2 = oe(durationFieldsToBigNano(e2, 5)), d2 = computeNanoInc(o2, r2);
  let m2 = roundByInc(f2, d2, i3);
  const [p2, h2] = clampRelativeDuration(a2, {
    ...e2,
    ...Fi
  }, 6, l3, s2, c2, u2), g2 = m2 - oe(re(p2, h2));
  let T2 = 0;
  g2 && Math.sign(g2) !== l3 ? n2 = moveBigNano(p2, m2) : (T2 += l3, m2 = roundByInc(g2, d2, i3), n2 = moveBigNano(h2, m2));
  const D2 = nanoToDurationTimeFields(m2);
  return [{
    ...e2,
    ...D2,
    days: e2.days + T2
  }, n2, Boolean(T2)];
}
function nudgeRelativeDuration(e2, n2, t2, o2, r2, i3, a2, s2, c2, u2) {
  const l3 = computeDurationSign(e2), f2 = F[o2], d2 = bi(o2, e2);
  7 === o2 && (e2 = {
    ...e2,
    weeks: e2.weeks + Math.trunc(e2.days / 7)
  });
  const m2 = divTrunc(e2[f2], r2) * r2;
  d2[f2] = m2;
  const [p2, h2] = clampRelativeDuration(a2, d2, o2, r2 * l3, s2, c2, u2), g2 = m2 + computeEpochNanoFrac(n2, p2, h2) * l3 * r2, T2 = roundByInc(g2, r2, i3), D2 = Math.sign(T2 - g2) === l3;
  return d2[f2] = T2, [d2, D2 ? h2 : p2, D2];
}
function me(e2, n2, t2, o2) {
  const [r2, i3, a2, s2] = ((e3) => {
    const n3 = refineTimeDisplayTuple(e3 = normalizeOptions(e3));
    return [e3.timeZone, ...n3];
  })(o2), c2 = void 0 !== r2;
  return ((e3, n3, t3, o3, r3, i4) => {
    t3 = roundBigNanoByInc(t3, r3, o3, 1);
    const a3 = n3.getOffsetNanosecondsFor(t3);
    return formatIsoDateTimeFields(Ie(t3, a3), i4) + (e3 ? Fe(roundToMinute(a3)) : "Z");
  })(c2, n2(c2 ? e2(r2) : Ta), t2.epochNanoseconds, i3, a2, s2);
}
function In(e2, n2, t2) {
  const [o2, r2, i3, a2, s2, c2] = ((e3) => {
    e3 = normalizeOptions(e3);
    const n3 = da(e3), t3 = refineSubsecDigits(e3), o3 = pa(e3), r3 = ha(e3, 4), i4 = aa(e3, 4);
    return [n3, ma(e3), o3, r3, ...refineSmallestUnitAndSubsecDigits(i4, t3)];
  })(t2);
  return ((e3, n3, t3, o3, r3, i4, a3, s3, c3, u2) => {
    o3 = roundBigNanoByInc(o3, c3, s3, 1);
    const l3 = e3(t3).getOffsetNanosecondsFor(o3);
    return formatIsoDateTimeFields(Ie(o3, l3), u2) + Fe(roundToMinute(l3), a3) + ((e4, n4) => 1 !== n4 ? "[" + (2 === n4 ? "!" : "") + I(e4) + "]" : "")(t3, i4) + formatCalendar(n3, r3);
  })(e2, n2.calendar, n2.timeZone, n2.epochNanoseconds, o2, r2, i3, a2, s2, c2);
}
function Tt(e2, n2) {
  const [t2, o2, r2, i3] = ((e3) => (e3 = normalizeOptions(e3), [da(e3), ...refineTimeDisplayTuple(e3)]))(n2);
  return a2 = e2.calendar, s2 = t2, c2 = i3, formatIsoDateTimeFields(roundDateTimeToNano(e2, r2, o2), c2) + formatCalendar(a2, s2);
  var a2, s2, c2;
}
function yt(e2, n2) {
  return t2 = e2.calendar, o2 = e2, r2 = refineDateDisplayOptions(n2), formatIsoDateFields(o2) + formatCalendar(t2, r2);
  var t2, o2, r2;
}
function et(e2, n2) {
  return formatDateLikeIso(e2.calendar, formatIsoYearMonthFields, e2, refineDateDisplayOptions(n2));
}
function W(e2, n2) {
  return formatDateLikeIso(e2.calendar, formatIsoMonthDayFields, e2, refineDateDisplayOptions(n2));
}
function qe(e2, n2) {
  const [t2, o2, r2] = refineTimeDisplayOptions(n2);
  return i3 = r2, formatIsoTimeFields(roundTimeToNano(e2, o2, t2)[0], i3);
  var i3;
}
function zt(e2, n2) {
  const [t2, o2, r2] = refineTimeDisplayOptions(n2, 3);
  return o2 > 1 && (e2 = {
    ...e2,
    ...roundDayTimeDurationByInc(e2, o2, t2)
  }), ((e3, n3) => {
    const { sign: t3 } = e3, o3 = -1 === t3 ? negateDurationFields(e3) : e3, { hours: r3, minutes: i3 } = o3, [a2, s2] = divModBigNano(durationFieldsToBigNano(o3, 3), _r, divModTrunc);
    checkDurationTimeUnit(a2);
    const c2 = formatSubsecNano(s2, n3), u2 = n3 >= 0 || !t3 || c2;
    return (t3 < 0 ? "-" : "") + "P" + formatDurationFragments({
      Y: formatDurationNumber(o3.years),
      M: formatDurationNumber(o3.months),
      W: formatDurationNumber(o3.weeks),
      D: formatDurationNumber(o3.days)
    }) + (r3 || i3 || a2 || u2 ? "T" + formatDurationFragments({
      H: formatDurationNumber(r3),
      M: formatDurationNumber(i3),
      S: formatDurationNumber(a2, u2) + c2
    }) : "");
  })(e2, r2);
}
function formatDateLikeIso(e2, n2, t2, o2) {
  const r2 = I(e2), i3 = o2 > 1 || 0 === o2 && r2 !== X;
  return 1 === o2 ? r2 === X ? n2(t2) : formatIsoDateFields(t2) : i3 ? formatIsoDateFields(t2) + formatCalendarId(r2, 2 === o2) : n2(t2);
}
function formatDurationFragments(e2) {
  const n2 = [];
  for (const t2 in e2) {
    const o2 = e2[t2];
    o2 && n2.push(o2, t2);
  }
  return n2.join("");
}
function formatIsoDateTimeFields(e2, n2) {
  return formatIsoDateFields(e2) + "T" + formatIsoTimeFields(e2, n2);
}
function formatIsoDateFields(e2) {
  return formatIsoYearMonthFields(e2) + "-" + xr(e2.isoDay);
}
function formatIsoYearMonthFields(e2) {
  const { isoYear: n2 } = e2;
  return (n2 < 0 || n2 > 9999 ? getSignStr(n2) + padNumber(6, Math.abs(n2)) : padNumber(4, n2)) + "-" + xr(e2.isoMonth);
}
function formatIsoMonthDayFields(e2) {
  return xr(e2.isoMonth) + "-" + xr(e2.isoDay);
}
function formatIsoTimeFields(e2, n2) {
  const t2 = [xr(e2.isoHour), xr(e2.isoMinute)];
  return -1 !== n2 && t2.push(xr(e2.isoSecond) + ((e3, n3, t3, o2) => formatSubsecNano(e3 * be + n3 * Vr + t3, o2))(e2.isoMillisecond, e2.isoMicrosecond, e2.isoNanosecond, n2)), t2.join(":");
}
function Fe(e2, n2 = 0) {
  if (1 === n2) {
    return "";
  }
  const [t2, o2] = divModFloor(Math.abs(e2), Kr), [r2, i3] = divModFloor(o2, Jr), [a2, s2] = divModFloor(i3, _r);
  return getSignStr(e2) + xr(t2) + ":" + xr(r2) + (a2 || s2 ? ":" + xr(a2) + formatSubsecNano(s2) : "");
}
function formatCalendar(e2, n2) {
  if (1 !== n2) {
    const t2 = I(e2);
    if (n2 > 1 || 0 === n2 && t2 !== X) {
      return formatCalendarId(t2, 2 === n2);
    }
  }
  return "";
}
function formatCalendarId(e2, n2) {
  return "[" + (n2 ? "!" : "") + "u-ca=" + e2 + "]";
}
function formatSubsecNano(e2, n2) {
  let t2 = padNumber(9, e2);
  return t2 = void 0 === n2 ? t2.replace(Na, "") : t2.slice(0, n2), t2 ? "." + t2 : "";
}
function getSignStr(e2) {
  return e2 < 0 ? "-" : "+";
}
function formatDurationNumber(e2, n2) {
  return e2 || n2 ? e2.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function _zonedEpochSlotsToIso(e2, n2) {
  const { epochNanoseconds: t2 } = e2, o2 = (n2.getOffsetNanosecondsFor ? n2 : n2(e2.timeZone)).getOffsetNanosecondsFor(t2), r2 = Ie(t2, o2);
  return {
    calendar: e2.calendar,
    ...r2,
    offsetNanoseconds: o2
  };
}
function mn(e2, n2) {
  const t2 = fn(n2, e2);
  return {
    calendar: n2.calendar,
    ...Vn(Yi, t2),
    offset: Fe(t2.offsetNanoseconds),
    timeZone: n2.timeZone
  };
}
function getMatchingInstantFor(e2, n2, t2, o2 = 0, r2 = 0, i3, a2) {
  if (void 0 !== t2 && 1 === o2 && (1 === o2 || a2)) {
    return isoToEpochNanoWithOffset(n2, t2);
  }
  const s2 = e2.getPossibleInstantsFor(n2);
  if (void 0 !== t2 && 3 !== o2) {
    const e3 = ((e4, n3, t3, o3) => {
      const r3 = isoToEpochNano(n3);
      o3 && (t3 = roundToMinute(t3));
      for (const n4 of e4) {
        let e5 = oe(re(n4, r3));
        if (o3 && (e5 = roundToMinute(e5)), e5 === t3) {
          return n4;
        }
      }
    })(s2, n2, t2, i3);
    if (void 0 !== e3) {
      return e3;
    }
    if (0 === o2) {
      throw new RangeError(kr);
    }
  }
  return a2 ? isoToEpochNano(n2) : we(e2, n2, r2, s2);
}
function we(e2, n2, t2 = 0, o2 = e2.getPossibleInstantsFor(n2)) {
  if (1 === o2.length) {
    return o2[0];
  }
  if (1 === t2) {
    throw new RangeError(Yr);
  }
  if (o2.length) {
    return o2[3 === t2 ? 1 : 0];
  }
  const r2 = isoToEpochNano(n2), i3 = ((e3, n3) => {
    const t3 = e3.getOffsetNanosecondsFor(moveBigNano(n3, -Qr));
    return ne(e3.getOffsetNanosecondsFor(moveBigNano(n3, Qr)) - t3);
  })(e2, r2), a2 = i3 * (2 === t2 ? -1 : 1);
  return (o2 = e2.getPossibleInstantsFor(Ie(r2, a2)))[2 === t2 ? 0 : o2.length - 1];
}
function ae(e2) {
  if (Math.abs(e2) >= Qr) {
    throw new RangeError(wr);
  }
  return e2;
}
function ne(e2) {
  if (e2 > Qr) {
    throw new RangeError(Br);
  }
  return e2;
}
function se(e2, n2, t2) {
  return _(checkEpochNanoInBounds(addBigNanos(n2.epochNanoseconds, ((e3) => {
    if (durationHasDateParts(e3)) {
      throw new RangeError(qr);
    }
    return durationFieldsToBigNano(e3, 5);
  })(e2 ? negateDurationFields(t2) : t2))));
}
function hn(e2, n2, t2, o2, r2, i3 = /* @__PURE__ */ Object.create(null)) {
  const a2 = n2(o2.timeZone), s2 = e2(o2.calendar);
  return {
    ...o2,
    ...moveZonedEpochs(a2, s2, o2, t2 ? negateDurationFields(r2) : r2, i3)
  };
}
function ct(e2, n2, t2, o2, r2 = /* @__PURE__ */ Object.create(null)) {
  const { calendar: i3 } = t2;
  return ee(moveDateTime(e2(i3), t2, n2 ? negateDurationFields(o2) : o2, r2), i3);
}
function bt(e2, n2, t2, o2, r2) {
  const { calendar: i3 } = t2;
  return v(moveDate(e2(i3), t2, n2 ? negateDurationFields(o2) : o2, r2), i3);
}
function Qe(e2, n2, t2, o2, r2 = /* @__PURE__ */ Object.create(null)) {
  const i3 = t2.calendar, a2 = e2(i3);
  let s2 = moveToDayOfMonthUnsafe(a2, t2);
  n2 && (o2 = xt(o2)), o2.sign < 0 && (s2 = a2.dateAdd(s2, {
    ...Si,
    months: 1
  }), s2 = moveByDays(s2, -1));
  const c2 = a2.dateAdd(s2, o2, r2);
  return createPlainYearMonthSlots(moveToDayOfMonthUnsafe(a2, c2), i3);
}
function Ye(e2, n2, t2) {
  return Ge(moveTime(n2, e2 ? negateDurationFields(t2) : t2)[0]);
}
function moveZonedEpochs(e2, n2, t2, o2, r2) {
  const i3 = durationFieldsToBigNano(o2, 5);
  let a2 = t2.epochNanoseconds;
  if (durationHasDateParts(o2)) {
    const s2 = fn(t2, e2);
    a2 = addBigNanos(we(e2, {
      ...moveDate(n2, s2, {
        ...o2,
        ...Fi
      }, r2),
      ...Vn(j, s2)
    }), i3);
  } else {
    a2 = addBigNanos(a2, i3), H(r2);
  }
  return {
    epochNanoseconds: checkEpochNanoInBounds(a2)
  };
}
function moveDateTime(e2, n2, t2, o2) {
  const [r2, i3] = moveTime(n2, t2);
  return checkIsoDateTimeInBounds({
    ...moveDate(e2, n2, {
      ...t2,
      ...Fi,
      days: t2.days + i3
    }, o2),
    ...r2
  });
}
function moveDate(e2, n2, t2, o2) {
  if (t2.years || t2.months || t2.weeks) {
    return e2.dateAdd(n2, t2, o2);
  }
  H(o2);
  const r2 = t2.days + durationFieldsToBigNano(t2, 5)[0];
  return r2 ? checkIsoDateInBounds(moveByDays(n2, r2)) : n2;
}
function moveToDayOfMonthUnsafe(e2, n2, t2 = 1) {
  return moveByDays(n2, t2 - e2.day(n2));
}
function moveTime(e2, n2) {
  const [t2, o2] = durationFieldsToBigNano(n2, 5), [r2, i3] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(e2) + o2);
  return [r2, t2 + i3];
}
function moveByDays(e2, n2) {
  return n2 ? {
    ...e2,
    ...epochMilliToIso(isoToEpochMilli(e2) + n2 * Gr)
  } : e2;
}
function createMarkerSystem(e2, n2, t2) {
  const o2 = e2(t2.calendar);
  return isZonedEpochSlots(t2) ? [t2, o2, n2(t2.timeZone)] : [{
    ...t2,
    ...Dt
  }, o2];
}
function createMarkerToEpochNano(e2) {
  return e2 ? extractEpochNano : isoToEpochNano;
}
function createMoveMarker(e2) {
  return e2 ? E(moveZonedEpochs, e2) : moveDateTime;
}
function createDiffMarkers(e2) {
  return e2 ? E(diffZonedEpochsExact, e2) : diffDateTimesExact;
}
function isZonedEpochSlots(e2) {
  return e2 && e2.epochNanoseconds;
}
function isUniformUnit(e2, n2) {
  return e2 <= 6 - (isZonedEpochSlots(n2) ? 1 : 0);
}
function Wt(e2, n2, t2, o2, r2, i3, a2) {
  const s2 = e2(normalizeOptions(a2).relativeTo), c2 = Math.max(getMaxDurationUnit(r2), getMaxDurationUnit(i3));
  if (isUniformUnit(c2, s2)) {
    return Vt(checkDurationUnits(((e3, n3, t3, o3) => {
      const r3 = addBigNanos(durationFieldsToBigNano(e3), durationFieldsToBigNano(n3), o3 ? -1 : 1);
      if (!Number.isFinite(r3[0])) {
        throw new RangeError(Cr);
      }
      return {
        ...Si,
        ...nanoToDurationDayTimeFields(r3, t3)
      };
    })(r2, i3, c2, o2)));
  }
  if (!s2) {
    throw new RangeError(zr);
  }
  o2 && (i3 = negateDurationFields(i3));
  const [u2, l3, f2] = createMarkerSystem(n2, t2, s2), d2 = createMoveMarker(f2), m2 = createDiffMarkers(f2), p2 = d2(l3, u2, r2);
  return Vt(m2(l3, u2, d2(l3, p2, i3), c2));
}
function Gt(e2, n2, t2, o2, r2) {
  const i3 = getMaxDurationUnit(o2), [a2, s2, c2, u2, l3] = ((e3, n3, t3) => {
    e3 = normalizeOptionsOrString(e3, Hi);
    let o3 = sa(e3);
    const r3 = t3(e3[Ki]);
    let i4 = parseRoundingIncInteger(e3);
    const a3 = ha(e3, 7);
    let s3 = aa(e3);
    if (void 0 === o3 && void 0 === s3) {
      throw new RangeError(Ur);
    }
    return null == s3 && (s3 = 0), null == o3 && (o3 = Math.max(s3, n3)), checkLargestSmallestUnit(o3, s3), i4 = refineRoundingInc(i4, s3, 1), [o3, s3, i4, a3, r3];
  })(r2, i3, e2), f2 = Math.max(i3, a2);
  if (!isZonedEpochSlots(l3) && f2 <= 6) {
    return Vt(checkDurationUnits(((e3, n3, t3, o3, r3) => {
      const i4 = roundBigNano(durationFieldsToBigNano(e3), t3, o3, r3);
      return {
        ...Si,
        ...nanoToDurationDayTimeFields(i4, n3)
      };
    })(o2, a2, s2, c2, u2)));
  }
  if (!l3) {
    throw new RangeError(zr);
  }
  const [d2, m2, p2] = createMarkerSystem(n2, t2, l3), h2 = createMarkerToEpochNano(p2), g2 = createMoveMarker(p2), T2 = createDiffMarkers(p2), D2 = g2(m2, d2, o2);
  let I2 = T2(m2, d2, D2, a2);
  const M2 = o2.sign, N2 = computeDurationSign(I2);
  if (M2 && N2 && M2 !== N2) {
    throw new RangeError(vr);
  }
  return N2 && (I2 = roundRelativeDuration(I2, h2(D2), a2, s2, c2, u2, m2, d2, h2, g2)), Vt(I2);
}
function Rt(e2) {
  return -1 === e2.sign ? xt(e2) : e2;
}
function xt(e2) {
  return Vt(negateDurationFields(e2));
}
function negateDurationFields(e2) {
  const n2 = {};
  for (const t2 of F) {
    n2[t2] = -1 * e2[t2] || 0;
  }
  return n2;
}
function Jt(e2) {
  return !e2.sign;
}
function computeDurationSign(e2, n2 = F) {
  let t2 = 0;
  for (const o2 of n2) {
    const n3 = Math.sign(e2[o2]);
    if (n3) {
      if (t2 && t2 !== n3) {
        throw new RangeError(Rr);
      }
      t2 = n3;
    }
  }
  return t2;
}
function checkDurationUnits(e2) {
  for (const n2 of vi) {
    clampEntity(n2, e2[n2], -ya, ya, 1);
  }
  return checkDurationTimeUnit(oe(durationFieldsToBigNano(e2), _r)), e2;
}
function checkDurationTimeUnit(e2) {
  if (!Number.isSafeInteger(e2)) {
    throw new RangeError(Zr);
  }
}
function durationFieldsToBigNano(e2, n2 = 6) {
  return givenFieldsToBigNano(e2, n2, F);
}
function nanoToDurationDayTimeFields(e2, n2 = 6) {
  const [t2, o2] = e2, r2 = nanoToGivenFields(o2, n2, F);
  if (r2[F[n2]] += t2 * (Qr / Xr[n2]), !Number.isFinite(r2[F[n2]])) {
    throw new RangeError(Cr);
  }
  return r2;
}
function nanoToDurationTimeFields(e2, n2 = 5) {
  return nanoToGivenFields(e2, n2, F);
}
function durationHasDateParts(e2) {
  return Boolean(computeDurationSign(e2, Pi));
}
function getMaxDurationUnit(e2) {
  let n2 = 9;
  for (; n2 > 0 && !e2[F[n2]]; n2--) {
  }
  return n2;
}
function createSplitTuple(e2, n2) {
  return [e2, n2];
}
function computePeriod(e2) {
  const n2 = Math.floor(e2 / Da) * Da;
  return [n2, n2 + Da];
}
function pe(e2) {
  const n2 = parseDateTimeLike(e2 = toStringViaPrimitive(e2));
  if (!n2) {
    throw new RangeError(failedParse(e2));
  }
  let t2;
  if (n2.m) {
    t2 = 0;
  } else {
    if (!n2.offset) {
      throw new RangeError(failedParse(e2));
    }
    t2 = parseOffsetNano(n2.offset);
  }
  return n2.timeZone && parseOffsetNanoMaybe(n2.timeZone, 1), _(isoToEpochNanoWithOffset(checkIsoDateTimeFields(n2), t2));
}
function Xt(e2) {
  const n2 = parseDateTimeLike(m(e2));
  if (!n2) {
    throw new RangeError(failedParse(e2));
  }
  if (n2.timeZone) {
    return finalizeZonedDateTime(n2, n2.offset ? parseOffsetNano(n2.offset) : void 0);
  }
  if (n2.m) {
    throw new RangeError(failedParse(e2));
  }
  return finalizeDate(n2);
}
function Mn(e2, n2) {
  const t2 = parseDateTimeLike(m(e2));
  if (!t2 || !t2.timeZone) {
    throw new RangeError(failedParse(e2));
  }
  const { offset: o2 } = t2, r2 = o2 ? parseOffsetNano(o2) : void 0, [, i3, a2] = wn(n2);
  return finalizeZonedDateTime(t2, r2, i3, a2);
}
function parseOffsetNano(e2) {
  const n2 = parseOffsetNanoMaybe(e2);
  if (void 0 === n2) {
    throw new RangeError(failedParse(e2));
  }
  return n2;
}
function Ct(e2) {
  const n2 = parseDateTimeLike(m(e2));
  if (!n2 || n2.m) {
    throw new RangeError(failedParse(e2));
  }
  return ee(finalizeDateTime(n2));
}
function At(e2) {
  const n2 = parseDateTimeLike(m(e2));
  if (!n2 || n2.m) {
    throw new RangeError(failedParse(e2));
  }
  return v(n2.p ? finalizeDateTime(n2) : finalizeDate(n2));
}
function ot(e2, n2) {
  const t2 = parseYearMonthOnly(m(n2));
  if (t2) {
    return requireIsoCalendar(t2), createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields(t2)));
  }
  const o2 = At(n2);
  return createPlainYearMonthSlots(moveToDayOfMonthUnsafe(e2(o2.calendar), o2));
}
function requireIsoCalendar(e2) {
  if (e2.calendar !== X) {
    throw new RangeError(invalidSubstring(e2.calendar));
  }
}
function Q(e2, n2) {
  const t2 = parseMonthDayOnly(m(n2));
  if (t2) {
    return requireIsoCalendar(t2), createPlainMonthDaySlots(checkIsoDateFields(t2));
  }
  const o2 = At(n2), { calendar: r2 } = o2, i3 = e2(r2), [a2, s2, c2] = i3.h(o2), [u2, l3] = i3.I(a2, s2), [f2, d2] = i3.N(u2, l3, c2);
  return createPlainMonthDaySlots(checkIsoDateInBounds(i3.P(f2, d2, c2)), r2);
}
function ze(e2) {
  let n2, t2 = ((e3) => {
    const n3 = Ca.exec(e3);
    return n3 ? (organizeAnnotationParts(n3[10]), organizeTimeParts(n3)) : void 0;
  })(m(e2));
  if (!t2) {
    if (t2 = parseDateTimeLike(e2), !t2) {
      throw new RangeError(failedParse(e2));
    }
    if (!t2.p) {
      throw new RangeError(failedParse(e2));
    }
    if (t2.m) {
      throw new RangeError(invalidSubstring("Z"));
    }
    requireIsoCalendar(t2);
  }
  if ((n2 = parseYearMonthOnly(e2)) && isIsoDateFieldsValid(n2)) {
    throw new RangeError(failedParse(e2));
  }
  if ((n2 = parseMonthDayOnly(e2)) && isIsoDateFieldsValid(n2)) {
    throw new RangeError(failedParse(e2));
  }
  return Ge(constrainIsoTimeFields(t2, 1));
}
function Kt(e2) {
  const n2 = ((e3) => {
    const n3 = za.exec(e3);
    return n3 ? ((e4) => {
      function parseUnit(e5, r3, i3) {
        let a2 = 0, s2 = 0;
        if (i3 && ([a2, o2] = divModFloor(o2, Xr[i3])), void 0 !== e5) {
          if (t2) {
            throw new RangeError(invalidSubstring(e5));
          }
          s2 = ((e6) => {
            const n5 = parseInt(e6);
            if (!Number.isFinite(n5)) {
              throw new RangeError(invalidSubstring(e6));
            }
            return n5;
          })(e5), n4 = 1, r3 && (o2 = parseSubsecNano(r3) * (Xr[i3] / _r), t2 = 1);
        }
        return a2 + s2;
      }
      let n4 = 0, t2 = 0, o2 = 0, r2 = {
        ...zipProps(F, [parseUnit(e4[2]), parseUnit(e4[3]), parseUnit(e4[4]), parseUnit(e4[5]), parseUnit(e4[6], e4[7], 5), parseUnit(e4[8], e4[9], 4), parseUnit(e4[10], e4[11], 3)]),
        ...nanoToGivenFields(o2, 2, F)
      };
      if (!n4) {
        throw new RangeError(noValidFields(F));
      }
      return parseSign(e4[1]) < 0 && (r2 = negateDurationFields(r2)), r2;
    })(n3) : void 0;
  })(m(e2));
  if (!n2) {
    throw new RangeError(failedParse(e2));
  }
  return Vt(checkDurationUnits(n2));
}
function sn(e2) {
  const n2 = parseDateTimeLike(e2) || parseYearMonthOnly(e2) || parseMonthDayOnly(e2);
  return n2 ? n2.calendar : e2;
}
function Ne(e2) {
  const n2 = parseDateTimeLike(e2);
  return n2 && (n2.timeZone || n2.m && Ta || n2.offset) || e2;
}
function finalizeZonedDateTime(e2, n2, t2 = 0, o2 = 0) {
  const r2 = ye(e2.timeZone), i3 = ie(r2);
  return Yn(getMatchingInstantFor(i3, checkIsoDateTimeFields(e2), n2, t2, o2, !i3.v, e2.m), r2, an(e2.calendar));
}
function finalizeDateTime(e2) {
  return resolveSlotsCalendar(checkIsoDateTimeInBounds(checkIsoDateTimeFields(e2)));
}
function finalizeDate(e2) {
  return resolveSlotsCalendar(checkIsoDateInBounds(checkIsoDateFields(e2)));
}
function resolveSlotsCalendar(e2) {
  return {
    ...e2,
    calendar: an(e2.calendar)
  };
}
function parseDateTimeLike(e2) {
  const n2 = Ya.exec(e2);
  return n2 ? ((e3) => {
    const n3 = e3[10], t2 = "Z" === (n3 || "").toUpperCase();
    return {
      isoYear: organizeIsoYearParts(e3),
      isoMonth: parseInt(e3[4]),
      isoDay: parseInt(e3[5]),
      ...organizeTimeParts(e3.slice(5)),
      ...organizeAnnotationParts(e3[16]),
      p: Boolean(e3[6]),
      m: t2,
      offset: t2 ? void 0 : n3
    };
  })(n2) : void 0;
}
function parseYearMonthOnly(e2) {
  const n2 = Ba.exec(e2);
  return n2 ? ((e3) => ({
    isoYear: organizeIsoYearParts(e3),
    isoMonth: parseInt(e3[4]),
    isoDay: 1,
    ...organizeAnnotationParts(e3[5])
  }))(n2) : void 0;
}
function parseMonthDayOnly(e2) {
  const n2 = ka.exec(e2);
  return n2 ? ((e3) => ({
    isoYear: ji,
    isoMonth: parseInt(e3[1]),
    isoDay: parseInt(e3[2]),
    ...organizeAnnotationParts(e3[3])
  }))(n2) : void 0;
}
function parseOffsetNanoMaybe(e2, n2) {
  const t2 = Za.exec(e2);
  return t2 ? ((e3, n3) => {
    const t3 = e3[4] || e3[5];
    if (n3 && t3) {
      throw new RangeError(invalidSubstring(t3));
    }
    return ae((parseInt0(e3[2]) * Kr + parseInt0(e3[3]) * Jr + parseInt0(e3[4]) * _r + parseSubsecNano(e3[5] || "")) * parseSign(e3[1]));
  })(t2, n2) : void 0;
}
function organizeIsoYearParts(e2) {
  const n2 = parseSign(e2[1]), t2 = parseInt(e2[2] || e2[3]);
  if (n2 < 0 && !t2) {
    throw new RangeError(invalidSubstring(-0));
  }
  return n2 * t2;
}
function organizeTimeParts(e2) {
  const n2 = parseInt0(e2[3]);
  return {
    ...nanoToIsoTimeAndDay(parseSubsecNano(e2[4] || ""))[0],
    isoHour: parseInt0(e2[1]),
    isoMinute: parseInt0(e2[2]),
    isoSecond: 60 === n2 ? 59 : n2
  };
}
function organizeAnnotationParts(e2) {
  let n2, t2;
  const o2 = [];
  if (e2.replace(Ra, (e3, r2, i3) => {
    const a2 = Boolean(r2), [s2, c2] = i3.split("=").reverse();
    if (c2) {
      if ("u-ca" === c2) {
        o2.push(s2), n2 || (n2 = a2);
      } else if (a2 || /[A-Z]/.test(c2)) {
        throw new RangeError(invalidSubstring(e3));
      }
    } else {
      if (t2) {
        throw new RangeError(invalidSubstring(e3));
      }
      t2 = s2;
    }
    return "";
  }), o2.length > 1 && n2) {
    throw new RangeError(invalidSubstring(e2));
  }
  return {
    timeZone: t2,
    calendar: o2[0] || X
  };
}
function parseSubsecNano(e2) {
  return parseInt(e2.padEnd(9, "0"));
}
function createRegExp(e2) {
  return new RegExp(`^${e2}$`, "i");
}
function parseSign(e2) {
  return e2 && "+" !== e2 ? -1 : 1;
}
function parseInt0(e2) {
  return void 0 === e2 ? 0 : parseInt(e2);
}
function Me(e2) {
  return ye(m(e2));
}
function ye(e2) {
  const n2 = getTimeZoneEssence(e2);
  return "number" == typeof n2 ? Fe(n2) : n2 ? ((e3) => {
    if (Ua.test(e3)) {
      throw new RangeError(br);
    }
    return e3.toLowerCase().split("/").map((e4, n3) => (e4.length <= 3 || /\d/.test(e4)) && !/etc|yap/.test(e4) ? e4.toUpperCase() : e4.replace(/baja|dumont|[a-z]+/g, (e5, t2) => e5.length <= 2 && !n3 || "in" === e5 || "chat" === e5 ? e5.toUpperCase() : e5.length > 2 || !t2 ? capitalize(e5).replace(/island|noronha|murdo|rivadavia|urville/, capitalize) : e5)).join("/");
  })(e2) : Ta;
}
function getTimeZoneAtomic(e2) {
  const n2 = getTimeZoneEssence(e2);
  return "number" == typeof n2 ? n2 : n2 ? n2.resolvedOptions().timeZone : Ta;
}
function getTimeZoneEssence(e2) {
  const n2 = parseOffsetNanoMaybe(e2 = e2.toUpperCase(), 1);
  return void 0 !== n2 ? n2 : e2 !== Ta ? qa(e2) : void 0;
}
function Ze(e2, n2) {
  return te(e2.epochNanoseconds, n2.epochNanoseconds);
}
function yn(e2, n2) {
  return te(e2.epochNanoseconds, n2.epochNanoseconds);
}
function $t(e2, n2, t2, o2, r2, i3) {
  const a2 = e2(normalizeOptions(i3).relativeTo), s2 = Math.max(getMaxDurationUnit(o2), getMaxDurationUnit(r2));
  if (allPropsEqual(F, o2, r2)) {
    return 0;
  }
  if (isUniformUnit(s2, a2)) {
    return te(durationFieldsToBigNano(o2), durationFieldsToBigNano(r2));
  }
  if (!a2) {
    throw new RangeError(zr);
  }
  const [c2, u2, l3] = createMarkerSystem(n2, t2, a2), f2 = createMarkerToEpochNano(l3), d2 = createMoveMarker(l3);
  return te(f2(d2(u2, c2, o2)), f2(d2(u2, c2, r2)));
}
function gt(e2, n2) {
  return rt(e2, n2) || He(e2, n2);
}
function rt(e2, n2) {
  return compareNumbers(isoToEpochMilli(e2), isoToEpochMilli(n2));
}
function He(e2, n2) {
  return compareNumbers(isoTimeFieldsToNano(e2), isoTimeFieldsToNano(n2));
}
function ue(e2, n2) {
  return !Ze(e2, n2);
}
function gn(e2, n2) {
  return !yn(e2, n2) && !!je(e2.timeZone, n2.timeZone) && isIdLikeEqual(e2.calendar, n2.calendar);
}
function ft(e2, n2) {
  return !gt(e2, n2) && isIdLikeEqual(e2.calendar, n2.calendar);
}
function It(e2, n2) {
  return !rt(e2, n2) && isIdLikeEqual(e2.calendar, n2.calendar);
}
function $e(e2, n2) {
  return !rt(e2, n2) && isIdLikeEqual(e2.calendar, n2.calendar);
}
function x(e2, n2) {
  return !rt(e2, n2) && isIdLikeEqual(e2.calendar, n2.calendar);
}
function Ve(e2, n2) {
  return !He(e2, n2);
}
function je(e2, n2) {
  if (e2 === n2) {
    return 1;
  }
  const t2 = I(e2), o2 = I(n2);
  if (t2 === o2) {
    return 1;
  }
  try {
    return getTimeZoneAtomic(t2) === getTimeZoneAtomic(o2);
  } catch (e3) {
  }
}
function le(e2, n2, t2, o2) {
  const r2 = refineDiffOptions(e2, U(o2), 3, 5), i3 = diffEpochNanos(n2.epochNanoseconds, t2.epochNanoseconds, ...r2);
  return Vt(e2 ? negateDurationFields(i3) : i3);
}
function Dn(e2, n2, t2, o2, r2, i3) {
  const a2 = getCommonCalendarSlot(o2.calendar, r2.calendar), s2 = U(i3), [c2, u2, l3, f2] = refineDiffOptions(t2, s2, 5), d2 = o2.epochNanoseconds, m2 = r2.epochNanoseconds, p2 = te(m2, d2);
  let h2;
  if (p2) {
    if (c2 < 6) {
      h2 = diffEpochNanos(d2, m2, c2, u2, l3, f2);
    } else {
      const t3 = n2(((e3, n3) => {
        if (!je(e3, n3)) {
          throw new RangeError(Fr);
        }
        return e3;
      })(o2.timeZone, r2.timeZone)), i4 = e2(a2);
      h2 = diffZonedEpochsBig(i4, t3, o2, r2, p2, c2, s2), h2 = roundRelativeDuration(h2, m2, c2, u2, l3, f2, i4, o2, extractEpochNano, E(moveZonedEpochs, t3));
    }
  } else {
    h2 = Si;
  }
  return Vt(t2 ? negateDurationFields(h2) : h2);
}
function ut(e2, n2, t2, o2, r2) {
  const i3 = getCommonCalendarSlot(t2.calendar, o2.calendar), a2 = U(r2), [s2, c2, u2, l3] = refineDiffOptions(n2, a2, 6), f2 = isoToEpochNano(t2), d2 = isoToEpochNano(o2), m2 = te(d2, f2);
  let p2;
  if (m2) {
    if (s2 <= 6) {
      p2 = diffEpochNanos(f2, d2, s2, c2, u2, l3);
    } else {
      const n3 = e2(i3);
      p2 = diffDateTimesBig(n3, t2, o2, m2, s2, a2), p2 = roundRelativeDuration(p2, d2, s2, c2, u2, l3, n3, t2, isoToEpochNano, moveDateTime);
    }
  } else {
    p2 = Si;
  }
  return Vt(n2 ? negateDurationFields(p2) : p2);
}
function Ft(e2, n2, t2, o2, r2) {
  const i3 = getCommonCalendarSlot(t2.calendar, o2.calendar), a2 = U(r2);
  return diffDateLike(n2, () => e2(i3), t2, o2, ...refineDiffOptions(n2, a2, 6, 9, 6), a2);
}
function Xe(e2, n2, t2, o2, r2) {
  const i3 = getCommonCalendarSlot(t2.calendar, o2.calendar), a2 = U(r2), s2 = refineDiffOptions(n2, a2, 9, 9, 8), c2 = e2(i3);
  return diffDateLike(n2, () => c2, moveToDayOfMonthUnsafe(c2, t2), moveToDayOfMonthUnsafe(c2, o2), ...s2, a2);
}
function diffDateLike(e2, n2, t2, o2, r2, i3, a2, s2, c2) {
  const u2 = isoToEpochNano(t2), l3 = isoToEpochNano(o2);
  let f2;
  if (te(l3, u2)) {
    if (6 === r2) {
      f2 = diffEpochNanos(u2, l3, r2, i3, a2, s2);
    } else {
      const e3 = n2();
      f2 = e3.dateUntil(t2, o2, r2, c2), 6 === i3 && 1 === a2 || (f2 = roundRelativeDuration(f2, l3, r2, i3, a2, s2, e3, t2, isoToEpochNano, moveDate));
    }
  } else {
    f2 = Si;
  }
  return Vt(e2 ? negateDurationFields(f2) : f2);
}
function Ae(e2, n2, t2, o2) {
  const r2 = U(o2), [i3, a2, s2, c2] = refineDiffOptions(e2, r2, 5, 5), u2 = roundByInc(diffTimes(n2, t2), computeNanoInc(a2, s2), c2), l3 = {
    ...Si,
    ...nanoToDurationTimeFields(u2, i3)
  };
  return Vt(e2 ? negateDurationFields(l3) : l3);
}
function diffZonedEpochsExact(e2, n2, t2, o2, r2, i3) {
  const a2 = te(o2.epochNanoseconds, t2.epochNanoseconds);
  return a2 ? r2 < 6 ? diffEpochNanosExact(t2.epochNanoseconds, o2.epochNanoseconds, r2) : diffZonedEpochsBig(n2, e2, t2, o2, a2, r2, i3) : Si;
}
function diffDateTimesExact(e2, n2, t2, o2, r2) {
  const i3 = isoToEpochNano(n2), a2 = isoToEpochNano(t2), s2 = te(a2, i3);
  return s2 ? o2 <= 6 ? diffEpochNanosExact(i3, a2, o2) : diffDateTimesBig(e2, n2, t2, s2, o2, r2) : Si;
}
function diffZonedEpochsBig(e2, n2, t2, o2, r2, i3, a2) {
  const [s2, c2, u2] = ((e3, n3, t3, o3) => {
    function updateMid() {
      return l4 = {
        ...moveByDays(a3, c3++ * -o3),
        ...i4
      }, f3 = we(e3, l4), te(s3, f3) === -o3;
    }
    const r3 = fn(n3, e3), i4 = Vn(j, r3), a3 = fn(t3, e3), s3 = t3.epochNanoseconds;
    let c3 = 0;
    const u3 = diffTimes(r3, a3);
    let l4, f3;
    if (Math.sign(u3) === -o3 && c3++, updateMid() && (-1 === o3 || updateMid())) {
      throw new RangeError(vr);
    }
    const d2 = oe(re(f3, s3));
    return [r3, l4, d2];
  })(n2, t2, o2, r2);
  var l3, f2;
  return {
    ...6 === i3 ? (l3 = s2, f2 = c2, {
      ...Si,
      days: diffDays(l3, f2)
    }) : e2.dateUntil(s2, c2, i3, a2),
    ...nanoToDurationTimeFields(u2)
  };
}
function diffDateTimesBig(e2, n2, t2, o2, r2, i3) {
  const [a2, s2, c2] = ((e3, n3, t3) => {
    let o3 = n3, r3 = diffTimes(e3, n3);
    return Math.sign(r3) === -t3 && (o3 = moveByDays(n3, -t3), r3 += Qr * t3), [e3, o3, r3];
  })(n2, t2, o2);
  return {
    ...e2.dateUntil(a2, s2, r2, i3),
    ...nanoToDurationTimeFields(c2)
  };
}
function diffEpochNanos(e2, n2, t2, o2, r2, i3) {
  return {
    ...Si,
    ...nanoToDurationDayTimeFields(roundBigNano(re(e2, n2), o2, r2, i3), t2)
  };
}
function diffEpochNanosExact(e2, n2, t2) {
  return {
    ...Si,
    ...nanoToDurationDayTimeFields(re(e2, n2), t2)
  };
}
function diffDays(e2, n2) {
  return diffEpochMilliByDay(isoToEpochMilli(e2), isoToEpochMilli(n2));
}
function diffEpochMilliByDay(e2, n2) {
  return Math.trunc((n2 - e2) / Gr);
}
function diffTimes(e2, n2) {
  return isoTimeFieldsToNano(n2) - isoTimeFieldsToNano(e2);
}
function getCommonCalendarSlot(e2, n2) {
  if (!isIdLikeEqual(e2, n2)) {
    throw new RangeError(Er);
  }
  return e2;
}
function createIntlCalendar(e2) {
  function epochMilliToIntlFields(e3) {
    return ((e4, n3) => ({
      ...parseIntlYear(e4, n3),
      F: e4.month,
      day: parseInt(e4.day)
    }))(hashIntlFormatParts(n2, e3), t2);
  }
  const n2 = La(e2), t2 = computeCalendarIdBase(e2);
  return {
    id: e2,
    O: createIntlFieldCache(epochMilliToIntlFields),
    B: createIntlYearDataCache(epochMilliToIntlFields)
  };
}
function createIntlFieldCache(e2) {
  return Jn((n2) => {
    const t2 = isoToEpochMilli(n2);
    return e2(t2);
  }, WeakMap);
}
function createIntlYearDataCache(e2) {
  const n2 = e2(0).year - Wi;
  return Jn((t2) => {
    let o2, r2 = isoArgsToEpochMilli(t2 - n2);
    const i3 = [], a2 = [];
    do {
      r2 += 400 * Gr;
    } while ((o2 = e2(r2)).year <= t2);
    do {
      r2 += (1 - o2.day) * Gr, o2.year === t2 && (i3.push(r2), a2.push(o2.F)), r2 -= Gr;
    } while ((o2 = e2(r2)).year >= t2);
    return {
      k: i3.reverse(),
      C: Wr(a2.reverse())
    };
  });
}
function parseIntlYear(e2, n2) {
  let t2, o2, r2 = parseIntlPartsYear(e2);
  if (e2.era) {
    const i3 = Di[n2];
    void 0 !== i3 && (t2 = "islamic" === n2 ? "ah" : e2.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), "bc" === t2 || "b" === t2 ? t2 = "bce" : "ad" !== t2 && "a" !== t2 || (t2 = "ce"), o2 = r2, r2 = eraYearToYear(o2, i3[t2] || 0));
  }
  return {
    era: t2,
    eraYear: o2,
    year: r2
  };
}
function parseIntlPartsYear(e2) {
  return parseInt(e2.relatedYear || e2.year);
}
function computeIntlDateParts(e2) {
  const { year: n2, F: t2, day: o2 } = this.O(e2), { C: r2 } = this.B(n2);
  return [n2, r2[t2] + 1, o2];
}
function computeIntlEpochMilli(e2, n2 = 1, t2 = 1) {
  return this.B(e2).k[n2 - 1] + (t2 - 1) * Gr;
}
function computeIntlLeapMonth(e2) {
  const n2 = queryMonthStrings(this, e2), t2 = queryMonthStrings(this, e2 - 1), o2 = n2.length;
  if (o2 > t2.length) {
    const e3 = getCalendarLeapMonthMeta(this);
    if (e3 < 0) {
      return -e3;
    }
    for (let e4 = 0; e4 < o2; e4++) {
      if (n2[e4] !== t2[e4]) {
        return e4 + 1;
      }
    }
  }
}
function computeIntlDaysInYear(e2) {
  return diffEpochMilliByDay(computeIntlEpochMilli.call(this, e2), computeIntlEpochMilli.call(this, e2 + 1));
}
function computeIntlDaysInMonth(e2, n2) {
  const { k: t2 } = this.B(e2);
  let o2 = n2 + 1, r2 = t2;
  return o2 > t2.length && (o2 = 1, r2 = this.B(e2 + 1).k), diffEpochMilliByDay(t2[n2 - 1], r2[o2 - 1]);
}
function computeIntlMonthsInYear(e2) {
  return this.B(e2).k.length;
}
function queryMonthStrings(e2, n2) {
  return Object.keys(e2.B(n2).C);
}
function rn(e2) {
  return an(m(e2));
}
function an(e2) {
  if ((e2 = e2.toLowerCase()) !== X && e2 !== gi && computeCalendarIdBase(e2) !== computeCalendarIdBase(La(e2).resolvedOptions().calendar)) {
    throw new RangeError(invalidCalendar(e2));
  }
  return e2;
}
function computeCalendarIdBase(e2) {
  return "islamicc" === e2 && (e2 = "islamic"), e2.split("-")[0];
}
function computeNativeWeekOfYear(e2) {
  return this.R(e2)[0];
}
function computeNativeYearOfWeek(e2) {
  return this.R(e2)[1];
}
function computeNativeDayOfYear(e2) {
  const [n2] = this.h(e2);
  return diffEpochMilliByDay(this.q(n2), isoToEpochMilli(e2)) + 1;
}
function parseMonthCode(e2) {
  const n2 = Wa.exec(e2);
  if (!n2) {
    throw new RangeError(invalidMonthCode(e2));
  }
  return [parseInt(n2[1]), Boolean(n2[2])];
}
function monthCodeNumberToMonth(e2, n2, t2) {
  return e2 + (n2 || t2 && e2 >= t2 ? 1 : 0);
}
function monthToMonthCodeNumber(e2, n2) {
  return e2 - (n2 && e2 >= n2 ? 1 : 0);
}
function eraYearToYear(e2, n2) {
  return (n2 + e2) * (Math.sign(n2) || 1) || 0;
}
function getCalendarEraOrigins(e2) {
  return Di[getCalendarIdBase(e2)];
}
function getCalendarLeapMonthMeta(e2) {
  return Ii[getCalendarIdBase(e2)];
}
function getCalendarIdBase(e2) {
  return computeCalendarIdBase(e2.id || X);
}
function Qt(e2, n2, t2, o2) {
  const r2 = refineCalendarFields(t2, o2, en, [], ri);
  if (void 0 !== r2.timeZone) {
    const o3 = t2.dateFromFields(r2), i3 = refineTimeBag(r2), a2 = e2(r2.timeZone);
    return {
      epochNanoseconds: getMatchingInstantFor(n2(a2), {
        ...o3,
        ...i3
      }, void 0 !== r2.offset ? parseOffsetNano(r2.offset) : void 0),
      timeZone: a2
    };
  }
  return {
    ...t2.dateFromFields(r2),
    ...Dt
  };
}
function jn(e2, n2, t2, o2, r2, i3) {
  const a2 = refineCalendarFields(t2, r2, en, ti, ri), s2 = e2(a2.timeZone), [c2, u2, l3] = wn(i3), f2 = t2.dateFromFields(a2, overrideOverflowOptions(i3, c2)), d2 = refineTimeBag(a2, c2);
  return Yn(getMatchingInstantFor(n2(s2), {
    ...f2,
    ...d2
  }, void 0 !== a2.offset ? parseOffsetNano(a2.offset) : void 0, u2, l3), s2, o2);
}
function Pt(e2, n2, t2) {
  const o2 = refineCalendarFields(e2, n2, en, [], w), r2 = H(t2);
  return ee(checkIsoDateTimeInBounds({
    ...e2.dateFromFields(o2, overrideOverflowOptions(t2, r2)),
    ...refineTimeBag(o2, r2)
  }));
}
function Yt(e2, n2, t2, o2 = []) {
  const r2 = refineCalendarFields(e2, n2, en, o2);
  return e2.dateFromFields(r2, t2);
}
function nt(e2, n2, t2, o2) {
  const r2 = refineCalendarFields(e2, n2, fi, o2);
  return e2.yearMonthFromFields(r2, t2);
}
function K(e2, n2, t2, o2, r2 = []) {
  const i3 = refineCalendarFields(e2, t2, en, r2);
  return n2 && void 0 !== i3.month && void 0 === i3.monthCode && void 0 === i3.year && (i3.year = ji), e2.monthDayFromFields(i3, o2);
}
function Ue(e2, n2) {
  const t2 = H(n2);
  return Ge(refineTimeBag(refineFields(e2, ei, [], 1), t2));
}
function Ht(e2) {
  const n2 = refineFields(e2, Ni);
  return Vt(checkDurationUnits({
    ...Si,
    ...n2
  }));
}
function refineCalendarFields(e2, n2, t2, o2 = [], r2 = []) {
  return refineFields(n2, [...e2.fields(t2), ...r2].sort(), o2);
}
function refineFields(e2, n2, t2, o2 = !t2) {
  const r2 = {};
  let i3, a2 = 0;
  for (const o3 of n2) {
    if (o3 === i3) {
      throw new RangeError(duplicateFields(o3));
    }
    if ("constructor" === o3 || "__proto__" === o3) {
      throw new RangeError(tn(o3));
    }
    let n3 = e2[o3];
    if (void 0 !== n3) {
      a2 = 1, Ga[o3] && (n3 = Ga[o3](n3, o3)), r2[o3] = n3;
    } else if (t2) {
      if (t2.includes(o3)) {
        throw new TypeError(missingField(o3));
      }
      r2[o3] = hi[o3];
    }
    i3 = o3;
  }
  if (o2 && !a2) {
    throw new TypeError(noValidFields(n2));
  }
  return r2;
}
function refineTimeBag(e2, n2) {
  return constrainIsoTimeFields(Ha({
    ...hi,
    ...e2
  }), n2);
}
function Sn(e2, n2, t2, o2, r2, i3) {
  const a2 = U(i3), { calendar: s2, timeZone: c2 } = t2;
  return Yn(((e3, n3, t3, o3, r3) => {
    const i4 = mergeCalendarFields(e3, t3, o3, en, oi, ni), [a3, s3, c3] = wn(r3, 2);
    return getMatchingInstantFor(n3, {
      ...e3.dateFromFields(i4, overrideOverflowOptions(r3, a3)),
      ...refineTimeBag(i4, a3)
    }, parseOffsetNano(i4.offset), s3, c3);
  })(e2(s2), n2(c2), o2, r2, a2), c2, s2);
}
function at(e2, n2, t2, o2, r2) {
  const i3 = U(r2);
  return ee(((e3, n3, t3, o3) => {
    const r3 = mergeCalendarFields(e3, n3, t3, en, w), i4 = H(o3);
    return checkIsoDateTimeInBounds({
      ...e3.dateFromFields(r3, overrideOverflowOptions(o3, i4)),
      ...refineTimeBag(r3, i4)
    });
  })(e2(n2.calendar), t2, o2, i3));
}
function Zt(e2, n2, t2, o2, r2) {
  const i3 = U(r2);
  return ((e3, n3, t3, o3) => {
    const r3 = mergeCalendarFields(e3, n3, t3, en);
    return e3.dateFromFields(r3, o3);
  })(e2(n2.calendar), t2, o2, i3);
}
function Ke(e2, n2, t2, o2, r2) {
  const i3 = U(r2);
  return createPlainYearMonthSlots(((e3, n3, t3, o3) => {
    const r3 = mergeCalendarFields(e3, n3, t3, fi);
    return e3.yearMonthFromFields(r3, o3);
  })(e2(n2.calendar), t2, o2, i3));
}
function k(e2, n2, t2, o2, r2) {
  const i3 = U(r2);
  return ((e3, n3, t3, o3) => {
    const r3 = mergeCalendarFields(e3, n3, t3, en);
    return e3.monthDayFromFields(r3, o3);
  })(e2(n2.calendar), t2, o2, i3);
}
function Be(e2, n2, t2) {
  return Ge(((e3, n3, t3) => {
    const o2 = H(t3);
    return refineTimeBag({
      ...Vn(ei, e3),
      ...refineFields(n3, ei)
    }, o2);
  })(e2, n2, t2));
}
function kt(e2, n2) {
  return Vt((t2 = e2, o2 = n2, checkDurationUnits({
    ...t2,
    ...refineFields(o2, Ni)
  })));
  var t2, o2;
}
function mergeCalendarFields(e2, n2, t2, o2, r2 = [], i3 = []) {
  const a2 = [...e2.fields(o2), ...r2].sort();
  let s2 = refineFields(n2, a2, i3);
  const c2 = refineFields(t2, a2);
  return s2 = e2.mergeFields(s2, c2), refineFields(s2, a2, []);
}
function convertToPlainMonthDay(e2, n2) {
  const t2 = refineCalendarFields(e2, n2, pi);
  return e2.monthDayFromFields(t2);
}
function convertToPlainYearMonth(e2, n2, t2) {
  const o2 = refineCalendarFields(e2, n2, di);
  return e2.yearMonthFromFields(o2, t2);
}
function convertToIso(e2, n2, t2, o2, r2) {
  n2 = Vn(t2 = e2.fields(t2), n2), o2 = refineFields(o2, r2 = e2.fields(r2), []);
  let i3 = e2.mergeFields(n2, o2);
  return i3 = refineFields(i3, [...t2, ...r2].sort(), []), e2.dateFromFields(i3);
}
function refineYear(e2, n2) {
  let { era: t2, eraYear: o2, year: r2 } = n2;
  const i3 = getCalendarEraOrigins(e2);
  if (void 0 !== t2 || void 0 !== o2) {
    if (void 0 === t2 || void 0 === o2) {
      throw new TypeError(Dr);
    }
    if (!i3) {
      throw new RangeError(gr);
    }
    const e3 = i3[t2];
    if (void 0 === e3) {
      throw new RangeError(invalidEra(t2));
    }
    const n3 = eraYearToYear(o2, e3);
    if (void 0 !== r2 && r2 !== n3) {
      throw new RangeError(Ir);
    }
    r2 = n3;
  } else if (void 0 === r2) {
    throw new TypeError(missingYear(i3));
  }
  return r2;
}
function refineMonth(e2, n2, t2, o2) {
  let { month: r2, monthCode: i3 } = n2;
  if (void 0 !== i3) {
    const n3 = ((e3, n4, t3, o3) => {
      const r3 = e3.U(t3), [i4, a2] = parseMonthCode(n4);
      let s2 = monthCodeNumberToMonth(i4, a2, r3);
      if (a2) {
        const n5 = getCalendarLeapMonthMeta(e3);
        if (void 0 === n5) {
          throw new RangeError(Pr);
        }
        if (n5 > 0) {
          if (s2 > n5) {
            throw new RangeError(Pr);
          }
          if (void 0 === r3) {
            if (1 === o3) {
              throw new RangeError(Pr);
            }
            s2--;
          }
        } else {
          if (s2 !== -n5) {
            throw new RangeError(Pr);
          }
          if (void 0 === r3 && 1 === o3) {
            throw new RangeError(Pr);
          }
        }
      }
      return s2;
    })(e2, i3, t2, o2);
    if (void 0 !== r2 && r2 !== n3) {
      throw new RangeError(Mr);
    }
    r2 = n3, o2 = 1;
  } else if (void 0 === r2) {
    throw new TypeError(Nr);
  }
  return clampEntity("month", r2, 1, e2.L(t2), o2);
}
function refineDay(e2, n2, t2, o2, r2) {
  return clampProp(n2, "day", 1, e2.j(o2, t2), r2);
}
function spliceFields(e2, n2, t2, o2) {
  let r2 = 0;
  const i3 = [];
  for (const e3 of t2) {
    void 0 !== n2[e3] ? r2 = 1 : i3.push(e3);
  }
  if (Object.assign(e2, n2), r2) {
    for (const n3 of o2 || i3) {
      delete e2[n3];
    }
  }
}
function Se(e2) {
  return _(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(e2))));
}
function vn(e2, n2, t2, o2, r2 = X) {
  return Yn(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(t2))), n2(o2), e2(r2));
}
function pt(e2, n2, t2, o2, r2 = 0, i3 = 0, a2 = 0, s2 = 0, c2 = 0, u2 = 0, l3 = X) {
  return ee(checkIsoDateTimeInBounds(checkIsoDateTimeFields(T(toInteger, zipProps(wi, [n2, t2, o2, r2, i3, a2, s2, c2, u2])))), e2(l3));
}
function Nt(e2, n2, t2, o2, r2 = X) {
  return v(checkIsoDateInBounds(checkIsoDateFields(T(toInteger, {
    isoYear: n2,
    isoMonth: t2,
    isoDay: o2
  }))), e2(r2));
}
function tt(e2, n2, t2, o2 = X, r2 = 1) {
  const i3 = toInteger(n2), a2 = toInteger(t2), s2 = e2(o2);
  return createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields({
    isoYear: i3,
    isoMonth: a2,
    isoDay: toInteger(r2)
  })), s2);
}
function G(e2, n2, t2, o2 = X, r2 = ji) {
  const i3 = toInteger(n2), a2 = toInteger(t2), s2 = e2(o2);
  return createPlainMonthDaySlots(checkIsoDateInBounds(checkIsoDateFields({
    isoYear: toInteger(r2),
    isoMonth: i3,
    isoDay: a2
  })), s2);
}
function ke(e2 = 0, n2 = 0, t2 = 0, o2 = 0, r2 = 0, i3 = 0) {
  return Ge(constrainIsoTimeFields(T(toInteger, zipProps(j, [e2, n2, t2, o2, r2, i3])), 1));
}
function Lt(e2 = 0, n2 = 0, t2 = 0, o2 = 0, r2 = 0, i3 = 0, a2 = 0, s2 = 0, c2 = 0, u2 = 0) {
  return Vt(checkDurationUnits(T(toStrictInteger, zipProps(F, [e2, n2, t2, o2, r2, i3, a2, s2, c2, u2]))));
}
function fe(e2, n2, t2 = X) {
  return Yn(e2.epochNanoseconds, n2, t2);
}
function Zn(e2) {
  return _(e2.epochNanoseconds);
}
function ht(e2, n2) {
  return ee(fn(n2, e2));
}
function Bt(e2, n2) {
  return v(fn(n2, e2));
}
function bn(e2, n2, t2) {
  return convertToPlainYearMonth(e2(n2.calendar), t2);
}
function Fn(e2, n2, t2) {
  return convertToPlainMonthDay(e2(n2.calendar), t2);
}
function Re(e2, n2) {
  return Ge(fn(n2, e2));
}
function mt(e2, n2, t2, o2) {
  const r2 = ((e3, n3, t3, o3) => {
    const r3 = ve(o3);
    return we(e3(n3), t3, r3);
  })(e2, t2, n2, o2);
  return Yn(checkEpochNanoInBounds(r2), t2, n2.calendar);
}
function St(e2, n2, t2) {
  const o2 = e2(n2.calendar);
  return createPlainYearMonthSlots({
    ...n2,
    ...convertToPlainYearMonth(o2, t2)
  });
}
function Ot(e2, n2, t2) {
  return convertToPlainMonthDay(e2(n2.calendar), t2);
}
function vt(e2, n2, t2, o2, r2) {
  const i3 = e2(r2.timeZone), a2 = r2.plainTime, s2 = void 0 !== a2 ? n2(a2) : Dt;
  return Yn(we(t2(i3), {
    ...o2,
    ...s2
  }), i3, o2.calendar);
}
function wt(e2, n2 = Dt) {
  return ee(checkIsoDateTimeInBounds({
    ...e2,
    ...n2
  }));
}
function jt(e2, n2, t2) {
  return convertToPlainYearMonth(e2(n2.calendar), t2);
}
function Mt(e2, n2, t2) {
  return convertToPlainMonthDay(e2(n2.calendar), t2);
}
function _e(e2, n2, t2, o2) {
  return ((e3, n3, t3) => convertToIso(e3, n3, di, de(t3), li))(e2(n2.calendar), t2, o2);
}
function R(e2, n2, t2, o2) {
  return ((e3, n3, t3) => convertToIso(e3, n3, pi, de(t3), si))(e2(n2.calendar), t2, o2);
}
function Je(e2, n2, t2, o2, r2) {
  const i3 = de(r2), a2 = n2(i3.plainDate), s2 = e2(i3.timeZone);
  return Yn(we(t2(s2), {
    ...a2,
    ...o2
  }), s2, a2.calendar);
}
function Le(e2, n2) {
  return ee(checkIsoDateTimeInBounds({
    ...e2,
    ...n2
  }));
}
function De(e2) {
  return _(checkEpochNanoInBounds(he(e2, _r)));
}
function Pe(e2) {
  return _(checkEpochNanoInBounds(he(e2, be)));
}
function Ce(e2) {
  return _(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(e2), Vr)));
}
function ge(e2) {
  return _(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(e2))));
}
function pn(e2, n2, t2 = Dt) {
  const o2 = n2.timeZone, r2 = e2(o2), i3 = {
    ...fn(n2, r2),
    ...t2
  };
  return Yn(getMatchingInstantFor(r2, i3, i3.offsetNanoseconds, 2), o2, n2.calendar);
}
function Tn(e2, n2, t2) {
  const o2 = n2.timeZone, r2 = e2(o2), i3 = {
    ...fn(n2, r2),
    ...t2
  }, a2 = getPreferredCalendarSlot(n2.calendar, t2.calendar);
  return Yn(getMatchingInstantFor(r2, i3, i3.offsetNanoseconds, 2), o2, a2);
}
function lt(e2, n2 = Dt) {
  return ee({
    ...e2,
    ...n2
  });
}
function st(e2, n2) {
  return ee({
    ...e2,
    ...n2
  }, getPreferredCalendarSlot(e2.calendar, n2.calendar));
}
function it(e2, n2) {
  return {
    ...e2,
    calendar: n2
  };
}
function On(e2, n2) {
  return {
    ...e2,
    timeZone: n2
  };
}
function getPreferredCalendarSlot(e2, n2) {
  if (e2 === n2) {
    return e2;
  }
  const t2 = I(e2), o2 = I(n2);
  if (t2 === o2 || t2 === X) {
    return n2;
  }
  if (o2 === X) {
    return e2;
  }
  throw new RangeError(Er);
}
function createNativeOpsCreator(e2, n2) {
  return (t2) => t2 === X ? e2 : t2 === gi || t2 === Ti ? Object.assign(Object.create(e2), {
    id: t2
  }) : Object.assign(Object.create(n2), Aa(t2));
}
function createOptionsTransformer(e2, n2, t2) {
  const o2 = new Set(t2);
  return (r2) => (((e3, n3) => {
    for (const t3 of n3) {
      if (t3 in e3) {
        return 1;
      }
    }
    return 0;
  })(r2 = V(o2, r2), e2) || Object.assign(r2, n2), t2 && (r2.timeZone = Ta, ["full", "long"].includes(r2.timeStyle) && (r2.timeStyle = "medium")), r2);
}
function e(e2, n2 = qn) {
  const [t2, , , o2] = e2;
  return (r2, i3 = Ns, ...a2) => {
    const s2 = n2(o2 && o2(...a2), r2, i3, t2), c2 = s2.resolvedOptions();
    return [s2, ...toEpochMillis(e2, c2, a2)];
  };
}
function qn(e2, n2, t2, o2) {
  if (t2 = o2(t2), e2) {
    if (void 0 !== t2.timeZone) {
      throw new TypeError(Lr);
    }
    t2.timeZone = e2;
  }
  return new En(n2, t2);
}
function toEpochMillis(e2, n2, t2) {
  const [, o2, r2] = e2;
  return t2.map((e3) => (e3.calendar && ((e4, n3, t3) => {
    if ((t3 || e4 !== X) && e4 !== n3) {
      throw new RangeError(Er);
    }
  })(I(e3.calendar), n2.calendar, r2), o2(e3, n2)));
}
function An(e2) {
  const n2 = Bn();
  return Ie(n2, e2.getOffsetNanosecondsFor(n2));
}
function Bn() {
  return he(Date.now(), be);
}
function Nn() {
  return ys || (ys = new En().resolvedOptions().timeZone);
}
var expectedInteger = (e2, n2) => `Non-integer ${e2}: ${n2}`;
var expectedPositive = (e2, n2) => `Non-positive ${e2}: ${n2}`;
var expectedFinite = (e2, n2) => `Non-finite ${e2}: ${n2}`;
var forbiddenBigIntToNumber = (e2) => `Cannot convert bigint to ${e2}`;
var invalidBigInt = (e2) => `Invalid bigint: ${e2}`;
var pr = "Cannot convert Symbol to string";
var hr = "Invalid object";
var numberOutOfRange = (e2, n2, t2, o2, r2) => r2 ? numberOutOfRange(e2, r2[n2], r2[t2], r2[o2]) : invalidEntity(e2, n2) + `; must be between ${t2}-${o2}`;
var invalidEntity = (e2, n2) => `Invalid ${e2}: ${n2}`;
var missingField = (e2) => `Missing ${e2}`;
var tn = (e2) => `Invalid field ${e2}`;
var duplicateFields = (e2) => `Duplicate field ${e2}`;
var noValidFields = (e2) => "No valid fields: " + e2.join();
var Z = "Invalid bag";
var invalidChoice = (e2, n2, t2) => invalidEntity(e2, n2) + "; must be " + Object.keys(t2).join();
var A = "Cannot use valueOf";
var P = "Invalid calling context";
var gr = "Forbidden era/eraYear";
var Dr = "Mismatching era/eraYear";
var Ir = "Mismatching year/eraYear";
var invalidEra = (e2) => `Invalid era: ${e2}`;
var missingYear = (e2) => "Missing year" + (e2 ? "/era/eraYear" : "");
var invalidMonthCode = (e2) => `Invalid monthCode: ${e2}`;
var Mr = "Mismatching month/monthCode";
var Nr = "Missing month/monthCode";
var yr = "Cannot guess year";
var Pr = "Invalid leap month";
var g = "Invalid protocol";
var vr = "Invalid protocol results";
var Er = "Mismatching Calendars";
var invalidCalendar = (e2) => `Invalid Calendar: ${e2}`;
var Fr = "Mismatching TimeZones";
var br = "Forbidden ICU TimeZone";
var wr = "Out-of-bounds offset";
var Br = "Out-of-bounds TimeZone gap";
var kr = "Invalid TimeZone offset";
var Yr = "Ambiguous offset";
var Cr = "Out-of-bounds date";
var Zr = "Out-of-bounds duration";
var Rr = "Cannot mix duration signs";
var zr = "Missing relativeTo";
var qr = "Cannot use large units";
var Ur = "Required smallestUnit or largestUnit";
var Ar = "smallestUnit > largestUnit";
var failedParse = (e2) => `Cannot parse: ${e2}`;
var invalidSubstring = (e2) => `Invalid substring: ${e2}`;
var Ln = (e2) => `Cannot format ${e2}`;
var kn = "Mismatching types for formatting";
var Lr = "Cannot specify TimeZone";
var Wr = /* @__PURE__ */ E(b, (e2, n2) => n2);
var jr = /* @__PURE__ */ E(b, (e2, n2, t2) => t2);
var xr = /* @__PURE__ */ E(padNumber, 2);
var $r = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
};
var Et = /* @__PURE__ */ Object.keys($r);
var Gr = 864e5;
var Hr = 1e3;
var Vr = 1e3;
var be = 1e6;
var _r = 1e9;
var Jr = 6e10;
var Kr = 36e11;
var Qr = 864e11;
var Xr = [1, Vr, be, _r, Jr, Kr, Qr];
var w = /* @__PURE__ */ Et.slice(0, 6);
var ei = /* @__PURE__ */ sortStrings(w);
var ni = ["offset"];
var ti = ["timeZone"];
var oi = /* @__PURE__ */ w.concat(ni);
var ri = /* @__PURE__ */ oi.concat(ti);
var ii = ["era", "eraYear"];
var ai = /* @__PURE__ */ ii.concat(["year"]);
var si = ["year"];
var ci = ["monthCode"];
var ui = /* @__PURE__ */ ["month"].concat(ci);
var li = ["day"];
var fi = /* @__PURE__ */ ui.concat(si);
var di = /* @__PURE__ */ ci.concat(si);
var en = /* @__PURE__ */ li.concat(fi);
var mi = /* @__PURE__ */ li.concat(ui);
var pi = /* @__PURE__ */ li.concat(ci);
var hi = /* @__PURE__ */ jr(w, 0);
var X = "iso8601";
var gi = "gregory";
var Ti = "japanese";
var Di = {
  [gi]: {
    bce: -1,
    ce: 0
  },
  [Ti]: {
    bce: -1,
    ce: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethioaa: {
    era0: 0
  },
  ethiopic: {
    era0: 0,
    era1: 5500
  },
  coptic: {
    era0: -1,
    era1: 0
  },
  roc: {
    beforeroc: -1,
    minguo: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
};
var Ii = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
};
var m = /* @__PURE__ */ E(requireType, "string");
var f = /* @__PURE__ */ E(requireType, "boolean");
var Mi = /* @__PURE__ */ E(requireType, "number");
var $ = /* @__PURE__ */ E(requireType, "function");
var F = /* @__PURE__ */ Et.map((e2) => e2 + "s");
var Ni = /* @__PURE__ */ sortStrings(F);
var yi = /* @__PURE__ */ F.slice(0, 6);
var Pi = /* @__PURE__ */ F.slice(6);
var vi = /* @__PURE__ */ Pi.slice(1);
var Ei = /* @__PURE__ */ Wr(F);
var Si = /* @__PURE__ */ jr(F, 0);
var Fi = /* @__PURE__ */ jr(yi, 0);
var bi = /* @__PURE__ */ E(zeroOutProps, F);
var j = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"];
var Oi = ["isoDay", "isoMonth", "isoYear"];
var wi = /* @__PURE__ */ j.concat(Oi);
var Bi = /* @__PURE__ */ sortStrings(Oi);
var ki = /* @__PURE__ */ sortStrings(j);
var Yi = /* @__PURE__ */ sortStrings(wi);
var Dt = /* @__PURE__ */ jr(ki, 0);
var Ci = /* @__PURE__ */ E(zeroOutProps, wi);
var En = Intl.DateTimeFormat;
var Zi = "en-GB";
var Ri = 1e8;
var zi = Ri * Gr;
var qi = [Ri, 0];
var Ui = [-Ri, 0];
var Ai = 275760;
var Li = -271821;
var Wi = 1970;
var ji = 1972;
var xi = 12;
var $i = /* @__PURE__ */ isoArgsToEpochMilli(1868, 9, 8);
var Gi = /* @__PURE__ */ Jn(computeJapaneseEraParts, WeakMap);
var Hi = "smallestUnit";
var Vi = "unit";
var _i = "roundingIncrement";
var Ji = "fractionalSecondDigits";
var Ki = "relativeTo";
var Qi = {
  constrain: 0,
  reject: 1
};
var Xi = /* @__PURE__ */ Object.keys(Qi);
var ea = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
};
var na = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
};
var ta = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
};
var oa = {
  auto: 0,
  never: 1,
  critical: 2
};
var ra = {
  auto: 0,
  never: 1
};
var ia = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
};
var aa = /* @__PURE__ */ E(refineUnitOption, Hi);
var sa = /* @__PURE__ */ E(refineUnitOption, "largestUnit");
var ca = /* @__PURE__ */ E(refineUnitOption, Vi);
var ua = /* @__PURE__ */ E(refineChoiceOption, "overflow", Qi);
var la = /* @__PURE__ */ E(refineChoiceOption, "disambiguation", ea);
var fa = /* @__PURE__ */ E(refineChoiceOption, "offset", na);
var da = /* @__PURE__ */ E(refineChoiceOption, "calendarName", ta);
var ma = /* @__PURE__ */ E(refineChoiceOption, "timeZoneName", oa);
var pa = /* @__PURE__ */ E(refineChoiceOption, "offset", ra);
var ha = /* @__PURE__ */ E(refineChoiceOption, "roundingMode", ia);
var L = "PlainYearMonth";
var q = "PlainMonthDay";
var J = "PlainDate";
var We = "PlainDateTime";
var xe = "PlainTime";
var Te = "ZonedDateTime";
var Oe = "Instant";
var qt = "Duration";
var ga = [Math.floor, (e2) => hasHalf(e2) ? Math.floor(e2) : Math.round(e2), Math.ceil, (e2) => hasHalf(e2) ? Math.ceil(e2) : Math.round(e2), Math.trunc, (e2) => hasHalf(e2) ? Math.trunc(e2) || 0 : Math.round(e2), (e2) => e2 < 0 ? Math.floor(e2) : Math.ceil(e2), (e2) => Math.sign(e2) * Math.round(Math.abs(e2)) || 0, (e2) => hasHalf(e2) ? (e2 = Math.trunc(e2) || 0) + e2 % 2 : Math.round(e2)];
var Ta = "UTC";
var Da = 5184e3;
var Ia = /* @__PURE__ */ isoArgsToEpochSec(1847);
var Ma = /* @__PURE__ */ isoArgsToEpochSec(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10);
var Na = /0+$/;
var fn = /* @__PURE__ */ Jn(_zonedEpochSlotsToIso, WeakMap);
var ya = 2 ** 32 - 1;
var ie = /* @__PURE__ */ Jn((e2) => {
  const n2 = getTimeZoneEssence(e2);
  return "object" == typeof n2 ? new IntlTimeZone(n2) : new FixedTimeZone(n2 || 0);
});
var FixedTimeZone = class {
  constructor(e2) {
    this.v = e2;
  }
  getOffsetNanosecondsFor() {
    return this.v;
  }
  getPossibleInstantsFor(e2) {
    return [isoToEpochNanoWithOffset(e2, this.v)];
  }
  l() {
  }
};
var IntlTimeZone = class {
  constructor(e2) {
    this.$ = ((e3) => {
      function getOffsetSec(e4) {
        const i3 = clampNumber(e4, o2, r2), [a2, s2] = computePeriod(i3), c2 = n2(a2), u2 = n2(s2);
        return c2 === u2 ? c2 : pinch(t2(a2, s2), c2, u2, e4);
      }
      function pinch(n3, t3, o3, r3) {
        let i3, a2;
        for (; (void 0 === r3 || void 0 === (i3 = r3 < n3[0] ? t3 : r3 >= n3[1] ? o3 : void 0)) && (a2 = n3[1] - n3[0]); ) {
          const t4 = n3[0] + Math.floor(a2 / 2);
          e3(t4) === o3 ? n3[1] = t4 : n3[0] = t4 + 1;
        }
        return i3;
      }
      const n2 = Jn(e3), t2 = Jn(createSplitTuple);
      let o2 = Ia, r2 = Ma;
      return {
        G(e4) {
          const n3 = getOffsetSec(e4 - 86400), t3 = getOffsetSec(e4 + 86400), o3 = e4 - n3, r3 = e4 - t3;
          if (n3 === t3) {
            return [o3];
          }
          const i3 = getOffsetSec(o3);
          return i3 === getOffsetSec(r3) ? [e4 - i3] : n3 > t3 ? [o3, r3] : [];
        },
        V: getOffsetSec,
        l(e4, i3) {
          const a2 = clampNumber(e4, o2, r2);
          let [s2, c2] = computePeriod(a2);
          const u2 = Da * i3, l3 = i3 < 0 ? () => c2 > o2 || (o2 = a2, 0) : () => s2 < r2 || (r2 = a2, 0);
          for (; l3(); ) {
            const o3 = n2(s2), r3 = n2(c2);
            if (o3 !== r3) {
              const n3 = t2(s2, c2);
              pinch(n3, o3, r3);
              const a3 = n3[0];
              if ((compareNumbers(a3, e4) || 1) === i3) {
                return a3;
              }
            }
            s2 += u2, c2 += u2;
          }
        }
      };
    })(/* @__PURE__ */ ((e3) => (n2) => {
      const t2 = hashIntlFormatParts(e3, n2 * Hr);
      return isoArgsToEpochSec(parseIntlPartsYear(t2), parseInt(t2.month), parseInt(t2.day), parseInt(t2.hour), parseInt(t2.minute), parseInt(t2.second)) - n2;
    })(e2));
  }
  getOffsetNanosecondsFor(e2) {
    return this.$.V(epochNanoToSec(e2)) * _r;
  }
  getPossibleInstantsFor(e2) {
    const [n2, t2] = [isoArgsToEpochSec((o2 = e2).isoYear, o2.isoMonth, o2.isoDay, o2.isoHour, o2.isoMinute, o2.isoSecond), o2.isoMillisecond * be + o2.isoMicrosecond * Vr + o2.isoNanosecond];
    var o2;
    return this.$.G(n2).map((e3) => checkEpochNanoInBounds(moveBigNano(he(e3, _r), t2)));
  }
  l(e2, n2) {
    const [t2, o2] = epochNanoToSecMod(e2), r2 = this.$.l(t2 + (n2 > 0 || o2 ? 1 : 0), n2);
    if (void 0 !== r2) {
      return he(r2, _r);
    }
  }
};
var Pa = "([+\u2212-])";
var va = "(?:[.,](\\d{1,9}))?";
var Ea = `(?:(?:${Pa}(\\d{6}))|(\\d{4}))-?(\\d{2})`;
var Sa = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + va + ")?)?";
var Fa = Pa + Sa;
var ba = Ea + "-?(\\d{2})(?:[T ]" + Sa + "(Z|" + Fa + ")?)?";
var Oa = "\\[(!?)([^\\]]*)\\]";
var wa = `((?:${Oa}){0,9})`;
var Ba = /* @__PURE__ */ createRegExp(Ea + wa);
var ka = /* @__PURE__ */ createRegExp("(?:--)?(\\d{2})-?(\\d{2})" + wa);
var Ya = /* @__PURE__ */ createRegExp(ba + wa);
var Ca = /* @__PURE__ */ createRegExp("T?" + Sa + "(?:" + Fa + ")?" + wa);
var Za = /* @__PURE__ */ createRegExp(Fa);
var Ra = /* @__PURE__ */ new RegExp(Oa, "g");
var za = /* @__PURE__ */ createRegExp(`${Pa}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${va}H)?(?:(\\d+)${va}M)?(?:(\\d+)${va}S)?)?`);
var qa = /* @__PURE__ */ Jn((e2) => new En(Zi, {
  timeZone: e2,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
}));
var Ua = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/;
var Aa = /* @__PURE__ */ Jn(createIntlCalendar);
var La = /* @__PURE__ */ Jn((e2) => new En(Zi, {
  calendar: e2,
  timeZone: Ta,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
}));
var Wa = /^M(\d{2})(L?)$/;
var ja = {
  era: toStringViaPrimitive,
  eraYear: toInteger,
  year: toInteger,
  month: toPositiveInteger,
  monthCode: toStringViaPrimitive,
  day: toPositiveInteger
};
var xa = /* @__PURE__ */ jr(w, toInteger);
var $a = /* @__PURE__ */ jr(F, toStrictInteger);
var Ga = /* @__PURE__ */ Object.assign({}, ja, xa, $a, {
  offset: toStringViaPrimitive
});
var Ha = /* @__PURE__ */ E(remapProps, w, j);
var Va = {
  dateAdd(e2, n2, t2) {
    const o2 = H(t2);
    let r2, { years: i3, months: a2, weeks: s2, days: c2 } = n2;
    if (c2 += durationFieldsToBigNano(n2, 5)[0], i3 || a2) {
      r2 = ((e3, n3, t3, o3, r3) => {
        let [i4, a3, s3] = e3.h(n3);
        if (t3) {
          const [n4, o4] = e3.I(i4, a3);
          i4 += t3, a3 = monthCodeNumberToMonth(n4, o4, e3.U(i4)), a3 = clampEntity("month", a3, 1, e3.L(i4), r3);
        }
        return o3 && ([i4, a3] = e3._(i4, a3, o3)), s3 = clampEntity("day", s3, 1, e3.j(i4, a3), r3), e3.q(i4, a3, s3);
      })(this, e2, i3, a2, o2);
    } else {
      if (!s2 && !c2) {
        return e2;
      }
      r2 = isoToEpochMilli(e2);
    }
    return r2 += (7 * s2 + c2) * Gr, checkIsoDateInBounds(epochMilliToIso(r2));
  },
  dateUntil(e2, n2, t2) {
    if (t2 <= 7) {
      let o3 = 0, r3 = diffDays({
        ...e2,
        ...Dt
      }, {
        ...n2,
        ...Dt
      });
      return 7 === t2 && ([o3, r3] = divModTrunc(r3, 7)), {
        ...Si,
        weeks: o3,
        days: r3
      };
    }
    const o2 = this.h(e2), r2 = this.h(n2);
    let [i3, a2, s2] = ((e3, n3, t3, o3, r3, i4, a3) => {
      let s3 = r3 - n3, c2 = i4 - t3, u2 = a3 - o3;
      if (s3 || c2) {
        const l3 = Math.sign(s3 || c2);
        let f2 = e3.j(r3, i4), d2 = 0;
        if (Math.sign(u2) === -l3) {
          const o4 = f2;
          [r3, i4] = e3._(r3, i4, -l3), s3 = r3 - n3, c2 = i4 - t3, f2 = e3.j(r3, i4), d2 = l3 < 0 ? -o4 : f2;
        }
        if (u2 = a3 - Math.min(o3, f2) + d2, s3) {
          const [o4, a4] = e3.I(n3, t3), [u3, f3] = e3.I(r3, i4);
          if (c2 = u3 - o4 || Number(f3) - Number(a4), Math.sign(c2) === -l3) {
            const t4 = l3 < 0 && -e3.L(r3);
            s3 = (r3 -= l3) - n3, c2 = i4 - monthCodeNumberToMonth(o4, a4, e3.U(r3)) + (t4 || e3.L(r3));
          }
        }
      }
      return [s3, c2, u2];
    })(this, ...o2, ...r2);
    return 8 === t2 && (a2 += this.J(i3, o2[0]), i3 = 0), {
      ...Si,
      years: i3,
      months: a2,
      days: s2
    };
  },
  dateFromFields(e2, n2) {
    const t2 = H(n2), o2 = refineYear(this, e2), r2 = refineMonth(this, e2, o2, t2), i3 = refineDay(this, e2, r2, o2, t2);
    return v(checkIsoDateInBounds(this.P(o2, r2, i3)), this.id || X);
  },
  yearMonthFromFields(e2, n2) {
    const t2 = H(n2), o2 = refineYear(this, e2), r2 = refineMonth(this, e2, o2, t2);
    return createPlainYearMonthSlots(checkIsoYearMonthInBounds(this.P(o2, r2, 1)), this.id || X);
  },
  monthDayFromFields(e2, n2) {
    const t2 = H(n2), o2 = !this.id, { monthCode: r2, year: i3, month: a2 } = e2;
    let s2, c2, u2, l3, f2;
    if (void 0 !== r2) {
      [s2, c2] = parseMonthCode(r2), f2 = getDefinedProp(e2, "day");
      const n3 = this.N(s2, c2, f2);
      if (!n3) {
        throw new RangeError(yr);
      }
      if ([u2, l3] = n3, void 0 !== a2 && a2 !== l3) {
        throw new RangeError(Mr);
      }
      o2 && (l3 = clampEntity("month", l3, 1, xi, 1), f2 = clampEntity("day", f2, 1, computeIsoDaysInMonth(void 0 !== i3 ? i3 : u2, l3), t2));
    } else {
      u2 = void 0 === i3 && o2 ? ji : refineYear(this, e2), l3 = refineMonth(this, e2, u2, t2), f2 = refineDay(this, e2, l3, u2, t2);
      const n3 = this.U(u2);
      c2 = l3 === n3, s2 = monthToMonthCodeNumber(l3, n3);
      const r3 = this.N(s2, c2, f2);
      if (!r3) {
        throw new RangeError(yr);
      }
      [u2, l3] = r3;
    }
    return createPlainMonthDaySlots(checkIsoDateInBounds(this.P(u2, l3, f2)), this.id || X);
  },
  fields(e2) {
    return getCalendarEraOrigins(this) && e2.includes("year") ? [...e2, ...ii] : e2;
  },
  mergeFields(e2, n2) {
    const t2 = Object.assign(/* @__PURE__ */ Object.create(null), e2);
    return spliceFields(t2, n2, ui), getCalendarEraOrigins(this) && (spliceFields(t2, n2, ai), this.id === Ti && spliceFields(t2, n2, mi, ii)), t2;
  },
  inLeapYear(e2) {
    const [n2] = this.h(e2);
    return this.K(n2);
  },
  monthsInYear(e2) {
    const [n2] = this.h(e2);
    return this.L(n2);
  },
  daysInMonth(e2) {
    const [n2, t2] = this.h(e2);
    return this.j(n2, t2);
  },
  daysInYear(e2) {
    const [n2] = this.h(e2);
    return this.X(n2);
  },
  dayOfYear: computeNativeDayOfYear,
  era(e2) {
    return this.ee(e2)[0];
  },
  eraYear(e2) {
    return this.ee(e2)[1];
  },
  monthCode(e2) {
    const [n2, t2] = this.h(e2), [o2, r2] = this.I(n2, t2);
    return ((e3, n3) => "M" + xr(e3) + (n3 ? "L" : ""))(o2, r2);
  },
  dayOfWeek: computeIsoDayOfWeek,
  daysInWeek() {
    return 7;
  }
};
var _a = {
  dayOfYear: computeNativeDayOfYear,
  h: computeIsoDateParts,
  q: isoArgsToEpochMilli
};
var Ja = /* @__PURE__ */ Object.assign({}, _a, {
  weekOfYear: computeNativeWeekOfYear,
  yearOfWeek: computeNativeYearOfWeek,
  R(e2) {
    function computeWeekShift(e3) {
      return (7 - e3 < n2 ? 7 : 0) - e3;
    }
    function computeWeeksInYear(e3) {
      const n3 = computeIsoDaysInYear(l3 + e3), t3 = e3 || 1, o3 = computeWeekShift(modFloor(a2 + n3 * t3, 7));
      return c2 = (n3 + (o3 - s2) * t3) / 7;
    }
    const n2 = this.id ? 1 : 4, t2 = computeIsoDayOfWeek(e2), o2 = this.dayOfYear(e2), r2 = modFloor(t2 - 1, 7), i3 = o2 - 1, a2 = modFloor(r2 - i3, 7), s2 = computeWeekShift(a2);
    let c2, u2 = Math.floor((i3 - s2) / 7) + 1, l3 = e2.isoYear;
    return u2 ? u2 > computeWeeksInYear(0) && (u2 = 1, l3++) : (u2 = computeWeeksInYear(-1), l3--), [u2, l3, c2];
  }
});
var Ka = {
  dayOfYear: computeNativeDayOfYear,
  h: computeIntlDateParts,
  q: computeIntlEpochMilli,
  weekOfYear: computeNativeWeekOfYear,
  yearOfWeek: computeNativeYearOfWeek,
  R() {
    return [];
  }
};
var Y = /* @__PURE__ */ createNativeOpsCreator(/* @__PURE__ */ Object.assign({}, Va, Ja, {
  h: computeIsoDateParts,
  ee(e2) {
    return this.id === gi ? computeGregoryEraParts(e2) : this.id === Ti ? Gi(e2) : [];
  },
  I: (e2, n2) => [n2, 0],
  N(e2, n2) {
    if (!n2) {
      return [ji, e2];
    }
  },
  K: computeIsoInLeapYear,
  U() {
  },
  L: computeIsoMonthsInYear,
  J: (e2) => e2 * xi,
  j: computeIsoDaysInMonth,
  X: computeIsoDaysInYear,
  P: (e2, n2, t2) => ({
    isoYear: e2,
    isoMonth: n2,
    isoDay: t2
  }),
  q: isoArgsToEpochMilli,
  _: (e2, n2, t2) => (e2 += divTrunc(t2, xi), (n2 += modTrunc(t2, xi)) < 1 ? (e2--, n2 += xi) : n2 > xi && (e2++, n2 -= xi), [e2, n2]),
  year(e2) {
    return e2.isoYear;
  },
  month(e2) {
    return e2.isoMonth;
  },
  day: (e2) => e2.isoDay
}), /* @__PURE__ */ Object.assign({}, Va, Ka, {
  h: computeIntlDateParts,
  ee(e2) {
    const n2 = this.O(e2);
    return [n2.era, n2.eraYear];
  },
  I(e2, n2) {
    const t2 = computeIntlLeapMonth.call(this, e2);
    return [monthToMonthCodeNumber(n2, t2), t2 === n2];
  },
  N(e2, n2, t2) {
    let [o2, r2, i3] = computeIntlDateParts.call(this, {
      isoYear: ji,
      isoMonth: xi,
      isoDay: 31
    });
    const a2 = computeIntlLeapMonth.call(this, o2), s2 = r2 === a2;
    1 === (compareNumbers(e2, monthToMonthCodeNumber(r2, a2)) || compareNumbers(Number(n2), Number(s2)) || compareNumbers(t2, i3)) && o2--;
    for (let r3 = 0; r3 < 100; r3++) {
      const i4 = o2 - r3, a3 = computeIntlLeapMonth.call(this, i4), s3 = monthCodeNumberToMonth(e2, n2, a3);
      if (n2 === (s3 === a3) && t2 <= computeIntlDaysInMonth.call(this, i4, s3)) {
        return [i4, s3];
      }
    }
  },
  K(e2) {
    const n2 = computeIntlDaysInYear.call(this, e2);
    return n2 > computeIntlDaysInYear.call(this, e2 - 1) && n2 > computeIntlDaysInYear.call(this, e2 + 1);
  },
  U: computeIntlLeapMonth,
  L: computeIntlMonthsInYear,
  J(e2, n2) {
    const t2 = n2 + e2, o2 = Math.sign(e2), r2 = o2 < 0 ? -1 : 0;
    let i3 = 0;
    for (let e3 = n2; e3 !== t2; e3 += o2) {
      i3 += computeIntlMonthsInYear.call(this, e3 + r2);
    }
    return i3;
  },
  j: computeIntlDaysInMonth,
  X: computeIntlDaysInYear,
  P(e2, n2, t2) {
    return epochMilliToIso(computeIntlEpochMilli.call(this, e2, n2, t2));
  },
  q: computeIntlEpochMilli,
  _(e2, n2, t2) {
    if (t2) {
      if (n2 += t2, !Number.isSafeInteger(n2)) {
        throw new RangeError(Cr);
      }
      if (t2 < 0) {
        for (; n2 < 1; ) {
          n2 += computeIntlMonthsInYear.call(this, --e2);
        }
      } else {
        let t3;
        for (; n2 > (t3 = computeIntlMonthsInYear.call(this, e2)); ) {
          n2 -= t3, e2++;
        }
      }
    }
    return [e2, n2];
  },
  year(e2) {
    return this.O(e2).year;
  },
  month(e2) {
    const { year: n2, F: t2 } = this.O(e2), { C: o2 } = this.B(n2);
    return o2[t2] + 1;
  },
  day(e2) {
    return this.O(e2).day;
  }
}));
var Qa = "numeric";
var Xa = ["timeZoneName"];
var es = {
  month: Qa,
  day: Qa
};
var ns = {
  year: Qa,
  month: Qa
};
var ts = /* @__PURE__ */ Object.assign({}, ns, {
  day: Qa
});
var os = {
  hour: Qa,
  minute: Qa,
  second: Qa
};
var rs = /* @__PURE__ */ Object.assign({}, ts, os);
var is = /* @__PURE__ */ Object.assign({}, rs, {
  timeZoneName: "short"
});
var as = /* @__PURE__ */ Object.keys(ns);
var ss = /* @__PURE__ */ Object.keys(es);
var cs = /* @__PURE__ */ Object.keys(ts);
var us = /* @__PURE__ */ Object.keys(os);
var ls = ["dateStyle"];
var fs = /* @__PURE__ */ as.concat(ls);
var ds = /* @__PURE__ */ ss.concat(ls);
var ms = /* @__PURE__ */ cs.concat(ls, ["weekday"]);
var ps = /* @__PURE__ */ us.concat(["dayPeriod", "timeStyle"]);
var hs = /* @__PURE__ */ ms.concat(ps);
var gs = /* @__PURE__ */ hs.concat(Xa);
var Ts = /* @__PURE__ */ Xa.concat(ps);
var Ds = /* @__PURE__ */ Xa.concat(ms);
var Is = /* @__PURE__ */ Xa.concat(["day", "weekday"], ps);
var Ms = /* @__PURE__ */ Xa.concat(["year", "weekday"], ps);
var Ns = {};
var t = [/* @__PURE__ */ createOptionsTransformer(hs, rs), y];
var s = [/* @__PURE__ */ createOptionsTransformer(gs, is), y, 0, (e2, n2) => {
  const t2 = I(e2.timeZone);
  if (n2 && I(n2.timeZone) !== t2) {
    throw new RangeError(Fr);
  }
  return t2;
}];
var n = [/* @__PURE__ */ createOptionsTransformer(hs, rs, Xa), isoToEpochMilli];
var o = [/* @__PURE__ */ createOptionsTransformer(ms, ts, Ts), isoToEpochMilli];
var r = [/* @__PURE__ */ createOptionsTransformer(ps, os, Ds), (e2) => isoTimeFieldsToNano(e2) / be];
var a = [/* @__PURE__ */ createOptionsTransformer(fs, ns, Is), isoToEpochMilli, 1];
var i2 = [/* @__PURE__ */ createOptionsTransformer(ds, es, Ms), isoToEpochMilli, 1];
var ys;

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/temporal-polyfill@0.2.5/node_modules/temporal-polyfill/chunks/classApi.js
function createSlotClass(e2, t2, n2, o2, r2) {
  function Class(...e3) {
    if (!(this instanceof Class)) {
      throw new TypeError(P);
    }
    oo(this, t2(...e3));
  }
  function bindMethod(e3, t3) {
    return Object.defineProperties(function(...t4) {
      return e3.call(this, getSpecificSlots(this), ...t4);
    }, D(t3));
  }
  function getSpecificSlots(t3) {
    const n3 = no(t3);
    if (!n3 || n3.branding !== e2) {
      throw new TypeError(P);
    }
    return n3;
  }
  return Object.defineProperties(Class.prototype, {
    ...O(T(bindMethod, n2)),
    ...p(T(bindMethod, o2)),
    ...h("Temporal." + e2)
  }), Object.defineProperties(Class, {
    ...p(r2),
    ...D(e2)
  }), [Class, (e3) => {
    const t3 = Object.create(Class.prototype);
    return oo(t3, e3), t3;
  }, getSpecificSlots];
}
function createProtocolValidator(e2) {
  return e2 = e2.concat("id").sort(), (t2) => {
    if (!C(t2, e2)) {
      throw new TypeError(g);
    }
    return t2;
  };
}
function rejectInvalidBag(e2) {
  if (no(e2) || void 0 !== e2.calendar || void 0 !== e2.timeZone) {
    throw new TypeError(Z);
  }
  return e2;
}
function createCalendarFieldMethods(e2, t2) {
  const n2 = {};
  for (const o2 in e2) {
    n2[o2] = ({ o: e3 }, n3) => {
      const r2 = no(n3) || {}, { branding: a2 } = r2, i3 = a2 === J || t2.includes(a2) ? r2 : toPlainDateSlots(n3);
      return e3[o2](i3);
    };
  }
  return n2;
}
function createCalendarGetters(e2) {
  const t2 = {};
  for (const n2 in e2) {
    t2[n2] = (e3) => {
      const { calendar: t3 } = e3;
      return (o2 = t3, "string" == typeof o2 ? Y(o2) : (r2 = o2, Object.assign(Object.create(co), {
        i: r2
      })))[n2](e3);
      var o2, r2;
    };
  }
  return t2;
}
function neverValueOf() {
  throw new TypeError(A);
}
function createCalendarFromSlots({ calendar: e2 }) {
  return "string" == typeof e2 ? new lr(e2) : e2;
}
function toPlainMonthDaySlots(e2, t2) {
  if (t2 = U(t2), z(e2)) {
    const n3 = no(e2);
    if (n3 && n3.branding === q) {
      return H(t2), n3;
    }
    const o2 = extractCalendarSlotFromBag(e2);
    return K(Qo(o2 || X), !o2, e2, t2);
  }
  const n2 = Q(Y, e2);
  return H(t2), n2;
}
function getOffsetNanosecondsForAdapter(e2, t2, n2) {
  return o2 = t2.call(e2, Co(_(n2))), ae(u(o2));
  var o2;
}
function createAdapterOps(e2, t2 = ho) {
  const n2 = Object.keys(t2).sort(), o2 = {};
  for (const r2 of n2) {
    o2[r2] = E(t2[r2], e2, $(e2[r2]));
  }
  return o2;
}
function createTimeZoneOps(e2, t2) {
  return "string" == typeof e2 ? ie(e2) : createAdapterOps(e2, t2);
}
function createTimeZoneOffsetOps(e2) {
  return createTimeZoneOps(e2, Do);
}
function toInstantSlots(e2) {
  if (z(e2)) {
    const t2 = no(e2);
    if (t2) {
      switch (t2.branding) {
        case Oe:
          return t2;
        case Te:
          return _(t2.epochNanoseconds);
      }
    }
  }
  return pe(e2);
}
function getImplTransition(e2, t2, n2) {
  const o2 = t2.l(toInstantSlots(n2).epochNanoseconds, e2);
  return o2 ? Co(_(o2)) : null;
}
function refineTimeZoneSlot(e2) {
  return z(e2) ? (no(e2) || {}).timeZone || Fo(e2) : ((e3) => ye(Ne(m(e3))))(e2);
}
function toPlainTimeSlots(e2, t2) {
  if (z(e2)) {
    const n2 = no(e2) || {};
    switch (n2.branding) {
      case xe:
        return H(t2), n2;
      case We:
        return H(t2), Ge(n2);
      case Te:
        return H(t2), Re(createTimeZoneOffsetOps, n2);
    }
    return Ue(e2, t2);
  }
  return H(t2), ze(e2);
}
function optionalToPlainTimeFields(e2) {
  return void 0 === e2 ? void 0 : toPlainTimeSlots(e2);
}
function toPlainYearMonthSlots(e2, t2) {
  if (t2 = U(t2), z(e2)) {
    const n3 = no(e2);
    return n3 && n3.branding === L ? (H(t2), n3) : nt(Ho(getCalendarSlotFromBag(e2)), e2, t2);
  }
  const n2 = ot(Y, e2);
  return H(t2), n2;
}
function toPlainDateTimeSlots(e2, t2) {
  if (t2 = U(t2), z(e2)) {
    const n3 = no(e2) || {};
    switch (n3.branding) {
      case We:
        return H(t2), n3;
      case J:
        return H(t2), ee({
          ...n3,
          ...Dt
        });
      case Te:
        return H(t2), ht(createTimeZoneOffsetOps, n3);
    }
    return Pt(Ko(getCalendarSlotFromBag(e2)), e2, t2);
  }
  const n2 = Ct(e2);
  return H(t2), n2;
}
function toPlainDateSlots(e2, t2) {
  if (t2 = U(t2), z(e2)) {
    const n3 = no(e2) || {};
    switch (n3.branding) {
      case J:
        return H(t2), n3;
      case We:
        return H(t2), v(n3);
      case Te:
        return H(t2), Bt(createTimeZoneOffsetOps, n3);
    }
    return Yt(Ko(getCalendarSlotFromBag(e2)), e2, t2);
  }
  const n2 = At(e2);
  return H(t2), n2;
}
function dayAdapter(e2, t2, n2) {
  return d(t2.call(e2, Yo(v(n2, e2))));
}
function createCompoundOpsCreator(e2) {
  return (t2) => "string" == typeof t2 ? Y(t2) : ((e3, t3) => {
    const n2 = Object.keys(t3).sort(), o2 = {};
    for (const r2 of n2) {
      o2[r2] = E(t3[r2], e3, e3[r2]);
    }
    return o2;
  })(t2, e2);
}
function toDurationSlots(e2) {
  if (z(e2)) {
    const t2 = no(e2);
    return t2 && t2.branding === qt ? t2 : Ht(e2);
  }
  return Kt(e2);
}
function refinePublicRelativeTo(e2) {
  if (void 0 !== e2) {
    if (z(e2)) {
      const t2 = no(e2) || {};
      switch (t2.branding) {
        case Te:
        case J:
          return t2;
        case We:
          return v(t2);
      }
      const n2 = getCalendarSlotFromBag(e2);
      return {
        ...Qt(refineTimeZoneSlot, createTimeZoneOps, Ko(n2), e2),
        calendar: n2
      };
    }
    return Xt(e2);
  }
}
function getCalendarSlotFromBag(e2) {
  return extractCalendarSlotFromBag(e2) || X;
}
function extractCalendarSlotFromBag(e2) {
  const { calendar: t2 } = e2;
  if (void 0 !== t2) {
    return refineCalendarSlot(t2);
  }
}
function refineCalendarSlot(e2) {
  return z(e2) ? (no(e2) || {}).calendar || cr(e2) : ((e3) => an(sn(m(e3))))(e2);
}
function toZonedDateTimeSlots(e2, t2) {
  if (t2 = U(t2), z(e2)) {
    const n2 = no(e2);
    if (n2 && n2.branding === Te) {
      return wn(t2), n2;
    }
    const o2 = getCalendarSlotFromBag(e2);
    return jn(refineTimeZoneSlot, createTimeZoneOps, Ko(o2), o2, e2, t2);
  }
  return Mn(e2, t2);
}
function adaptDateMethods(e2) {
  return T((e3) => (t2) => e3(slotsToIso(t2)), e2);
}
function slotsToIso(e2) {
  return fn(e2, createTimeZoneOffsetOps);
}
function createDateTimeFormatClass() {
  const e2 = En.prototype, t2 = Object.getOwnPropertyDescriptors(e2), n2 = Object.getOwnPropertyDescriptors(En), DateTimeFormat = function(e3, t3 = {}) {
    if (!(this instanceof DateTimeFormat)) {
      return new DateTimeFormat(e3, t3);
    }
    Or.set(this, ((e4, t4 = {}) => {
      const n3 = new En(e4, t4), o2 = n3.resolvedOptions(), r2 = o2.locale, a2 = Vn(Object.keys(t4), o2), i3 = Jn(createFormatPrepperForBranding), prepFormat = (...e5) => {
        let t5;
        const o3 = e5.map((e6, n4) => {
          const o4 = no(e6), r3 = (o4 || {}).branding;
          if (n4 && t5 && t5 !== r3) {
            throw new TypeError(kn);
          }
          return t5 = r3, o4;
        });
        return t5 ? i3(t5)(r2, a2, ...o3) : [n3, ...e5];
      };
      return prepFormat.u = n3, prepFormat;
    })(e3, t3));
  };
  for (const e3 in t2) {
    const n3 = t2[e3], o2 = e3.startsWith("format") && createFormatMethod(e3);
    "function" == typeof n3.value ? n3.value = "constructor" === e3 ? DateTimeFormat : o2 || createProxiedMethod(e3) : o2 && (n3.get = function() {
      return o2.bind(this);
    });
  }
  return n2.prototype.value = Object.create(e2, t2), Object.defineProperties(DateTimeFormat, n2), DateTimeFormat;
}
function createFormatMethod(e2) {
  return function(...t2) {
    const n2 = Or.get(this), [o2, ...r2] = n2(...t2);
    return o2[e2](...r2);
  };
}
function createProxiedMethod(e2) {
  return function(...t2) {
    return Or.get(this).u[e2](...t2);
  };
}
function createFormatPrepperForBranding(t2) {
  const n2 = xn[t2];
  if (!n2) {
    throw new TypeError(Ln(t2));
  }
  return e(n2, Jn(qn));
}
var xn = {
  Instant: t,
  PlainDateTime: n,
  PlainDate: o,
  PlainTime: r,
  PlainYearMonth: a,
  PlainMonthDay: i2
};
var Rn = /* @__PURE__ */ e(t);
var Wn = /* @__PURE__ */ e(s);
var Gn = /* @__PURE__ */ e(n);
var Un = /* @__PURE__ */ e(o);
var zn = /* @__PURE__ */ e(r);
var Hn = /* @__PURE__ */ e(a);
var Kn = /* @__PURE__ */ e(i2);
var Qn = {
  era: l2,
  eraYear: c,
  year: u,
  month: d,
  daysInMonth: d,
  daysInYear: d,
  inLeapYear: f,
  monthsInYear: d
};
var Xn = {
  monthCode: m
};
var $n = {
  day: d
};
var _n = {
  dayOfWeek: d,
  dayOfYear: d,
  weekOfYear: S,
  yearOfWeek: c,
  daysInWeek: d
};
var eo = /* @__PURE__ */ Object.assign({}, Qn, Xn, $n, _n);
var to = /* @__PURE__ */ new WeakMap();
var no = /* @__PURE__ */ to.get.bind(to);
var oo = /* @__PURE__ */ to.set.bind(to);
var ro = {
  ...createCalendarFieldMethods(Qn, [L]),
  ...createCalendarFieldMethods(_n, []),
  ...createCalendarFieldMethods(Xn, [L, q]),
  ...createCalendarFieldMethods($n, [q])
};
var ao = /* @__PURE__ */ createCalendarGetters(eo);
var io = /* @__PURE__ */ createCalendarGetters({
  ...Qn,
  ...Xn
});
var so = /* @__PURE__ */ createCalendarGetters({
  ...Xn,
  ...$n
});
var lo = {
  calendarId: (e2) => I(e2.calendar)
};
var co = /* @__PURE__ */ T((e2, t2) => function(n2) {
  const { i: o2 } = this;
  return e2(o2[t2](Yo(v(n2, o2))));
}, eo);
var uo = /* @__PURE__ */ b((e2) => (t2) => t2[e2], F.concat("sign"));
var fo = /* @__PURE__ */ b((e2, t2) => (e3) => e3[j[t2]], w);
var mo = {
  epochSeconds: M,
  epochMilliseconds: y,
  epochMicroseconds: N,
  epochNanoseconds: B
};
var So = /* @__PURE__ */ E(V, /* @__PURE__ */ new Set(["branding"]));
var [Oo, To, po] = createSlotClass(q, E(G, refineCalendarSlot), {
  ...lo,
  ...so
}, {
  getISOFields: So,
  getCalendar: createCalendarFromSlots,
  with(e2, t2, n2) {
    return To(k(_o, e2, this, rejectInvalidBag(t2), n2));
  },
  equals: (e2, t2) => x(e2, toPlainMonthDaySlots(t2)),
  toPlainDate(e2, t2) {
    return Yo(R($o, e2, this, t2));
  },
  toLocaleString(e2, t2, n2) {
    const [o2, r2] = Kn(t2, n2, e2);
    return o2.format(r2);
  },
  toString: W,
  toJSON: (e2) => W(e2),
  valueOf: neverValueOf
}, {
  from: (e2, t2) => To(toPlainMonthDaySlots(e2, t2))
});
var ho = {
  getOffsetNanosecondsFor: getOffsetNanosecondsForAdapter,
  getPossibleInstantsFor(e2, t2, n2) {
    const o2 = [...t2.call(e2, No(ee(n2, X)))].map((e3) => go(e3).epochNanoseconds), r2 = o2.length;
    return r2 > 1 && (o2.sort(te), ne(oe(re(o2[0], o2[r2 - 1])))), o2;
  }
};
var Do = {
  getOffsetNanosecondsFor: getOffsetNanosecondsForAdapter
};
var [Po, Co, go] = createSlotClass(Oe, Se, mo, {
  add: (e2, t2) => Co(se(0, e2, toDurationSlots(t2))),
  subtract: (e2, t2) => Co(se(1, e2, toDurationSlots(t2))),
  until: (e2, t2, n2) => ar(le(0, e2, toInstantSlots(t2), n2)),
  since: (e2, t2, n2) => ar(le(1, e2, toInstantSlots(t2), n2)),
  round: (e2, t2) => Co(ce(e2, t2)),
  equals: (e2, t2) => ue(e2, toInstantSlots(t2)),
  toZonedDateTime(e2, t2) {
    const n2 = de(t2);
    return dr(fe(e2, refineTimeZoneSlot(n2.timeZone), refineCalendarSlot(n2.calendar)));
  },
  toZonedDateTimeISO: (e2, t2) => dr(fe(e2, refineTimeZoneSlot(t2))),
  toLocaleString(e2, t2, n2) {
    const [o2, r2] = Rn(t2, n2, e2);
    return o2.format(r2);
  },
  toString: (e2, t2) => me(refineTimeZoneSlot, createTimeZoneOffsetOps, e2, t2),
  toJSON: (e2) => me(refineTimeZoneSlot, createTimeZoneOffsetOps, e2),
  valueOf: neverValueOf
}, {
  from: (e2) => Co(toInstantSlots(e2)),
  fromEpochSeconds: (e2) => Co(De(e2)),
  fromEpochMilliseconds: (e2) => Co(Pe(e2)),
  fromEpochMicroseconds: (e2) => Co(Ce(e2)),
  fromEpochNanoseconds: (e2) => Co(ge(e2)),
  compare: (e2, t2) => Ze(toInstantSlots(e2), toInstantSlots(t2))
});
var [Zo, bo] = createSlotClass("TimeZone", (e2) => {
  const t2 = Me(e2);
  return {
    branding: "TimeZone",
    id: t2,
    o: ie(t2)
  };
}, {
  id: (e2) => e2.id
}, {
  getPossibleInstantsFor: ({ o: e2 }, t2) => e2.getPossibleInstantsFor(toPlainDateTimeSlots(t2)).map((e3) => Co(_(e3))),
  getOffsetNanosecondsFor: ({ o: e2 }, t2) => e2.getOffsetNanosecondsFor(toInstantSlots(t2).epochNanoseconds),
  getOffsetStringFor(e2, t2) {
    const n2 = toInstantSlots(t2).epochNanoseconds, o2 = createAdapterOps(this, Do).getOffsetNanosecondsFor(n2);
    return Fe(o2);
  },
  getPlainDateTimeFor(e2, t2, n2 = X) {
    const o2 = toInstantSlots(t2).epochNanoseconds, r2 = createAdapterOps(this, Do).getOffsetNanosecondsFor(o2);
    return No(ee(Ie(o2, r2), refineCalendarSlot(n2)));
  },
  getInstantFor(e2, t2, n2) {
    const o2 = toPlainDateTimeSlots(t2), r2 = ve(n2), a2 = createAdapterOps(this);
    return Co(_(we(a2, o2, r2)));
  },
  getNextTransition: ({ o: e2 }, t2) => getImplTransition(1, e2, t2),
  getPreviousTransition: ({ o: e2 }, t2) => getImplTransition(-1, e2, t2),
  equals(e2, t2) {
    return !!je(this, refineTimeZoneSlot(t2));
  },
  toString: (e2) => e2.id,
  toJSON: (e2) => e2.id
}, {
  from(e2) {
    const t2 = refineTimeZoneSlot(e2);
    return "string" == typeof t2 ? new Zo(t2) : t2;
  }
});
var Fo = /* @__PURE__ */ createProtocolValidator(Object.keys(ho));
var [Io, vo] = createSlotClass(xe, ke, fo, {
  getISOFields: So,
  with(e2, t2, n2) {
    return vo(Be(this, rejectInvalidBag(t2), n2));
  },
  add: (e2, t2) => vo(Ye(0, e2, toDurationSlots(t2))),
  subtract: (e2, t2) => vo(Ye(1, e2, toDurationSlots(t2))),
  until: (e2, t2, n2) => ar(Ae(0, e2, toPlainTimeSlots(t2), n2)),
  since: (e2, t2, n2) => ar(Ae(1, e2, toPlainTimeSlots(t2), n2)),
  round: (e2, t2) => vo(Ee(e2, t2)),
  equals: (e2, t2) => Ve(e2, toPlainTimeSlots(t2)),
  toZonedDateTime: (e2, t2) => dr(Je(refineTimeZoneSlot, toPlainDateSlots, createTimeZoneOps, e2, t2)),
  toPlainDateTime: (e2, t2) => No(Le(e2, toPlainDateSlots(t2))),
  toLocaleString(e2, t2, n2) {
    const [o2, r2] = zn(t2, n2, e2);
    return o2.format(r2);
  },
  toString: qe,
  toJSON: (e2) => qe(e2),
  valueOf: neverValueOf
}, {
  from: (e2, t2) => vo(toPlainTimeSlots(e2, t2)),
  compare: (e2, t2) => He(toPlainTimeSlots(e2), toPlainTimeSlots(t2))
});
var [wo, jo, Mo] = createSlotClass(L, E(tt, refineCalendarSlot), {
  ...lo,
  ...io
}, {
  getISOFields: So,
  getCalendar: createCalendarFromSlots,
  with(e2, t2, n2) {
    return jo(Ke(Xo, e2, this, rejectInvalidBag(t2), n2));
  },
  add: (e2, t2, n2) => jo(Qe(nr, 0, e2, toDurationSlots(t2), n2)),
  subtract: (e2, t2, n2) => jo(Qe(nr, 1, e2, toDurationSlots(t2), n2)),
  until: (e2, t2, n2) => ar(Xe(or, 0, e2, toPlainYearMonthSlots(t2), n2)),
  since: (e2, t2, n2) => ar(Xe(or, 1, e2, toPlainYearMonthSlots(t2), n2)),
  equals: (e2, t2) => $e(e2, toPlainYearMonthSlots(t2)),
  toPlainDate(e2, t2) {
    return Yo(_e($o, e2, this, t2));
  },
  toLocaleString(e2, t2, n2) {
    const [o2, r2] = Hn(t2, n2, e2);
    return o2.format(r2);
  },
  toString: et,
  toJSON: (e2) => et(e2),
  valueOf: neverValueOf
}, {
  from: (e2, t2) => jo(toPlainYearMonthSlots(e2, t2)),
  compare: (e2, t2) => rt(toPlainYearMonthSlots(e2), toPlainYearMonthSlots(t2))
});
var [yo, No] = createSlotClass(We, E(pt, refineCalendarSlot), {
  ...lo,
  ...ao,
  ...fo
}, {
  getISOFields: So,
  getCalendar: createCalendarFromSlots,
  with(e2, t2, n2) {
    return No(at($o, e2, this, rejectInvalidBag(t2), n2));
  },
  withCalendar: (e2, t2) => No(it(e2, refineCalendarSlot(t2))),
  withPlainDate: (e2, t2) => No(st(e2, toPlainDateSlots(t2))),
  withPlainTime: (e2, t2) => No(lt(e2, optionalToPlainTimeFields(t2))),
  add: (e2, t2, n2) => No(ct(er, 0, e2, toDurationSlots(t2), n2)),
  subtract: (e2, t2, n2) => No(ct(er, 1, e2, toDurationSlots(t2), n2)),
  until: (e2, t2, n2) => ar(ut(tr, 0, e2, toPlainDateTimeSlots(t2), n2)),
  since: (e2, t2, n2) => ar(ut(tr, 1, e2, toPlainDateTimeSlots(t2), n2)),
  round: (e2, t2) => No(dt(e2, t2)),
  equals: (e2, t2) => ft(e2, toPlainDateTimeSlots(t2)),
  toZonedDateTime: (e2, t2, n2) => dr(mt(createTimeZoneOps, e2, refineTimeZoneSlot(t2), n2)),
  toPlainDate: (e2) => Yo(v(e2)),
  toPlainTime: (e2) => vo(Ge(e2)),
  toPlainYearMonth(e2) {
    return jo(St(Ho, e2, this));
  },
  toPlainMonthDay(e2) {
    return To(Ot(Qo, e2, this));
  },
  toLocaleString(e2, t2, n2) {
    const [o2, r2] = Gn(t2, n2, e2);
    return o2.format(r2);
  },
  toString: Tt,
  toJSON: (e2) => Tt(e2),
  valueOf: neverValueOf
}, {
  from: (e2, t2) => No(toPlainDateTimeSlots(e2, t2)),
  compare: (e2, t2) => gt(toPlainDateTimeSlots(e2), toPlainDateTimeSlots(t2))
});
var [Bo, Yo, Ao] = createSlotClass(J, E(Nt, refineCalendarSlot), {
  ...lo,
  ...ao
}, {
  getISOFields: So,
  getCalendar: createCalendarFromSlots,
  with(e2, t2, n2) {
    return Yo(Zt($o, e2, this, rejectInvalidBag(t2), n2));
  },
  withCalendar: (e2, t2) => Yo(it(e2, refineCalendarSlot(t2))),
  add: (e2, t2, n2) => Yo(bt(er, 0, e2, toDurationSlots(t2), n2)),
  subtract: (e2, t2, n2) => Yo(bt(er, 1, e2, toDurationSlots(t2), n2)),
  until: (e2, t2, n2) => ar(Ft(tr, 0, e2, toPlainDateSlots(t2), n2)),
  since: (e2, t2, n2) => ar(Ft(tr, 1, e2, toPlainDateSlots(t2), n2)),
  equals: (e2, t2) => It(e2, toPlainDateSlots(t2)),
  toZonedDateTime(e2, t2) {
    const n2 = !z(t2) || t2 instanceof Zo ? {
      timeZone: t2
    } : t2;
    return dr(vt(refineTimeZoneSlot, toPlainTimeSlots, createTimeZoneOps, e2, n2));
  },
  toPlainDateTime: (e2, t2) => No(wt(e2, optionalToPlainTimeFields(t2))),
  toPlainYearMonth(e2) {
    return jo(jt(Ho, e2, this));
  },
  toPlainMonthDay(e2) {
    return To(Mt(Qo, e2, this));
  },
  toLocaleString(e2, t2, n2) {
    const [o2, r2] = Un(t2, n2, e2);
    return o2.format(r2);
  },
  toString: yt,
  toJSON: (e2) => yt(e2),
  valueOf: neverValueOf
}, {
  from: (e2, t2) => Yo(toPlainDateSlots(e2, t2)),
  compare: (e2, t2) => rt(toPlainDateSlots(e2), toPlainDateSlots(t2))
});
var Eo = {
  fields(e2, t2, n2) {
    return [...t2.call(e2, n2)];
  }
};
var Vo = /* @__PURE__ */ Object.assign({
  dateFromFields(e2, t2, n2, o2) {
    return Ao(t2.call(e2, Object.assign(/* @__PURE__ */ Object.create(null), n2), o2));
  }
}, Eo);
var Jo = /* @__PURE__ */ Object.assign({
  yearMonthFromFields(e2, t2, n2, o2) {
    return Mo(t2.call(e2, Object.assign(/* @__PURE__ */ Object.create(null), n2), o2));
  }
}, Eo);
var Lo = /* @__PURE__ */ Object.assign({
  monthDayFromFields(e2, t2, n2, o2) {
    return po(t2.call(e2, Object.assign(/* @__PURE__ */ Object.create(null), n2), o2));
  }
}, Eo);
var qo = {
  mergeFields(e2, t2, n2, o2) {
    return de(t2.call(e2, Object.assign(/* @__PURE__ */ Object.create(null), n2), Object.assign(/* @__PURE__ */ Object.create(null), o2)));
  }
};
var ko = /* @__PURE__ */ Object.assign({}, Vo, qo);
var xo = /* @__PURE__ */ Object.assign({}, Jo, qo);
var Ro = /* @__PURE__ */ Object.assign({}, Lo, qo);
var Wo = {
  dateAdd(e2, t2, n2, o2, r2) {
    return Ao(t2.call(e2, Yo(v(n2, e2)), ar(Vt(o2)), r2));
  }
};
var Go = /* @__PURE__ */ Object.assign({}, Wo, {
  dateUntil(e2, t2, n2, o2, r2, a2) {
    return ir(t2.call(e2, Yo(v(n2, e2)), Yo(v(o2, e2)), Object.assign(/* @__PURE__ */ Object.create(null), a2, {
      largestUnit: Et[r2]
    })));
  }
});
var Uo = /* @__PURE__ */ Object.assign({}, Wo, {
  day: dayAdapter
});
var zo = /* @__PURE__ */ Object.assign({}, Go, {
  day: dayAdapter
});
var Ho = /* @__PURE__ */ createCompoundOpsCreator(Jo);
var Ko = /* @__PURE__ */ createCompoundOpsCreator(Vo);
var Qo = /* @__PURE__ */ createCompoundOpsCreator(Lo);
var Xo = /* @__PURE__ */ createCompoundOpsCreator(xo);
var $o = /* @__PURE__ */ createCompoundOpsCreator(ko);
var _o = /* @__PURE__ */ createCompoundOpsCreator(Ro);
var er = /* @__PURE__ */ createCompoundOpsCreator(Wo);
var tr = /* @__PURE__ */ createCompoundOpsCreator(Go);
var nr = /* @__PURE__ */ createCompoundOpsCreator(Uo);
var or = /* @__PURE__ */ createCompoundOpsCreator(zo);
var [rr, ar, ir] = createSlotClass(qt, Lt, {
  ...uo,
  blank: Jt
}, {
  with: (e2, t2) => ar(kt(e2, t2)),
  negated: (e2) => ar(xt(e2)),
  abs: (e2) => ar(Rt(e2)),
  add: (e2, t2, n2) => ar(Wt(refinePublicRelativeTo, tr, createTimeZoneOps, 0, e2, toDurationSlots(t2), n2)),
  subtract: (e2, t2, n2) => ar(Wt(refinePublicRelativeTo, tr, createTimeZoneOps, 1, e2, toDurationSlots(t2), n2)),
  round: (e2, t2) => ar(Gt(refinePublicRelativeTo, tr, createTimeZoneOps, e2, t2)),
  total: (e2, t2) => Ut(refinePublicRelativeTo, tr, createTimeZoneOps, e2, t2),
  toLocaleString(e2, t2, n2) {
    return Intl.DurationFormat ? new Intl.DurationFormat(t2, n2).format(this) : zt(e2);
  },
  toString: zt,
  toJSON: (e2) => zt(e2),
  valueOf: neverValueOf
}, {
  from: (e2) => ar(toDurationSlots(e2)),
  compare: (e2, t2, n2) => $t(refinePublicRelativeTo, er, createTimeZoneOps, toDurationSlots(e2), toDurationSlots(t2), n2)
});
var sr = {
  toString: (e2) => e2.id,
  toJSON: (e2) => e2.id,
  ...ro,
  dateAdd: ({ id: e2, o: t2 }, n2, o2, r2) => Yo(v(t2.dateAdd(toPlainDateSlots(n2), toDurationSlots(o2), r2), e2)),
  dateUntil: ({ o: e2 }, t2, n2, o2) => ar(Vt(e2.dateUntil(toPlainDateSlots(t2), toPlainDateSlots(n2), _t(o2)))),
  dateFromFields: ({ id: e2, o: t2 }, n2, o2) => Yo(Yt(t2, n2, o2, ln(e2))),
  yearMonthFromFields: ({ id: e2, o: t2 }, n2, o2) => jo(nt(t2, n2, o2, un(e2))),
  monthDayFromFields: ({ id: e2, o: t2 }, n2, o2) => To(K(t2, 0, n2, o2, cn(e2))),
  fields({ o: e2 }, t2) {
    const n2 = new Set(en), o2 = [];
    for (const e3 of t2) {
      if (m(e3), !n2.has(e3)) {
        throw new RangeError(tn(e3));
      }
      n2.delete(e3), o2.push(e3);
    }
    return e2.fields(o2);
  },
  mergeFields: ({ o: e2 }, t2, n2) => e2.mergeFields(nn(on(t2)), nn(on(n2)))
};
var [lr] = createSlotClass("Calendar", (e2) => {
  const t2 = rn(e2);
  return {
    branding: "Calendar",
    id: t2,
    o: Y(t2)
  };
}, {
  id: (e2) => e2.id
}, sr, {
  from(e2) {
    const t2 = refineCalendarSlot(e2);
    return "string" == typeof t2 ? new lr(t2) : t2;
  }
});
var cr = /* @__PURE__ */ createProtocolValidator(Object.keys(sr).slice(4));
var [ur, dr] = createSlotClass(Te, E(vn, refineCalendarSlot, refineTimeZoneSlot), {
  ...mo,
  ...lo,
  ...adaptDateMethods(ao),
  ...adaptDateMethods(fo),
  offset: (e2) => Fe(slotsToIso(e2).offsetNanoseconds),
  offsetNanoseconds: (e2) => slotsToIso(e2).offsetNanoseconds,
  timeZoneId: (e2) => I(e2.timeZone),
  hoursInDay: (e2) => dn(createTimeZoneOps, e2)
}, {
  getISOFields: (e2) => mn(createTimeZoneOffsetOps, e2),
  getCalendar: createCalendarFromSlots,
  getTimeZone: ({ timeZone: e2 }) => "string" == typeof e2 ? new Zo(e2) : e2,
  with(e2, t2, n2) {
    return dr(Sn($o, createTimeZoneOps, e2, this, rejectInvalidBag(t2), n2));
  },
  withCalendar: (e2, t2) => dr(it(e2, refineCalendarSlot(t2))),
  withTimeZone: (e2, t2) => dr(On(e2, refineTimeZoneSlot(t2))),
  withPlainDate: (e2, t2) => dr(Tn(createTimeZoneOps, e2, toPlainDateSlots(t2))),
  withPlainTime: (e2, t2) => dr(pn(createTimeZoneOps, e2, optionalToPlainTimeFields(t2))),
  add: (e2, t2, n2) => dr(hn(er, createTimeZoneOps, 0, e2, toDurationSlots(t2), n2)),
  subtract: (e2, t2, n2) => dr(hn(er, createTimeZoneOps, 1, e2, toDurationSlots(t2), n2)),
  until: (e2, t2, n2) => ar(Vt(Dn(tr, createTimeZoneOps, 0, e2, toZonedDateTimeSlots(t2), n2))),
  since: (e2, t2, n2) => ar(Vt(Dn(tr, createTimeZoneOps, 1, e2, toZonedDateTimeSlots(t2), n2))),
  round: (e2, t2) => dr(Pn(createTimeZoneOps, e2, t2)),
  startOfDay: (e2) => dr(Cn(createTimeZoneOps, e2)),
  equals: (e2, t2) => gn(e2, toZonedDateTimeSlots(t2)),
  toInstant: (e2) => Co(Zn(e2)),
  toPlainDateTime: (e2) => No(ht(createTimeZoneOffsetOps, e2)),
  toPlainDate: (e2) => Yo(Bt(createTimeZoneOffsetOps, e2)),
  toPlainTime: (e2) => vo(Re(createTimeZoneOffsetOps, e2)),
  toPlainYearMonth(e2) {
    return jo(bn(Ho, e2, this));
  },
  toPlainMonthDay(e2) {
    return To(Fn(Qo, e2, this));
  },
  toLocaleString(e2, t2, n2 = {}) {
    const [o2, r2] = Wn(t2, n2, e2);
    return o2.format(r2);
  },
  toString: (e2, t2) => In(createTimeZoneOffsetOps, e2, t2),
  toJSON: (e2) => In(createTimeZoneOffsetOps, e2),
  valueOf: neverValueOf
}, {
  from: (e2, t2) => dr(toZonedDateTimeSlots(e2, t2)),
  compare: (e2, t2) => yn(toZonedDateTimeSlots(e2), toZonedDateTimeSlots(t2))
});
var fr = /* @__PURE__ */ Object.defineProperties({}, {
  ...h("Temporal.Now"),
  ...p({
    timeZoneId: () => Nn(),
    instant: () => Co(_(Bn())),
    zonedDateTime: (e2, t2 = Nn()) => dr(Yn(Bn(), refineTimeZoneSlot(t2), refineCalendarSlot(e2))),
    zonedDateTimeISO: (e2 = Nn()) => dr(Yn(Bn(), refineTimeZoneSlot(e2), X)),
    plainDateTime: (e2, t2 = Nn()) => No(ee(An(createTimeZoneOffsetOps(refineTimeZoneSlot(t2))), refineCalendarSlot(e2))),
    plainDateTimeISO: (e2 = Nn()) => No(ee(An(createTimeZoneOffsetOps(refineTimeZoneSlot(e2))), X)),
    plainDate: (e2, t2 = Nn()) => Yo(v(An(createTimeZoneOffsetOps(refineTimeZoneSlot(t2))), refineCalendarSlot(e2))),
    plainDateISO: (e2 = Nn()) => Yo(v(An(createTimeZoneOffsetOps(refineTimeZoneSlot(e2))), X)),
    plainTimeISO: (e2 = Nn()) => vo(Ge(An(createTimeZoneOffsetOps(refineTimeZoneSlot(e2)))))
  })
});
var mr = /* @__PURE__ */ Object.defineProperties({}, {
  ...h("Temporal"),
  ...p({
    PlainYearMonth: wo,
    PlainMonthDay: Oo,
    PlainDate: Bo,
    PlainTime: Io,
    PlainDateTime: yo,
    ZonedDateTime: ur,
    Instant: Po,
    Calendar: lr,
    TimeZone: Zo,
    Duration: rr,
    Now: fr
  })
});
var Sr = /* @__PURE__ */ createDateTimeFormatClass();
var Or = /* @__PURE__ */ new WeakMap();
var Tr = /* @__PURE__ */ Object.defineProperties(Object.create(Intl), p({
  DateTimeFormat: Sr
}));

// ../../enhanced/openehr_base.ts
var TYPE_REGISTRY = /* @__PURE__ */ new Map();
function registerType(name, constructor) {
  TYPE_REGISTRY.set(name.toUpperCase(), constructor);
}
function isTypeRegistered(name) {
  return TYPE_REGISTRY.has(name.toUpperCase());
}
function getRegisteredTypes() {
  return [...TYPE_REGISTRY.keys()];
}
var Any = class {
  /**
   * Reference equality for reference types, value equality for value types.
   * @param other - Parameter
   * @returns Result value
   */
  equal(other) {
    return new Boolean2(this === other);
  }
  /**
   * Create new instance of a type.
   * Uses the type registry to look up constructors by name.
   * Types must be registered using registerType() before they can be instantiated.
   * 
   * **Security Note:** This method creates instances dynamically based on type name.
   * Do not use with untrusted input as it could instantiate arbitrary registered types.
   * Only use with type names from trusted sources (e.g., parsed from validated openEHR data).
   * 
   * @param a_type - The type name as a String
   * @returns A new instance of the specified type
   * @throws Error if the type is not registered
   */
  instance_of(a_type) {
    const typeName = a_type?.value?.toUpperCase() || "";
    const constructor = TYPE_REGISTRY.get(typeName);
    if (!constructor) {
      throw new Error(`Unknown type: ${a_type?.value}. Type must be registered using registerType() first.`);
    }
    return new constructor();
  }
  /**
   * Type name of an object as a string. May include generic parameters, as in \`"Interval<Time>"\`.
   * @param an_object - Parameter
   * @returns Result value
   */
  type_of(an_object) {
    const typeName = an_object.constructor.name;
    return String2.from(typeName);
  }
  /**
   * True if current object not equal to \`_other_\`. Returns not \`_equal_()\`.
   * @param other - Parameter
   * @returns Result value
   */
  not_equal(other) {
    return new Boolean2(!this.equal(other).value);
  }
};
var Container = class extends Any {
};
var Hash = class _Hash extends Container {
  _map = /* @__PURE__ */ new Map();
  /**
   * Constructor that optionally accepts initial entries.
   * @param entries - Optional array of [key, value] pairs
   */
  constructor(entries) {
    super();
    if (entries) {
      for (const [key, value] of entries) {
        this.put(key, value);
      }
    }
  }
  /**
   * Test for presence of \`_a_key_\`.
   * @param a_key - Parameter
   * @returns Result value
   */
  has_key(a_key) {
    const keyStr = this._keyToString(a_key);
    return new Boolean2(this._map.has(keyStr));
  }
  /**
   * Return item for key \`_a_key_\`.
   * @param a_key - Parameter
   * @returns Result value
   */
  item(a_key) {
    const keyStr = this._keyToString(a_key);
    const entry = this._map.get(keyStr);
    if (!entry) {
      throw new Error(`Key not found: ${keyStr}`);
    }
    return entry.value;
  }
  /**
   * Test for membership of a value (key in this case).
   */
  has(v2) {
    return this.has_key(v2);
  }
  /**
   * Return the number of items in the hash.
   */
  count() {
    const int3 = new Integer();
    int3.value = this._map.size;
    return int3;
  }
  /**
   * Check if the hash is empty.
   */
  is_empty() {
    return new Boolean2(this._map.size === 0);
  }
  /**
   * Test if all items satisfy a condition.
   */
  for_all(test) {
    for (const entry of this._map.values()) {
      if (!test(entry.key).value) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * Test if any item satisfies a condition.
   */
  there_exists(test) {
    for (const entry of this._map.values()) {
      if (test(entry.key).value) {
        return new Boolean2(true);
      }
    }
    return new Boolean2(false);
  }
  /**
   * Check value equality with another object.
   */
  is_equal(other) {
    if (!(other instanceof _Hash)) {
      return new Boolean2(false);
    }
    if (this._map.size !== other._map.size) {
      return new Boolean2(false);
    }
    for (const [keyStr, entry] of this._map.entries()) {
      const otherEntry = other._map.get(keyStr);
      if (!otherEntry) {
        return new Boolean2(false);
      }
      if (!entry.key.is_equal(otherEntry.key).value) {
        return new Boolean2(false);
      }
      if (entry.value instanceof Any) {
        if (!entry.value.is_equal(otherEntry.value).value) {
          return new Boolean2(false);
        }
      } else if (entry.value !== otherEntry.value) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * Put a key-value pair into the hash.
   */
  put(key, value) {
    const keyStr = this._keyToString(key);
    this._map.set(keyStr, { key, value });
  }
  /**
   * Return a List of all keys matching the predicate function.
   * Note: Per openEHR specification, Hash<K,V> extends Container<K>, so matching operates on keys.
   * To search values, use item() to retrieve values for matched keys.
   * @param test - Predicate function with signature (v: K) => Boolean
   * @returns List of matching keys, empty list if no matches
   */
  matching(test) {
    const results = new List();
    for (const entry of this._map.values()) {
      const testResult = test(entry.key);
      if (testResult?.value === true) {
        results.append(entry.key);
      }
    }
    return results;
  }
  /**
   * Return first key matching the predicate function, or undefined if no match.
   * Note: Per openEHR specification, Hash<K,V> extends Container<K>, so select operates on keys.
   * To retrieve the value, call item() with the returned key.
   * @param test - Predicate function with signature (v: K) => Boolean
   * @returns First matching key or undefined
   */
  select(test) {
    for (const entry of this._map.values()) {
      const testResult = test(entry.key);
      if (testResult?.value === true) {
        return entry.key;
      }
    }
    return void 0;
  }
  /**
   * Helper to convert key to string for Map storage.
   */
  _keyToString(key) {
    if (key instanceof String2) {
      return key.value || "";
    }
    return JSON.stringify(key);
  }
};
var List = class _List extends Container {
  _items = [];
  /**
   * Test for membership of a value.
   */
  has(v2) {
    for (const item of this._items) {
      if (item.is_equal(v2).value === true) {
        return new Boolean2(true);
      }
    }
    return new Boolean2(false);
  }
  /**
   * Return the number of items in the list.
   */
  count() {
    const int3 = new Integer();
    int3.value = this._items.length;
    return int3;
  }
  /**
   * Check if the list is empty.
   */
  is_empty() {
    return new Boolean2(this._items.length === 0);
  }
  /**
   * Test if all items satisfy a condition.
   */
  for_all(test) {
    for (const item of this._items) {
      if (!test(item).value) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * Test if any item satisfies a condition.
   */
  there_exists(test) {
    for (const item of this._items) {
      if (test(item).value) {
        return new Boolean2(true);
      }
    }
    return new Boolean2(false);
  }
  /**
   * Get the item at index i (0-based).
   */
  item(i3) {
    const idx = i3.value;
    if (idx === void 0 || idx < 0 || idx >= this._items.length) {
      throw new Error(`Index out of bounds: ${idx}`);
    }
    return this._items[idx];
  }
  /**
   * Return first element.
   * @returns Result value
   */
  first() {
    if (this._items.length === 0) {
      throw new Error("Cannot get first item of empty list");
    }
    return this._items[0];
  }
  /**
   * Return last element.
   * @returns Result value
   */
  last() {
    if (this._items.length === 0) {
      throw new Error("Cannot get last item of empty list");
    }
    return this._items[this._items.length - 1];
  }
  /**
   * Add an item to the end of the list.
   */
  append(v2) {
    this._items.push(v2);
  }
  /**
   * Add an item to the beginning of the list.
   */
  prepend(v2) {
    this._items.unshift(v2);
  }
  /**
   * Append all items from another list.
   */
  extend(other) {
    const otherCount = other.count().value;
    if (otherCount !== void 0) {
      for (let i3 = 0; i3 < otherCount; i3++) {
        const idx = new Integer();
        idx.value = i3;
        this._items.push(other.item(idx));
      }
    }
  }
  /**
   * Remove the item at index i.
   */
  remove(i3) {
    const idx = i3.value;
    if (idx === void 0 || idx < 0 || idx >= this._items.length) {
      throw new Error(`Index out of bounds: ${idx}`);
    }
    this._items.splice(idx, 1);
  }
  /**
   * Find the index of the first occurrence of a value.
   * Returns -1 if not found.
   */
  index_of(v2) {
    for (let i3 = 0; i3 < this._items.length; i3++) {
      if (this._items[i3].is_equal(v2).value === true) {
        const idx2 = new Integer();
        idx2.value = i3;
        return idx2;
      }
    }
    const idx = new Integer();
    idx.value = -1;
    return idx;
  }
  /**
   * Check value equality with another object.
   */
  is_equal(other) {
    if (!(other instanceof _List)) {
      return new Boolean2(false);
    }
    if (this._items.length !== other._items.length) {
      return new Boolean2(false);
    }
    for (let i3 = 0; i3 < this._items.length; i3++) {
      if (!this._items[i3].is_equal(other._items[i3]).value) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * Return a List of all items matching the predicate function.
   * @param test - Predicate function with signature (v: T) => Boolean
   * @returns List of matching items, empty list if no matches
   */
  matching(test) {
    const results = new _List();
    for (const item of this._items) {
      const testResult = test(item);
      if (testResult?.value === true) {
        results.append(item);
      }
    }
    return results;
  }
  /**
   * Return first item matching the predicate function, or undefined if no match.
   * @param test - Predicate function with signature (v: T) => Boolean
   * @returns First matching item or undefined
   */
  select(test) {
    for (const item of this._items) {
      const testResult = test(item);
      if (testResult?.value === true) {
        return item;
      }
    }
    return void 0;
  }
};
var Set2 = class _Set extends Container {
  _items = [];
  /**
   * Test for membership of a value.
   */
  has(v2) {
    for (const item of this._items) {
      if (item.is_equal(v2).value === true) {
        return new Boolean2(true);
      }
    }
    return new Boolean2(false);
  }
  /**
   * Return the number of items in the set.
   */
  count() {
    const int3 = new Integer();
    int3.value = this._items.length;
    return int3;
  }
  /**
   * Check if the set is empty.
   */
  is_empty() {
    return new Boolean2(this._items.length === 0);
  }
  /**
   * Test if all items satisfy a condition.
   */
  for_all(test) {
    for (const item of this._items) {
      if (!test(item).value) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * Test if any item satisfies a condition.
   */
  there_exists(test) {
    for (const item of this._items) {
      if (test(item).value) {
        return new Boolean2(true);
      }
    }
    return new Boolean2(false);
  }
  /**
   * Add an item to the set if it doesn't already exist.
   */
  add(v2) {
    if (!this.has(v2).value) {
      this._items.push(v2);
    }
  }
  /**
   * Remove an item from the set.
   */
  remove(v2) {
    for (let i3 = 0; i3 < this._items.length; i3++) {
      if (this._items[i3].is_equal(v2).value === true) {
        this._items.splice(i3, 1);
        return;
      }
    }
  }
  /**
   * Check value equality with another object.
   */
  is_equal(other) {
    if (!(other instanceof _Set)) {
      return new Boolean2(false);
    }
    if (this._items.length !== other._items.length) {
      return new Boolean2(false);
    }
    for (const item of this._items) {
      if (!other.has(item).value) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * Return a List of all items matching the predicate function.
   * @param test - Predicate function with signature (v: T) => Boolean
   * @returns List of matching items, empty list if no matches
   */
  matching(test) {
    const results = new List();
    for (const item of this._items) {
      const testResult = test(item);
      if (testResult?.value === true) {
        results.append(item);
      }
    }
    return results;
  }
  /**
   * Return first item matching the predicate function, or undefined if no match.
   * @param test - Predicate function with signature (v: T) => Boolean
   * @returns First matching item or undefined
   */
  select(test) {
    for (const item of this._items) {
      const testResult = test(item);
      if (testResult?.value === true) {
        return item;
      }
    }
    return void 0;
  }
};
var Array2 = class _Array extends Container {
  _items = [];
  /**
   * Test for membership of a value.
   */
  has(v2) {
    for (const item of this._items) {
      if (item.is_equal(v2).value === true) {
        return new Boolean2(true);
      }
    }
    return new Boolean2(false);
  }
  /**
   * Return the number of items in the array.
   */
  count() {
    const int3 = new Integer();
    int3.value = this._items.length;
    return int3;
  }
  /**
   * Check if the array is empty.
   */
  is_empty() {
    return new Boolean2(this._items.length === 0);
  }
  /**
   * Test if all items satisfy a condition.
   */
  for_all(test) {
    for (const item of this._items) {
      if (!test(item).value) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * Test if any item satisfies a condition.
   */
  there_exists(test) {
    for (const item of this._items) {
      if (test(item).value) {
        return new Boolean2(true);
      }
    }
    return new Boolean2(false);
  }
  /**
   * Return item for key  \`_a_key_\`.
   * @param a_key - Parameter
   * @returns Result value
   */
  item(a_key) {
    const idx = a_key.value;
    if (idx === void 0 || idx < 0 || idx >= this._items.length) {
      throw new Error(`Index out of bounds: ${idx}`);
    }
    return this._items[idx];
  }
  /**
   * Check value equality with another object.
   */
  is_equal(other) {
    if (!(other instanceof _Array)) {
      return new Boolean2(false);
    }
    if (this._items.length !== other._items.length) {
      return new Boolean2(false);
    }
    for (let i3 = 0; i3 < this._items.length; i3++) {
      if (!this._items[i3].is_equal(other._items[i3]).value) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * Set the item at index i.
   */
  put(i3, v2) {
    const idx = i3.value;
    if (idx === void 0 || idx < 0 || idx >= this._items.length) {
      throw new Error(`Index out of bounds: ${idx}`);
    }
    this._items[idx] = v2;
  }
  /**
   * Append an item to the array.
   */
  append(v2) {
    this._items.push(v2);
  }
  /**
   * Return a List of all items matching the predicate function.
   * @param test - Predicate function with signature (v: T) => Boolean
   * @returns List of matching items, empty list if no matches
   */
  matching(test) {
    const results = new List();
    for (const item of this._items) {
      const testResult = test(item);
      if (testResult?.value === true) {
        results.append(item);
      }
    }
    return results;
  }
  /**
   * Return first item matching the predicate function, or undefined if no match.
   * @param test - Predicate function with signature (v: T) => Boolean
   * @returns First matching item or undefined
   */
  select(test) {
    for (const item of this._items) {
      const testResult = test(item);
      if (testResult?.value === true) {
        return item;
      }
    }
    return void 0;
  }
};
var Ordered = class extends Any {
  /**
   * True if current object less than or equal to \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than_or_equal(other) {
    return new Boolean2(
      this.less_than(other).value || this.is_equal(other).value
    );
  }
  /**
   * True if current object greater than \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  greater_than(other) {
    return new Boolean2(
      !this.less_than(other).value && !this.is_equal(other).value
    );
  }
  /**
   * True if current object greater than or equal to \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  greater_than_or_equal(other) {
    return new Boolean2(!this.less_than(other).value);
  }
};
var String2 = class _String extends Ordered {
  static {
    TYPE_REGISTRY.set("STRING", _String);
  }
  /**
   * The underlying primitive value.
   */
  value;
  /**
   * Creates a new String instance.
   * @param val - The primitive value to wrap
   */
  constructor(val) {
    super();
    this.value = val;
  }
  /**
   * Creates a String instance from a primitive value.
   * @param val - The primitive value to wrap
   * @returns A new String instance
   */
  static from(val) {
    return new _String(val);
  }
  /**
   * Compares this String with another for value equality.
   * @param other - The object to compare with
   * @returns true if the values are equal
   */
  is_equal(other) {
    if (other instanceof _String) {
      return new Boolean2(this.value === other.value);
    }
    return new Boolean2(false);
  }
  /**
   * True if string is empty, i.e. equal to "".
   * @returns Result value
   */
  is_empty() {
    return new Boolean2((this.value || "").length === 0);
  }
  /**
   * Number of characters in string.
   * @returns Result value
   */
  count() {
    const int3 = new Integer();
    int3.value = (this.value || "").length;
    return int3;
  }
  /**
   * True if string can be parsed as an integer.
   * @returns Result value
   */
  is_integer() {
    const val = this.value || "";
    const num = Number(val);
    return new Boolean2(
      !isNaN(num) && Number.isInteger(num) && val.trim() !== ""
    );
  }
  /**
   * Return the integer corresponding to the integer value represented in this string.
   * @returns Result value
   */
  as_integer() {
    const num = parseInt(this.value || "", 10);
    if (isNaN(num)) {
      throw new Error(`Cannot parse "${this.value}" as integer`);
    }
    return Integer.from(num);
  }
  /**
   * Concatenation operator - causes \`_other_\` to be appended to this string.
   * @param other - Parameter
   * @returns Result value
   */
  append(other) {
    return _String.from((this.value || "") + (other.value || ""));
  }
  /**
   * Convert string to lowercase.
   * @returns Result value
   */
  as_lower() {
    return _String.from((this.value || "").toLowerCase());
  }
  /**
   * Convert string to uppercase.
   * @returns Result value
   */
  as_upper() {
    return _String.from((this.value || "").toUpperCase());
  }
  /**
   * Lexical comparison of string content based on ordering in relevant character set.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (!(other instanceof _String)) {
      throw new Error("Cannot compare String with non-String");
    }
    return new Boolean2((this.value || "") < (other.value || ""));
  }
  /**
   * Return True if this String contains \`_other_\` (case-sensitive).
   * @param other - Parameter
   * @returns Result value
   */
  contains(other) {
    return new Boolean2((this.value || "").includes(other.value || ""));
  }
  /**
   * Extract a substring (1-based indexing in openEHR).
   * @param start - Start index (1-based)
   * @param end - End index (1-based)
   * @returns Result value
   */
  substring(start, end) {
    const startIdx = (start.value || 1) - 1;
    const endIdx = end.value || (this.value || "").length;
    return _String.from((this.value || "").substring(startIdx, endIdx));
  }
  /**
   * Find the index of a substring (1-based indexing in openEHR).
   * @param pattern - Pattern to find
   * @param from - Start index (1-based)
   * @returns Result value (1-based index or -1 if not found)
   */
  index_of(pattern, from) {
    const startIdx = (from.value || 1) - 1;
    const foundIdx = (this.value || "").indexOf(pattern.value || "", startIdx);
    const result2 = new Integer();
    result2.value = foundIdx === -1 ? -1 : foundIdx + 1;
    return result2;
  }
  /**
   * Split string by delimiter.
   * @param delimiter - Delimiter to split by
   * @returns Result value
   */
  split(delimiter) {
    const parts = (this.value || "").split(delimiter.value || "");
    const list = new List();
    for (const part of parts) {
      list.append(_String.from(part));
    }
    return list;
  }
};
var Uri = class extends String2 {
};
var Numeric = class extends Any {
};
var Ordered_Numeric = class extends Ordered {
};
var Integer = class _Integer extends Ordered_Numeric {
  static {
    TYPE_REGISTRY.set("INTEGER", _Integer);
  }
  /**
   * The underlying primitive value.
   */
  value;
  /**
   * Creates a new Integer instance.
   * @param val - The primitive value to wrap
   */
  constructor(val) {
    super();
    if (val !== void 0 && val !== null && !Number.isInteger(val)) {
      throw new Error(`Integer value must be an integer, got: ${val}`);
    }
    this.value = val;
  }
  /**
   * Creates a Integer instance from a primitive value.
   * @param val - The primitive value to wrap
   * @returns A new Integer instance
   */
  static from(val) {
    return new _Integer(val);
  }
  /**
   * Compares this Integer with another for value equality.
   * @param other - The object to compare with
   * @returns true if the values are equal
   */
  is_equal(other) {
    if (other instanceof _Integer) {
      return new Boolean2(this.value === other.value);
    }
    return new Boolean2(false);
  }
  /**
   * Lexical comparison for integers.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (!(other instanceof _Integer)) {
      throw new Error("Cannot compare Integer with non-Integer");
    }
    const thisVal = this.value || 0;
    const otherVal = other.value || 0;
    return new Boolean2(thisVal < otherVal);
  }
  /**
   * Integer addition.
   * @param other - Parameter
   * @returns Result value
   */
  add(other) {
    const thisVal = this.value || 0;
    const otherVal = other.value || 0;
    return _Integer.from(thisVal + otherVal);
  }
  /**
   * Integer subtraction.
   * @param other - Parameter
   * @returns Result value
   */
  subtract(other) {
    const thisVal = this.value || 0;
    const otherVal = other.value || 0;
    return _Integer.from(thisVal - otherVal);
  }
  /**
   * Integer multiplication.
   * @param other - Parameter
   * @returns Result value
   */
  multiply(other) {
    const thisVal = this.value || 0;
    const otherVal = other.value || 0;
    return _Integer.from(thisVal * otherVal);
  }
  /**
   * Integer division.
   * @param other - Parameter
   * @returns Result value
   */
  divide(other) {
    const thisVal = this.value || 0;
    const otherVal = other.value || 1;
    if (otherVal === 0) {
      throw new Error("Division by zero");
    }
    return thisVal / otherVal;
  }
  /**
   * Integer modulo.
   * @param other - Parameter
   * @returns Result value
   */
  modulo(other) {
    const thisVal = this.value || 0;
    const otherVal = other.value || 1;
    if (otherVal === 0) {
      throw new Error("Modulo by zero");
    }
    return _Integer.from(thisVal % otherVal);
  }
  /**
   * Generate negative of current value.
   * @returns Result value
   */
  negative() {
    return _Integer.from(-(this.value || 0));
  }
  /**
   * Integer exponentiation.
   * @param other - Parameter
   * @returns Result value
   */
  exponent(other) {
    const thisVal = this.value || 0;
    return Math.pow(thisVal, other);
  }
  // modulo, less_than, negative, and is_equal are implemented above
  /**
   * Reference equality for reference types, value equality for value types.
   * @param other - Parameter
   * @returns Result value
   */
  equal(other) {
    return new Boolean2(this === other);
  }
};
var Double = class _Double extends Ordered_Numeric {
  static {
    TYPE_REGISTRY.set("DOUBLE", _Double);
  }
  /**
   * The underlying primitive value.
   */
  value;
  /**
   * Creates a new Double instance.
   * @param val - The primitive value to wrap
   */
  constructor(val) {
    super();
    this.value = val;
  }
  /**
   * Creates a Double instance from a primitive value.
   * @param val - The primitive value to wrap
   * @returns A new Double instance
   */
  static from(val) {
    return new _Double(val);
  }
  /**
   * Return the greatest integer no greater than the value of this object.
   * @returns Result value
   */
  floor() {
    const thisVal = this.value || 0;
    return Integer.from(Math.floor(thisVal));
  }
  /**
   * Double-precision real number addition.
   * @param other - Parameter
   * @returns Result value
   */
  add(other) {
    const thisVal = this.value || 0;
    return thisVal + other;
  }
  /**
   * Double-precision real number subtraction.
   * @param other - Parameter
   * @returns Result value
   */
  subtract(other) {
    const thisVal = this.value || 0;
    return thisVal - other;
  }
  /**
   * Double-precision real number multiplication.
   * @param other - Parameter
   * @returns Result value
   */
  multiply(other) {
    const thisVal = this.value || 0;
    return thisVal * other;
  }
  /**
   * Double-precision real number division.
   * @param other - Parameter
   * @returns Result value
   */
  divide(other) {
    const thisVal = this.value || 0;
    if (other === 0) {
      throw new Error("Division by zero");
    }
    return thisVal / other;
  }
  /**
   * Double-precision real number exponentiation.
   * @param other - Parameter
   * @returns Result value
   */
  exponent(other) {
    const thisVal = this.value || 0;
    return Math.pow(thisVal, other);
  }
  /**
   * Returns True if current Double is less than \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (other instanceof _Double) {
      const thisVal = this.value || 0;
      const otherVal = other.value || 0;
      return new Boolean2(thisVal < otherVal);
    }
    return new Boolean2(false);
  }
  /**
   * Generate negative of current Double value.
   * @returns Result value
   */
  negative() {
    const thisVal = this.value || 0;
    return -thisVal;
  }
  /**
   * Value equality: return True if \`this\` and \`_other_\` are attached to objects considered to be equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (other instanceof _Double) {
      const thisVal = this.value || 0;
      const otherVal = other.value || 0;
      return new Boolean2(thisVal === otherVal);
    }
    return new Boolean2(false);
  }
};
var Octet = class _Octet extends Ordered {
  static {
    TYPE_REGISTRY.set("OCTET", _Octet);
  }
  /**
   * The underlying primitive value.
   */
  value;
  /**
   * Creates a new Octet instance.
   * @param val - The primitive value to wrap (0-255)
   */
  constructor(val) {
    super();
    if (val !== void 0 && val !== null && (!Number.isInteger(val) || val < 0 || val > 255)) {
      throw new Error(`Octet value must be an integer between 0 and 255, got: ${val}`);
    }
    this.value = val;
  }
  /**
   * Creates an Octet instance from a primitive value.
   * @param val - The primitive value to wrap
   * @returns A new Octet instance
   */
  static from(val) {
    return new _Octet(val);
  }
  /**
   * Returns True if current Octet is less than other.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (other instanceof _Octet) {
      const thisVal = this.value || 0;
      const otherVal = other.value || 0;
      return new Boolean2(thisVal < otherVal);
    }
    return new Boolean2(false);
  }
  /**
   * Value equality: return True if this and other are equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (other instanceof _Octet) {
      const thisVal = this.value || 0;
      const otherVal = other.value || 0;
      return new Boolean2(thisVal === otherVal);
    }
    return new Boolean2(false);
  }
};
var Character = class _Character extends Ordered {
  static {
    TYPE_REGISTRY.set("CHARACTER", _Character);
  }
  /**
   * The underlying primitive value.
   */
  value;
  /**
   * Creates a new Character instance.
   * @param val - The primitive value to wrap (single character)
   */
  constructor(val) {
    super();
    if (val !== void 0 && val !== null && val.length !== 1) {
      throw new Error(`Character value must be a single character, got: ${val}`);
    }
    this.value = val;
  }
  /**
   * Creates a Character instance from a primitive value.
   * @param val - The primitive value to wrap
   * @returns A new Character instance
   */
  static from(val) {
    return new _Character(val);
  }
  /**
   * Returns True if current Character is less than other.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (other instanceof _Character) {
      const thisVal = this.value || "";
      const otherVal = other.value || "";
      return new Boolean2(thisVal < otherVal);
    }
    return new Boolean2(false);
  }
  /**
   * Value equality: return True if this and other are equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (other instanceof _Character) {
      const thisVal = this.value || "";
      const otherVal = other.value || "";
      return new Boolean2(thisVal === otherVal);
    }
    return new Boolean2(false);
  }
};
var Boolean2 = class _Boolean extends Any {
  static {
    TYPE_REGISTRY.set("BOOLEAN", _Boolean);
  }
  /**
   * The underlying primitive value.
   */
  value;
  /**
   * Creates a new Boolean instance.
   * @param val - The primitive value to wrap
   */
  constructor(val) {
    super();
    this.value = val;
  }
  /**
   * Creates a Boolean instance from a primitive value.
   * @param val - The primitive value to wrap
   * @returns A new Boolean instance
   */
  static from(val) {
    return new _Boolean(val);
  }
  /**
   * Compares this Boolean with another for value equality.
   * @param other - The object to compare with
   * @returns true if the values are equal
   */
  is_equal(other) {
    if (other instanceof _Boolean) {
      return new _Boolean(this.value === other.value);
    }
    return new _Boolean(false);
  }
  /**
   * Logical conjunction of this with \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  conjunction(other) {
    return new _Boolean(this.value === true && other.value === true);
  }
  /**
   * Boolean semi-strict conjunction with \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  semistrict_conjunction(other) {
    if (this.value !== true) {
      return new _Boolean(false);
    }
    return new _Boolean(other.value === true);
  }
  /**
   * Boolean disjunction with \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  disjunction(other) {
    return new _Boolean(this.value === true || other.value === true);
  }
  /**
   * Boolean semi-strict disjunction with \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  semistrict_disjunction(other) {
    if (this.value === true) {
      return new _Boolean(true);
    }
    return new _Boolean(other.value === true);
  }
  /**
   * Boolean exclusive or with \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  exclusive_disjunction(other) {
    return new _Boolean(this.value === true !== (other.value === true));
  }
  /**
   * Boolean implication of \`_other_\` (semi-strict)
   * @param other - Parameter
   * @returns Result value
   */
  implication(other) {
    if (this.value !== true) {
      return new _Boolean(true);
    }
    return new _Boolean(other.value === true);
  }
  /**
   * Boolean negation of the current value.
   * @returns Result value
   */
  negation() {
    return new _Boolean(this.value !== true);
  }
};
var Real = class _Real extends Ordered_Numeric {
  static {
    TYPE_REGISTRY.set("REAL", _Real);
  }
  /**
   * The underlying primitive value.
   */
  value;
  /**
   * Creates a new Real instance.
   * @param val - The primitive value to wrap
   */
  constructor(val) {
    super();
    this.value = val;
  }
  /**
   * Creates a Real instance from a primitive value.
   * @param val - The primitive value to wrap
   * @returns A new Real instance
   */
  static from(val) {
    return new _Real(val);
  }
  /**
   * Return the greatest integer no greater than the value of this object.
   * @returns Result value
   */
  floor() {
    const thisVal = this.value || 0;
    return Integer.from(Math.floor(thisVal));
  }
  /**
   * Real number addition.
   * @param other - Parameter
   * @returns Result value
   */
  add(other) {
    const thisVal = this.value || 0;
    return thisVal + other;
  }
  /**
   * Real number subtraction.
   * @param other - Parameter
   * @returns Result value
   */
  subtract(other) {
    const thisVal = this.value || 0;
    return thisVal - other;
  }
  /**
   * Real number multiplication.
   * @param other - Parameter
   * @returns Result value
   */
  multiply(other) {
    const thisVal = this.value || 0;
    return thisVal * other;
  }
  /**
   * Real number division.
   * @param other - Parameter
   * @returns Result value
   */
  divide(other) {
    const thisVal = this.value || 0;
    if (other === 0) {
      throw new Error("Division by zero");
    }
    return thisVal / other;
  }
  /**
   * Real number exponentiation.
   * @param other - Parameter
   * @returns Result value
   */
  exponent(other) {
    const thisVal = this.value || 0;
    return Math.pow(thisVal, other);
  }
  /**
   * Returns True if current Real is less than \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (other instanceof _Real) {
      const thisVal = this.value || 0;
      const otherVal = other.value || 0;
      return new Boolean2(thisVal < otherVal);
    }
    return new Boolean2(false);
  }
  /**
   * Generate negative of current Real value.
   * @returns Result value
   */
  negative() {
    const thisVal = this.value || 0;
    return -thisVal;
  }
  /**
   * Value equality: return True if \`this\` and \`_other_\` are attached to objects considered to be equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (other instanceof _Real) {
      const thisVal = this.value || 0;
      const otherVal = other.value || 0;
      return new Boolean2(thisVal === otherVal);
    }
    return new Boolean2(false);
  }
};
var Integer64 = class _Integer64 extends Ordered_Numeric {
  static {
    TYPE_REGISTRY.set("INTEGER64", _Integer64);
  }
  /**
   * The underlying primitive value.
   */
  value;
  /**
   * Creates a new Integer64 instance.
   * @param val - The primitive value to wrap
   */
  constructor(val) {
    super();
    if (val !== void 0 && val !== null && !Number.isInteger(val)) {
      throw new Error(`Integer64 value must be an integer, got: ${val}`);
    }
    this.value = val;
  }
  /**
   * Creates a Integer64 instance from a primitive value.
   * @param val - The primitive value to wrap
   * @returns A new Integer64 instance
   */
  static from(val) {
    return new _Integer64(val);
  }
  /**
   * Compares this Integer64 with another for value equality.
   * @param other - The object to compare with
   * @returns true if the values are equal
   */
  is_equal(other) {
    if (other instanceof _Integer64) {
      return new Boolean2(this.value === other.value);
    }
    return new Boolean2(false);
  }
  /**
   * Lexical comparison for large integers.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (!(other instanceof _Integer64)) {
      throw new Error("Cannot compare Integer64 with non-Integer64");
    }
    const thisVal = this.value || 0;
    const otherVal = other.value || 0;
    return new Boolean2(thisVal < otherVal);
  }
  /**
   * Large integer addition.
   * @param other - Parameter
   * @returns Result value
   */
  add(other) {
    const thisVal = this.value || 0;
    const otherVal = other.value || 0;
    return _Integer64.from(thisVal + otherVal);
  }
  /**
   * Large integer subtraction.
   * @param other - Parameter
   * @returns Result value
   */
  subtract(other) {
    const thisVal = this.value || 0;
    const otherVal = other.value || 0;
    return _Integer64.from(thisVal - otherVal);
  }
  /**
   * Large integer multiplication.
   * @param other - Parameter
   * @returns Result value
   */
  multiply(other) {
    const thisVal = this.value || 0;
    const otherVal = other.value || 0;
    return _Integer64.from(thisVal * otherVal);
  }
  /**
   * Large integer division.
   * @param other - Parameter
   * @returns Result value
   */
  divide(other) {
    const thisVal = this.value || 0;
    const otherVal = other.value || 1;
    if (otherVal === 0) {
      throw new Error("Division by zero");
    }
    return thisVal / otherVal;
  }
  /**
   * Large integer exponentiation.
   * @param other - Parameter
   * @returns Result value
   */
  exponent(other) {
    const thisVal = this.value || 0;
    return Math.pow(thisVal, other);
  }
  /**
   * Large integer modulus.
   * @param mod - Parameter
   * @returns Result value
   */
  modulo(mod) {
    const thisVal = this.value || 0;
    const modVal = mod.value || 1;
    if (modVal === 0) {
      throw new Error("Modulo by zero");
    }
    return _Integer64.from(thisVal % modVal);
  }
  /**
   * Generate negative of current Integer value.
   * @returns Result value
   */
  negative() {
    return _Integer64.from(-(this.value || 0));
  }
  /**
   * Reference equality for reference types, value equality for value types.
   * @param other - Parameter
   * @returns Result value
   */
  equal(other) {
    return new Boolean2(this === other);
  }
};
var Byte = class _Byte extends Ordered {
  static {
    TYPE_REGISTRY.set("BYTE", _Byte);
  }
  /**
   * The underlying primitive value.
   */
  value;
  /**
   * Creates a new Byte instance.
   * @param val - The primitive value to wrap
   */
  constructor(val) {
    super();
    if (val !== void 0 && val !== null && (!Number.isInteger(val) || val < 0 || val > 255)) {
      throw new Error(
        `Byte value must be an integer between 0 and 255, got: ${val}`
      );
    }
    this.value = val;
  }
  /**
   * Creates a Byte instance from a primitive value.
   * @param val - The primitive value to wrap
   * @returns A new Byte instance
   */
  static from(val) {
    return new _Byte(val);
  }
  /**
   * Returns True if current Byte is less than other.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (other instanceof _Byte) {
      const thisVal = this.value || 0;
      const otherVal = other.value || 0;
      return new Boolean2(thisVal < otherVal);
    }
    return new Boolean2(false);
  }
  /**
   * Compares this Byte with another for value equality.
   * @param other - The object to compare with
   * @returns true if the values are equal
   */
  is_equal(other) {
    if (other instanceof _Byte) {
      const thisVal = this.value || 0;
      const otherVal = other.value || 0;
      return new Boolean2(thisVal === otherVal);
    }
    return new Boolean2(false);
  }
};
var Temporal = class extends Ordered {
};
var Time_Definitions = class {
  /**
   * True if \`y >= 0\`.
   *
   * TODO: Verify if this validation is sufficient. The openEHR specification
   * states y >= 0 is correct (no negative years, only 4-digit years assumed),
   * but this may need additional validation for:
   * - Maximum year value (e.g., 9999 for 4-digit constraint)
   * - Whether year 0 is historically/calendrically valid
   * See corresponding TODO in tasks/instructions/base/Time_Definitions.md
   *
   * @param y - Parameter
   * @returns Result value
   */
  valid_year(y2) {
    const val = y2.value || 0;
    return new Boolean2(val >= 0);
  }
  /**
   * True if \`m >= 1 and m <= months_in_year\`.
   * @param m - Parameter
   * @returns Result value
   */
  valid_month(m2) {
    const val = m2.value || 0;
    return new Boolean2(val >= 1 && val <= 12);
  }
  /**
   * True if \`d >= 1 and d <= days_in_month (m, y)\`.
   * @param y - Parameter
   * @param m - Parameter
   * @param d - Parameter
   * @returns Result value
   */
  valid_day(y2, m2, d2) {
    const dVal = d2.value || 0;
    const mVal = m2.value || 1;
    const yVal = y2.value || 0;
    if (dVal < 1)
      return new Boolean2(false);
    const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    const isLeapYear = yVal % 4 === 0 && yVal % 100 !== 0 || yVal % 400 === 0;
    if (isLeapYear && mVal === 2) {
      return new Boolean2(dVal <= 29);
    }
    return new Boolean2(dVal <= (daysInMonth[mVal - 1] || 31));
  }
  /**
   * True if \`(h >= 0 and h < Hours_in_day) or (h = Hours_in_day and m = 0 and s = 0)\` .
   * @param h - Parameter
   * @param m - Parameter
   * @param s - Parameter
   * @returns Result value
   */
  valid_hour(h2, m2, s2) {
    const hVal = h2.value || 0;
    const mVal = m2.value || 0;
    const sVal = s2.value || 0;
    if (hVal >= 0 && hVal < 24)
      return new Boolean2(true);
    if (hVal === 24 && mVal === 0 && sVal === 0)
      return new Boolean2(true);
    return new Boolean2(false);
  }
  /**
   * True if \`m >= 0 and m < Minutes_in_hour\`.
   * @param m - Parameter
   * @returns Result value
   */
  valid_minute(m2) {
    const val = m2.value || 0;
    return new Boolean2(val >= 0 && val < 60);
  }
  /**
   * True if \`s >= 0 and s < Seconds_in_minute\` .
   * @param s - Parameter
   * @returns Result value
   */
  valid_second(s2) {
    const val = s2.value || 0;
    return new Boolean2(val >= 0 && val < 60);
  }
  /**
   * True if \`fs >= 0.0\` and \`fs < 1.0\` .
   * @param fs - Parameter
   * @returns Result value
   */
  valid_fractional_second(fs2) {
    return new Boolean2(fs2 >= 0 && fs2 < 1);
  }
  /**
   * String is a valid ISO 8601 date, i.e. takes the complete form:
   *
   * * \`YYYY-MM-DD\` (extended, preferred) or one of the partial forms \`YYYY-MM\` or \`YYYY\`
   * * \`YYYYMMDD\` (compact) or a partial variant \`YYYYMM\`.
   *
   * Where:
   *
   * * \`YYYY\` is the string form of any positive number in the range \`0000\` - \`9999\` (zero-filled to four digits)
   * * \`MM\` is \`01\` - \`12\` (zero-filled to two digits)
   * * \`DD\` is \`01\` - \`31\` (zero-filled to two digits)
   *
   * The combinations of \`YYYY\`, \`MM\`, \`DD\` numbers must be correct with respect to the Gregorian calendar.
   * @param s - Parameter
   * @returns Result value
   */
  valid_iso8601_date(s2) {
    const val = s2.value || "";
    const extendedPattern = /^(\d{4})(-((0[1-9]|1[0-2])(-([0-2]\d|3[01]))?)?)?$/;
    const compactPattern = /^(\d{4})((0[1-9]|1[0-2])([0-2]\d|3[01])?)?$/;
    return new Boolean2(
      extendedPattern.test(val) || compactPattern.test(val)
    );
  }
  /**
   * String is a valid ISO 8601 date, i.e. takes the form:
   *
   * * \`hh:mm:ss[(,|.)s+][Z|hh[:mm]]\` (extended)
   * * \`hhmmss[(,|.)s+][Z|hh[mm]]\` (compact)
   * * or one of the partial forms:
   * ** \`hh:mm\` (extended)
   * ** \`hhmm\` or \`hh\` (compact)
   *
   * with an additional optional timezone indicator of:
   *
   * * \`Z\` or \`hh[:mm]\` (extended)  \`hh[mm]\` (compact)
   *
   * Where:
   *
   * * \`hh\` is "00" - "23" (0-filled to two digits)
   * * \`mm\` is "00" - "59" (0-filled to two digits)
   * * \`ss\` is "00" - "60" (0-filled to two digits)
   * * \`[(,|.)s+]\` is an optional string consisting of a comma or decimal point followed by numeric string of 1 or more digits, representing a fractional second
   * * \`Z\` is a literal meaning UTC (modern replacement for GMT), i.e. timezone \`+0000\`
   *
   * @param s - Parameter
   * @returns Result value
   */
  valid_iso8601_time(s2) {
    const val = s2.value || "";
    const timePattern = /^([01]\d|2[0-3]):?([0-5]\d)?:?([0-5]\d|60)?([.,]\d+)?(Z|[+-]([01]\d|2[0-3]):?([0-5]\d)?)?$/;
    return new Boolean2(timePattern.test(val));
  }
  /**
   * String is a valid ISO 8601 date-time, i.e. takes the form:
   *
   * * \`YYYY-MM-DDThh:mm:ss[(,|.)s+][Z|hh[:mm]]\` (extended)
   * * \`YYYYMMDDThhmmss[(,|.)s+][Z|hh[mm]]\` (compact)
   * * or one of the partial forms:
   * ** \`YYYY-MM-DDThh:mm\` or \`YYYY-MM-DDThh\` (extended)
   * ** \`YYYYMMDDThhmm\` or \`YYYYMMDDThh\` (compact)
   * @param s - Parameter
   * @returns Result value
   */
  valid_iso8601_date_time(s2) {
    const val = s2.value || "";
    const dateTimePattern = /^(\d{4})-?(0[1-9]|1[0-2])-?([0-2]\d|3[01])T([01]\d|2[0-3]):?([0-5]\d)?:?([0-5]\d|60)?([.,]\d+)?(Z|[+-]([01]\d|2[0-3]):?([0-5]\d)?)?$/;
    return new Boolean2(dateTimePattern.test(val));
  }
  /**
   * String is a valid ISO 8601 duration, i.e. takes the form:
   *
   * * \`P[nnY][nnM][nnW][nnD][T[nnH][nnM][nnS]]\`
   *
   * Where each nn represents a number of years, months, etc. \`nnW\` represents a number of 7-day weeks.
   *
   * Note: allowing the \`W\` designator in the same expression as other designators is an exception to the published standard, but necessary in clinical information (typically for representing pregnancy duration).
   * @param s - Parameter
   * @returns Result value
   */
  valid_iso8601_duration(s2) {
    const val = s2.value || "";
    const durationPattern = /^P(?:\d+Y)?(?:\d+M)?(?:\d+W)?(?:\d+D)?(?:T(?:\d+H)?(?:\d+M)?(?:\d+(?:\.\d+)?S)?)?$/;
    return new Boolean2(durationPattern.test(val) && val.length > 1);
  }
};
var Iso8601_type = class extends Temporal {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * Representation of all descendants is a single String.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the String wrapper object for value.
   * Use this to access String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
};
var Iso8601_date_time = class _Iso8601_date_time extends Iso8601_type {
  static {
    TYPE_REGISTRY.set("ISO8601_DATE_TIME", _Iso8601_date_time);
  }
  /**
   * Extract the year part of the date as an Integer.
   *
   * Uses Temporal API for robust ISO 8601 parsing.
   * @returns Result value
   */
  year() {
    const val = this.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      return Integer.from(dt2.year);
    } catch {
      try {
        const match = val.match(/^(\d{4})-?(\d{2})?-?(\d{2})?/);
        if (match && match[1]) {
          return Integer.from(parseInt(match[1], 10));
        }
      } catch {
      }
    }
    return Integer.from(0);
  }
  /**
   * Extract the month part of the date/time as an Integer, or return 0 if not present.
   *
   * Uses Temporal API for robust ISO 8601 parsing.
   * @returns Result value
   */
  month() {
    const val = this.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      return Integer.from(dt2.month);
    } catch {
      try {
        const match = val.match(/^(\d{4})-?(\d{2})?/);
        if (match && match[2]) {
          return Integer.from(parseInt(match[2], 10));
        }
      } catch {
      }
    }
    return Integer.from(0);
  }
  /**
   * Extract the day part of the date/time as an Integer, or return 0 if not present.
   *
   * Uses Temporal API for robust ISO 8601 parsing.
   * @returns Result value
   */
  day() {
    const val = this.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      return Integer.from(dt2.day);
    } catch {
      try {
        const match = val.match(/^(\d{4})-?(\d{2})?-?(\d{2})?/);
        if (match && match[3]) {
          return Integer.from(parseInt(match[3], 10));
        }
      } catch {
      }
    }
    return Integer.from(0);
  }
  /**
   * Extract the hour part of the date/time as an Integer, or return 0 if not present.
   *
   * Uses Temporal API for robust ISO 8601 parsing.
   * @returns Result value
   */
  hour() {
    const val = this.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      return Integer.from(dt2.hour);
    } catch {
    }
    return Integer.from(0);
  }
  /**
   * Extract the minute part of the date/time as an Integer, or return 0 if not present.
   *
   * Uses Temporal API for robust ISO 8601 parsing.
   * @returns Result value
   */
  minute() {
    const val = this.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      return Integer.from(dt2.minute);
    } catch {
    }
    return Integer.from(0);
  }
  /**
   * Extract the integral seconds part of the date/time (i.e. prior to any decimal sign) as an Integer, or return 0 if not present.
   *
   * Uses Temporal API for robust ISO 8601 parsing.
   * @returns Result value
   */
  second() {
    const val = this.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      return Integer.from(dt2.second);
    } catch {
    }
    return Integer.from(0);
  }
  /**
   * Extract the fractional seconds part of the date/time (i.e. following to any decimal sign) as a Real, or return 0.0 if not present.
   *
   * Uses Temporal API for robust ISO 8601 parsing.
   * @returns Result value
   */
  fractional_second() {
    const val = this.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      return dt2.millisecond / 1e3 + dt2.microsecond / 1e6 + dt2.nanosecond / 1e9;
    } catch {
    }
    return 0;
  }
  /**
   * Timezone; may be Void.
   *
   * Uses Temporal API to extract timezone information.
   * @returns Result value
   */
  timezone() {
    const val = this.value || "";
    const match = val.match(/(Z|[+-]\d{2}:?\d{2})$/);
    if (match) {
      const tz = new Iso8601_timezone();
      tz.value = match[1];
      return tz;
    }
    throw new Error("No timezone present in date-time");
  }
  /**
   * Indicates whether month in year is unknown.
   * @returns Result value
   */
  month_unknown() {
    return new Boolean2(this.month().value === 0);
  }
  /**
   * Indicates whether day in month is unknown.
   * @returns Result value
   */
  day_unknown() {
    return new Boolean2(this.day().value === 0);
  }
  /**
   * Indicates whether minute in hour is known.
   * @returns Result value
   */
  minute_unknown() {
    const val = this.value || "";
    return new Boolean2(!val.includes("T") || this.minute().value === 0);
  }
  /**
   * Indicates whether minute in hour is known.
   * @returns Result value
   */
  second_unknown() {
    const val = this.value || "";
    const hasSeconds = /T\d{2}:?\d{2}:?\d{2}/.test(val);
    return new Boolean2(!hasSeconds);
  }
  /**
   * True if this time has a decimal part indicated by \`','\` (comma) rather than \`'.'\` (period).
   * @returns Result value
   */
  is_decimal_sign_comma() {
    const val = this.value || "";
    return new Boolean2(val.includes(","));
  }
  /**
   * True if this date time is partial, i.e. if seconds or more is missing.
   * @returns Result value
   */
  is_partial() {
    return this.second_unknown();
  }
  /**
   * True if this date/time uses \`'-'\`, \`':'\` separators.
   * @returns Result value
   */
  is_extended() {
    const val = this.value || "";
    return new Boolean2(val.includes("-") || val.includes(":"));
  }
  /**
   * True if the \`_fractional_second_\` part is significant (i.e. even if = 0.0).
   * @returns Result value
   */
  has_fractional_second() {
    const val = this.value || "";
    return new Boolean2(/T\d{2}:?\d{2}:?\d{2}[,.]/.test(val));
  }
  /**
   * Return the string value in extended format.
   *
   * Uses Temporal API to parse and format in extended ISO 8601 format.
   * @returns Result value
   */
  as_string() {
    const val = this.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      return String2.from(dt2.toString());
    } catch {
      return String2.from(val);
    }
  }
  /**
   * Arithmetic addition of a duration to a date/time.
   * @param a_diff - Parameter
   * @returns Result value
   */
  add(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = dt2.add(dur);
      const newDateTime = new _Iso8601_date_time();
      newDateTime.value = result2.toString();
      return newDateTime;
    } catch (e2) {
      throw new Error(`Failed to add duration to date_time: ${e2}`);
    }
  }
  /**
   * Arithmetic subtraction of a duration from a date/time.
   * @param a_diff - Parameter
   * @returns Result value
   */
  subtract(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = dt2.subtract(dur);
      const newDateTime = new _Iso8601_date_time();
      newDateTime.value = result2.toString();
      return newDateTime;
    } catch (e2) {
      throw new Error(`Failed to subtract duration from date_time: ${e2}`);
    }
  }
  /**
   * Difference of two date/times.
   * @param a_date_time - Parameter
   * @returns Result value
   */
  diff(a_date_time) {
    const val = this.value || "";
    const otherVal = a_date_time.value || "";
    try {
      const dt1 = mr.PlainDateTime.from(val);
      const dt2 = mr.PlainDateTime.from(otherVal);
      const diff = dt1.since(dt2);
      const duration = new Iso8601_duration();
      duration.value = diff.toString();
      return duration;
    } catch (e2) {
      throw new Error(`Failed to calculate difference: ${e2}`);
    }
  }
  /**
   * Addition of nominal duration represented by \`_a_diff_\`. See \`Iso8601_date._add_nominal_()\` for semantics.
   * @param a_diff - Parameter
   * @returns Result value
   */
  add_nominal(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = dt2.add(dur);
      const newDateTime = new Iso8601_date();
      newDateTime.value = result2.toPlainDate().toString();
      return newDateTime;
    } catch (e2) {
      throw new Error(`Failed to add nominal duration: ${e2}`);
    }
  }
  /**
   * Subtraction of nominal duration represented by \`_a_diff_\`. See \`_add_nominal_()\` for semantics.
   * @param a_diff - Parameter
   * @returns Result value
   */
  subtract_nominal(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const dt2 = mr.PlainDateTime.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = dt2.subtract(dur);
      const newDateTime = new Iso8601_date();
      newDateTime.value = result2.toPlainDate().toString();
      return newDateTime;
    } catch (e2) {
      throw new Error(`Failed to subtract nominal duration: ${e2}`);
    }
  }
  /**
   * Compares this date-time with another for ordering.
   * @param other - The object to compare with
   * @returns true if this date-time is less than the other
   */
  less_than(other) {
    if (!(other instanceof _Iso8601_date_time)) {
      return new Boolean2(false);
    }
    const val = this.value || "";
    const otherVal = other.value || "";
    try {
      const dt1 = mr.PlainDateTime.from(val);
      const dt2 = mr.PlainDateTime.from(otherVal);
      return new Boolean2(mr.PlainDateTime.compare(dt1, dt2) < 0);
    } catch {
      return new Boolean2(val < otherVal);
    }
  }
  /**
   * Value equality: return True if this and other are equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _Iso8601_date_time)) {
      return new Boolean2(false);
    }
    const val = this.value || "";
    const otherVal = other.value || "";
    try {
      const dt1 = mr.PlainDateTime.from(val);
      const dt2 = mr.PlainDateTime.from(otherVal);
      return new Boolean2(mr.PlainDateTime.compare(dt1, dt2) === 0);
    } catch {
      return new Boolean2(val === otherVal);
    }
  }
};
var Iso8601_duration = class _Iso8601_duration extends Iso8601_type {
  static {
    TYPE_REGISTRY.set("ISO8601_DURATION", _Iso8601_duration);
  }
  /**
   * Helper method to convert openEHR duration with weeks to standard ISO 8601.
   * OpenEHR allows weeks to be mixed with other designators, but Temporal API doesn't.
   * This converts weeks to days (1W = 7D).
   * @param value - Duration string that may contain weeks
   * @returns Duration string with weeks converted to days
   */
  static normalizeWeeks(value) {
    const weeksMatch = value.match(/(\d+(?:\.\d+)?)W/);
    if (!weeksMatch)
      return value;
    const weeks = parseFloat(weeksMatch[1]);
    const days = weeks * 7;
    let normalized = value.replace(/\d+(?:\.\d+)?W/, "");
    const daysMatch = normalized.match(/(\d+(?:\.\d+)?)D/);
    if (daysMatch) {
      const existingDays = parseFloat(daysMatch[1]);
      const totalDays = existingDays + days;
      normalized = normalized.replace(/\d+(?:\.\d+)?D/, `${totalDays}D`);
    } else {
      if (normalized.includes("T")) {
        normalized = normalized.replace("T", `${days}DT`);
      } else {
        normalized = normalized.replace(/P(.*)$/, `P$1${days}D`);
      }
    }
    return normalized;
  }
  /**
   * Returns True.
   * @returns Result value
   */
  is_extended() {
    return new Boolean2(true);
  }
  /**
   * Returns False.
   * @returns Result value
   */
  is_partial() {
    return new Boolean2(false);
  }
  /**
   * Number of years in the \`_value_\`, i.e. the number preceding the \`'Y'\` in the \`'YMD'\` part, if one exists.
   * @returns Result value
   */
  years() {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(val);
      return Integer.from(dur.years || 0);
    } catch {
      return Integer.from(0);
    }
  }
  /**
   * Number of months in the \`_value_\`, i.e. the value preceding the \`'M'\` in the \`'YMD'\` part, if one exists.
   * @returns Result value
   */
  months() {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(val);
      return Integer.from(dur.months || 0);
    } catch {
      return Integer.from(0);
    }
  }
  /**
   * Number of days in the \`_value_\`, i.e. the number preceding the \`'D'\` in the \`'YMD'\` part, if one exists.
   * Note: This returns only the D component, not converted weeks.
   * @returns Result value
   */
  days() {
    const val = this.value || "";
    try {
      const normalized = _Iso8601_duration.normalizeWeeks(val);
      const dur = mr.Duration.from(normalized);
      return Integer.from(dur.days || 0);
    } catch {
      const daysMatch = val.match(/(\d+(?:\.\d+)?)D/);
      if (daysMatch) {
        return Integer.from(Math.floor(parseFloat(daysMatch[1])));
      }
      return Integer.from(0);
    }
  }
  /**
   * Number of hours in the \`_value_\`, i.e. the number preceding the \`'H'\` in the \`'HMS'\` part, if one exists.
   * @returns Result value
   */
  hours() {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(val);
      return Integer.from(dur.hours || 0);
    } catch {
      return Integer.from(0);
    }
  }
  /**
   * Number of minutes in the \`_value_\`, i.e. the number preceding the \`'M'\` in the \`'HMS'\` part, if one exists.
   * @returns Result value
   */
  minutes() {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(val);
      return Integer.from(dur.minutes || 0);
    } catch {
      return Integer.from(0);
    }
  }
  /**
   * Number of seconds in the \`_value_\`, i.e. the integer number preceding the \`'S'\` in the \`'HMS'\` part, if one exists.
   * @returns Result value
   */
  seconds() {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(val);
      return Integer.from(dur.seconds || 0);
    } catch {
      return Integer.from(0);
    }
  }
  /**
   * Fractional seconds in the \`_value_\`, i.e. the decimal part of the number preceding the \`'S'\` in the \`'HMS'\` part, if one exists.
   * @returns Result value
   */
  fractional_seconds() {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(val);
      return (dur.milliseconds || 0) / 1e3 + (dur.microseconds || 0) / 1e6 + (dur.nanoseconds || 0) / 1e9;
    } catch {
      return 0;
    }
  }
  /**
   * Number of weeks in the \`_value_\`, i.e. the value preceding the \`W\`, if one exists.
   * @returns Result value
   */
  weeks() {
    const val = this.value || "";
    const weeksMatch = val.match(/(\d+(?:\.\d+)?)W/);
    if (weeksMatch) {
      return Integer.from(Math.floor(parseFloat(weeksMatch[1])));
    }
    return Integer.from(0);
  }
  /**
   * True if this time has a decimal part indicated by ',' (comma) rather than '.' (period).
   * @returns Result value
   */
  is_decimal_sign_comma() {
    const val = this.value || "";
    return new Boolean2(val.includes(","));
  }
  /**
   * Total number of seconds equivalent (including fractional) of entire duration. Where non-definite elements such as year and month (i.e. 'Y' and 'M') are included, the corresponding 'average' durations from \`Time_definitions\` are used to compute the result.
   * @returns Result value
   */
  to_seconds() {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(val);
      const totalSeconds = (dur.years || 0) * 31536e3 + (dur.months || 0) * 2592e3 + (dur.weeks || 0) * 604800 + (dur.days || 0) * 86400 + (dur.hours || 0) * 3600 + (dur.minutes || 0) * 60 + (dur.seconds || 0) + (dur.milliseconds || 0) / 1e3 + (dur.microseconds || 0) / 1e6 + (dur.nanoseconds || 0) / 1e9;
      return totalSeconds;
    } catch {
      return 0;
    }
  }
  /**
   * Return the duration string value.
   * @returns Result value
   */
  as_string() {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(
        _Iso8601_duration.normalizeWeeks(val)
      );
      return String2.from(dur.toString());
    } catch {
      return String2.from(val);
    }
  }
  /**
   * Arithmetic addition of a duration to a duration, via conversion to seconds, using \`Time_definitions._Average_days_in_year_\` and \`Time_definitions._Average_days_in_month_\`
   * @param a_val - Parameter
   * @returns Result value
   */
  add(a_val) {
    const val = this.value || "";
    const otherVal = a_val.value || "";
    try {
      const dur1 = mr.Duration.from(
        _Iso8601_duration.normalizeWeeks(val)
      );
      const dur2 = mr.Duration.from(
        _Iso8601_duration.normalizeWeeks(otherVal)
      );
      const result2 = dur1.add(dur2);
      const newDuration = new _Iso8601_duration();
      newDuration.value = result2.toString();
      return newDuration;
    } catch (e2) {
      throw new Error(`Failed to add durations: ${e2}`);
    }
  }
  /**
   * Arithmetic subtraction of a duration from a duration, via conversion to seconds, using \`Time_definitions._Average_days_in_year_\` and \`Time_definitions._Average_days_in_month_\`
   * @param a_val - Parameter
   * @returns Result value
   */
  subtract(a_val) {
    const val = this.value || "";
    const otherVal = a_val.value || "";
    try {
      const dur1 = mr.Duration.from(
        _Iso8601_duration.normalizeWeeks(val)
      );
      const dur2 = mr.Duration.from(
        _Iso8601_duration.normalizeWeeks(otherVal)
      );
      const result2 = dur1.subtract(dur2);
      const newDuration = new _Iso8601_duration();
      newDuration.value = result2.toString();
      return newDuration;
    } catch (e2) {
      throw new Error(`Failed to subtract durations: ${e2}`);
    }
  }
  /**
   * Arithmetic multiplication a duration by a number.
   * @param a_val - Parameter
   * @returns Result value
   */
  multiply(a_val) {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(
        _Iso8601_duration.normalizeWeeks(val)
      );
      const result2 = dur.add(dur.negated()).add({
        years: dur.years * a_val,
        months: dur.months * a_val,
        weeks: dur.weeks * a_val,
        days: dur.days * a_val,
        hours: dur.hours * a_val,
        minutes: dur.minutes * a_val,
        seconds: dur.seconds * a_val,
        milliseconds: dur.milliseconds * a_val,
        microseconds: dur.microseconds * a_val,
        nanoseconds: dur.nanoseconds * a_val
      });
      const newDuration = new _Iso8601_duration();
      newDuration.value = result2.toString();
      return newDuration;
    } catch (e2) {
      throw new Error(`Failed to multiply duration: ${e2}`);
    }
  }
  /**
   * Arithmetic division of a duration by a number.
   * @param a_val - Parameter
   * @returns Result value
   */
  divide(a_val) {
    if (a_val === 0) {
      throw new Error("Division by zero");
    }
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(
        _Iso8601_duration.normalizeWeeks(val)
      );
      const result2 = dur.add(dur.negated()).add({
        years: dur.years / a_val,
        months: dur.months / a_val,
        weeks: dur.weeks / a_val,
        days: dur.days / a_val,
        hours: dur.hours / a_val,
        minutes: dur.minutes / a_val,
        seconds: dur.seconds / a_val,
        milliseconds: dur.milliseconds / a_val,
        microseconds: dur.microseconds / a_val,
        nanoseconds: dur.nanoseconds / a_val
      });
      const newDuration = new _Iso8601_duration();
      newDuration.value = result2.toString();
      return newDuration;
    } catch (e2) {
      throw new Error(`Failed to divide duration: ${e2}`);
    }
  }
  /**
   * Generate negative of current duration value.
   * @returns Result value
   */
  negative() {
    const val = this.value || "";
    try {
      const dur = mr.Duration.from(
        _Iso8601_duration.normalizeWeeks(val)
      );
      const result2 = dur.negated();
      const newDuration = new _Iso8601_duration();
      newDuration.value = result2.toString();
      return newDuration;
    } catch (e2) {
      throw new Error(`Failed to negate duration: ${e2}`);
    }
  }
  /**
   * Compares this duration with another for ordering.
   * @param other - The object to compare with
   * @returns true if this duration is less than the other
   */
  less_than(other) {
    if (!(other instanceof _Iso8601_duration)) {
      return new Boolean2(false);
    }
    const val = this.value || "";
    const otherVal = other.value || "";
    try {
      const dur1 = mr.Duration.from(_Iso8601_duration.normalizeWeeks(val));
      const dur2 = mr.Duration.from(_Iso8601_duration.normalizeWeeks(otherVal));
      const total1 = dur1.total({ unit: "seconds" });
      const total2 = dur2.total({ unit: "seconds" });
      return new Boolean2(total1 < total2);
    } catch {
      return new Boolean2(val < otherVal);
    }
  }
  /**
   * Value equality: return True if this and other are equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _Iso8601_duration)) {
      return new Boolean2(false);
    }
    const val = this.value || "";
    const otherVal = other.value || "";
    try {
      const dur1 = mr.Duration.from(_Iso8601_duration.normalizeWeeks(val));
      const dur2 = mr.Duration.from(_Iso8601_duration.normalizeWeeks(otherVal));
      const total1 = dur1.total({ unit: "seconds" });
      const total2 = dur2.total({ unit: "seconds" });
      return new Boolean2(total1 === total2);
    } catch {
      return new Boolean2(val === otherVal);
    }
  }
};
var Iso8601_time = class _Iso8601_time extends Iso8601_type {
  static {
    TYPE_REGISTRY.set("ISO8601_TIME", _Iso8601_time);
  }
  /**
   * Extract the hour part of the date/time as an Integer.
   * @returns Result value
   */
  hour() {
    const val = this.value || "";
    try {
      const time = mr.PlainTime.from(val);
      return Integer.from(time.hour);
    } catch {
      const match = val.match(/^(\d{2})/);
      if (match) {
        return Integer.from(parseInt(match[1], 10));
      }
    }
    return Integer.from(0);
  }
  /**
   * Extract the minute part of the time as an Integer, or return 0 if not present.
   * @returns Result value
   */
  minute() {
    const val = this.value || "";
    try {
      const time = mr.PlainTime.from(val);
      return Integer.from(time.minute);
    } catch {
    }
    return Integer.from(0);
  }
  /**
   * Extract the integral seconds part of the time (i.e. prior to any decimal sign) as an Integer, or return 0 if not present.
   * @returns Result value
   */
  second() {
    const val = this.value || "";
    try {
      const time = mr.PlainTime.from(val);
      return Integer.from(time.second);
    } catch {
    }
    return Integer.from(0);
  }
  /**
   * Extract the fractional seconds part of the time (i.e. following to any decimal sign) as a Real, or return 0.0 if not present.
   * @returns Result value
   */
  fractional_second() {
    const val = this.value || "";
    try {
      const time = mr.PlainTime.from(val);
      return time.millisecond / 1e3 + time.microsecond / 1e6 + time.nanosecond / 1e9;
    } catch {
    }
    return 0;
  }
  /**
   * Timezone; may be Void.
   * @returns Result value
   */
  timezone() {
    const val = this.value || "";
    const match = val.match(/(Z|[+-]\d{2}:?\d{2})$/);
    if (match) {
      const tz = new Iso8601_timezone();
      tz.value = match[1];
      return tz;
    }
    throw new Error("No timezone present in time");
  }
  /**
   * Indicates whether minute is unknown. If so, the time is of the form hh.
   * @returns Result value
   */
  minute_unknown() {
    const val = this.value || "";
    const hasMinutes = /^\d{2}:?\d{2}/.test(val);
    return new Boolean2(!hasMinutes);
  }
  /**
   * Indicates whether second is unknown. If so and month is known, the time is of the form \`"hh:mm"\` or \`"hhmm"\`.
   * @returns Result value
   */
  second_unknown() {
    const val = this.value || "";
    const hasSeconds = /^\d{2}:?\d{2}:?\d{2}/.test(val);
    return new Boolean2(!hasSeconds);
  }
  /**
   * True if this time has a decimal part indicated by \`','\` (comma) rather than \`'.'\` (period).
   * @returns Result value
   */
  is_decimal_sign_comma() {
    const val = this.value || "";
    return new Boolean2(val.includes(","));
  }
  /**
   * True if this time is partial, i.e. if seconds or more is missing.
   * @returns Result value
   */
  is_partial() {
    return this.second_unknown();
  }
  /**
   * True if this time uses \`'-'\`, \`':'\` separators.
   * @returns Result value
   */
  is_extended() {
    const val = this.value || "";
    return new Boolean2(val.includes(":"));
  }
  /**
   * True if the \`_fractional_second_\` part is significant (i.e. even if = 0.0).
   * @returns Result value
   */
  has_fractional_second() {
    const val = this.value || "";
    return new Boolean2(/\d{2}[,.]/.test(val));
  }
  /**
   * Return string value in extended format.
   * @returns Result value
   */
  as_string() {
    const val = this.value || "";
    try {
      const time = mr.PlainTime.from(val);
      return String2.from(time.toString());
    } catch {
      return String2.from(val);
    }
  }
  /**
   * Arithmetic addition of a duration to a time.
   * @param a_diff - Parameter
   * @returns Result value
   */
  add(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const time = mr.PlainTime.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = time.add(dur);
      const newTime = new _Iso8601_time();
      newTime.value = result2.toString();
      return newTime;
    } catch (e2) {
      throw new Error(`Failed to add duration to time: ${e2}`);
    }
  }
  /**
   * Arithmetic subtraction of a duration from a time.
   * @param a_diff - Parameter
   * @returns Result value
   */
  subtract(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const time = mr.PlainTime.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = time.subtract(dur);
      const newTime = new _Iso8601_time();
      newTime.value = result2.toString();
      return newTime;
    } catch (e2) {
      throw new Error(`Failed to subtract duration from time: ${e2}`);
    }
  }
  /**
   * Difference of two times.
   * @param a_time - Parameter
   * @returns Result value
   */
  diff(a_time) {
    const val = this.value || "";
    const otherVal = a_time.value || "";
    try {
      const time1 = mr.PlainTime.from(val);
      const time2 = mr.PlainTime.from(otherVal);
      const diff = time1.since(time2);
      const duration = new Iso8601_duration();
      duration.value = diff.toString();
      return duration;
    } catch (e2) {
      throw new Error(`Failed to calculate time difference: ${e2}`);
    }
  }
  /**
   * Compares this time with another for ordering.
   * @param other - The object to compare with
   * @returns true if this time is less than the other
   */
  less_than(other) {
    if (!(other instanceof _Iso8601_time)) {
      return new Boolean2(false);
    }
    const val = this.value || "";
    const otherVal = other.value || "";
    try {
      const time1 = mr.PlainTime.from(val);
      const time2 = mr.PlainTime.from(otherVal);
      return new Boolean2(mr.PlainTime.compare(time1, time2) < 0);
    } catch {
      return new Boolean2(val < otherVal);
    }
  }
  /**
   * Value equality: return True if this and other are equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _Iso8601_time)) {
      return new Boolean2(false);
    }
    const val = this.value || "";
    const otherVal = other.value || "";
    try {
      const time1 = mr.PlainTime.from(val);
      const time2 = mr.PlainTime.from(otherVal);
      return new Boolean2(mr.PlainTime.compare(time1, time2) === 0);
    } catch {
      return new Boolean2(val === otherVal);
    }
  }
};
var Iso8601_date = class _Iso8601_date extends Iso8601_type {
  static {
    TYPE_REGISTRY.set("ISO8601_DATE", _Iso8601_date);
  }
  /**
   * Extract the year part of the date as an Integer.
   *
   * Uses Temporal API for robust ISO 8601 date parsing.
   * @returns Result value
   */
  year() {
    const val = this.value || "";
    try {
      const date = mr.PlainDate.from(val);
      return Integer.from(date.year);
    } catch {
      const match = val.match(/^(\d{4})/);
      if (match) {
        return Integer.from(parseInt(match[1], 10));
      }
    }
    return Integer.from(0);
  }
  /**
   * Extract the month part of the date as an Integer, or return 0 if not present.
   *
   * Uses Temporal API for robust ISO 8601 date parsing.
   * @returns Result value
   */
  month() {
    const val = this.value || "";
    try {
      const date = mr.PlainDate.from(val);
      return Integer.from(date.month);
    } catch {
      try {
        const ym = mr.PlainYearMonth.from(val);
        return Integer.from(ym.month);
      } catch {
      }
    }
    return Integer.from(0);
  }
  /**
   * Extract the day part of the date as an Integer, or return 0 if not present.
   *
   * Uses Temporal API for robust ISO 8601 date parsing.
   * @returns Result value
   */
  day() {
    const val = this.value || "";
    try {
      const date = mr.PlainDate.from(val);
      return Integer.from(date.day);
    } catch {
    }
    return Integer.from(0);
  }
  /**
   * Timezone; may be Void.
   *
   * NOTE: ISO 8601 dates typically don't have timezones, but this checks for them.
   * @returns Result value
   */
  timezone() {
    const val = this.value || "";
    const match = val.match(/(Z|[+-]\d{2}:?\d{2})$/);
    if (match) {
      const tz = new Iso8601_timezone();
      tz.value = match[1];
      return tz;
    }
    throw new Error("No timezone present in date");
  }
  /**
   * Indicates whether month in year is unknown. If so, the date is of the form \`"YYYY"\`.
   * @returns Result value
   */
  month_unknown() {
    return new Boolean2(this.month().value === 0);
  }
  /**
   * Indicates whether day in month is unknown. If so, and month is known, the date is of the form \`"YYYY-MM"\` or \`"YYYYMM"\`.
   * @returns Result value
   */
  day_unknown() {
    return new Boolean2(this.day().value === 0);
  }
  /**
   * True if this date is partial, i.e. if days or more is missing.
   * @returns Result value
   */
  is_partial() {
    return this.day_unknown();
  }
  /**
   * True if this date uses \`'-'\` separators.
   * @returns Result value
   */
  is_extended() {
    const val = this.value || "";
    return new Boolean2(val.includes("-"));
  }
  /**
   * Return string value in extended format.
   *
   * Uses Temporal API to parse and format in extended ISO 8601 format.
   * @returns Result value
   */
  as_string() {
    const val = this.value || "";
    try {
      const date = mr.PlainDate.from(val);
      return String2.from(date.toString());
    } catch {
      try {
        const ym = mr.PlainYearMonth.from(val);
        return String2.from(ym.toString());
      } catch {
        return String2.from(val);
      }
    }
  }
  /**
   * Arithmetic addition of a duration to a date.
   * @param a_diff - Parameter
   * @returns Result value
   */
  add(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const date = mr.PlainDate.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = date.add(dur);
      const newDate = new _Iso8601_date();
      newDate.value = result2.toString();
      return newDate;
    } catch (e2) {
      throw new Error(`Failed to add duration to date: ${e2}`);
    }
  }
  /**
   * Arithmetic subtraction of a duration from a date.
   * @param a_diff - Parameter
   * @returns Result value
   */
  subtract(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const date = mr.PlainDate.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = date.subtract(dur);
      const newDate = new _Iso8601_date();
      newDate.value = result2.toString();
      return newDate;
    } catch (e2) {
      throw new Error(`Failed to subtract duration from date: ${e2}`);
    }
  }
  /**
   * Difference of two dates.
   * @param a_date - Parameter
   * @returns Result value
   */
  diff(a_date) {
    const val = this.value || "";
    const otherVal = a_date.value || "";
    try {
      const date1 = mr.PlainDate.from(val);
      const date2 = mr.PlainDate.from(otherVal);
      const diff = date1.since(date2);
      const duration = new Iso8601_duration();
      duration.value = diff.toString();
      return duration;
    } catch (e2) {
      throw new Error(`Failed to calculate date difference: ${e2}`);
    }
  }
  /**
   * Addition of nominal duration represented by \`_a_diff_\`. For example, a duration of \`'P1Y'\` means advance to the same date next year, with the exception of the date 29 February in a leap year, to which the addition of a nominal year will result in 28 February of the following year. Similarly, \`'P1M'\` is understood here as a nominal month, the addition of which will result in one of:
   *
   * * the same day in the following month, if it exists, or;
   * * one or two days less where the following month is shorter, or;
   * * in the case of adding a month to the date 31 Jan, the result will be 28 Feb in a non-leap year (i.e. three less) and 29 Feb in a leap year (i.e. two less).
   * @param a_diff - Parameter
   * @returns Result value
   */
  add_nominal(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const date = mr.PlainDate.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = date.add(dur, { overflow: "constrain" });
      const newDate = new _Iso8601_date();
      newDate.value = result2.toString();
      return newDate;
    } catch (e2) {
      throw new Error(`Failed to add nominal duration to date: ${e2}`);
    }
  }
  /**
   * Subtraction of nominal duration represented by \`_a_diff_\`. See \`_add_nominal_()\` for semantics.
   * @param a_diff - Parameter
   * @returns Result value
   */
  subtract_nominal(a_diff) {
    const val = this.value || "";
    const diffVal = a_diff.value || "";
    try {
      const date = mr.PlainDate.from(val);
      const dur = mr.Duration.from(
        Iso8601_duration.normalizeWeeks(diffVal)
      );
      const result2 = date.subtract(dur, { overflow: "constrain" });
      const newDate = new _Iso8601_date();
      newDate.value = result2.toString();
      return newDate;
    } catch (e2) {
      throw new Error(`Failed to subtract nominal duration from date: ${e2}`);
    }
  }
  /**
   * Compares this date with another for ordering.
   * @param other - The object to compare with
   * @returns true if this date is less than the other
   */
  less_than(other) {
    if (!(other instanceof _Iso8601_date)) {
      return new Boolean2(false);
    }
    const val = this.value || "";
    const otherVal = other.value || "";
    try {
      const date1 = mr.PlainDate.from(val);
      const date2 = mr.PlainDate.from(otherVal);
      return new Boolean2(mr.PlainDate.compare(date1, date2) < 0);
    } catch {
      return new Boolean2(val < otherVal);
    }
  }
  /**
   * Value equality: return True if this and other are equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _Iso8601_date)) {
      return new Boolean2(false);
    }
    const val = this.value || "";
    const otherVal = other.value || "";
    try {
      const date1 = mr.PlainDate.from(val);
      const date2 = mr.PlainDate.from(otherVal);
      return new Boolean2(mr.PlainDate.compare(date1, date2) === 0);
    } catch {
      return new Boolean2(val === otherVal);
    }
  }
};
var Interval = class _Interval extends Any {
  /**
   * Lower bound.
   */
  lower;
  /**
   * Upper bound.
   */
  upper;
  /**
   * Internal storage for lower_unbounded
   * @protected
   */
  _lower_unbounded;
  /**
   * True if \`_lower_\` boundary open (i.e. = \`-infinity\`).
   */
  get lower_unbounded() {
    return this._lower_unbounded?.value;
  }
  /**
   * Gets the Boolean wrapper object for lower_unbounded.
   * Use this to access Boolean methods.
   */
  get $lower_unbounded() {
    return this._lower_unbounded;
  }
  /**
   * Sets lower_unbounded from either a primitive value or Boolean wrapper.
   */
  set lower_unbounded(val) {
    if (val === void 0 || val === null) {
      this._lower_unbounded = void 0;
    } else if (typeof val === "boolean") {
      this._lower_unbounded = Boolean2.from(val);
    } else {
      this._lower_unbounded = val;
    }
  }
  /**
   * Internal storage for upper_unbounded
   * @protected
   */
  _upper_unbounded;
  /**
   * True if \`_upper_\` boundary open (i.e. = \`+infinity\`).
   */
  get upper_unbounded() {
    return this._upper_unbounded?.value;
  }
  /**
   * Gets the Boolean wrapper object for upper_unbounded.
   * Use this to access Boolean methods.
   */
  get $upper_unbounded() {
    return this._upper_unbounded;
  }
  /**
   * Sets upper_unbounded from either a primitive value or Boolean wrapper.
   */
  set upper_unbounded(val) {
    if (val === void 0 || val === null) {
      this._upper_unbounded = void 0;
    } else if (typeof val === "boolean") {
      this._upper_unbounded = Boolean2.from(val);
    } else {
      this._upper_unbounded = val;
    }
  }
  /**
   * Internal storage for lower_included
   * @protected
   */
  _lower_included;
  /**
   * True if \`_lower_\` boundary value included in range, if \`not _lower_unbounded_\`.
   */
  get lower_included() {
    return this._lower_included?.value;
  }
  /**
   * Gets the Boolean wrapper object for lower_included.
   * Use this to access Boolean methods.
   */
  get $lower_included() {
    return this._lower_included;
  }
  /**
   * Sets lower_included from either a primitive value or Boolean wrapper.
   */
  set lower_included(val) {
    if (val === void 0 || val === null) {
      this._lower_included = void 0;
    } else if (typeof val === "boolean") {
      this._lower_included = Boolean2.from(val);
    } else {
      this._lower_included = val;
    }
  }
  /**
   * Internal storage for upper_included
   * @protected
   */
  _upper_included;
  /**
   * True if \`_upper_\` boundary value included in range if \`not _upper_unbounded_\`.
   */
  get upper_included() {
    return this._upper_included?.value;
  }
  /**
   * Gets the Boolean wrapper object for upper_included.
   * Use this to access Boolean methods.
   */
  get $upper_included() {
    return this._upper_included;
  }
  /**
   * Sets upper_included from either a primitive value or Boolean wrapper.
   */
  set upper_included(val) {
    if (val === void 0 || val === null) {
      this._upper_included = void 0;
    } else if (typeof val === "boolean") {
      this._upper_included = Boolean2.from(val);
    } else {
      this._upper_included = val;
    }
  }
  /**
   * True if current object's interval is semantically same as \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _Interval)) {
      return new Boolean2(false);
    }
    const otherInterval = other;
    if (this.lower_unbounded !== otherInterval.lower_unbounded) {
      return new Boolean2(false);
    }
    if (!this.lower_unbounded) {
      if (this.lower === void 0 || otherInterval.lower === void 0) {
        return new Boolean2(false);
      }
      if (!this.lower.is_equal(otherInterval.lower).value) {
        return new Boolean2(false);
      }
      if (this.lower_included !== otherInterval.lower_included) {
        return new Boolean2(false);
      }
    }
    if (this.upper_unbounded !== otherInterval.upper_unbounded) {
      return new Boolean2(false);
    }
    if (!this.upper_unbounded) {
      if (this.upper === void 0 || otherInterval.upper === void 0) {
        return new Boolean2(false);
      }
      if (!this.upper.is_equal(otherInterval.upper).value) {
        return new Boolean2(false);
      }
      if (this.upper_included !== otherInterval.upper_included) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
};
var Proper_interval = class extends Interval {
  /**
   * True if the value \`e\` is properly contained in this Interval.
   * @param e - Parameter
   * @returns Result value
   */
  has(e2) {
    if (!this.lower_unbounded && this.lower !== void 0) {
      const cmp = e2.less_than(this.lower);
      if (cmp.value === true)
        return new Boolean2(false);
      if (!this.lower_included) {
        const eq = e2.is_equal(this.lower);
        if (eq.value === true)
          return new Boolean2(false);
      }
    }
    if (!this.upper_unbounded && this.upper !== void 0) {
      const cmp = this.upper.less_than(e2);
      if (cmp.value === true)
        return new Boolean2(false);
      if (!this.upper_included) {
        const eq = e2.is_equal(this.upper);
        if (eq.value === true)
          return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * True if there is any overlap between intervals represented by Current and \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  intersects(other) {
    if (!this.upper_unbounded && this.upper !== void 0 && !other.lower_unbounded && other.lower !== void 0) {
      if (this.upper.less_than(other.lower).value) {
        return new Boolean2(false);
      }
      if (this.upper.is_equal(other.lower).value && (!this.upper_included || !other.lower_included)) {
        return new Boolean2(false);
      }
    }
    if (!other.upper_unbounded && other.upper !== void 0 && !this.lower_unbounded && this.lower !== void 0) {
      if (other.upper.less_than(this.lower).value) {
        return new Boolean2(false);
      }
      if (other.upper.is_equal(this.lower).value && (!other.upper_included || !this.lower_included)) {
        return new Boolean2(false);
      }
    }
    return new Boolean2(true);
  }
  /**
   * True if current interval properly contains \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  contains(other) {
    if (!other.lower_unbounded && other.lower !== void 0) {
      if (this.lower_unbounded) {
      } else if (this.lower === void 0) {
        return new Boolean2(false);
      } else {
        if (this.lower.less_than(other.lower).value) {
        } else if (this.lower.is_equal(other.lower).value) {
          if (!this.lower_included && other.lower_included) {
            return new Boolean2(false);
          }
        } else {
          return new Boolean2(false);
        }
      }
    }
    if (!other.upper_unbounded && other.upper !== void 0) {
      if (this.upper_unbounded) {
      } else if (this.upper === void 0) {
        return new Boolean2(false);
      } else {
        if (other.upper.less_than(this.upper).value) {
        } else if (this.upper.is_equal(other.upper).value) {
          if (!this.upper_included && other.upper_included) {
            return new Boolean2(false);
          }
        } else {
          return new Boolean2(false);
        }
      }
    }
    return new Boolean2(true);
  }
};
var Multiplicity_interval = class _Multiplicity_interval extends Proper_interval {
  static {
    TYPE_REGISTRY.set("MULTIPLICITY_INTERVAL", _Multiplicity_interval);
  }
  /**
   * True if this interval imposes no constraints, i.e. is set to `0..*`.
   * @returns Result value
   */
  is_open() {
    const lowerVal = this.lower?.value || 0;
    return new Boolean2(
      lowerVal === 0 && this.upper_unbounded === true
    );
  }
  /**
   * True if this interval expresses optionality, i.e. \`0..1\`.
   * @returns Result value
   */
  is_optional() {
    const lowerVal = this.lower?.value || 0;
    const upperVal = this.upper?.value || 0;
    return new Boolean2(
      lowerVal === 0 && upperVal === 1
    );
  }
  /**
   * True if this interval expresses mandation, i.e. \`1..1\`.
   * @returns Result value
   */
  is_mandatory() {
    const lowerVal = this.lower?.value || 0;
    const upperVal = this.upper?.value || 0;
    return new Boolean2(
      lowerVal === 1 && upperVal === 1
    );
  }
  /**
   * True if this interval is set to \`0..0\`.
   * @returns Result value
   */
  is_prohibited() {
    const lowerVal = this.lower?.value || 0;
    const upperVal = this.upper?.value || 0;
    return new Boolean2(
      lowerVal === 0 && upperVal === 0
    );
  }
};
var Cardinality = class {
  /**
   * The interval of this cardinality.
   */
  interval;
  /**
   * Internal storage for is_ordered
   * @protected
   */
  _is_ordered;
  /**
   * True if the members of the container attribute to which this cardinality refers are ordered.
   */
  get is_ordered() {
    return this._is_ordered?.value;
  }
  /**
   * Gets the Boolean wrapper object for is_ordered.
   * Use this to access Boolean methods.
   */
  get $is_ordered() {
    return this._is_ordered;
  }
  /**
   * Sets is_ordered from either a primitive value or Boolean wrapper.
   */
  set is_ordered(val) {
    if (val === void 0 || val === null) {
      this._is_ordered = void 0;
    } else if (typeof val === "boolean") {
      this._is_ordered = Boolean2.from(val);
    } else {
      this._is_ordered = val;
    }
  }
  /**
   * Internal storage for is_unique
   * @protected
   */
  _is_unique;
  /**
   * True if the members of the container attribute to which this cardinality refers are unique.
   */
  get is_unique() {
    return this._is_unique?.value;
  }
  /**
   * Gets the Boolean wrapper object for is_unique.
   * Use this to access Boolean methods.
   */
  get $is_unique() {
    return this._is_unique;
  }
  /**
   * Sets is_unique from either a primitive value or Boolean wrapper.
   */
  set is_unique(val) {
    if (val === void 0 || val === null) {
      this._is_unique = void 0;
    } else if (typeof val === "boolean") {
      this._is_unique = Boolean2.from(val);
    } else {
      this._is_unique = val;
    }
  }
  /**
   * True if the semantics of this cardinality represent a bag, i.e. unordered, non-unique membership.
   * @returns Result value
   */
  is_bag() {
    return new Boolean2(
      this.is_ordered !== true && this.is_unique !== true
    );
  }
  /**
   * True if the semantics of this cardinality represent a list, i.e. ordered, non-unique membership.
   * @returns Result value
   */
  is_list() {
    return new Boolean2(
      this.is_ordered === true && this.is_unique !== true
    );
  }
  /**
   * True if the semantics of this cardinality represent a set, i.e. unordered, unique membership.
   * @returns Result value
   */
  is_set() {
    return new Boolean2(
      this.is_ordered !== true && this.is_unique === true
    );
  }
};
var Terminology_code = class _Terminology_code extends Any {
  static {
    TYPE_REGISTRY.set("TERMINOLOGY_CODE", _Terminology_code);
  }
  /**
   * Internal storage for terminology_id
   * @protected
   */
  _terminology_id;
  /**
   * The archetype environment namespace identifier used to identify a terminology. Typically a value like \`"snomed_ct"\` that is mapped elsewhere to the full URI identifying the terminology.
   */
  get terminology_id() {
    return this._terminology_id?.value;
  }
  /**
   * Gets the String wrapper object for terminology_id.
   * Use this to access String methods.
   */
  get $terminology_id() {
    return this._terminology_id;
  }
  /**
   * Sets terminology_id from either a primitive value or String wrapper.
   */
  set terminology_id(val) {
    if (val === void 0 || val === null) {
      this._terminology_id = void 0;
    } else if (typeof val === "string") {
      this._terminology_id = String2.from(val);
    } else {
      this._terminology_id = val;
    }
  }
  /**
   * Internal storage for terminology_version
   * @protected
   */
  _terminology_version;
  /**
   * Optional string value representing terminology version, typically a date or dotted numeric.
   */
  get terminology_version() {
    return this._terminology_version?.value;
  }
  /**
   * Gets the String wrapper object for terminology_version.
   * Use this to access String methods.
   */
  get $terminology_version() {
    return this._terminology_version;
  }
  /**
   * Sets terminology_version from either a primitive value or String wrapper.
   */
  set terminology_version(val) {
    if (val === void 0 || val === null) {
      this._terminology_version = void 0;
    } else if (typeof val === "string") {
      this._terminology_version = String2.from(val);
    } else {
      this._terminology_version = val;
    }
  }
  /**
   * Internal storage for code_string
   * @protected
   */
  _code_string;
  /**
   * A terminology code or post-coordinated code expression, if supported by the terminology. The code may refer to a single term, a value set consisting of multiple terms, or some other entity representable within the terminology.
   */
  get code_string() {
    return this._code_string?.value;
  }
  /**
   * Gets the String wrapper object for code_string.
   * Use this to access String methods.
   */
  get $code_string() {
    return this._code_string;
  }
  /**
   * Sets code_string from either a primitive value or String wrapper.
   */
  set code_string(val) {
    if (val === void 0 || val === null) {
      this._code_string = void 0;
    } else if (typeof val === "string") {
      this._code_string = String2.from(val);
    } else {
      this._code_string = val;
    }
  }
  /**
   * The URI reference that may be used as a concrete key into a notional terminology service for queries that can obtain the term text, definition, and other associated elements.
   */
  uri;
  /**
   * Value equality: return True if this and other are equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _Terminology_code)) {
      return new Boolean2(false);
    }
    const termIdMatch = this.terminology_id === other.terminology_id || this._terminology_id !== void 0 && other._terminology_id !== void 0 && this._terminology_id.is_equal(other._terminology_id).value;
    const codeMatch = this.code_string === other.code_string || this._code_string !== void 0 && other._code_string !== void 0 && this._code_string.is_equal(other._code_string).value;
    const versionMatch = this.terminology_version === other.terminology_version || this._terminology_version === void 0 && other._terminology_version === void 0 || this._terminology_version !== void 0 && other._terminology_version !== void 0 && this._terminology_version.is_equal(other._terminology_version).value;
    return new Boolean2(termIdMatch && codeMatch && versionMatch);
  }
};
var Terminology_term = class _Terminology_term extends Any {
  static {
    TYPE_REGISTRY.set("TERMINOLOGY_TERM", _Terminology_term);
  }
  /**
   * Reference to the terminology concept formally representing this term.
   */
  concept;
  /**
   * Internal storage for text
   * @protected
   */
  _text;
  /**
   * Text of term.
   */
  get text() {
    return this._text?.value;
  }
  /**
   * Gets the String wrapper object for text.
   * Use this to access String methods.
   */
  get $text() {
    return this._text;
  }
  /**
   * Sets text from either a primitive value or String wrapper.
   */
  set text(val) {
    if (val === void 0 || val === null) {
      this._text = void 0;
    } else if (typeof val === "string") {
      this._text = String2.from(val);
    } else {
      this._text = val;
    }
  }
  /**
   * Value equality: return True if this and other are equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _Terminology_term)) {
      return new Boolean2(false);
    }
    const textMatch = this.text === other.text || this._text !== void 0 && other._text !== void 0 && this._text.is_equal(other._text).value;
    const conceptMatch = this.concept === void 0 && other.concept === void 0 || this.concept !== void 0 && other.concept !== void 0 && this.concept.is_equal(other.concept).value;
    return new Boolean2(textMatch && conceptMatch);
  }
};
var OBJECT_ID = class {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * The value of the id in the form defined below.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the String wrapper object for value.
   * Use this to access String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
};
var ARCHETYPE_ID = class extends OBJECT_ID {
  /**
   * Globally qualified reference model entity, e.g.  \`"openehr-EHR-OBSERVATION"\`.
   * @returns Result value
   */
  qualified_rm_entity() {
    const val = this.value || "";
    const dotIndex = val.indexOf(".");
    if (dotIndex === -1) {
      throw new Error("Invalid ARCHETYPE_ID format: no '.' found");
    }
    return String2.from(val.substring(0, dotIndex));
  }
  /**
   * Name of the concept represented by this archetype, including specialisation, e.g. \`"Biochemistry_result-cholesterol"\`.
   * @returns Result value
   */
  domain_concept() {
    const val = this.value || "";
    const dotIndex = val.indexOf(".");
    const vIndex = val.lastIndexOf(".v");
    if (dotIndex === -1 || vIndex === -1 || vIndex <= dotIndex) {
      throw new Error("Invalid ARCHETYPE_ID format");
    }
    return String2.from(val.substring(dotIndex + 1, vIndex));
  }
  /**
   * Organisation originating the reference model on which this archetype is based, e.g. \`"openEHR"\`, \`"CEN"\`, \`"HL7"\`.
   * @returns Result value
   */
  rm_originator() {
    const qualified = this.qualified_rm_entity().value || "";
    const parts = qualified.split("-");
    if (parts.length < 3) {
      throw new Error("Invalid qualified_rm_entity format");
    }
    return String2.from(parts[0]);
  }
  /**
   * Name of the reference model, e.g. \`"RIM"\`,  \`"EHR"\`,  \`"EN13606"\`.
   * @returns Result value
   */
  rm_name() {
    const qualified = this.qualified_rm_entity().value || "";
    const parts = qualified.split("-");
    if (parts.length < 3) {
      throw new Error("Invalid qualified_rm_entity format");
    }
    return String2.from(parts[1]);
  }
  /**
   * Name of the ontological level within the reference model to which this archetype is targeted, e.g. for openEHR:  \`"FOLDER"\`, \`"COMPOSITION"\`, \`"SECTION"\`, \`"OBSERVATION"\`.
   * @returns Result value
   */
  rm_entity() {
    const qualified = this.qualified_rm_entity().value || "";
    const parts = qualified.split("-");
    if (parts.length < 3) {
      throw new Error("Invalid qualified_rm_entity format");
    }
    return String2.from(parts[2]);
  }
  /**
   * Name of specialisation of concept, if this archetype is a specialisation of another archetype, e.g. \`"cholesterol"\`.
   * @returns Result value
   */
  specialisation() {
    const concept = this.domain_concept().value || "";
    const hyphenIndex = concept.indexOf("-");
    if (hyphenIndex === -1) {
      return String2.from("");
    }
    return String2.from(concept.substring(hyphenIndex + 1));
  }
  /**
   * Version of this archetype.
   *
   * @returns Result value
   */
  version_id() {
    const val = this.value || "";
    const vIndex = val.lastIndexOf(".v");
    if (vIndex === -1) {
      throw new Error("Invalid ARCHETYPE_ID format: no '.v' found");
    }
    return String2.from(val.substring(vIndex + 2));
  }
};
var GENERIC_ID = class extends OBJECT_ID {
  /**
   * Internal storage for scheme
   * @protected
   */
  _scheme;
  /**
   * Name of the scheme to which this identifier conforms. Ideally this name will be recognisable globally but realistically it may be a local ad hoc scheme whose name is not controlled or standardised in any way.
   */
  get scheme() {
    return this._scheme?.value;
  }
  /**
   * Gets the String wrapper object for scheme.
   * Use this to access String methods.
   */
  get $scheme() {
    return this._scheme;
  }
  /**
   * Sets scheme from either a primitive value or String wrapper.
   */
  set scheme(val) {
    if (val === void 0 || val === null) {
      this._scheme = void 0;
    } else if (typeof val === "string") {
      this._scheme = String2.from(val);
    } else {
      this._scheme = val;
    }
  }
};
var UID_BASED_ID = class extends OBJECT_ID {
  /**
   * The identifier of the conceptual namespace in which the object exists, within the identification scheme. Returns the part to the left of the first '::' separator, if any, or else the whole string.
   * @returns Result value
   */
  root() {
    const val = this.value || "";
    const separatorIndex = val.indexOf("::");
    const rootValue = separatorIndex === -1 ? val : val.substring(0, separatorIndex);
    if (rootValue.includes("-")) {
      const uuid = new UUID();
      uuid.value = rootValue;
      return uuid;
    } else if (rootValue.match(/^\d+(\.\d+)*$/)) {
      const oid = new ISO_OID();
      oid.value = rootValue;
      return oid;
    } else {
      const internetId = new INTERNET_ID();
      internetId.value = rootValue;
      return internetId;
    }
  }
  /**
   * Optional local identifier of the object within the context of the root identifier. Returns the part to the right of the first '::' separator if any, or else any empty String.
   * @returns Result value
   */
  extension() {
    const val = this.value || "";
    const separatorIndex = val.indexOf("::");
    if (separatorIndex === -1) {
      return String2.from("");
    }
    return String2.from(val.substring(separatorIndex + 2));
  }
  /**
   * True if not \`_extension_.is_empty()\`.
   * @returns Result value
   */
  has_extension() {
    return new Boolean2(!this.extension().is_empty().value);
  }
};
var HIER_OBJECT_ID = class extends UID_BASED_ID {
};
var OBJECT_REF = class _OBJECT_REF {
  /**
   * Internal storage for namespace
   * @protected
   */
  _namespace;
  /**
   * Namespace to which this identifier belongs in the local system context (and possibly in any other openEHR compliant environment) e.g.  terminology ,  demographic . These names are not yet standardised. Legal values for \`_namespace_\` are:
   *
   * * \`"local"\`
   * * \`"unknown"\`
   * * a string matching the standard regex \`[a-zA-Z][a-zA-Z0-9_.:\/&?=+-]*\`.
   *
   * Note that the first two are just special values of the regex, and will be matched by it.
   */
  get namespace() {
    return this._namespace?.value;
  }
  /**
   * Gets the String wrapper object for namespace.
   * Use this to access String methods.
   */
  get $namespace() {
    return this._namespace;
  }
  /**
   * Sets namespace from either a primitive value or String wrapper.
   */
  set namespace(val) {
    if (val === void 0 || val === null) {
      this._namespace = void 0;
    } else if (typeof val === "string") {
      this._namespace = String2.from(val);
    } else {
      this._namespace = val;
    }
  }
  /**
   * Internal storage for type
   * @protected
   */
  _type;
  /**
   * Name of the  class (concrete or abstract) of object to which this identifier type refers, e.g. \`PARTY\`, \`PERSON\`,  \`GUIDELINE\`  etc. These class names are from the relevant reference model. The type name \`ANY\` can be used to indicate that any type is accepted (e.g. if the type is unknown).
   */
  get type() {
    return this._type?.value;
  }
  /**
   * Gets the String wrapper object for type.
   * Use this to access String methods.
   */
  get $type() {
    return this._type;
  }
  /**
   * Sets type from either a primitive value or String wrapper.
   */
  set type(val) {
    if (val === void 0 || val === null) {
      this._type = void 0;
    } else if (typeof val === "string") {
      this._type = String2.from(val);
    } else {
      this._type = val;
    }
  }
  /**
   * Globally unique id of an object, regardless of where it is stored.
   */
  id;
  /**
   * Compare two OBJECT_REF instances for equality.
   * @param other - The other OBJECT_REF to compare with
   * @returns Boolean indicating if they are equal
   */
  is_equal(other) {
    if (!(other instanceof _OBJECT_REF)) {
      return new Boolean2(false);
    }
    if (this.namespace !== other.namespace) {
      return new Boolean2(false);
    }
    if (this.type !== other.type) {
      return new Boolean2(false);
    }
    if (this.id && other.id) {
      if (this.id instanceof Any && other.id instanceof Any) {
        return this.id.is_equal(other.id);
      }
    } else if (!this.id && !other.id) {
      return new Boolean2(true);
    } else {
      return new Boolean2(false);
    }
    return new Boolean2(true);
  }
};
var LOCATABLE_REF = class extends OBJECT_REF {
  /**
   * Internal storage for path
   * @protected
   */
  _path;
  /**
   * The path to an instance, as an absolute path with respect to the object found at \`VERSION._data_\`. An empty path means that the object referred to by \`_id_\` is being specified.
   */
  get path() {
    return this._path?.value;
  }
  /**
   * Gets the String wrapper object for path.
   * Use this to access String methods.
   */
  get $path() {
    return this._path;
  }
  /**
   * Sets path from either a primitive value or String wrapper.
   */
  set path(val) {
    if (val === void 0 || val === null) {
      this._path = void 0;
    } else if (typeof val === "string") {
      this._path = String2.from(val);
    } else {
      this._path = val;
    }
  }
  /**
   * Globally unique id of an object, regardless of where it is stored.
   */
  id = void 0;
  /**
   * A URI form of the reference, created by concatenating the following:
   *
   * * scheme, e.g. \`ehr:\`, derived from \`_namespace_\`
   * * \`_id.value_\`
   * * \`/\` + \`_path_\`, where \`_path_\` is non-empty
   *
   * @returns Result value
   */
  as_uri() {
    const namespace = this.namespace || "";
    const idValue = this.id?.value || "";
    const path = this.path || "";
    let uri = `${namespace}:${idValue}`;
    if (path && path.length > 0) {
      uri += `/${path}`;
    }
    return String2.from(uri);
  }
};
var OBJECT_VERSION_ID = class extends UID_BASED_ID {
  /**
   * Unique identifier for logical object of which this identifier identifies one version; normally the \`_object_id_\` will be the unique identifier of the version container containing the version referred to by this \`OBJECT_VERSION_ID\` instance.
   * @returns Result value
   */
  object_id() {
    const val = this.value || "";
    const parts = val.split("::");
    if (parts.length !== 3) {
      throw new Error("OBJECT_VERSION_ID must have 3 parts separated by '::'");
    }
    const uid = new UUID();
    uid.value = parts[0];
    return uid;
  }
  /**
   * Identifier of the system that created the Version corresponding to this Object version id.
   * @returns Result value
   */
  creating_system_id() {
    const val = this.value || "";
    const parts = val.split("::");
    if (parts.length !== 3) {
      throw new Error("OBJECT_VERSION_ID must have 3 parts separated by '::'");
    }
    const uid = new INTERNET_ID();
    uid.value = parts[1];
    return uid;
  }
  /**
   * Tree identifier of this version with respect to other versions in the same version tree, as either 1 or 3 part dot-separated numbers, e.g.  1 ,  2.1.4 .
   * @returns Result value
   */
  version_tree_id() {
    const val = this.value || "";
    const parts = val.split("::");
    if (parts.length !== 3) {
      throw new Error("OBJECT_VERSION_ID must have 3 parts separated by '::'");
    }
    const versionTreeId = new VERSION_TREE_ID();
    versionTreeId.value = parts[2];
    return versionTreeId;
  }
  /**
   * True if this version identifier represents a branch.
   * @returns Result value
   */
  is_branch() {
    return this.version_tree_id().is_branch();
  }
};
var PARTY_REF = class extends OBJECT_REF {
};
var TERMINOLOGY_ID = class extends OBJECT_ID {
  /**
   * Return the terminology id (which includes the  version  in some cases). Distinct names correspond to distinct (i.e. non-compatible) terminologies. Thus the names  \`"ICD10AM"\` and \`"ICD10"\` refer to distinct terminologies.
   * @returns Result value
   */
  name() {
    const val = this.value || "";
    const parenIndex = val.indexOf("(");
    if (parenIndex > 0) {
      return String2.from(val.substring(0, parenIndex));
    }
    return String2.from(val);
  }
  /**
   * Version of this terminology, if versioning supported, else the empty string.
   * @returns Result value
   */
  version_id() {
    const val = this.value || "";
    const parenIndex = val.indexOf("(");
    if (parenIndex > 0) {
      const closeParenIndex = val.indexOf(")");
      if (closeParenIndex > parenIndex) {
        return String2.from(val.substring(parenIndex + 1, closeParenIndex));
      }
    }
    return String2.from("");
  }
};
var VERSION_TREE_ID = class {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * String form of this identifier.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the String wrapper object for value.
   * Use this to access String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * Trunk version number; numbering starts at 1.
   * @returns Result value
   */
  trunk_version() {
    const val = this.value || "";
    const parts = val.split(".");
    return String2.from(parts[0]);
  }
  /**
   * True if this version identifier represents a branch, i.e. has \`_branch_number()_\` and \`_branch_version()_\` parts.
   * @returns Result value
   */
  is_branch() {
    const val = this.value || "";
    const parts = val.split(".");
    return new Boolean2(parts.length === 3);
  }
  /**
   * Number of branch from the trunk point; numbering starts at 1.
   * @returns Result value
   */
  branch_number() {
    const val = this.value || "";
    const parts = val.split(".");
    if (parts.length === 3) {
      return String2.from(parts[1]);
    }
    throw new Error("Not a branch version");
  }
  /**
   * Version of the branch; numbering starts at 1.
   * @returns Result value
   */
  branch_version() {
    const val = this.value || "";
    const parts = val.split(".");
    if (parts.length === 3) {
      return String2.from(parts[2]);
    }
    throw new Error("Not a branch version");
  }
};
var UID = class {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * The value of the id.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the String wrapper object for value.
   * Use this to access String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
};
var UUID = class extends UID {
};
var INTERNET_ID = class extends UID {
};
var ISO_OID = class extends UID {
};
var TEMPLATE_ID = class extends OBJECT_ID {
};
var ACCESS_GROUP_REF = class extends OBJECT_REF {
};
var BASIC_DEFINITIONS = class {
};
var OPENEHR_DEFINITIONS = class extends BASIC_DEFINITIONS {
};
var VALIDITY_KIND = class extends String2 {
};
var VERSION_STATUS = class extends String2 {
};
var Comparable = class {
};
var Iso8601_timezone = class _Iso8601_timezone extends Iso8601_type {
  static {
    TYPE_REGISTRY.set("ISO8601_TIMEZONE", _Iso8601_timezone);
  }
  /**
   * Extract the hour part of timezone, as an Integer in the range `00 - 14`.
   * @returns Result value
   */
  hour() {
    const val = this.value || "";
    if (val === "Z")
      return Integer.from(0);
    const match = val.match(/([+-])(\d{2}):?(\d{2})/);
    if (match) {
      return Integer.from(parseInt(match[2], 10));
    }
    return Integer.from(0);
  }
  /**
   * Extract the minute part of timezone, as an Integer, usually either 0 or 30.
   * @returns Result value
   */
  minute() {
    const val = this.value || "";
    if (val === "Z")
      return Integer.from(0);
    const match = val.match(/([+-])(\d{2}):?(\d{2})?/);
    if (match && match[3]) {
      return Integer.from(parseInt(match[3], 10));
    }
    return Integer.from(0);
  }
  /**
   * Direction of timezone expresssed as +1 or -1.
   * @returns Result value
   */
  sign() {
    const val = this.value || "";
    if (val === "Z")
      return Integer.from(1);
    const match = val.match(/([+-])/);
    if (match) {
      return Integer.from(match[1] === "+" ? 1 : -1);
    }
    return Integer.from(1);
  }
  /**
   * Indicates whether minute part known.
   * @returns Result value
   */
  minute_unknown() {
    const val = this.value || "";
    if (val === "Z")
      return new Boolean2(false);
    const match = val.match(/([+-])(\d{2}):?(\d{2})?/);
    return new Boolean2(!match || !match[3]);
  }
  /**
   * True if this time zone is partial, i.e. if minutes is missing.
   * @returns Result value
   */
  is_partial() {
    return this.minute_unknown();
  }
  /**
   * True if this time-zone uses : separators.
   * @returns Result value
   */
  is_extended() {
    const val = this.value || "";
    return new Boolean2(val.includes(":"));
  }
  /**
   * True if timezone is UTC, i.e. \`+0000\` or \`Z\`.
   * @returns Result value
   */
  is_gmt() {
    const val = this.value || "";
    if (val === "Z")
      return new Boolean2(true);
    const match = val.match(/([+-])(\d{2}):?(\d{2})?/);
    if (match) {
      const hours = parseInt(match[2], 10);
      const minutes = match[3] ? parseInt(match[3], 10) : 0;
      return new Boolean2(hours === 0 && minutes === 0);
    }
    return new Boolean2(false);
  }
  /**
   * Return timezone string in extended format.
   * @returns Result value
   */
  as_string() {
    const val = this.value || "";
    if (val === "Z")
      return String2.from("Z");
    const match = val.match(/([+-])(\d{2}):?(\d{2})?/);
    if (match) {
      const sign = match[1];
      const hours = match[2];
      const minutes = match[3] || "00";
      return String2.from(`${sign}${hours}:${minutes}`);
    }
    return String2.from(val);
  }
  /**
   * Compares this timezone with another for ordering.
   * Timezones are ordered by their offset from UTC in minutes.
   * @param other - The object to compare with
   * @returns true if this timezone is less than the other
   */
  less_than(other) {
    if (!(other instanceof _Iso8601_timezone)) {
      return new Boolean2(false);
    }
    const thisSign = this.sign().value || 1;
    const thisHour = this.hour().value || 0;
    const thisMinute = this.minute().value || 0;
    const thisOffset = thisSign * (thisHour * 60 + thisMinute);
    const otherSign = other.sign().value || 1;
    const otherHour = other.hour().value || 0;
    const otherMinute = other.minute().value || 0;
    const otherOffset = otherSign * (otherHour * 60 + otherMinute);
    return new Boolean2(thisOffset < otherOffset);
  }
  /**
   * Value equality: return True if this and other are equal in value.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _Iso8601_timezone)) {
      return new Boolean2(false);
    }
    const thisSign = this.sign().value || 1;
    const thisHour = this.hour().value || 0;
    const thisMinute = this.minute().value || 0;
    const thisOffset = thisSign * (thisHour * 60 + thisMinute);
    const otherSign = other.sign().value || 1;
    const otherHour = other.hour().value || 0;
    const otherMinute = other.minute().value || 0;
    const otherOffset = otherSign * (otherHour * 60 + otherMinute);
    return new Boolean2(thisOffset === otherOffset);
  }
};
var Point_interval = class _Point_interval extends Interval {
  /**
   * Lower boundary open (i.e. = -infinity).
   */
  get lower_unbounded() {
    return this._lower_unbounded?.value;
  }
  /**
   * Gets the Boolean wrapper object for lower_unbounded.
   * Use this to access Boolean methods.
   */
  get $lower_unbounded() {
    return this._lower_unbounded;
  }
  /**
   * Sets lower_unbounded from either a primitive value or Boolean wrapper.
   */
  set lower_unbounded(val) {
    if (val === void 0 || val === null) {
      this._lower_unbounded = void 0;
    } else if (typeof val === "boolean") {
      this._lower_unbounded = Boolean2.from(val);
    } else {
      this._lower_unbounded = val;
    }
  }
  /**
   * Upper boundary open (i.e. = +infinity).
   */
  get upper_unbounded() {
    return this._upper_unbounded?.value;
  }
  /**
   * Gets the Boolean wrapper object for upper_unbounded.
   * Use this to access Boolean methods.
   */
  get $upper_unbounded() {
    return this._upper_unbounded;
  }
  /**
   * Sets upper_unbounded from either a primitive value or Boolean wrapper.
   */
  set upper_unbounded(val) {
    if (val === void 0 || val === null) {
      this._upper_unbounded = void 0;
    } else if (typeof val === "boolean") {
      this._upper_unbounded = Boolean2.from(val);
    } else {
      this._upper_unbounded = val;
    }
  }
  /**
   * Lower boundary value included in range if not \`_lower_unbounded_\`.
   */
  get lower_included() {
    return this._lower_included?.value;
  }
  /**
   * Gets the Boolean wrapper object for lower_included.
   * Use this to access Boolean methods.
   */
  get $lower_included() {
    return this._lower_included;
  }
  /**
   * Sets lower_included from either a primitive value or Boolean wrapper.
   */
  set lower_included(val) {
    if (val === void 0 || val === null) {
      this._lower_included = void 0;
    } else if (typeof val === "boolean") {
      this._lower_included = Boolean2.from(val);
    } else {
      this._lower_included = val;
    }
  }
  /**
   * Upper boundary value included in range if not \`_upper_unbounded_\`.
   */
  get upper_included() {
    return this._upper_included?.value;
  }
  /**
   * Gets the Boolean wrapper object for upper_included.
   * Use this to access Boolean methods.
   */
  get $upper_included() {
    return this._upper_included;
  }
  /**
   * Sets upper_included from either a primitive value or Boolean wrapper.
   */
  set upper_included(val) {
    if (val === void 0 || val === null) {
      this._upper_included = void 0;
    } else if (typeof val === "boolean") {
      this._upper_included = Boolean2.from(val);
    } else {
      this._upper_included = val;
    }
  }
  /**
   * True if the value \`v\` equals this point value.
   * @param v - Parameter
   * @returns Result value
   */
  has(v2) {
    if (this.lower === void 0) {
      return new Boolean2(false);
    }
    return this.lower.is_equal(v2);
  }
  /**
   * A point interval never intersects with any other interval (it's a single point).
   * @param other - Parameter
   * @returns Result value
   */
  intersects(other) {
    if (this.lower === void 0) {
      return new Boolean2(false);
    }
    return other.has(this.lower);
  }
  /**
   * A point interval can only contain another interval if that interval is also the same point.
   * @param other - Parameter
   * @returns Result value
   */
  contains(other) {
    if (this.lower === void 0) {
      return new Boolean2(false);
    }
    if (other instanceof _Point_interval) {
      return this.is_equal(other);
    }
    return new Boolean2(false);
  }
};
var CODE_PHRASE = class _CODE_PHRASE {
  /**
   * Identifier of the distinct terminology from which the code_string (or its elements) was extracted.
   */
  terminology_id;
  /**
   * Internal storage for code_string
   * @protected
   */
  _code_string;
  /**
   * The key used by the terminology service to identify a concept or coordination of concepts. This string is most likely parsable inside the terminology service, but nothing can be assumed about its syntax outside that context.
   */
  get code_string() {
    return this._code_string?.value;
  }
  /**
   * Gets the String wrapper object for code_string.
   * Use this to access String methods.
   */
  get $code_string() {
    return this._code_string;
  }
  /**
   * Sets code_string from either a primitive value or String wrapper.
   */
  set code_string(val) {
    if (val === void 0 || val === null) {
      this._code_string = void 0;
    } else if (typeof val === "string") {
      this._code_string = String2.from(val);
    } else {
      this._code_string = val;
    }
  }
  /**
   * Internal storage for preferred_term
   * @protected
   */
  _preferred_term;
  /**
   * Optional attribute to carry preferred term corresponding to the code or expression in \`_code_string_\`. Typical use in integration situations which create mappings, and representing data for which both a (non-preferred) actual term and a preferred term are both required.
   */
  get preferred_term() {
    return this._preferred_term?.value;
  }
  /**
   * Gets the String wrapper object for preferred_term.
   * Use this to access String methods.
   */
  get $preferred_term() {
    return this._preferred_term;
  }
  /**
   * Sets preferred_term from either a primitive value or String wrapper.
   */
  set preferred_term(val) {
    if (val === void 0 || val === null) {
      this._preferred_term = void 0;
    } else if (typeof val === "string") {
      this._preferred_term = String2.from(val);
    } else {
      this._preferred_term = val;
    }
  }
  /**
   * Factory method to create a CODE_PHRASE.
   * @param terminologyId - The terminology identifier
   * @param codeString - The code string
   * @returns A new CODE_PHRASE instance
   */
  static from(terminologyId, codeString) {
    const codePhrase = new _CODE_PHRASE();
    const termId = new TERMINOLOGY_ID();
    termId.value = terminologyId;
    codePhrase.terminology_id = termId;
    codePhrase.code_string = codeString;
    return codePhrase;
  }
  /**
   * Compare two CODE_PHRASE objects for equality.
   * @param other - The other object to compare with
   * @returns Boolean indicating if they are equal
   */
  is_equal(other) {
    if (!(other instanceof _CODE_PHRASE)) {
      return new Boolean2(false);
    }
    if (!this.terminology_id || !other.terminology_id) {
      return new Boolean2(this.terminology_id === other.terminology_id);
    }
    if (this.terminology_id.value !== other.terminology_id.value) {
      return new Boolean2(false);
    }
    if (this.code_string !== other.code_string) {
      return new Boolean2(false);
    }
    return new Boolean2(true);
  }
};
var AUTHORED_RESOURCE = class {
  /**
   * Unique identifier of the family of archetypes having the same interface identifier (same major version).
   */
  uid;
  /**
   * Language in which this resource was initially authored. Although there is no language primacy of resources overall, the language of original authoring is required to ensure natural language translations can preserve quality. Language is relevant in both the description and ontology sections.
   */
  original_language;
  /**
   * Description and lifecycle information of the resource.
   */
  description;
  /**
   * Internal storage for is_controlled
   * @protected
   */
  _is_controlled;
  /**
   * True if this resource is under any kind of change control (even file copying), in which case revision history is created.
   */
  get is_controlled() {
    return this._is_controlled?.value;
  }
  /**
   * Gets the Boolean wrapper object for is_controlled.
   * Use this to access Boolean methods.
   */
  get $is_controlled() {
    return this._is_controlled;
  }
  /**
   * Sets is_controlled from either a primitive value or Boolean wrapper.
   */
  set is_controlled(val) {
    if (val === void 0 || val === null) {
      this._is_controlled = void 0;
    } else if (typeof val === "boolean") {
      this._is_controlled = Boolean2.from(val);
    } else {
      this._is_controlled = val;
    }
  }
  /**
   * Annotations on individual items within the resource, keyed by path. The inner table takes the form of a Hash table of String values keyed by String tags.
   */
  annotations;
  /**
   * List of details for each natural translation made of this resource, keyed by language code. For each translation listed here, there must be corresponding sections in all language-dependent parts of the resource. The \`_original_language_\` does not appear in this list.
   */
  translations;
  /**
   * Most recent revision in revision_history if is_controlled else  (uncontrolled) .
   * @returns Result value
   */
  current_revision() {
    if (!this.is_controlled) {
      return String2.from("(uncontrolled)");
    }
    return String2.from("1.0.0");
  }
  /**
   * Total list of languages available in this resource, derived from original_language and translations.
   * @returns Result value
   */
  languages_available() {
    if (this.original_language?.code_string) {
      return String2.from(this.original_language.code_string);
    }
    return String2.from("");
  }
};
var RESOURCE_DESCRIPTION = class {
  /**
   * Original author of this resource, with all relevant details, including organisation.
   */
  original_author;
  /**
   * Internal storage for original_namespace
   * @protected
   */
  _original_namespace;
  /**
   * Namespace of original author's organisation, in reverse internet form, if applicable.
   */
  get original_namespace() {
    return this._original_namespace?.value;
  }
  /**
   * Gets the String wrapper object for original_namespace.
   * Use this to access String methods.
   */
  get $original_namespace() {
    return this._original_namespace;
  }
  /**
   * Sets original_namespace from either a primitive value or String wrapper.
   */
  set original_namespace(val) {
    if (val === void 0 || val === null) {
      this._original_namespace = void 0;
    } else if (typeof val === "string") {
      this._original_namespace = String2.from(val);
    } else {
      this._original_namespace = val;
    }
  }
  /**
   * Internal storage for original_publisher
   * @protected
   */
  _original_publisher;
  /**
   * Plain text name of organisation that originally published this artefact, if any.
   */
  get original_publisher() {
    return this._original_publisher?.value;
  }
  /**
   * Gets the String wrapper object for original_publisher.
   * Use this to access String methods.
   */
  get $original_publisher() {
    return this._original_publisher;
  }
  /**
   * Sets original_publisher from either a primitive value or String wrapper.
   */
  set original_publisher(val) {
    if (val === void 0 || val === null) {
      this._original_publisher = void 0;
    } else if (typeof val === "string") {
      this._original_publisher = String2.from(val);
    } else {
      this._original_publisher = val;
    }
  }
  /**
   * Other contributors to the resource, each listed in "name <email>"  form.
   */
  other_contributors;
  /**
   * Lifecycle state of the resource, typically including states such as: initial, in_development, in_review, published, superseded, obsolete.
   */
  lifecycle_state;
  /**
   * Reference to owning resource.
   */
  parent_resource;
  /**
   * Internal storage for custodian_namespace
   * @protected
   */
  _custodian_namespace;
  /**
   * Namespace in reverse internet id form, of current custodian organisation.
   */
  get custodian_namespace() {
    return this._custodian_namespace?.value;
  }
  /**
   * Gets the String wrapper object for custodian_namespace.
   * Use this to access String methods.
   */
  get $custodian_namespace() {
    return this._custodian_namespace;
  }
  /**
   * Sets custodian_namespace from either a primitive value or String wrapper.
   */
  set custodian_namespace(val) {
    if (val === void 0 || val === null) {
      this._custodian_namespace = void 0;
    } else if (typeof val === "string") {
      this._custodian_namespace = String2.from(val);
    } else {
      this._custodian_namespace = val;
    }
  }
  /**
   * Internal storage for custodian_organisation
   * @protected
   */
  _custodian_organisation;
  /**
   * Plain text name of current custodian organisation.
   */
  get custodian_organisation() {
    return this._custodian_organisation?.value;
  }
  /**
   * Gets the String wrapper object for custodian_organisation.
   * Use this to access String methods.
   */
  get $custodian_organisation() {
    return this._custodian_organisation;
  }
  /**
   * Sets custodian_organisation from either a primitive value or String wrapper.
   */
  set custodian_organisation(val) {
    if (val === void 0 || val === null) {
      this._custodian_organisation = void 0;
    } else if (typeof val === "string") {
      this._custodian_organisation = String2.from(val);
    } else {
      this._custodian_organisation = val;
    }
  }
  /**
   * Internal storage for copyright
   * @protected
   */
  _copyright;
  /**
   * Optional copyright statement for the resource as a knowledge resource.
   */
  get copyright() {
    return this._copyright?.value;
  }
  /**
   * Gets the String wrapper object for copyright.
   * Use this to access String methods.
   */
  get $copyright() {
    return this._copyright;
  }
  /**
   * Sets copyright from either a primitive value or String wrapper.
   */
  set copyright(val) {
    if (val === void 0 || val === null) {
      this._copyright = void 0;
    } else if (typeof val === "string") {
      this._copyright = String2.from(val);
    } else {
      this._copyright = val;
    }
  }
  /**
   * Internal storage for licence
   * @protected
   */
  _licence;
  /**
   * Licence of current artefact, in format "short licence name <URL of licence>", e.g. "Apache 2.0 License <http://www.apache.org/licenses/LICENSE-2.0.html>"
   */
  get licence() {
    return this._licence?.value;
  }
  /**
   * Gets the String wrapper object for licence.
   * Use this to access String methods.
   */
  get $licence() {
    return this._licence;
  }
  /**
   * Sets licence from either a primitive value or String wrapper.
   */
  set licence(val) {
    if (val === void 0 || val === null) {
      this._licence = void 0;
    } else if (typeof val === "string") {
      this._licence = String2.from(val);
    } else {
      this._licence = val;
    }
  }
  /**
   * List of acknowledgements of other IP directly referenced in this archetype, typically terminology codes, ontology ids etc. Recommended keys are the widely known name or namespace for the IP source, as shown in the following example:
   *
   * ----
   * ip_acknowledgements = <
   *     ["loinc"] = <"This content from LOINC is copyright  1995 Regenstrief Institute, Inc. and the LOINC Committee, and available at no cost under the license at http://loinc.org/terms-of-use">
   *     ["snomedct"] = <"Content from SNOMED CT is copyright  2007 IHTSDO <ihtsdo.org>">
   * >
   * ----
   */
  ip_acknowledgements;
  /**
   * List of references of material on which this artefact is based, as a keyed list of strings. The keys should be in a standard citation format.
   */
  references;
  /**
   * Internal storage for resource_package_uri
   * @protected
   */
  _resource_package_uri;
  /**
   * URI of package to which this resource belongs.
   */
  get resource_package_uri() {
    return this._resource_package_uri?.value;
  }
  /**
   * Gets the String wrapper object for resource_package_uri.
   * Use this to access String methods.
   */
  get $resource_package_uri() {
    return this._resource_package_uri;
  }
  /**
   * Sets resource_package_uri from either a primitive value or String wrapper.
   */
  set resource_package_uri(val) {
    if (val === void 0 || val === null) {
      this._resource_package_uri = void 0;
    } else if (typeof val === "string") {
      this._resource_package_uri = String2.from(val);
    } else {
      this._resource_package_uri = val;
    }
  }
  /**
   * Details related to conversion process that generated this model from an original, if relevant, as a list of name/value pairs. Typical example with recommended tags:
   *
   * ----
   * conversion_details = <
   *     ["source_model"] = <"CEM model xyz <http://location.in.clinicalelementmodels.com>">
   *     ["tool"] = <"cem2adl v6.3.0">
   *     ["time"] = <"2014-11-03T09:05:00">
   * >
   * ----
   */
  conversion_details;
  /**
   * Additional non-language-sensitive resource meta-data, as a list of name/value pairs.
   */
  other_details;
  /**
   * Details of all parts of resource description that are natural language-dependent, keyed by language code.
   */
  details;
};
var TRANSLATION_DETAILS = class {
  /**
   * Language of the translation, coded using ISO 639-1 (2 character) language codes.
   */
  language;
  /**
   * Primary translator name and other demographic details.
   */
  author;
  /**
   * Internal storage for accreditation
   * @protected
   */
  _accreditation;
  /**
   * Accreditation of primary translator or group, usually a national translator's registration or association membership id.
   */
  get accreditation() {
    return this._accreditation?.value;
  }
  /**
   * Gets the String wrapper object for accreditation.
   * Use this to access String methods.
   */
  get $accreditation() {
    return this._accreditation;
  }
  /**
   * Sets accreditation from either a primitive value or String wrapper.
   */
  set accreditation(val) {
    if (val === void 0 || val === null) {
      this._accreditation = void 0;
    } else if (typeof val === "string") {
      this._accreditation = String2.from(val);
    } else {
      this._accreditation = val;
    }
  }
  /**
   * Any other meta-data.
   */
  other_details;
  /**
   * Internal storage for version_last_translated
   * @protected
   */
  _version_last_translated;
  /**
   * Version of this resource last time it was translated into the language represented by this \`TRANSLATION_DETAILS\` object.
   */
  get version_last_translated() {
    return this._version_last_translated?.value;
  }
  /**
   * Gets the String wrapper object for version_last_translated.
   * Use this to access String methods.
   */
  get $version_last_translated() {
    return this._version_last_translated;
  }
  /**
   * Sets version_last_translated from either a primitive value or String wrapper.
   */
  set version_last_translated(val) {
    if (val === void 0 || val === null) {
      this._version_last_translated = void 0;
    } else if (typeof val === "string") {
      this._version_last_translated = String2.from(val);
    } else {
      this._version_last_translated = val;
    }
  }
  /**
   * Additional contributors to this translation, each listed in the preferred format of the relevant organisation for the artefacts in question. A typical default is \`"name <email>"\` if nothing else is specified.
   */
  other_contributors;
};
var RESOURCE_DESCRIPTION_ITEM = class {
  /**
   * The localised language in which the items in this description item are written. Coded using ISO 639-1 (2 character) language codes.
   */
  language;
  /**
   * Internal storage for purpose
   * @protected
   */
  _purpose;
  /**
   * Purpose of the resource.
   */
  get purpose() {
    return this._purpose?.value;
  }
  /**
   * Gets the String wrapper object for purpose.
   * Use this to access String methods.
   */
  get $purpose() {
    return this._purpose;
  }
  /**
   * Sets purpose from either a primitive value or String wrapper.
   */
  set purpose(val) {
    if (val === void 0 || val === null) {
      this._purpose = void 0;
    } else if (typeof val === "string") {
      this._purpose = String2.from(val);
    } else {
      this._purpose = val;
    }
  }
  /**
   * Keywords which characterise this resource, used e.g. for indexing and searching.
   */
  keywords;
  /**
   * Internal storage for use
   * @protected
   */
  _use;
  /**
   * Description of the uses of the resource, i.e. contexts in which it could be used.
   */
  get use() {
    return this._use?.value;
  }
  /**
   * Gets the String wrapper object for use.
   * Use this to access String methods.
   */
  get $use() {
    return this._use;
  }
  /**
   * Sets use from either a primitive value or String wrapper.
   */
  set use(val) {
    if (val === void 0 || val === null) {
      this._use = void 0;
    } else if (typeof val === "string") {
      this._use = String2.from(val);
    } else {
      this._use = val;
    }
  }
  /**
   * Internal storage for misuse
   * @protected
   */
  _misuse;
  /**
   * Description of any misuses of the resource, i.e. contexts in which it should not be used.
   */
  get misuse() {
    return this._misuse?.value;
  }
  /**
   * Gets the String wrapper object for misuse.
   * Use this to access String methods.
   */
  get $misuse() {
    return this._misuse;
  }
  /**
   * Sets misuse from either a primitive value or String wrapper.
   */
  set misuse(val) {
    if (val === void 0 || val === null) {
      this._misuse = void 0;
    } else if (typeof val === "string") {
      this._misuse = String2.from(val);
    } else {
      this._misuse = val;
    }
  }
  /**
   * URIs of original clinical document(s) or description of which resource is a formalisation, in the language of this description item; keyed by meaning.
   */
  original_resource_uri;
  /**
   * Additional language-senstive resource metadata, as a list of name/value pairs.
   */
  other_details;
};
var RESOURCE_ANNOTATIONS = class {
  /**
   * Documentary annotations in a multi-level keyed structure.
   */
  documentation;
};

// ../../enhanced/openehr_rm.ts
var openehr_rm_exports = {};
__export(openehr_rm_exports, {
  ACCESS_CONTROL_SETTINGS: () => ACCESS_CONTROL_SETTINGS,
  ACTION: () => ACTION,
  ACTIVITY: () => ACTIVITY,
  ACTOR: () => ACTOR,
  ADDRESS: () => ADDRESS,
  ADDRESSED_MESSAGE: () => ADDRESSED_MESSAGE,
  ADMIN_ENTRY: () => ADMIN_ENTRY,
  AGENT: () => AGENT,
  ARCHETYPED: () => ARCHETYPED,
  ATTESTATION: () => ATTESTATION,
  AUDIT_DETAILS: () => AUDIT_DETAILS,
  AUTHORED_RESOURCE: () => AUTHORED_RESOURCE2,
  CAPABILITY: () => CAPABILITY,
  CARE_ENTRY: () => CARE_ENTRY,
  CLUSTER: () => CLUSTER,
  CODE_PHRASE: () => CODE_PHRASE2,
  CODE_SET_ACCESS: () => CODE_SET_ACCESS,
  COMPOSITION: () => COMPOSITION,
  CONTACT: () => CONTACT,
  CONTENT_ITEM: () => CONTENT_ITEM,
  CONTRIBUTION: () => CONTRIBUTION,
  DATA_STRUCTURE: () => DATA_STRUCTURE,
  DATA_VALUE: () => DATA_VALUE,
  DV_ABSOLUTE_QUANTITY: () => DV_ABSOLUTE_QUANTITY,
  DV_AMOUNT: () => DV_AMOUNT,
  DV_BOOLEAN: () => DV_BOOLEAN,
  DV_CODED_TEXT: () => DV_CODED_TEXT,
  DV_COUNT: () => DV_COUNT,
  DV_DATE: () => DV_DATE,
  DV_DATE_TIME: () => DV_DATE_TIME,
  DV_DURATION: () => DV_DURATION,
  DV_EHR_URI: () => DV_EHR_URI,
  DV_ENCAPSULATED: () => DV_ENCAPSULATED,
  DV_GENERAL_TIME_SPECIFICATION: () => DV_GENERAL_TIME_SPECIFICATION,
  DV_IDENTIFIER: () => DV_IDENTIFIER,
  DV_INTERVAL: () => DV_INTERVAL,
  DV_MULTIMEDIA: () => DV_MULTIMEDIA,
  DV_ORDERED: () => DV_ORDERED,
  DV_ORDINAL: () => DV_ORDINAL,
  DV_PARAGRAPH: () => DV_PARAGRAPH,
  DV_PARSABLE: () => DV_PARSABLE,
  DV_PERIODIC_TIME_SPECIFICATION: () => DV_PERIODIC_TIME_SPECIFICATION,
  DV_PROPORTION: () => DV_PROPORTION,
  DV_QUANTIFIED: () => DV_QUANTIFIED,
  DV_QUANTITY: () => DV_QUANTITY,
  DV_SCALE: () => DV_SCALE,
  DV_STATE: () => DV_STATE,
  DV_TEMPORAL: () => DV_TEMPORAL,
  DV_TEXT: () => DV_TEXT,
  DV_TIME: () => DV_TIME,
  DV_TIME_SPECIFICATION: () => DV_TIME_SPECIFICATION,
  DV_URI: () => DV_URI,
  EHR: () => EHR,
  EHR_ACCESS: () => EHR_ACCESS,
  EHR_STATUS: () => EHR_STATUS,
  ELEMENT: () => ELEMENT,
  ENTRY: () => ENTRY,
  EVALUATION: () => EVALUATION,
  EVENT: () => EVENT,
  EVENT_CONTEXT: () => EVENT_CONTEXT,
  EXTERNAL_ENVIRONMENT_ACCESS: () => EXTERNAL_ENVIRONMENT_ACCESS,
  EXTRACT: () => EXTRACT,
  EXTRACT_ACTION_REQUEST: () => EXTRACT_ACTION_REQUEST,
  EXTRACT_CHAPTER: () => EXTRACT_CHAPTER,
  EXTRACT_CONTENT_ITEM: () => EXTRACT_CONTENT_ITEM,
  EXTRACT_ENTITY_CHAPTER: () => EXTRACT_ENTITY_CHAPTER,
  EXTRACT_ENTITY_MANIFEST: () => EXTRACT_ENTITY_MANIFEST,
  EXTRACT_ERROR: () => EXTRACT_ERROR,
  EXTRACT_FOLDER: () => EXTRACT_FOLDER,
  EXTRACT_ITEM: () => EXTRACT_ITEM,
  EXTRACT_MANIFEST: () => EXTRACT_MANIFEST,
  EXTRACT_PARTICIPATION: () => EXTRACT_PARTICIPATION,
  EXTRACT_REQUEST: () => EXTRACT_REQUEST,
  EXTRACT_SPEC: () => EXTRACT_SPEC,
  EXTRACT_UPDATE_SPEC: () => EXTRACT_UPDATE_SPEC,
  EXTRACT_VERSION_SPEC: () => EXTRACT_VERSION_SPEC,
  FEEDER_AUDIT: () => FEEDER_AUDIT,
  FEEDER_AUDIT_DETAILS: () => FEEDER_AUDIT_DETAILS,
  FOLDER: () => FOLDER,
  GENERIC_CONTENT_ITEM: () => GENERIC_CONTENT_ITEM,
  GENERIC_ENTRY: () => GENERIC_ENTRY,
  GROUP: () => GROUP,
  HISTORY: () => HISTORY,
  IMPORTED_VERSION: () => IMPORTED_VERSION,
  INSTRUCTION: () => INSTRUCTION,
  INSTRUCTION_DETAILS: () => INSTRUCTION_DETAILS,
  INTERVAL_EVENT: () => INTERVAL_EVENT,
  ISM_TRANSITION: () => ISM_TRANSITION,
  ITEM: () => ITEM,
  ITEM_LIST: () => ITEM_LIST,
  ITEM_SINGLE: () => ITEM_SINGLE,
  ITEM_STRUCTURE: () => ITEM_STRUCTURE,
  ITEM_TABLE: () => ITEM_TABLE,
  ITEM_TAG: () => ITEM_TAG,
  ITEM_TREE: () => ITEM_TREE,
  LINK: () => LINK,
  LOCATABLE: () => LOCATABLE,
  MEASUREMENT_SERVICE: () => MEASUREMENT_SERVICE,
  MESSAGE: () => MESSAGE,
  MESSAGE_CONTENT: () => MESSAGE_CONTENT,
  OBSERVATION: () => OBSERVATION,
  OPENEHR_CODE_SET_IDENTIFIERS: () => OPENEHR_CODE_SET_IDENTIFIERS,
  OPENEHR_CONTENT_ITEM: () => OPENEHR_CONTENT_ITEM,
  OPENEHR_TERMINOLOGY_GROUP_IDENTIFIERS: () => OPENEHR_TERMINOLOGY_GROUP_IDENTIFIERS,
  ORGANISATION: () => ORGANISATION,
  ORIGINAL_VERSION: () => ORIGINAL_VERSION,
  PARTICIPATION: () => PARTICIPATION,
  PARTY: () => PARTY,
  PARTY_IDENTIFIED: () => PARTY_IDENTIFIED,
  PARTY_IDENTITY: () => PARTY_IDENTITY,
  PARTY_PROXY: () => PARTY_PROXY,
  PARTY_RELATED: () => PARTY_RELATED,
  PARTY_RELATIONSHIP: () => PARTY_RELATIONSHIP,
  PARTY_SELF: () => PARTY_SELF,
  PATHABLE: () => PATHABLE,
  PERSON: () => PERSON,
  POINT_EVENT: () => POINT_EVENT,
  PROPORTION_KIND: () => PROPORTION_KIND,
  REFERENCE_RANGE: () => REFERENCE_RANGE,
  RESOURCE_DESCRIPTION: () => RESOURCE_DESCRIPTION2,
  RESOURCE_DESCRIPTION_ITEM: () => RESOURCE_DESCRIPTION_ITEM2,
  REVISION_HISTORY: () => REVISION_HISTORY,
  REVISION_HISTORY_ITEM: () => REVISION_HISTORY_ITEM,
  ROLE: () => ROLE,
  SECTION: () => SECTION,
  SYNC_EXTRACT: () => SYNC_EXTRACT,
  SYNC_EXTRACT_REQUEST: () => SYNC_EXTRACT_REQUEST,
  SYNC_EXTRACT_SPEC: () => SYNC_EXTRACT_SPEC,
  TERMINOLOGY_ACCESS: () => TERMINOLOGY_ACCESS,
  TERMINOLOGY_SERVICE: () => TERMINOLOGY_SERVICE,
  TERM_MAPPING: () => TERM_MAPPING,
  TRANSLATION_DETAILS: () => TRANSLATION_DETAILS2,
  VERSION: () => VERSION,
  VERSIONED_COMPOSITION: () => VERSIONED_COMPOSITION,
  VERSIONED_EHR_ACCESS: () => VERSIONED_EHR_ACCESS,
  VERSIONED_EHR_STATUS: () => VERSIONED_EHR_STATUS,
  VERSIONED_FOLDER: () => VERSIONED_FOLDER,
  VERSIONED_OBJECT: () => VERSIONED_OBJECT,
  VERSIONED_PARTY: () => VERSIONED_PARTY,
  X_CONTRIBUTION: () => X_CONTRIBUTION,
  X_VERSIONED_COMPOSITION: () => X_VERSIONED_COMPOSITION,
  X_VERSIONED_EHR_ACCESS: () => X_VERSIONED_EHR_ACCESS,
  X_VERSIONED_EHR_STATUS: () => X_VERSIONED_EHR_STATUS,
  X_VERSIONED_FOLDER: () => X_VERSIONED_FOLDER,
  X_VERSIONED_OBJECT: () => X_VERSIONED_OBJECT,
  X_VERSIONED_PARTY: () => X_VERSIONED_PARTY
});
init_define_BUILD_INFO();

// ../../enhanced/terminology_service.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/deno-dom-wasm.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/build/deno-wasm/deno-wasm.js
init_define_BUILD_INFO();
var wasm;
var WASM_VECTOR_LEN = 0;
var cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}
var cachedTextDecoder = new TextDecoder("utf-8", {
  ignoreBOM: true,
  fatal: true
});
cachedTextDecoder.decode();
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function parse(html) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    var ptr0 = passStringToWasm0(
      html,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    var len0 = WASM_VECTOR_LEN;
    wasm.parse(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(r0, r1);
  }
}
function parse_frag(html, context_local_name) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    var ptr0 = passStringToWasm0(
      html,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    var len0 = WASM_VECTOR_LEN;
    var ptr1 = passStringToWasm0(
      context_local_name,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    var len1 = WASM_VECTOR_LEN;
    wasm.parse_frag(retptr, ptr0, len0, ptr1, len1);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(r0, r1);
  }
}
async function load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e2) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn(
            "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
            e2
          );
        } else {
          throw e2;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
async function init(input) {
  if (typeof input === "undefined") {
    input = new URL("deno-wasm_bg.wasm", import.meta.url);
  }
  const imports = {};
  imports.env = { now() {
  } };
  input = Uint8Array.from(
    atob(
      "AGFzbQEAAAABpoKAgAAlYAAAYAABf2AAAXxgAX8AYAF/AX9gAX8BfmACf38AYAJ/fwF/YAJ/fwF+YAN/f38AYAN/f38Bf2AEf39/fwBgBH9/f38Bf2AFf39/f38AYAV/f39/fwF/YAZ/f39/f38Bf2AHf39/f39/fwBgB39/f39/f38Bf2ALf39/f39/f39/f38Bf2APf39/f39/f39/f39/f39/AX9gE39/f39/f39/f39/f39/f39/f38Bf2AJf39/f39/fn5+AGAFf39/f34AYAZ/f39/fn8AYAR/f39+AGADf39+AGADf39+AX9gBX9/fn5/AX9gAn9+AGACf34Bf2ADf35/AGADf35/AX9gBH9+f38Bf2AFf35/fn8AYAJ/fABgBH98f38Bf2ADfn9/AX8Ci4CAgAABA2VudgNub3cAAgOLhYCAAIkFCwkYBgsDDRwECRcLCgkKCQMMCQwFBgcKDQofCQkJGwkGAwoHBwMGDQkKBwoGGQYMAwcHIwMNCg0PCwkJCh4DBwkHCSMKAwoLBAYHBAMGCQYJBgMGBgMDGgYHBgsJBgYJCgYJAwQGGhoYBwggHwYGHAcGBhAJCRwHCgkVBwcKBxYQAwMDCQoMEQcHBwQJDg4DBwMGBwcJBgcGHQoLJA0EBwcLBwQGBgMDBwcKBwYHBwQHBgEJBwcGBwYDDQcYCQsDBwYGBgMHAwcEBwMHBwcHCQkDBiIJCQkJCQkHBwkGBgYGBgYGBwMGBgYJCQkJFAYGBgYGEQMHAwYNBwMKDgsTAwMDAx0JBwcKBwcJBwQSBiEJAwsLCwsLCwcDAwYHAwkDAwMJBgMJBAcHBwMDAwcDBwcDBwcKBwcHAwoDBgcDAw0LBwcDAwMEBwYJCQkJCQcGBgQLBwcHCQYGCQsGBwcHBwcHBw0GCQYHBwcHBwcJBwYHBwcKBgMHBwcKBgcHBwYJBgMGBAYDAwYBAwcECQoHBwcDCgMKCgoKCgoHCgcDBgAHBgcGBAkOBwYHBwcHAwMHAAYEBBoHBwcHBgQGBAcECwMHBwcDBwYECQsGCQYECQMHCgkHBwcHBwYLAwMEBwMDBwYEBAMDBwYHBwQHBgQGBAQHBwcMBgQHBwoHBw0HBwcHBwcDBwMHBwcHBgMEAwQHBwQECQcDBAMfAwYDBAQGBAcHCQkJBwcKCgcEBgcHBwcHBwcHBwcEBAQEBwYGCgcHCgoKCgMHAwEHAwcHBwQEAAkEBAQEBAUHAQEBAAUCBQUFAAcBAQQODAoHBAQFAwMDAwMDAwMDAwMDAwMDAwYDAwMDAwMAAwADAwSHgICAAAFwAa8BrwEFg4CAgAABABUGiYCAgAABfwFBgIDAAAsHgoGAgAAHBm1lbW9yeQIABXBhcnNlANABCnBhcnNlX2ZyYWcAngEfX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcgCrBBFfX3diaW5kZ2VuX21hbGxvYwCzAxJfX3diaW5kZ2VuX3JlYWxsb2MA0gMPX193YmluZGdlbl9mcmVlAPYDCd+CgIAAAQBBAQuuAe4EtgPvBPkD+APwBOkD8QSTA6wB3QLXBPcC1gOvBIAErQSBBKoCqgGJAvIEtQEyjwOqBKgDmwOVBPME/wLiA64E2wOhA4YDyQS7AswB9ASHA5YDrgHpArEC1gLCAqYEggTcA5wDmAHqAvUE+wP2BJcDlAHeAvcEtwP4BLEEgwSzBPkEigGuAqUCkAP6BLAE5wPFAooCxgTPAvsE3gPyA9UDyAL8BNcD8gL9BNgE/gT/BIAFiwGyBIUEtgK3AoEFhwK4Ar8CkQPGAowCggWGAoQBiwODBYED6AOEBd0E1AOKBIgEf9kChgWYA5UB3wK1ArUE4AKVA7YE4QK0BNgDhwTGA98DiQSKA7oCkQHrApkDrwHsAuAE3wTQA/gB3AKkA4sE4QTqA4gFmgOhBOICuQO7BOAD7QKiBPwDkASRBNQCfIkF7QTABH7GAe8CvwSpBMEB4wKjAcoBCqy1kIAAiQXukAICBX8CfiMAQdAHayIEJAAgBCACOgCrBwJAQQAoAsiOUkEESQ0AQQRB2JrAAEEXEPQCRQ0AQQAoAsiOUkEESQ0AIAQgAzYCrAcgBEGwB2pBDGoiBUEBNgIAIARBxAdqIgZBATYCACAEQcyGwAA2ArgHIARBADYCsAcgBEEPNgKEByAEIARBgAdqNgLAByAEIARBrAdqNgKAByAEQZAEaiAEQbAHahBiIARBg4DEADYCyAcgBEGDgMQANgK8ByAEIAQoApQEIgc2ArQHIAQgByAEKAKYBGo2ArAHIARBoARqIARBsAdqEG8CQCAEKAKQBCIIRQ0AIAcgCEEBEJQECyAEQYAHakEMakEONgIAIAVBAjYCACAGQQI2AgAgBEEQNgKEByAEQZCbwAA2ArgHIARBADYCsAcgBCAEQasHajYCiAcgBCAEQaAEajYCgAcgBCAEQYAHajYCwAcgBEGwB2pBBEGMnMAAEIsCIAQoAqAEIgdFDQAgBCgCpAQgB0EBEJQECwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAkH/AXEOFwABAgMEBQYHCAk+Cjc2NQswDA0ODxARAAtBASECIAMtABRBfmpB/wFxIgdBAWpBACAHQQRJG0F/ag4CYmNkC0EBIQIgAy0AFCIHQX5qIgZB/wFxIgVBAWpBACAFQQRJGw4DXV5fcQtBASECIAMtABQiB0F+aiIGQf8BcSIFQQFqQQAgBUEESRsOA1hZWnULQQEhAiADLQAUIgVBfmoiBkH/AXEiB0EBakEAIAdBBEkbDgNWVFV5CyADLQAUIgJBfmpB/wFxIgdBAWpBACAHQQRJGw4DUlBRfQtBASECIAMtABQiBUF+aiIGQf8BcSIHQQFqQQAgB0EESRsOA05MTYABC0EBIQIgAy0AFCIFQX5qQf8BcSIHQQFqQQAgB0EESRsOBUdERsQBRUcLQQAhAiADLQAUIgVBfmpB/wFxIgdBAWpBACAHQQRJG0F+ag4DPkA/QAtBASECIAMtABQiBUF+akH/AXEiB0EBakEAIAdBBEkbDgU8ODk6OzwLQQAhAiADLQAUQX5qQf8BcSIHQQFqQQAgB0EESRtBfmoOAjXiATYLQQEhByADLQAUIgVBfmpB/wFxIgJBAWpBACACQQRJGw4FMi0u0QEv0QELQQEhAiADLQAUIgVBfmpB/wFxIgdBAWpBACAHQQRJGw4FKCUmvwEnKAsgAy0AFCIHQX5qQf8BcSICQQFqQQAgAkEESRsOBSEeHyIgIgtBASEHIAMtABQiBUF+akH/AXEiAkEBakEAIAJBBEkbDgUcFxj9ARn9AQtBASECIAMtABQiBUF+akH/AXEiB0EBakEAIAdBBEkbDgUVEBH/ARL/AQtBASEHIAMtABQiBUF+akH/AXEiAkEBakEAIAJBBEkbDgUOCQqGAguGAgtBASEHIAMtABQiBUF+akH/AXEiAkEBakEAIAJBBEkbDgUBAgOIAgSIAgtBASEHAkACQAJAAkACQCADLQAUIgVBfmpB/wFxIgJBAWpBACACQQRJGw4FAFkBjQICjQILIAVB/wFxRQ0DDIwCCyADLQAMDgIBQIsCCyAAQQA6AAAM3wELIABBAjoAACAAIAMpAgA3AgQgAEEMaiADQQhqKAIANgIAQQAhAgyDAgsCQCADKQMAIglCgoCAgNDLAFENACAJQoKAgICg5gBSDYkCIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGogA0EIaikDADcDACAEIAMpAwA3A7AHIAAgAUEGIARBsAdqEAEMigILIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGogA0EIaikDADcDACAEIAMpAwA3A7AHIAAgAUEDIARBsAdqEAEMiQILIAVB/wFxRQ0FDIYCCyAEQfAGakEIaiADQQhqKAIANgIAIAQgAykCADcD8AYgACABIARB8AZqEKYCDNsBCyADLQAMDgIBAoQCCyAAQQA6AAAM2QELIABBAjoAACAAIAMpAgA3AgQgAEEMaiADQQhqKAIANgIAQQAhAgz9AQsgBEGwB2pBEGogA0EQaikDADcDACAEQbAHakEIaiADQQhqKQMANwMAIAQgAykDADcDsAcgACABQQYgBEGwB2oQAQyDAgsgAykDAEKCgICAoOYAUg2AAiAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBBiAEQbAHahABDIICCyAEQeAGakEIaiADQQhqKAIANgIAIAQgAykCADcD4AYgACABIARB4AZqEJ8CDNUBCyADLQAMDgIBAvsBCyAAQQA6AAAM0wELIABBAjoAACAAIAMpAgA3AgQgAEEMaiADQQhqKAIANgIAQQAhAgz3AQsgBEHQBmpBCGogA0EIaigCADYCACAEIAMpAgA3A9AGIAAgASAEQdAGahCAA0EAIQIM9gELIAMpAwAhCSAFQf8BcUUN9gEgCUKCgICAoOYAUg33ASAAQQA6AAAgAUEWOgBjDNABCyAEQcAGakEIaiADQQhqKAIANgIAIAQgAykCADcDwAYgACABIARBwAZqEJ8CQQEhBwz0AQsgAy0ADA4CAQLtAQsCQCABQThqKAIAQQFGDQAgBEGwB2ogASADEHUgBEGwB2oQ9QELIABBADoAAEEBIQcMzQELIABBAjoAACAAIAMpAgA3AgQgAEEMaiADQQhqKAIANgIADPABCyAEQbAGakEIaiADQQhqKAIANgIAIAQgAykCADcDsAYgACABIARBsAZqEIADDO8BCyADKQMAIQkgBUH/AXFFDegBIAlCgoCAgNDSAFIN6QECQAJAIAFBOGooAgBBAUcNACAEQbAHaiABIAMQdSAEQbAHahD1AQwBCyAEIAEQpQM2ArAHIARBsAdqEPsBIAFBEGooAgANACABQTRqKAIAIAFBOGooAgBCgoCAgNDSABC1Aw0AIAFBFDoAYwsgAEEAOgAAQQEhBwzKAQsgBEGgBmpBCGogA0EIaigCADYCACAEIAMpAgA3A6AGIAAgASAEQaAGahCFAgzJAQsgAy0ADA4CAQLkAQsgAEEAOgAADMcBCyAAQQI6AAAgACADKQIANwIEIABBDGogA0EIaigCADYCAEEAIQIM6wELIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGogA0EIaikDADcDACAEIAMpAwA3A7AHIAAgAUEGIARBsAdqEAEM8QELIAMpAwAhCSAFQf8BcUUN3wEgCUKCgICAoOYAUg3gAQJAAkAgAUEQaigCAA0AIAFBFToAYwwBCyAEQbAHaiABIAMQdSAEQbAHahD1AQsgAEEAOgAADMQBCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBBiAEQbAHahABDO8BCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBBiAEQbAHahABDO4BCwJAIAFBNGooAgAgAUE4aigCABDVAkUNACAEQbAHaiABIAMQdSAEQbAHahD1ASABQoKAgIDgBxCaARogARCSAQJAIAFBHGooAgAiAkUNACABIAJBf2o2AhwLIAEgARBJQf8BcToAYyABEEkhAiAAQQM6AAAgAEEYaiADQRBqKQMANwMAIABBEGogA0EIaikDADcDACAAIAMpAwA3AwggACACQf8BcToAAQzuAQsgAEEAOgAAQQEhBwzBAQsgAykDACEJIAdB/wFxRQ3VASAJQoKAgIDgB1IN1AEM1gELIAdB/wFxDdMBDNgBCyADLQAUIgJBAk8N0QEgAykDACEJIAJFDdABAkACQCAJQoGAgICA0gBVDQACQCAJQoGAgICAN1UNACAJQoKAgIDQBVENAiAJQoKAgIDwMVIN1AEMAgsgCUKCgICAgDdRDQEgCUKCgICAkM0AUg3TAQwBCwJAIAlCgYCAgNDyAFUNACAJQoKAgICA0gBRDQEgCUKCgICA0NsAUg3TAQwBCyAJQoKAgIDQ8gBRDQAgCUKCgICAwPUAUg3SAQsgBEGAB2pBEGogA0EQaikDADcDACAEQYAHakEIaiADQQhqKQMANwMAIAQgAykDADcDgAcgBEGwB2ogASAEQYAHahB2IARBsAdqEPUBIAQpA4AHIglCA4NQDTYMzgELIARBwAVqQQhqIANBCGooAgA2AgAgBCADKQIANwPABSAAIAEgBEHABWoQnwJBASEHDOIBCyAEQbAFakEIaiADQQhqKAIANgIAIAQgAykCADcDsAUgACABIARBsAVqEIADQQEhB0EAIQIM4QELIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGog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IAAgAykCADcCBCAAQQxqIANBCGooAgA2AgAMwAELIARBgAFqQQhqIANBCGooAgA2AgAgBCADKQIANwOAASAAIAEgBEGAAWoQgAMMvwELIAMpAwAhCSAFQf8BcUUNMCAJQoKAgIDgB1INMiAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBAyAEQbAHahABDMYBCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBAyAEQbAHahABDMUBCwJAAkAgAy0ADA4CAAEtCyAAQQI6AAAgACADKQIANwIEIABBDGogA0EIaigCADYCAAy9AQsgBEGwB2pBEGogA0EQaikDADcDACAEQbAHakEIaiADQQhqKQMANwMAIAQgAykDADcDsAcgACABQQMgBEGwB2oQAQzEAQsgAykDACEJIAJB/wFxRQ0pIAlCgoCAgLDFAFINKiAEIAEQpQM2ArAHIARBsAdqEPsBIABBADoAACABQQM6AGMMHwsgBEHAAGpBCGogA0EIaigCADYCACAEIAMpAgA3A0AgACABIARBwABqEJ8CQQEhBwy7AQsCQAJAIAMtAAwOAgABJQsgAEECOgAAIAAgAykCADcCBCAAQQxqIANBCGooAgA2AgAMugELIARBMGpBCGogA0EIaigCADYCACAEIAMpAgA3AzAgACABIARBMGoQgAMMuQELIAMpAwAhCSAFQf8BcUUNIQJAIAlCgoCAgOAHUQ0AIAlCgoCAgPAGUg0kIAQgARClAzYCsAcgBEGwB2oQ+wEgAEEAOgAAIAFBBToAY0EBIQcMugELIARBgAdqQRBqIANBEGopAwA3AwAgBEGAB2pBCGogA0EIaikDADcDACAEIAMpAwA3A4AHAkACQCABQTRqKAIAIAFBOGooAgAQ1QJFDQAgARCaAiABQoKAgIDgBxB3IAEQkgECQCABQRxqKAIAIgdFDQAgASAHQX9qNgIcCyABIAEQSUH/AXE6AGMMAQsgBEGwB2ogASAEQYAHahB2IARBsAdqEPUBC0EAIQcgAEEAOgAAIARBgAdqEOYBDLkBCyAHQf8BcUUNAgwcCyAEQSBqQQhqIANBCGooAgA2AgAgBCADKQIANwMgIAAgASAEQSBqEJ8CQQEhBwy3AQsCQAJAIAMtAAwOAgABHAsgAEECOgAAIAAgAykCADcCBCAAQQxqIANBCGooAgA2AgAMtgELIABBADoAAAwZCwJAIAMpAwAiCUKCgICA8AZRDQACQCAJQoKAgICg5gBRDQAgA0EVaiEFIANBCGohAgwcCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBBiAEQbAHahABDL0BCyAEQbAHakEIaiADQRBqKAIANgIAIAQgAykDCDcDsAdBACEHIAFBAEKCgICA8ABCgoCAgPAGIARBsAdqEB8hBQJAIAEoAghFDQAgAUEIahD7AQsgAUEDOgBjIAEgBTYCCCAAQQA6AAAMtQELIAdB/wFxRQ0CDBMLIARBEGpBCGogA0EIaigCADYCACAEIAMpAgA3AxAgACABIARBEGoQpgJBASEHDLMBCwJAAkAgAy0ADA4CAAETCyAAQQI6AAAgACADKQIANwIEIABBDGogA0EIaigCADYCAAyyAQsgAEEAOgAADBULAkAgAykDACIJQoKAgICg5gBRDQAgA0EVaiEFIANBCGohAgwSCyAEQbAHakEQaiADQRBqKQMAIgk3AwAgBEGwB2pBCGogA0EIaikDACIKNwMAIAQgAykDADcDsAcgBEGAB2pBCGogCT4CACAEIAo3A4AHIAEgBEGAB2oQjwIgAEEAOgAAIAFBAjoAYyAEQbAHahDEAkEAIQcMsQELIARBCGogA0EIaigCADYCACAEIAMpAgA3AwAgACABIAQQpgJBASEHDLABCwJAAkAgAy0ADA4CAAECCyAAQQI6AAAgACADKQIANwIEIABBDGogA0EIaigCADYCAAyvAQsgAEEAOgAADBILIARBgAdqQRBqIgIgA0EQaikDADcDACAEQYAHakEIaiIHIANBCGopAwA3AwAgBCADKQMANwOAByABQd8Aai0AAA0MIARBsAdqIAEgBEGAB2oQdSAEQbAHahD1ASABQdgAakEAOgAAIAFBADoAZAwMCyAEQZgHakEIaiADQQhqKAIANgIAIAQgAykCADcDmAcgACABIARBmAdqEKYCDIgBCyAJpyICIAIoAgxBAWo2AgwgBCkDgAchCQyXAQsgBSAHQeSpwAAQywIACyAEIAEQpQM2ArAH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DHoLIARBuAdqIANBEGooAgA2AgAgBCADKQMINwOwByABEIACQQEhAiAEIAFBAUKCgICA8ABCgoCAgIDnACAEQbAHahAfNgKAByAEQYAHahD7ASAAQQE6AAAgAUEAOgBlQQAhBwx5CyAEQZgCakEQaiADQRBqKQMANwMAIARBmAJqQQhqIANBCGopAwA3AwAgBCADKQMANwOYAiABEIACIAEQMSABQQA6AGUgACABIARBmAJqQQMQ0wJBACEHDHgLIAFBADoAZSAEQbACakEQaiADQRBqKQMANwMAIARBsAJqQQhqIANBCGopAwA3AwAgBCADKQMANwOwAiAAIAEgBEGwAmpBAxDTAkEAIQcMdwsgBEHIAmpBEGogA0EQaikDADcDACAEQcgCakEIaiADQQhqKQMANwMAIAQgAykDADcDyAIgACABIARByAJqQQMQ0wJBACEHDHYLIARB4AJqQRBqIANBEGopAwA3AwAgBEHgAmpBCGogA0EIaikDADcDACAEIAMpAwA3A+ACIAAgASAEQeACakKCgICA4AAQvQFBACEHDHULIARB+AJqQRBqIANBEGopAwA3AwAgBEH4AmpBCGogA0EIaikDADcDACAEIAMpAwA3A/gCIAAgASAEQfgCakKCgICAIBC9AUEAIQcMdAsgAUKCgICAoAQQcAwkCyABEJsCDCELIARBgAdqQQhqIgcgA0EQaigCADYCACAEIAMpAwg3A4AHIAFBNGooAgAgAUE4aigCAEKCgICAwO4AELUDRQ0aIAQgARClAzYCsAcgBEGwB2oQ+wEMGgsgBEG4B2ogA0EQaigCADYCACAEIAMpAwg3A7AHQQEhAiAEIAFBAUKCgICA8AAgCSAEQbAHahAfNgKAByAEQYAHahD7AQxuCyADKAIIIQUgAygCDCIHIAMoAhAiAhBCQQFzIQYMIgsgBEHwAWpBCGoiByADQRBqKAIANgIAIAQgAykDCDcD8AEgAS0AZEUNFiABEIACDBYLIARBuAdqIANBEGooAgA2AgAgBCADKQMINwOwByABEDFBACEHIAQgAUEAQoKAgIDwACAJIARBsAdqEB82AoAHIARBgAdqEPsBQQEhAiAEQQE2ArAHIAFBPGogBEGwB2oQ0QIMIgsgBEHYAWpBEGogA0EQaikDADcDACAEQdgBakEIaiADQQhqKQMANwMAIAQgAykDADcD2AEgARAxIAFBNGooAgAgAUE4aigCAEKCgICA0AcQWEUNEyAEQbAHakEIakENNgIAIARBvK3AADYCtAcgBEEANgKwByABQcgAaiAEQbAHahDwAiABQoKAgIDQBxAIIAEQMQwTCyAEQbAHakEIakEONgIAIARBya3AADYCtAcgBEEANgKwByABQcgAaiAEQbAHahDwAiABEJsCIAFCgoCAgIA2EJoBGgwfC0EBIQYLIAFBADoAZSAEQbgHaiADQRBqKQMANwMAIAQgAykDCDcDsAcgBEIANwOQBCABQThqKAIAIQcgAUE0aigCACEFIAYNCyAHQQJ0IQcgBUF8aiEIA0AgB0UNECAIIAdqKAIAIgVBGGotAABBBEcNCCAFQShqIgYgBUEwaiIFEMQDDQ0gB0F8aiEHIAYgBRCjA0UNAAwQCwsgBEGwB2pBEGoiByADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwBwJAAkAgASgCDEUNACABQTRqKAIAIAFBOGooAgAQ1QJFDQELIAEQgAIgBCkDsAchCSAEQYAHakEIaiAHKAIANgIAIAQgBCkDuAc3A4AHIAQgAUEAQoKAgIDwACAJIARBgAdqEB8iBzYCkAQgAUE0aigCACABQThqKAIAENUCDQgCQCABQQxqIgEoAgBFDQAgARD7AQsgASAHNgIADAoLIARBiAdqQQw2AgAgBEHXrcAANgKEByAEQQA2AoAHIAFByABqIARBgAdqEPACIABBADoAACAEQbAHahDmAUEAIQcMaAsgBEGAB2pBEGogA0EQaikDADcDACAEQYAHakEIaiADQQhqKQMANwMAIAQgAykDADcDgAcgBEGwB2ogASAEQYAHahB2IARBsAdqEPUBAkACQAJAIAEtAGVFDQACQCABQThqKAIAQQJJDQAgAUE0aigCACIHKAIEQoKAgIDw9wAQhAINAwsgAEEAOgAADAELIABBADoAAAsgBEGAB2oQ5gEMbwtBASECIAcoAgQiByAHKAIAQQFqIgU2AgAgBUUNBCAEIAc2AqAEIARBoARqELoBIAFBMGpBARCIAyAEKQOAByEJIARBuAdqIARBkAdqKAIANgIAIAQgBCkDiAc3A7AHIAQgAUEAQoKAgIDwACAJIARBsAdqEB82ApAEIARBkARq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AgALIAlCgoCAgNDLAFENAiAJQoKAgICg5gBRDQELIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGogA0EIaikDADcDACAEIAMpAwA3A7AHIAAgASAEQbAHahB1IARBsAdqEFYMBAsgBEGwB2pBEGogA0EQaikDADcDACAEQbAHakEIaiADQQhqKQMANwMAIAQgAykDADcDsAcgACABQQYgBEGwB2oQAQwDCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBAyAEQbAHahABDAILIARBgAdqQRBqIgIgA0EQaikDADcDACAEQYAHakEIaiIHIANBCGopAwA3AwAgBCADKQMANwOAByAEQbAHaiABIARBgAdqEHUgBEGwB2oQ9QEgAEEYaiACKQMANwMAIABBEGogBykDADcDACAAIAQpA4AHNwMIIABBgww7AQAMAQsgBEGwB2pBEGogA0EQaikDADcDACAEQbAHakEIaiADQQhqKQMANwMAIAQgAykDADcDsAcgACABIARBsAdqEHUgBEGwB2oQVgsgBEHQB2okAAu6kwECDX8BfiMAQcACayIDJAACQAJAAkACQAJAIAEoAoABIgRFDQAgAUEANgKAAUEBIQUCQAJAAkAgBCABIAIQDUH/AXEOAwIBAAILIANB2AFqIARBxAAQxAQaIANBsAJqIANB2AFqEPEBIAEgAykDsAIgAy0AuAIQPiAEQcQAQQQQlARBACEFDAYLQQAhBQsCQCABKAKAASICRQ0AAkAgAigCAEUNAAJAIAIoAgQiBkEQSQ0AIAZBfnEhBwJAAkAgBkEBcQ0AIAJBDGooAgAiBkEIaiICIAZPDQFBACgCoLZRQQAoAqS2UUGossAAEO4CAAsgByAHKAEAIgJBf2o2AQAgAkEBRw0BIAcoAgQiBkEIaiICIAZJDQULIAcgAkF/akF4cUEIakEEEJQECyABKAKAASECCyACQcQAQQQQlAQLIAEgBDYCgAEMAwtBACgCyI5SQQNNDQEgA0HkAWpBATYCACADQewBakEBNgIAIANB9LvAADYC4AEgA0EANgLYASADQRg2ArQCIAMgAUGkAmo2ArACIAMgA0GwAmo2AugBIANB2AFqQQRB/LvAABCLAgwBC0EAKAKgtlFBACgCpLZRQaiywAAQ7gIACyABQaQCaiEGAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAKQCDisxACsqKSgBJwIlJCMDIiEgHx4dHBsaGRgXFhUUExIREA8OBAUGDQwKCQgHMQsgA0HIAWogASACQoHIABBpIAMoAsgBIgRBAkYNKyABQewBaiEIIANB2AFqQQRyIQcDQCADKALMASEFAkACQAJAAkACQCAEDQAgBQ0DIAEtAOYBDQFBACEFQcC2wAAhBEENIQkMAgsgAyADKQPQATcD4AEgAyAFNgLcASADQQM2AtgBIAEgA0HYAWoQ5wEMAwsgA0ECNgLkASADQbC2wAA2AuABIANBAjYC7AEgA0EANgLYASADQRg2ArwCIAMgBjYCuAIgA0EXNgK0AiADIAg2ArACIAMgA0GwAmo2AugBIANBuAFqIANB2AFqEGIgAygCuAEhBCADKAK8ASEJIAMoAsABIQpBASEFCyADIAo2AugBIAMgCTYC5AEgAyAENgLgASADIAU2AtwBIANBBjYC2AEgASADQdgBahDnASADQgA3ArQCIANBDzYCsAIgA0Hv//YFNgK4ASADQbACaiADQbgBakEDEBwgB0EIaiADQbACakEIaigCADYCACAHIAMpA7ACNwIAIANBAzYC2AEgASADQdgBahDnAQwBCyABIAUQpQELIANByAFqIAEgAkKByAAQaSADKALIASIEQQJHDQAMLAsLAkACQCABQaUCai0AACIFQQJJDQACQAJAAkAgASACELADIgJBX2oODwIEBAQEBAQEBAQEBAQEAQALIAJBgIDEAEYNKAwDCyABELICIAEgBToApQIgAUEHOgCkAkEAIQUMNQsgBUEERw0BIAFBPBClASABQSEQpQEgAUEJOwGkAkEAIQUMNAsgASACELADIQICQCAFRQ0AIAJBgIDEAEYNJgJAIAJBL0cNACABELICIAFBLxClASABQQ06AKQCQQAhBQw1CyABQYUCOwGkAiABQQE6AKcCQQAhBQw0CwJAAkACQCACQS9GDQAgAkGAgMQARg0oIAIQzgMiBUGAgMQARw0BIAFBPBClASABQQE6AKcC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aiICEGQgAUGgAmogA0GIAmooAgA2AgAgAUGYAmogA0GAAmopAwA3AgAgAUGQAmogA0HYAWpBIGopAwA3AgAgAUGIAmogA0HwAWopAwA3AgAgAUGAAmogA0HoAWopAwA3AgAgAUH4AWogA0HgAWopAwA3AgAgASADKQPYATcC8AEgAiAGQSBzIAYgBkG/f2pBGkkbEFkgAUEfOgCkAkEAIQUMIwsgARDSASADQdgBahDmAyABQfABaiICEGQgAUGgAmogA0GIAmooAgA2AgAgAUGYAmogA0GAAmopAwA3AgAgAUGQAmogA0H4AWopAwA3AgAgAUGIAmogA0HwAWopAwA3AgAgAUGAAmogA0HoAWopAwA3AgAgAUH4AWogA0HgAWopAwA3AgAgASADKQPYATcC8AEgAkH9/wMQWSABQR86AKQCQQAhBQwjCyABENIBIANB2AFqEOYDIAFB8AFqEGQgAUGgAmoiAiADQYgCaigCADYCACABQZgCaiADQYACaikDADcCACABQZACaiADQfgBaikDADcCACABQYgCaiADQfABaikDADcCACABQYACaiADQegBaikDADcCACABQfgBaiADQeABaikDADcCACABIAMpA9gBNwLwASACQQE6AAAgARDLASABQQA6AKQCQQAhBQwiCwJAIAEgAhCwAyIFQXdqIgJBF0sNAEEBIAJ0QYuAgARxRQ0AIAZBHjoAAEEAIQUMIgsgBUGAgMQARg0ZIAEQ0gEgAUEeOgCkAiABQQE6AKcCQQAhBQwhCwJAAkACQAJAAkAgASACELADIgJBU2oOEgIBAQEBAQEBAQEBAQEBAQEBAwALIAJFDQMgAkGAgMQARg0cCyABQagBaiIEQaS8wABBAxAcQQAhBSADQQA2AtgBIANBsAFqIAIgA0HYAWoQ1QEgBCADKAKwASADKAK0ARAcIAFBGToApAIMIgsgAUGoAWpBpLzAAEEDEBwgAUEaOgCkAkEAIQUMIgsgASkCqAEhECABQQ82AqgBIANB5AFqIAFBsAFqKAIANgIAIAFBrAFqQgA3AgAgA0ECNgLYASADIBA3AtwBIAEgA0HYAWoQ5wEgAUEAOgCkAkEAIQUMIQsgARDSASABQagBakGnvMAAQQYQHCABQRk6AKQCQQAhBQwgCyABQagBaiEKIAFB7AFqIQgDQAJAAkAgAS0ApwINACACEKQBIgVBgIDEAEYNGiABIAUgAhB5IQcMAQsgAUEAOgCnAiABKALsASEHCwJAIAdBLUYNAAJAAkACQAJAIAdBPUoNACAHRQ0DIAdBIUcNASABENIBIAFBHDoApAJBACEFDCULIAdBPkYNAUEBIQUgB0GAgMQARg0kCyABENIBIApBrbzAAEECEBxBACEFIANBADYC2AEgA0GoAWogByADQdgBahDVASAKIAMoAqgBIAMoAqwBEBwgAUEZOgCkAgwiCyADQeQBaiAKQQhqKAIANgIAIAopAgAhECABQawBakIANwIAIAFBDzYCqAEgA0ECNgLYASADIBA3AtwBIAEgA0HYAWoQ5wEgAUEAOgCkAkEAIQUMIgsgARDSASAKQa+8wABBBRAcIAFBGToApAJBACEFDCELAkACQCABLQDmAQ0AQQAhBUHAtsAAIQRBDSEHDAELIANBAjYC5AEgA0GwtsAANgLgASADQQI2AuwBIANBADYC2AEgA0EYNgK8AiADIAY2ArgCIANBFzYCtAIgAyAINgKwAiADIANBsAJqNgLoASADQcgBaiADQdgBahBiIAMoAsgBIQQgAygCzAEhByADKALQASEJQQEhBQsgAyAJNgLoASADIAc2AuQBIAMgBDYC4AEgAyAFNgLcASADQQY2AtgBIAEgA0HYAWoQ5wEgA0EtNgLYASAKIANB2AFqQQEQHAwACwsCQCABIAIQsAMiAkUNAAJAIAJBLUYNACACQYCAxABGDRggA0EtNgLYASABQagBaiIFIANB2AFqQQEQHCADQQA2AtgBIANBoAFqIAIgA0HYAWoQ1QEgBSADKAKgASADKAKkARAcIAFBGToApAJBACEFDCALIAZBGzoAAEEAIQUMHwsgARDSASABQagBakG0vMAAQQQQHCABQRk6AKQCQQAhBQweCyABQagBaiEEIAFB7AFqIQgDQAJAAkAgAS0ApwINACACEKQBIgVBgIDEAEYNGCABIAUgAhB5IQUMAQsgAUEAOgCnAiABKALsASEFCwJAIAVFDQACQCAFQS1GDQAgBUGAgMQARg0YIANBADYC2AECQAJAIAVBgAFJDQACQCAFQYAQSQ0AAkAgBUGAgARJDQAgAyAFQT9xQYABcjoA2wEgAyAFQRJ2QfABcjoA2AEgAyAFQQZ2QT9xQYABcjoA2gEgAyAFQQx2QT9xQYABcjoA2QFBBCEFDAMLIAMgBUE/cUGAAXI6ANoBIAMgBUEMdkHgAXI6ANgBIAMgBUEGdkE/cUGAAXI6ANkBQQMhBQwCCyADIAVBP3FBgAFyOgDZASADIAVBBnZBwAFyOgDYAUECIQUMAQsgAyAFOgDYAUEBIQULIAQgA0HYAWogBRAcDAILIAZBGjoAAEEAIQUMHwsCQAJAIAEtAOYBDQBBACEFQcC2wAAhB0ENIQkMAQsgA0ECNgLkASADQbC2wAA2AuABIANBAjYC7AEgA0EANgLYASADQRg2ArwCIAMgBjYCuAIgA0EXNgK0AiADIAg2ArACIAMgA0GwAmo2AugBIANByAFqIANB2AFqEGIgAygCyAEhByADKALMASEJIAMoAtABIQpBASEFCyADIAo2AugBIAMgCTYC5AEgAyAHNgLgASADIAU2AtwBIANBBjYC2AEgASADQdgBahDnASADQe//9gU2AtgBIAQgA0HYAWpBAxAcDAALCwJAAkACQAJAAkAgASACELADIgJBU2oOEgIBAQEBAQEBAQEBAQEBAQEBBAALIAJFDQIgAkGAgMQARg0YCyADQS02AtgBIAFBqAFqIgQgA0HYAWpBARAcQQAhBSADQQA2AtgBIANBmAFqIAIgA0HYAWoQ1QEgBCADKAKYASADKAKcARAcIAFBGToApAIMHgsgBkEbOgAAQQAhBQweCyABENIBIAFBqAFqQbS8wABBBBAcIAFBGToApAJBACEFDB0LIAEQ0gEgA0HkAWogAUGwAWooAgA2AgAgASkCqAEhECABQawBakIANwIAIAFBDzYCqAEgA0ECNgLYASADIBA3AtwBIAEgA0HYAWoQ5wEgAUEAOgCkAkEAIQUMHAsCQAJAAkACQAJAIAEgAhCwAyICQVNqDhICAQEBAQEBAQEBAQEBAQEBAQQACyACRQ0CIAJBgIDEAEYNFwtBACEFIANBADYC2AEgA0GQAWogAiADQdgBahDVASABQagBaiADKAKQASADKAKUARAcIAFBGToApAIMHQsgBkEYOgAAQQAhBQwdCyABENIBIANB7//2BTYC2AEgAUGoAWogA0HYAWpBAxAcIAFBGToApAJBACEFDBwLIAEQ0gEgA0HkAWogAUGwAWooAgA2AgAgASkCqAEhECABQawBakIANwIAIAFBDzYCqAEgA0ECNgLYASADIBA3AtwBIAEgA0HYAWoQ5wEgAUEAOgCkAkEAIQUMGwtBASEFAkACQAJAAkAgASACQa28wABBAkEdEI8BQf8BcQ4DAAEeAQsgASACQbi8wABBB0EcEI8BQf8BcQ4DAgEdAQsgAUGoAWoQuQIgAUEXOgCkAkEAIQUMHAsgBkEdOgAAQQAhBQwbCwJAIAFBGGoQxwJFDQACQCABIAJBv7zAAEEHQR0QjwFB/wFxDgMBABwACyABELICIAFBKDoApAJBACEFDBsLIAEQ0gEgAUEVOgCkAkEAIQUMGQsgAUGoAWohBANAAkACQCABLQCnAg0AIAIQpAEiBUGAgMQARg0UIAEgBSACEHkhBQwBCyABQQA6AKcCIAEoAuwBIQULAkAgBUUNAAJAIAVBPkYNACAFQYCAxABGDRQgA0EANgLYAQJAAkAgBUGAAUkNAAJAIAVBgBBJDQACQCAFQYCABEkNACADIAVBP3FBgAFyOgDbASADIAVBEnZB8AFyOgDYASADIAVBBnZBP3FBgAFyOgDaASADIAVBDHZBP3FBgAFyOgDZAUEEIQUMAwsgAyAFQT9xQYABcjoA2gEgAyAFQQx2QeABcjoA2AEgAyAFQQZ2QT9xQYABcjoA2QFBAyEFDAILIAMgBUE/cUGAAXI6ANkBIAMgBUEGdkHAAXI6ANgBQQIhBQwBCyADIAU6ANgBQQEhBQsgBCADQdgBaiAFEBwMAgsgA0HkAWogBEEIaigCADYCACAEKQIAIRAgAUGsAWpCADcCACABQQ82AqgBIANBAjYC2AEgAyAQNwLcASABIANB2AFqEOcBIAFBADoApAJBACEFDBsLIANB7//2BTYC2AEgBCADQdgBakEDEBwMAAsLAkAgASACELADIgJBPkYNACACQYCAxABGDREgARDSASABQQ46AKQCIAFBAToApwJBACEFDBkLIAFBADoApAIgAUEBOgCrAiADQYgBaiABEC8gAygCjAEhBCADKAKIASEFDBgLAkACQAJAAkACQCABIAIQsAMiAkF3ag42AgIBAgEBAQEBAQEBAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEEAAsgAkGAgMQARg0TCyABENIBIAFBDjoApAIgAUEBOgCnAkEAIQUMGQsgBkEOOgAAQQAhBQwZCyAGQRQ6AABBACEFDBgLIAFBADoApAIgA0GAAWogARAvIAMoAoQBIQQgAygCgAEhBQwXCwJAAkACQCABQaUCai0AAA4DAQIAAQsgA0HYAWogASACQoHIgIDACBBpQQEhBSADKALYAUECRg0XIAFBnAFqIQ4gA0GwAmpBCGohCgJAA0AgCiADQdgBakEIaikDADcDACADIAMpA9gBIhA3A7ACAkACQAJAAkACQAJAAkACQAJAAkAgEKcNACADKAK0AiIFRQ0DIAVBXmoOBQIBAQEEAQtBACABKAKcASIEIAEoAqABIgsgBEEJSRsgBEEPRhsiB0EAIAMoArQCIgUgAygCuAIiCCAFQQlJIg0bIAVBD0YiCRtqIgwgB0kNBAJAAkAgBEEQSQ0AIAVBD0sNAQsgCQ0GIA0NBiAFQQFxIQkgBUF+cSEHDAcLIAVBfnEhByAFQQFxIgkgBHFFDQYgBEF+cSAHRw0GIAMoArwCIAsgASgCpAFqRw0GIAEgDDYCoAEMBwsgA0EANgLIASADQfgAaiAFIANByAFqENUBIA4gAygCeCADKAJ8EBwMBwsgBkETOgAAQQAhBQwgCyABENIBIANB7//2BTYCyAEgDiADQcgBakEDEBwMBQsgAUEiEMMBQQAhBQweC0EAKAKgtlFBACgCpLZRQaizwAAQ7gIACyAOQcyxwAAgCiAJG0EAIAUgCRsQHAwCCyAOIAcgAygCvAJBACAJG2pBCGogCBAcIAVBEEkNAQsgBUF+cSEEAkACQCAFQQFxDQAgAygCvAIiB0EIaiIFIAdPDQFBACgCoLZRQQAoAqS2UUGossAAEO4CAAsgBCAEKAEAIgVBf2o2AQAgBUEBRw0BIAQoAgQiB0EIaiIFIAdJDQMLIAQgBUF/akF4cUEIakEEEJQECyADQdgBaiABIAJCgciAgMAIEGkgAygC2AFBAkcNAAtBASEFDBgLQQAoAqC2UUEAKAKktlFBqLLAABDuAgALIANByAFqIAEgAkKB7ICAkIiAgMAAEGkgAygCyAFBAkYNDyABQewBaiEPIAFBnAFqIQ4gA0G4AWpBCGohCgJAA0AgCiADQcgBakEIaikDADcDACADIAMpA8gBIhA3A7gBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQpw0AIAMoArwBIgUOYQMEBAQEBAQEBAEBBAEEBAQEBAQEBAQEBAQEBAQEBAQEAQQFBAQEAgUEBAQEBAQEBAQEBAQEBAQEBAQEBAUFBgQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAUEC0EAIAEoApwBIgQgASgCoAEiCyAEQQlJGyAEQQ9GGyIHQQAgAygCvAEiBSADKALAASIIIAVBCUkiDRsgBUEPRiIJG2oiDCAHSQ0GAkACQCAEQRBJDQAgBUEPSw0BCyAJDQggDQ0IIAVBAXEhCSAFQX5xIQcMCwsgBUF+cSEHIAVBAXEiCSAEcUUNCiAEQX5xIAdHDQogAygCxAEgCyABKAKkAWpHDQogASAMNgKgAQwLCyAGQQ46AABBACEFDCULIAFBPhDDAUEAIQUMJAsgARDSASADQe//9gU2AtgBIA4gA0HYAWpBAxAcDAkLIANBADYC2AEgBUGAAUkNBAJAIAVBgBBJDQACQCAFQYCABEkNACADIAVBP3FBgAFyOgDbASADIAVBEnZB8AFyOgDYASADIAVBBnZBP3FBgAFyOgDaASADIAVBDHZBP3FBgAFyOgDZAUEEIQUMBwsgAyAFQT9xQYABcjoA2gEgAyAFQQx2QeABcjoA2AEgAyAFQQZ2QT9xQYABcjoA2QFBAyEFDAYLIAMgBUE/cUGAAXI6ANkBIAMgBUEGdkHAAXI6ANgBQQIhBQwFCwJAAkAgAS0A5gENAEEAIQRBwLbAACEHQQ0hCQwBCyADQQI2AuQBIANBsLbAADYC4AEgA0ECNgLsASADQQA2AtgBIANBGDYCvAIgAyAGNgK4AiADQRc2ArQCIAMgDzYCsAIgAyADQbACajYC6AEgA0GgAmogA0HYAWoQYiADKAKgAiEHIAMoAqQCIQkgAygCqAIhCEEBIQQLIAMgCDYC6AEgAyAJNgLkASADIAc2AuABIAMgBDYC3AEgA0EGNgLYASABIANB2AFqEOcBIANBADYC2AEMAwsgAUEAOgCkAiADQegAaiABEC8gAygCbCEEIAMoAmghBQwgC0EAKAKgtlFBACgCpLZRQaizwAAQ7gIACyAOQcyxwAAgCiAJG0EAIAUgCRsQHAwECyADIAU6ANgBQQEhBQsgDiADQdgBaiAFEBwMAgsgDiAHIAMoAsQBQQAgCRtqQQhqIAgQHCAFQRBJDQELIAVBfnEhBAJAAkAgBUEBcQ0AIAMoAsQBIgdBCGoiBSAHTw0BQQAoAqC2UUEAKAKktlFBqLLAABDuAgALIAQgBCgBACIFQX9qNgEAIAVBAUcNASAEKAIEIgdBCGoiBSAHSQ0DCyAEIAVBf2pBeHFBCGpBBBCUBAsgA0HIAWogASACQoHsgICQiICAwAAQaSADKALIAUECRw0ADAsLC0EAKAKgtlFBACgCpLZRQaiywAAQ7gIACyADQdgBaiABIAJCgciAgIAYEGlBASEFIAMoAtgBQQJGDRUgAUGcAWohDiADQbACakEIaiEHAkADQCAHIANB2AFqQQhqKQMANwMAIAMgAykD2AEiEDcDsAICQAJAAkACQAJAAkACQAJAAkACQCAQpw0AIAMoArQCIgVFDQMgBUFaag4CBAIBC0EAIAEoApwBIgQgASgCoAEiCyAEQQlJGyAEQQ9GGyIJQQAgAygCtAIiBSADKAK4AiIIIAVBCUkiDRsgBUEPRiIKG2oiDCAJSQ0EAkACQCAEQRBJDQAgBUEPSw0BCyAKDQYgDQ0GIAVBAXEhCiAFQX5xIQkMBwsgBUF+cSEJIAVBAXEiCiAEcUUNBiAEQX5xIAlHDQYgAygCvAIgCyABKAKkAWpHDQYgASAMNgKgAQwHCyADQQA2AsgBIANB8ABqIAUgA0HIAWoQ1QEgDiADKAJwIAMoAnQQHAwHCyAGQRM6AABBACEFDB4LIAEQ0gEgA0Hv//YFNgLIASAOIANByAFqQQMQHAwFCyABQScQwwFBACEFDBwLQQAoAqC2UUEAKAKktlFBqLPAABDuAgALIA5BzLHAACAHIAobQQAgBSAKGxAcDAILIA4gCSADKAK8AkEAIAobakEIaiAIEBwgBUEQSQ0BCyAFQX5xIQQCQAJAIAVBAXENACADKAK8AiIJQQhqIgUgCU8NAUEAKAKgtlFBACgCpLZRQaiywAAQ7gIACyAEIAQoAQAiBUF/ajYBACAFQQFHDQEgBCgCBCIJQQhqIgUgCUkNAwsgBCAFQX9qQXhxQQhqQQQQlAQLIANB2AFqIAEgAkKByICAgBgQaSADKALYAUECRw0AC0EBIQUMFgtBACgCoLZRQQAoAqS2UUGossAAEO4CAAsCQAJAAkADQAJAAkAgAS0ApwINACACELABIQUMAQsgASgC7AEhBQsCQAJAAkACQCAFDj8GAQEBAQEBAQECAgECAgEBAQEBAQEBAQEBAQEBAQEBAQIBAwEBAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQcACyAFQYCAxABGDRoLIAFBEjsBpAJBACEFDBoLAkAgAS0ApwINACACEKQBIgVBgIDEAEYNAiABIAUgAhB5GgwCCyABQQA6AKcCDAELCyABIAIQvAMgAUGSBDsBpAJBACEFDBgLIAEgAhC8AyABQZICOwGkAkEAIQUMFwsgASACELwDIAEQ0gEgA0Hv//YFNgLYASABQZwBaiADQdgBakEDEBwgAUESOwGkAkEAIQUMFgsgASACELwDIAEQ0gEgAUEAOgCkAiADQeAAaiABEC8gAygCZCEEIAMoAmAhBQwVCwJAAkACQAJAAkACQAJAAkADQAJAAkAgAS0ApwINACACEKQBIgVBgIDEAEYNFyABIAUgAhB5IQcMAQsgAUEAOgCnAiABKALsASEHCwJAIAcOPwYCAgICAgICAgEBAgECAgICAgICAgICAgICAgICAgICAQICAgICAgICAgICAgICAwICAgICAgICAgICAgIEBQALC0EBIQUgB0GAgMQARg0cCyAHEM4DIgJBgIDEAEcNBiAHQV5qIgJBGksNBUEBIAJ0QaGAgCBxDQQMBQsgBkEUOgAAQQAhBQwaCyAGQRE6AABBACEFDBkLIAFBADoApAIgA0HYAGogARAvIAMoAlwhBCADKAJYIQUMGAsgARDSASABQf3/AxDEASABQQ86AKQCQQAhBQwXCyABENIBCyAHIQILIAEgAhDEASABQQ86AKQCQQAhBQwTCyABQZABaiEEIAFB7AFqIQgDQAJAAkAgAS0ApwINACACEKQBIgVBgIDEAEYNDiABIAUgAhB5IQUMAQsgAUEAOgCnAiABKALsASEFCwJAAkACQAJAAkACQAJAAkAgBQ4/BgEBAQEBAQEBAgIBAgEBAQEBAQEBAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQQFAAsgBUGAgMQARg0TCyAFEM4DIgdBgIDEAEYNBSADQQA2AtgBIANByABqIAcgA0HYAWoQ1QEgBCADKAJIIAMoAkwQHAwGCyAGQRA6AABBACEFDBkLIAZBFDoAAEEAIQUMGAsgBkEROgAAQQAhBQwXCyABQQA6AKQCIANB0ABqIAEQLyADKAJUIQQgAygCUCEFDBYLAkACQCABLQDmAQ0AQQAhBUHAtsAAIQdBDSEJDAELIANBAjYC5AEgA0GwtsAANgLgASADQQI2AuwBIANBADYC2AEgA0EYNgK8AiADIAY2ArgCIANBFzYCtAIgAyAINgKwAiADIANBsAJqNgLoASADQcgBaiADQdgBahBiIAMoAsgBIQcgAygCzAEhCSADKALQASEKQQEhBQsgAyAKNgLoASADIAk2AuQBIAMgBzYC4AEgAyAFNgLcASADQQY2AtgBIAEgA0HYAWoQ5wEgA0Hv//YFNgLYASAEIANB2AFqQQMQHAwBCwJAIAVBXmoiB0EaSw0AQQEgB3RBoYCAIHFFDQAgARDSAQsgA0EANgLYASADQcAAaiAFIANB2AFqENUBIAQgAygCQCADKAJEEBwMAAsLAkACQAJAAkACQAJAAkADQAJAAkAgAS0ApwINACACEKQBIgVBgIDEAEYNFCABIAUgAhB5IQcMAQsgAUEAOgCnAiABKALsASEHCwJAIAcOPwUCAgICAgICAgEBAgECAgICAgICAgICAgICAgICAgICAQICAgICAgICAgICAgICAwICAgICAgICAgICAgICBAALC0EBIQUgB0GAgMQARg0ZCyAHEM4DIgJBgIDEAEcNBSAHQV5qIgJBG0sNBEEBIAJ0QaGAgOAAcQ0DDAQLIAZBFDoAAEEAIQUMFwsgAUEAOgCkAiADQThqIAEQLyADKAI8IQQgAygCOCEFDBYLIAEQ0gEgAUH9/wMQxAEgAUEPOgCkAkEAIQUMFQsgARDSAQsgByECCyABIAIQxAEgAUEPOgCkAkEAIQUMEQsgAUG0AWohBgNAAkACQCABLQCnAg0AIAIQpAEiBUGAgMQARg0MIAEgBSACEHkhBQwBCyABQQA6AKcCIAEoAuwBIQULAkACQAJAAkACQAJAAkACQCAFQXdqDjYCAgECAQEBAQEBAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQIACyAFQYCAxABGDRELIAUQzgMiBEGAgMQARg0BIANBADYC2AEgBEGAAUkNBCAEQYAQSQ0DIARBgIAESQ0CIAMgBEE/cUGAAXI6ANsBIAMgBEESdkHwAXI6ANgBIAMgBEEGdkE/cUGAAXI6ANoBIAMgBEEMdkE/cUGAAXI6ANkBQQQhBAwFC0EBIQQCQCAGKAIAIgJBD0YNAAJAAkAgAkEJSQ0AIAJBfnFBACACQQFxayABQbwBaigCAHFqQQhqIQYgAUG4AWooAgAhAgwBCyABQbgBaiEGCyACQQZHDQAgBkHGvMAAQQYQwgRBAEchBAsgASAFEKUBIAFBpQJqIAQ6AAAgAUEFOgCkAkEAIQUMFgsgAUGFAjsBpAIgAUEBOgCnAkEAIQUMFgsgAyAEQT9xQYABcjoA2gEgAyAEQQx2QeABcjoA2AEgAyAEQQZ2QT9xQYABcjoA2QFBAyEEDAILIAMgBEE/cUGAAXI6ANkBIAMgBEEGdkHAAXI6ANgBQQIhBAwBCyADIAQ6ANgBQQEhBAsgBiADQdgBaiAEEBwgASAFEKUBDAALCyABQaUCai0AACEFAkACQAJAAkACQCABIAIQsAMiAkFTag4QAgEBAQEBAQEBAQEBAQEBBAALIAJFDQIgAkGAgMQARg0MCyABIAIQpQEgASAFOgClAiABQQU6AKQCQQAhBQwSCyABQS0QpQEgASAFOgClAiABQQw6AKQCQQAhBQwSCyABENIBIAFB/f8DEKUBIAEgBToApQIgAUEFOgCkAkEAIQUMEQsCQCAFQf8BcUUNACABQTwQpQELIAEgBToApQIgAUEGOgCkAkEAIQUMDwsCQCABIAIQsAMiAkEtRg0AIAJBgIDEAEYNCCABQYUIOwGkAiABQQE6AKcCQQAhBQwQCyABQS0QpQEgAUEMOwGkAkEAIQUMDwsCQCABQaUCai0AAEUNACABQbQBaiEGAkADQAJAAkAgAS0ApwINACACEKQBIgVBgIDEAEYNBSABIAUgAhB5IQQMAQsgAUEAOgCnAiABKALsASEECwJAAkACQCAEQXdqDjYCAgECAQEBAQEBAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQIACyAEQYCAxABGDQULIAQQzgMiBUGAgMQARg0CIANBADYC2AEgA0EwaiAFIANB2AFqENUBIAYgAygCMCADKAI0EBwgASAEEKUBDAELC0EAIQVBACEHAkAgBigCACICQQ9GDQACQAJAIAJBCUkNACACQX5xQQAgAkEBcWsgAUG8AWooAgBxakEIaiEGIAFBuAFqKAIAIQIMAQsgAUG4AWohBgtBACEHIAJBBkcNACAGQca8wABBBhDCBEUhBwsgASAEEKUBIAEgBzoApQIgAUEFOgCkAgwPCyABQQU7AaQCIAFBAToApwJBACEFDA8LAkAgASACELADIgJBLUYNACACQYCAxABGDQEgAUGFCDsBpAIgAUEBOgCnAkEAIQUMDwsgAUEtEKUBIAFBCjoApAJBACEFDA4LQQEhBQwNCyABQaUCai0AACEFIAEgAhCwAyICQYCAxABGDQQCQAJAIAIQzgMiBEGAgMQARw0AIAFBPBClASABQS8QpQEgAUEBOgCnAkEFIQIMAQsgAUEBIAQQvgEgA0EANgLYASADQSBqIAIgA0HYAWoQ1QEgAUG0AWogAygCICADKAIkEBxBCCECCyABIAU6AKUCIAEgAjoApAJBACEFDAsLAkACQAJAAkACQAJAAkACQCABQaUCai0AACIEQX5qQf8BcSIFQQMgBUEDSRsOBAIBAAMCCyADQbACaiABIAJCgciAgICAgIAQEGkgAygCsAIiBEECRw0FQQEhBQwRCyADQbACaiABIAJCgciAgICAgIAQEGkgAygCsAIiBEECRw0DQQEhBQwQCyADQbACaiABIAJCgciAgICIgIAQEGkgAygCsAIiBEECRw0BQQEhBQwPCwJAAkAgBEEBcUUNACADQbACaiABIAJCgciAgICAiIAQEGkgAygCsAIiBEECRw0BQQEhBQwQCyADQbACaiABIAJCgciAgICAiIAQEGkgAygCsAIiBEECRw0EQQEhBQwPCwNAIAMoArQCIQUCQAJAAkACQAJAAkACQCAEDQAgBUUNAiAFQVNqDhADAQEBAQEBAQEBAQEBAQEEAQsgAyADKQO4AjcD4AEgAyAFNgLcASADQQM2AtgBIAEgA0HYAWoQ5wEMBQsgASAFEKUBDAQLIAEQ0gEgAUH9/wMQpQEMAwtBCyECDAELQQYhAgsgASAFEKUBIAFBAToApQIgASACOgCkAkEAIQUMEAsgA0GwAmogASACQoHIgICAgIiAEBBpIAMoArACIgRBAkcNAAtBASEFDA4LA0AgAygCtAIhBQJAAkACQAJAAkAgBA0AIAVFDQEgBUEmRg0CIAVBPEYNAyABIAUQpQEMBAsgAyADKQO4AjcD4AEgAyAFNgLcASADQQM2AtgBIAEgA0HYAWoQ5wEMAwsgARDSASABQf3/AxClAQwCCyABQYCAxAAQwwFBACEFDBALIAFBhgQ7AaQCQQAhBQwPCyADQbACaiABIAJCgciAgICIgIAQEGkgAygCsAIiBEECRw0AC0EBIQUMDQsDQCADKAK0AiEFAkACQAJAAkAgBA0AIAVFDQEgBUE8Rg0CIAEgBRClAQwDCyADIAMpA7gCNwPgASADIAU2AtwBIANBAzYC2AEgASADQdgBahDnAQwCCyABENIBIAFB/f8DEKUBDAELIAFBhgY7AaQCQQAhBQwOCyADQbACaiABIAJCgciAgICAgIAQEGkgAygCsAIiBEECRw0AC0EBIQUMDAsDQCADKAK0AiEFAkACQAJAAkAgBA0AIAVFDQEgBUE8Rg0CIAEgBRClAQwDCyADIAMpA7gCNwPgASADIAU2AtwBIANBAzYC2AEgASADQdgBahDnAQwCCyABENIBIAFB/f8DEKUBDAELIAFBhgg7AaQCQQAhBQwNCyADQbACaiABIAJCgciAgICAgIAQEGkgAygCsAIiBEECRw0AC0EBIQUMCwsDQCADKAK0AiEFAkACQAJAAkACQAJAAkAgBA0AIAVFDQIgBUFTag4QAwEBAQEBAQEBAQEBAQEBBAELIAMgAykDuAI3A+ABIAMgBTYC3AEgA0EDNgLYASABIANB2AFqEOcBDAULIAEgBRClAQwECyABENIBIAFB/f8DEKUBDAMLIAFBLRClAUELIQIMAQtBBiECC0EAIQUgAUEAOgClAiABIAI6AKQCDAwLIANBsAJqIAEgAkKByICAgICIgBAQaSADKAKwAiIEQQJHDQALQQEhBQwKCyABQYQBaiEEIAFB7AFqIQgDQAJAAkAgAS0ApwINACACEKQBIgVBgIDEAEYNBSABIAUgAhB5IQUMAQsgAUEAOgCnAiABKALsASEFCwJAAkACQAJAAkACQCAFDj8FAQEBAQEBAQECAgECAQEBAQEBAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQMBAQEBAQEBAQEBAQEBAQQACyAFQYCAxABGDQgLIANBADYC2AECQAJAIAVBIHMgBSAFQb9/akEaSRsiBUGAAUkNAAJAIAVBgBBJDQACQCAFQYCABEkNACADIAVBP3FBgAFyOgDbASADIAVBEnZB8AFyOgDYASADIAVBBnZBP3FBgAFyOgDaASADIAVBDHZBP3FBgAFyOgDZAUEEIQUMAwsgAyAFQT9xQYABcjoA2gEgAyAFQQx2QeABcjoA2AEgAyAFQQZ2QT9xQYABcjoA2QFBAyEFDAILIAMgBUE/cUGAAXI6ANkBIAMgBUEGdkHAAXI6ANgBQQIhBQwBCyADIAU6ANgBQQEhBQsgBCADQdgBaiAFEBwMBAsgBkEOOgAAQQAhBQwOCyAGQRQ6AABBACEFDA0LIAFBADoApAIgA0EQaiABEC8gAygCFCEEIAMoAhAhBQwMCwJAAkAgAS0A5gENAEEAIQVBwLbAACEHQQ0hCQwBCyADQQI2AuQBIANBsLbAADYC4AEgA0ECNgLsASADQQA2AtgBIANBGDYCvAIgAyAGNgK4AiADQRc2ArQCIAMgCDYCsAIgAyADQbACajYC6AEgA0HIAWogA0HYAWoQYiADKALIASEHIAMoAswBIQkgAygC0AEhCkEBIQULIAMgCjYC6AEgAyAJNgLkASADIAc2AuABIAMgBTYC3AEgA0EGNgLYASABIANB2AFqEOcBIANB7//2BTYC2AEgBCADQdgBakEDEBwMAAsLAkACQAJAIAEgAhCwAyICRQ0AAkAgAkE+Rg0AIAJBgIDEAEYNBSACEM4DIgVBgIDEAEYNAiABQQEgBRC+AUEEIQEMAwsgARDSASABQQA6AKQCQQAhBQwMCyABENIBIAFBqAFqIgIQuQIgA0Hv//YFNgLYASACIANB2AFqQQMQHCABQRU6AKQCQQAhBQwLCyABENIBIAFBqAFqIgEQuQIgA0EANgLYASADQQhqIAIgA0HYAWoQ1QEgASADKAIIIAMoAgwQHEEVIQELIAYgAToAAEEAIQUMCAsCQCABIAIQsAMiAkFRag4RAwUFBQUFBQUFBQUFBQUFBQQACyACQSFGDQEgAkGAgMQARw0EC0EBIQUMBgsgARCyAiABQRY6AKQCQQAhBQwGCyAGQQM6AABBACEFDAULIAEQ0gEgAUGoAWoiAhC5AiADQT82AtgBIAIgA0HYAWpBARAcIAFBFToApAJBACEFDAQLAkACQCACEM4DIgJBgIDEAEYNACABQQAgAhC+AUEEIQEMAQsgARDSASABQTwQpQEgAUEBOgCnAkEAIQELIAYgAToAAEEAIQUMAgsgA0HIAWogASACQoHIgICAiICAEBBpAkAgAygCyAEiBEECRw0AQQEhBQwCCyABQewBaiEKA0AgAygCzAEhBQJAAkACQAJAAkAgBA0AIAVFDQEgBUEmRg0CIAVBPEYNAyABIAUQpQEMBAsgAyADKQPQATcD4AEgAyAFNgLcASADQQM2AtgBIAEgA0HYAWoQ5wEMAwsCQAJAIAEtAOYBDQBBACEFQcC2wAAhBEENIQcMAQsgA0ECNgLkASADQbC2wAA2AuABIANBAjYC7AEgA0EANgLYASADQRg2ArwCIAMgBjYCuAIgA0EXNgK0AiADIAo2ArACIAMgA0GwAmo2AugBIANBuAFqIANB2AFqEGIgAygCuAEhBCADKAK8ASEHIAMoAsABIQlBASEFCyADIAk2AugBIAMgBzYC5AEgAyAENgLgASADIAU2AtwBIANBBjYC2AEgASADQdgBahDnASADQQQ2AtgBIAEgA0HYAWoQ5wEMAgsgAUGAgMQAEMMBQQAhBQwECyAGQQI6AABBACEFDAMLIANByAFqIAEgAkKByICAgIiAgBAQaSADKALIASIEQQJHDQALQQEhBQwBC0EBIQULCyAAIAQ2AgQgACAFNgIAIANBwAJqJAAL9UsCHH8BfiMAQaACayIEJAAgAS0AZiEFIAFBADoAZkEEIQYCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACKAIADgcFAwAEDQECBQsgBEEYaiACQQxqKAIANgIAIAQgAikCBDcDEEECIQYMDAtBBSEGDAsLIAJBBGohBgJAIAFB1ABqKAIAIgcgAUHMAGoiAigCAEcNACACIAcQ3wEgASgCVCEHCyABQdAAaigCACAHQQR0aiIHIAYpAgA3AgAgB0EIaiAGQQhqKQIANwIAIABBADoAACABIAEoAlRBAWo2AlQMCwsgBEEYaiACQRBqKAIANgIAIAQgAikDCDcDECAEIAIoABU2AgggBCACQRhqKAAANgALIAJBHmovAAAhCCACQR1qLQAAIQkgAkEcai0AACEGIAJBFGotAAAhBwwJCyAEQShqIAJBDGooAgA2AgAgBCACKQIENwMgIAVB/wFxRQ0FIAQoAiAiBkEPRg0GAkACQCAGQQlJDQAgBCgCJEUNB0EAIQUgBkF+cUEAIAZBAXFrIARBIGpBCGooAgBxakEIai0AAEEKRw0HIAQoAiQiAkUNBiAGQX5xQQAgBkEBcWsgBEEgakEIaigCAHFqQQhqIQcMAQsgBC0AJEEKRw0GIARBIGpBBHIhByAGIQILIAJBf2oiCkUNA0EBIQUCQCAHLQABIgZBwAFxIgJBwAFGDQAgAkGAAUcNBAwFC0EEIQIgBkH4AXFB8AFGDQJBAyECIAZB8AFxQeABRw0BDAILIARB0ABqIAJBNGooAgA2AgAgBEHIAGogAkEsaikCADcDACAEQcAAaiACQSRqKQIANwMAIARBOGogAkEcaikCADcDACAEQTBqIAJBFGopAgA3AwAgBEEoaiACQQxqKQIANwMAIAQgAikCBDcDIAJAAkACQAJAIAEtAGNFDQAgAUHdAGotAAANAUEAIQdBDyECQeiXwAAhBQwCCyAEIARBIGogAUHfAGotAAAQECAELQABIQcgBC0AAEEBcUUNAgJAAkAgAUHdAGotAAANAEEAIQJBuJfAACEFQQshCgwBC0EBIQIgBEHcAWpBATYCACAEQeQBakEBNgIAIARBsJfAADYC2AEgBEEANgLQASAEQQ02AowCIAQgBEGIAmo2AuABIAQgBEEgajYCiAIgBEGAAWogBEHQAWoQYiAEKAKAASEFIAQoAoQBIQogBCgCiAEhCwsCQCABQdQAaigCACIGIAFBzABqIgwoAgBHDQAgDCAGEN8BIAEoAlQhBgsgAUHQAGooAgAgBkEEdGoiBiALNgIMIAYgCjYCCCAGIAU2AgQgBiACNgIAIAEgASgCVEEBajYCVAwCC0EBIQcgBEHcAWpBATYCACAEQeQBakEBNgIAIARB4JfAADYC2AEgBEEANgLQASAEQQ42AowCIAQgAUHjAGo2AogCIAQgBEGIAmo2AuABIARBgAFqIARB0AFqEGIgBCgCgAEhBSAEKAKEASECIAQoAogBIQoLAkAgAUHUAGooAgAiBiABQcwAaiILKAIARw0AIAsgBhDfASABKAJUIQYLIAFB0ABqKAIAIAZBBHRqIgYgCjYCDCAGIAI2AgggBiAFNgIEIAYgBzYCACAAQQA6AAAgASABKAJUQQFqNgJUAkACQAJAAkAgBCgCIEUNACAEKAIkIgZBEEkNACAGQX5xIQcCQAJAIAZBAXENACAEQSxqKAIAIgJBCGoiBiACTw0BQQAoAqC2UUEAKAKktlFBnJnAABDuAgALIAcgBygBACIGQX9qNgEAIAZBAUcNASAHKAIEIgJBCGoiBiACSQ0CCyAHIAZBf2pBeHFBCGpBBBCUBAsCQCAEKAIwRQ0AIARBNGooAgAiBkEQSQ0AIAZBfnEhBwJAAkAgBkEBcQ0AIARBPGooAgAiAkEIaiIGIAJPDQFBACgCoLZRQQAoAqS2UUGcmcAAEO4CAAsgByAHKAEAIgZBf2o2AQAgBkEBRw0BIAcoAgQiAkEIaiIGIAJJDQMLIAcgBkF/akF4cUEIakEEEJQECyAEKAJARQ0MIARBxABqKAIAIgZBEEkNDCAGQX5xIQcCQAJAIAZBAXENACAEQcwAaigCACICQQhqIgYgAk8NAUEAKAKgtlFBACgCpLZRQZyZwAAQ7gIACyAHIAcoAQAiBkF/ajYBACAGQQFHDQ0gBygCBCICQQhqIgYgAkkNAwsgByAGQX9qQXhxQQhqQQQQlAQMDAtBACgCoLZRQQAoAqS2UUGcmcAAEO4CAAtBACgCoLZRQQAoAqS2UUGcmcAAEO4CAAtBACgCoLZRQQAoAqS2UUGcmcAAEO4CAAsgBEHMAGooAgAhCSAEQcQAaigCACEGIARBPGooAgAhCCAEQTRqKAIAIQIgBCgCQCEKIAQoAjAhCyAEKAIsIQ0gBCgCJCEFIAQoAiAhDAJAAkACQAJAAkACQAJAAkACQAJAIAFB4ABqLQAADQAgBEHIAGooAgAhDiAEQThqKAIAIQ8gBCgCKCEQIARCADcC1AFBDyERIARBDzYC0AFBACESQQAhE0EAIRRBDyEVAkAgDEUNACAEQdABahCrAiANIRMgECEUIAUhFQsgBEIANwLUASAEQQ82AtABQQAhBQJAIAtFDQAgBEHQAWoQqwIgCCESIA8hBSACIRELIARCADcC1AFBDyECIARBDzYC0AEgCg0BQQAhDkEAIQkMAgsgAUEBOgBjIAEgBzoAZCAAQQA6AAAgAUHYAGogBzoAAAJAIApFDQAgBkEQSQ0AIAZBfnEhBwJAAkAgBkEBcQ0AIAlBCGoiBiAJTw0BQQAoAqC2UUEAKAKktlFBnJnAABDuAgALIAcgBygBACIGQX9qNgEAIAZBAUcNASAHKAIEIgpBCGoiBiAKSQ0HCyAHIAZBf2pBeHFBCGpBBBCUBAsgC0UNBCACQRBJDQQgAkF+cSEGIAJBAXENAiAIQQhqIgcgCE8NA0EAKAKgtlFBACgCpLZRQZyZwAAQ7gIACyAEQdABahCrAiAGIQILQdAAQQgQ/gMiBkUNBCAGQQA2AkggBiAJNgI8IAYgDjYCOCAGIAI2AjQgBiASNgIwIAYgBTYCLCAGIBE2AiggBiATNgIkIAYgFDYCICAGIBU2AhwgBkEBOgAYIAZCBDcDECAGQgA3AwggBkKBgICAEDcDACABQcgAaiAGEOkBIAFBAToAYyABQdgAaiAHOgAAIAEgBzoAZCAAQQA6AAAMDwsgBiAGKAEAIgdBf2o2AQAgB0EBRw0BIAYoAgQiAkEIaiIHIAJJDQQLIAYgB0F/akF4cUEIakEEEJQECyAMRQ0MIAVBEEkNDCAFQX5xIQYCQAJAIAVBAXENACANQQhqIgcgDU8NAUEAKAKgtlFBACgCpLZRQZyZwAAQ7gIACyAGIAYoAQAiB0F/ajYBACAHQQFHDQ0gBigCBCICQQhqIgcgAkkNBAsgBiAHQX9qQXhxQQhqQQQQlAQMDAtBACgCoLZRQQAoAqS2UUGcmcAAEO4CAAtB0ABBCBC8BAALQQAoAqC2UUEAKAKktlFBnJnAABDuAgALQQAoAqC2UUEAKAKktlFBnJnAABDuAgALQQIhAiAGQeABcUHAAUcNAgsgAiAKSw0BQQEhBQJAIAJBAWoiCkECRg0AIActAAJBwAFxQYABRw0CIApBA0YNACAHLQADQcABcUGAAUcNAiAKQQRGDQAgBy0ABEHAAXFBgAFHDQIgCkEFRw0CCwJAAkACQAJAIAJBfmoOAwABAgALIAZBH3FBBnQgBy0AAkE/cXIiBkGAAUkNBAwCCyAHLQACQT9xQQZ0IAZBD3FBDHRyIgIgBy0AA0E/cXIiBkGAEEkNAyACQYDwA3FBgAhyQYC4A0YNAwwBCyAHLQACQT9xQQx0IAZBB3FBEnRyIActAANBP3FBBnRyIActAARBP3FyIgZBgIAESQ0CCyAGQYCwA3NBgIC8f2pBgJC8f0kNASAGQYCAxABGDQELIARBIGpBARByDAELIAQgBToA0AFB9JXAAEErIARB0AFqQaCWwABBkJfAABDAAgALIAQoAiAiBkEPRw0BCyAAQQA6AAAMAgsCQCAGQQlJDQAgBCgCJA0AIABBADoAACAGQRBJDQIgBkF+cSEHAkACQAJAIAZBAXENACAEQSBqQQhqKAIAIgJBCGoiBiACTw0BQQAoAqC2UUEAKAKktlFBnJnAABDuAgALIAcgBygBACIGQX9qNgEAIAZBAUcNBCAHKAIEIgJBCGoiBiACSQ0BCyAHIAZBf2pBeHFBCGpBBBCUBAwDC0EAKAKgtlFBACgCpLZRQZyZwAAQ7gIACyAEQRBqQQhqIARBIGpBCGooAgA2AgAgBCAEKQMgNwMQQQAhB0EDIQYLIARB4ABqQQhqIg0gBEEQakEIaigCADYCACAEIAQpAxA3A2AgBCAEKAIINgJYIAQgBCgACzYAWyAEQoCAgICAATcDcCAEQgA3A3ggAUHMAGohFiAEQSBqQQNqIRcgBEGAAWpBFWohFCAEQSBqQQ1qIREgBEHwAWpBDWohGCAEQYgCakENaiEZIARB0AFqQRVqIRogBEG4AWpBDWohGyAEQaABakENaiEcIARB0AFqQQRyIR0gBEGAAWpBBHIhDiAEQYABakEIaiEVIARBIGpBBHIhHiAEQSBqQQhqIRMgBEHQAWpBCGohECABQTRqIQ8gBEEnaiEfA0ACQAJAAkACQAJAAkACQAJAAkAgBkH/AXEiCkEFRg0AIAEoAjgiBUUNAAJAAkACQAJAAkAgBUEBRw0AIAEoAhAiAg0BCyAPKAIAIgJFDQEgBUECdCACakF8aigCACECCyACQRhqLQAAQQRHDQEgAkEoaiIFKQMAQoKAgIDwAFENAyAFIAJBMGoiAhD8AkUNAgJAIAZBfmpB/wFxIgtBAWpBACALQQRJGw4EAAMEBAMLIAoNAiAEKQNgIiBCgoCAgIASUQ0CICBCgoCAgLDqAFENAgwDC0GsmcAAQRJBoJ3AABDuAgALQYSMwABBD0GUjMAAEMwDAAsCQCAFIAIQqgNFDQACQCAGQX5qQf8BcSILQQFqQQAgC0EESRsOBAABAgIBCyAKRQ0BCyAFKQMAQoKAgIDgAFINASACKQMAQoKAgICwElINAQJAAkAgBkF+akH/AXEiAkEBakEAIAJBBEkbDgQAAwEBAwsgCg0CIAQpA2BCgoCAgPA0UQ0BCwJAAkAgASgCOCIFQQFHDQAgASgCECICDQELIAVFDQMgDygCACICRQ0DIAVBAnQgAmpBfGooAgAhAgsgAkEYai0AAEEERw0DIAJBGWotAABFDQELIAEtAGMhAiATIA0oAgA2AgAgESAEKAJYNgAAIBFBA2ogBCgAWzYAACAEIAQpA2A3AyAgBCAHOgAsIAQgCDsBNiAEIAk6ADUgBCAGOgA0IARBgAFqIAEgAiAEQSBqEAEMBwsgHCAEKAJYNgAAIBxBA2ogBCgAWzYAACAEQaABakEIaiIFIA0oAgA2AgAgBCAEKQNgNwOgASAEIAc6AKwBIAQgCDsBtgEgBCAJOgC1ASAEIAY6ALQBAkACQAJAAkACQCAGQX5qQf8BcSICQQFqQQAgAkEESRsOBAABAwIKCyAKRQ0DDAkLIBcgBCkDYDcAACAXQQhqIA0oAgA2AABB0ABBCBD+AyIGRQ0FIAZBAzoAGCAGQgQ3AxAgBkIANwMIIAZCgYCAgBA3AwAgBiAEKQAgNwAZIAZBADYCSCAGQSBqIB8pAAA3AAAgBEEANgIgIAQgBjYCJCAEQdABaiABQQAQOyABIARB0AFqIARBIGoQkQIgBEEAOgCAAQwJCyAEQSBqIAEgBEGgAWoQdQJAAkACQAJAIAQtACBBfmoOBAABAQIDCyAEKAIkIgZBEEkNAiAGQX5xIQcCQAJAIAZBAXENACAEKAIsIgJBCGoiBiACTw0BQQAoAqC2UUEAKAKktlFBnJnAABDuAgALIAcgBygBACIGQX9qNgEAIAZBAUcNAyAHKAIEIgJBCGoiBiACSQ0JCyAHIAZBf2pBeHFBCGpBBBCUBAwCCyATEFYMAQsgHhD7AQsgBELv//YFNwMoIARCgYCAgDA3AyAgBEHQAWogAUEAEDsgASAEQdABaiAEQSBqEJECIARBADoAgAEMCAsgBEGIAmpBCGoiBiANKAIANgIAIAQgBCkDYDcDiAIgBEGIAmoQnwFFDQUgAUEAOgBlDAULAkACQAJAIAQpA6ABIiBCgYCAgKDVAFUNAAJAICBCgYCAgJApVQ0AAkAgIEKBgICAwA5VDQACQCAgQoGAgIDwBFUNACAgQoKAgIDgAFENBCAgQoKAgICABFINCwwECyAgQoKAgIDwBFENAyAgQoKAgIDwBlENAyAgQoKAgIDQB1INCgwDCwJAICBCgYCAgOAaVQ0AICBCgoCAgMAOUQ0DICBCgoCAgJAQUQ0DICBCgoCAgLAVUg0KDAMLICBCgoCAgOAaUQ0CICBCgoCAgNAjUQ0CICBCgoCAgNAoUg0JDAILAkAgIEKBgICA0MgAVQ0AAkAgIEKBgICAsDtVDQAgIEKCgICAkClRDQMgIEKCgICAgDdSDQoMAwsgIEKCgICAsDtRDQIgIEKCgICAwDtRDQMgIEKCgICAsMgAUg0JDAILAkAgIEKBgICAwM8AVQ0AICBCgoCAgNDIAFENAiAgQoKAgICQyQBRDQIgIEKCgICA8M4AUg0JDAILICBCgoCAgMDPAFENASAgQoKAgICg0ABRDQEgIEKCgICAkNUAUg0IDAELAkAgIEKBgICAsPMAVQ0AAkAgIEKBgICAsOEAVQ0AAkAgIEKBgICAoNkAVQ0AICBCgoCAgKDVAFENAyAgQoKAgICg2ABSDQoMAwsgIEKCgICAoNkAUQ0CICBCgoCAgKDdAFENAiAgQoKAgIDA4ABSDQkMAgsCQCAgQoGAgICA7ABVDQAgIEKCgICAsOEAUQ0CICBCgoCAgNDkAFENAiAgQoKAgICA5wBSDQkMAgsgIEKCgICAgOwAUQ0BICBCgoCAgNDuAFENASAgQoKAgICA7wBSDQgMAQsCQCAgQoGAgICQ/QBVDQACQCAgQoGAgIDw9wBVDQAgIEKCgICAsPMAUQ0CICBCgoCAgID0AFENAiAgQoKAgICg9ABSDQkMAgsgIEKCgICA8PcAUQ0BICBCgoCAgID4AFENASAgQoKAgIDQ+QBSDQgMAQsCQCAgQoGAgIDwhQFVDQAgIEKCgICAkP0AUQ0BICBCgoCAgICEAVENASAgQoKAgIDwhAFSDQgMAQsgIEKCgICA8IUBUQ0AICBCgoCAgMCGAVENACAgQoKAgICAhwFSDQcLIARBIGpBEGogBEGgAWpBEGopAwA3AwAgEyAFKQMANwMAIAQgBCkDoAE3AyAgBEGAAWogASAEQSBqEE8MBwsgGyAEKAJYNgAAIBtBA2ogBCgAWzYAACAEQbgBakEIaiANKAIANgIAIAQgBzoAxAEgBCAEKQNgNwO4ASAEIAg7Ac4BIAQgCToAzQEgBEEAOgDMAQJAAkAgBCgCyAEiBkUNACAGQShsIQcgBCgCxAFBEGohBgNAAkAgBkF4aikDAEKCgICAEFINACAGKQMAIiBCgoCAgNDrAFENAyAgQoKAgIDwggFRDQMgIEKCgICAoIcBUQ0DCyAGQShqIQYgB0FYaiIHDQALCyAEQYABaiABIARBuAFqECAMBwsgBEGAAWogASAEQbgBahBPDAYLQayZwABBEkGgncAAEO4CAAtBhIzAAEEPQcSPwAAQzAMAC0HQAEEIELwEAAtBACgCoLZRQQAoAqS2UUGcmcAAEO4CAAsgHiAEKQOIAjcCACAeQQhqIAYoAgA2AgAgBEEBNgIgIARB0AFqIAFBABA7IAEgBEHQAWogBEEgahCRAiAEQQA6AIABDAELIBAgBCkDYDcDACAaIAQoAlg2AAAgGkEDaiAEKABbNgAAIBBBCGogDSgCADYCACAEIAc6AOQBIAQgCDsB7gEgBCAJOgDtASAEQQE6ANABIAQgBjoA7AECQAJAAkACQAJAAkACQAJAAkAgCkECTw0AIApFDQIgGSAEKAJYNgAAIBlBA2ogBCgAWzYAACAEQYgCakEIaiIFIA0oAgA2AgAgBCAEKQNgNwOIAiAEIAc6AJQCIAQgCDsBngIgBCAJOgCdAiAEIAY6AJwCIAEoAjgiBkF/aiIHRQ0HIAYNAUEAIQZBfyEHDAwLQbCdwABBIkHUncAAEMwDAAsgDygCACAHQQJ0aigCACICQRhqLQAAQQRHDQEgAkEwaiAEQYgCahBxDQQgBEEgaiABIARBiAJqEHYCQAJAAkACQAJAIAQtACBBfmoOBAEAAgMECyATEFYMAwsgBCgCJCIHQRBJDQIgB0F+cSECAkACQCAHQQFxDQAgBCgCLCILQQhqIgcgC08NAUEAKAKgtlFBACgCpLZRQZyZwAAQ7gIACyACIAIoAQAiB0F/ajYBACAHQQFHDQMgAigCBCILQQhqIgcgC0kNBgsgAiAHQX9qQXhxQQhqQQQQlAQMAgsgExBWDAELIB4Q+wELIAZBfmoiB0UNBSAGQQJ0QXhqIQIDQCAHIAEoAjgiBk8NCyAPKAIAIAJqKAIAIgZBGGotAABBBEcNBCAGQShqKQMAISAgBkEwaiAEQYgCahBxIQYCQAJAICBCgoCAgPAAUQ0AIAZFDQEMBwsgAS0AYyEGIARBIGpBEGogBEGIAmpBEGopAwA3AwAgEyAFKQMANwMAIAQgBCkDiAI3AyAgBEGAAWogASAGIARBIGoQAQwICyACQXxqIQIgB0F/aiIHDQAMBgsLIBggBCgCWDYAACAYQQNqIAQoAFs2AAAgBEHwAWpBCGogDSgCADYCACAEIAQpA2A3A/ABIAQgBzoA/AEgBCAIOwGGAiAEIAk6AIUCIARBADoAhAIgBEGAAWogASAEQfABahAgDAYLQYSMwABBD0GUjMAAEMwDAAtBACgCoLZRQQAoAqS2UUGcmcAAEO4CAAtBhIzAAEEPQZSMwAAQzAMACyABKAI4IgIgB0kNACABIAc2AjggAiAHRg0AIA8oAgAgB0ECdGohBiACIAdrIQcDQCAGEPsBIAZBBGohBiAHQX9qIgcNAAsLIARBADoAgAECQCAEKQOIAiIgQgODQgBSDQAgIKciBiAGKAIMIgZBf2o2AgwgBkEBRw0AQcyw0QAQjAMiBiAGLQAAIgdBASAHGzoAAAJAIAdFDQAgBiAgQYCU69wDEBsaCyAGQQRqIAQoAogCENACIAZBACAGLQAAIgcgB0EBRiIHGzoAACAHDQAgBkEAEEoLAkAgBCgCmAIiB0UNACAEKAKUAiEGA0AgBhBXIAZBKGohBiAHQX9qIgcNAAsLIAQoApACIgZFDQAgBCgClAIgBkEobEEIEJQECyAELQDsAUECSQ0AIBAQVgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAQtAIABDggMAAECAwcGBQwLIAQoAnwiBg0KQQAhAiAAQQA6AAAMEAsgECAOQQhqKAIANgIAIAQgDikCACIgNwPQAQJAICCnIgJBD0cNACAAQQA6AAAMCQsCQAJAIAJBCUkNACAEKALUASIGRQ0JIAJBfnFBACACQQFxayAEKALYAXFqQQhqIgcgBmohDAwBCyAdIAJqIQwgHSEHCwJAIAcsAAAiBUF/TA0AIAVB/wFxIQUgB0EBaiIGIAdrIQoMFQsgBy0AAUE/cSEGIAVBH3EhCgJAIAVBX0sNACAKQQZ0IAZyIQUgB0ECaiIGIAdrIQoMFQsgBkEGdCAHLQACQT9xciELIAdBA2ohBiAFQXBPDQYgCyAKQQx0ciEFIAYgB2shCgwUCyABIAQtAIEBOgBjIA0gFUEIaigCADYCACAEIBUpAwA3A2AgBCAUKAAANgJYIAQgFEEDaigAADYAWwwBCyANIBVBCGooAgA2AgAgBCAVKQMANwNgIAQgFCgAADYCWCAEIBRBA2ooAAA2AFsLIAQvAZ4BIQggBC0AnQEhCSAELQCcASEGIAQtAJQBIQcMEgsCQCAEKAJ8DQAgACAELQCBAToAAUEDIQYMCQtBvKXAAEEoQeSlwAAQjQMACyAEKAJ8RQ0LQbylwABBKEH0pcAAEI0DAAsgBCgCfEUNBUG8pcAAQShBhKbAABCNAwALIAtBBnQgBi0AAEE/cXIgCkESdEGAgPAAcXIiBUGAgMQARw0MCyAAQQA6AAAgAkEQSQ0AIAJBfnEhBgJAAkAgAkEBcQ0AIAQoAtgBIgJBCGoiByACTw0BQQAoAqC2UUEAKAKktlFBnJnAABDuAgALIAYgBigBACIHQX9qNgEAIAdBAUcNASAGKAIEIgJBCGoiByACSQ0GCyAGIAdBf2pBeHFBCGpBBBCUBAsgBCgCfCECDAYLIAQgBkF/aiICNgJ8IAQgBCgCeCIGQQFqIgdBACAEKAJwIgUgByAFSRtrNgJ4AkAgBCgCdCAGQRhsaiIHLQAUIgZBBkcNACAAQQA6AAAMBgsgDSAHQQhqKAIANgIAIAQgBykDADcDYCAEIAcoAA02AlggBCAHQRBqKAAANgBbIActABUhCSAHLwEWIQggBy0ADCEHDAsLIApFIAlB/wFxQQBHcUUNAwJAIAEoAlQiBiABKAJMRw0AIBYgBhDfASABKAJUIQYLIAEoAlAgBkEEdGoiBkEfNgIIIAZBlKbAADYCBCAGQQA2AgAgASABKAJUQQFqNgJUDAMLIAAgBCgChAE2AgRBASEGCyAAIAY6AAAMBAtBACgCoLZRQQAoAqS2UUGcmcAAEO4CAAsCQCAEKAJ8IgYNAEEAIQIgAEEAOgAADAELIAQgBkF/aiICNgJ8IAQgBCgCeCIGQQFqIgdBACAEKAJwIgUgByAFSRtrNgJ4AkAgBCgCdCAGQRhsaiIHLQAUIgZBBkcNACAAQQA6AAAMAQsgDSAHQQhqKAIANgIAIAQgBykDADcDYCAEIAcoAA02AlggBCAHQRBqKAAANgBbIActABUhCSAHLwEWIQggBy0ADCEHDAYLIAJFDQFBACEFAkAgAiAEKAJwIgcgBCgCeCIGQQAgByAGIAdJG2siBmsiCk0NACACIAprIQUMAwsgBiACaiEHDAILIABBAjoAAAtBACEGQQAhB0EAIQULIAQoAnQiAiAGQRhsaiAHIAZrEE4gAiAFEE4gBCgCcCIGRQ0DIAQoAnQgBkEYbEEIEJQEDAMLQQQhCiAHQQRqIQYLIAUQ8QMhEgJAAkADQCAKIQUCQAJAAkAgBiAMRg0AAkACQAJAIAYsAAAiAkF/TA0AIAZBAWohByACQf8BcSECDAELIAYtAAFBP3EhByACQR9xIQoCQCACQV9LDQAgCkEGdCAHciECIAZBAmohBwwBCyAHQQZ0IAYtAAJBP3FyIQsgBkEDaiEHIAJBcE8NASALIApBDHRyIQILIAUgBmsgB2ohCgwDCyALQQZ0IActAABBP3FyIApBEnRBgIDwAHFyIgJBgIDEAEcNAQsCQAJAAkACQCAEKALQASIGQQ9LDQAgBCkC1AEhIAwBCwJAIAZBAXENACAGIAQoAtgBNgIEIARBADYC2AEgBCAGQQFyIgY2AtABCyAGQX5xIgYoAQBBAWoiB0UNASAGIAc2AQAgBCkC1AEhICAEKALQASIGQRBJDQACQCAGQQFxDQAgBCAgNwJkIAQgBjYCYCAEQQA2AtQBQQFBAiASGyEHDAcLIAZBfnEiByAHKAEAIgJBf2o2AQACQCACQQFHDQAgBygCBCICQQhqIgUgAkkNAyAHIAVBf2pBeHFBCGpBBBCUBAsgBEIANwLUAQsgBEEPNgLQASAEICA3AmQgBCAGNgJgQQFBAiASGyEHDAYLQQAoAqC2UUEAKAKktlFBsJjAABDuAgALQQAoAqC2UUEAKAKktlFBnJnAABDuAgALIAVBBGohCiAGQQRqIQcLIAIQ8QMhCyAHIQYgAkGAgMQARg0AIAchBiASIAtzRQ0ACyAEKALQASEGAkACQAJAIAVBCUkNAAJAIAZBAXENACAGIAQoAtgBNgIEIARBADYC2AEgBCAGQQFyIgY2AtABCyAGQX5xIgYoAQBBAWoiB0UNASAGIAc2AQAgBCgC0AFBAXIhBiAENQLYAUIghiAFrYQhIAwCC0HEl8AAIQcCQCAGQQ9GDQAgHSEHIAZBCUkNACAGQX5xQQAgBkEBcWsgBCgC2AFxakEIaiEHCyAEQgA3AyAgBEEgaiAHIAUQxAQaIAVBDyAFGyEGIAQpAyAhIAwBC0EAKAKgtlFBACgCpLZRQbCYwAAQ7gIACyAEQdABaiAFEHIgBCAgNwJkIAQgBjYCYEEBQQIgEhshByAEKALQASIGQQ9GDQELAkACQCAGQQlJDQAgBCgC1AFFDQELIBMgECgCADYCACAEIAQpA9ABNwMgAkAgBCgCfCICIAQoAnAiBkcNACAEQfAAahCgAiAEKAJwIQYgBCgCfCECCyAEKAJ0IAQoAnggAmoiAkEAIAYgAiAGSRtrQRhsaiIGIAQpAyA3AwAgBkEDOgAUIAZBADoADCAGQQhqIBMoAgA2AgAgBCAEKAJ8QQFqNgJ8QQMhBgwCCyAGQRBJDQAgBkF+cSECAkACQAJAIAZBAXENACAEKALYASIFQQhqIgYgBU8NAUEAKAKgtlFBACgCpLZRQZyZwAAQ7gIACyACIAIoAQAiBkF/ajYBACAGQQFHDQIgAigCBCIFQQhqIgYgBUkNAQsgAiAGQX9qQXhxQQhqQQQQlARBAyEGDAILQQAoAqC2UUEAKAKktlFBnJnAABDuAgALQQMhBgwACwsgBEGgAmokAA8LIAcgBkHkncAAEMsCAAulPgIKfwN+IwBBwABrIgIkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEoAgAiA0EYai0AAA4FBAABAgMLCyACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJBmMXAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEBIAItABAhBAJAAkAgAUUNACAEQf8BcUEERw0BQbzIwACtQiCGIQxCAiENQgAhDgwNCyAEQf8BcUEDRw0KIAIoAhQiASgCACABKAIEKAIAEQMAAkAgASgCBCIEQQRqKAIAIgVFDQAgASgCACAFIARBCGooAgAQlAQLIAIoAhRBDEEEEJQEDAoLIAIpAxAiDUL/AYNCBFENCSANQoCAgIBwgyEMIA1CgP7//w+DIQ4MCwsgAkEEOgAQIAIgADYCGCACQQA2AjQgAkHcwMAANgIwIAJBATYCLCACQczEwAA2AiggAkEANgIgIAJBEGpBlMjAACACQSBqEEchASACLQAQIQQCQAJAIAFFDQAgBEH/AXFBBEcNAUG8yMAArUIghiEMQgAhDkICIQ0MCQsgBEH/AXFBA0cNByACKAIUIgEoAgAgASgCBCgCABEDAAJAIAEoAgQiBEEEaigCACIFRQ0AIAEoAgAgBSAEQQhqKAIAEJQECyACKAIUQQxBBBCUBAwHCyACKQMQIg1C/wGDQgRRDQYgDUKAgICAcIMhDCANQoD+//8PgyEODAcLIAJBBDoAECACIAA2AhggAkEANgI0IAJB3MDAADYCMCACQQE2AiwgAkGQxMAANgIoIAJBADYCICACQRBqQZTIwAAgAkEgahBHIQEgAi0AECEEAkACQCABRQ0AIARB/wFxQQRHDQFBvMjAAK1CIIYhDEICIQ1CACEODAYLIARB/wFxQQNHDQQgAigCFCIBKAIAIAEoAgQoAgARAwACQCABKAIEIgRBBGooAgAiBUUNACABKAIAIAUgBEEIaigCABCUBAsgAigCFEEMQQQQlAQMBAsgAikDECINQv8Bg0IEUQ0DIA1CgICAgHCDIQwgDUKA/v//D4MhDgwECyACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB7MHAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEBIAItABAhBAJAAkACQCABRQ0AIARB/wFxQQRHDQFBvMjAAK1CIIYhDEIAIQ5CAiENDAILIARB/wFxQQNHDQMgAigCFCIBKAIAIAEoAgQoAgARAwACQCABKAIEIgRBBGooAgAiBUUNACABKAIAIAUgBEEIaigCABCUBAsgAigCFEEMQQQQlAQMAwsgAikDECINQv8Bg0IEUQ0CIA1CgICAgHCDIQwgDUKA/v//D4MhDgsgAiANQv8BgyAMhCAOhDcDIEH0wcAAQSsgAkEgakGgwsAAQbDCwAAQwAIACwJAAkACQCADKAIIIgFB/v///wdLDQAgAyABQQFqNgIIIAJBBDoAECACIAA2AhggAkEANgI0IAJB3MDAADYCMCACQQE2AiwgAkG0xsAANgIoIAJBADYCICACQRBqQZTIwAAgAkEgahBHIQEgAi0AECEEAkACQCABRQ0AIARB/wFxQQRHDQFBvMjAAK1CIIYhDEIAIQ5CAiENDAQLIARB/wFxQQNHDQIgAigCFCIBKAIAIAEoAgQoAgARAwACQCABKAIEIgRBBGooAgAiBUUNACABKAIAIAUgBEEIaigCABCUBAsgAigCFEEMQQQQlAQMAgsgAikDECINQv8Bg0IEUQ0BIA1CgICAgHCDIQwgDUKA/v//D4MhDgwCC0H8wsAAQRggAkE4akGUw8AAQZDGwAAQwAIACwJAAkAgA0EUaigCAA0AIAAoAgghAQwBCyACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB5MLAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEBIAItABAhBAJAAkACQAJAIAFFDQAgBEH/AXFBBEcNAUG8yMAArUIghiEMQgAhDkICIQ0MAwsgBEH/AXFBA0cNASACKAIUIgEoAgAgASgCBCgCABEDAAJAIAEoAgQiBEEEaigCACIFRQ0AIAEoAgAgBSAEQQhqKAIAEJQECyACKAIUQQxBBBCUBAwBCyACKQMQIg1C/wGDQgRRDQAgDUKAgICAcIMhDCANQoD+//8PgyEODAELAkACQCADKAIUIgENACAAKAIIIQUMAQsgA0EQaigCACEEIAFBAnQhBiAAKAIIIQFBACEHA0ACQAJAIAdBAXENACABIQUMAQsCQCABIAAoAgBHDQAgACABEO8BIAAoAgghAQsgACgCBCABakEsOgAAIAAgACgCCEEBaiIFNgIICyAAIAQQBCAAKAIIIgEgBUchByAEQQRqIQQgBkF8aiIGDQALIAEgBUcNAgsCQCAFRQ0AIAAgBUF/aiIBNgIIDAILQbTDwABBK0HcxsAAEI0DAAsgAiANQv8BgyAMhCAOhDcDIEH0wcAAQSsgAkEgakGgwsAAQczGwAAQwAIACwJAIAEgACgCAEcNACAAIAEQ7wEgACgCCCEBCyAAKAIEIAFqQd0AOgAAIAAgACgCCEEBajYCCCADIAMoAghBf2o2AggMBwsgAiANQv8BgyAMhCAOhDcDIEH0wcAAQSsgAkEgakGgwsAAQbzGwAAQwAIACyACIAA2AiACQCADQTBqIAJBIGoQ5QEiAUUNACACIAE2AiBB9MHAAEErIAJBIGpBwMLAAEHQwsAAEMACAAsgAkEEOgAQIAIgADYCGCACQQA2AjQgAkHcwMAANgIwIAJBATYCLCACQeTCwAA2AiggAkEANgIgIAJBEGpBlMjAACACQSBqEEchASACLQAQIQQCQAJAAkACQCABRQ0AIARB/wFxQQRHDQFBvMjAAK1CIIYhDEIAIQ5CAiENDAMLIARB/wFxQQNHDQEgAigCFCIBKAIAIAEoAgQoAgARAwACQCABKAIEIgRBBGooAgAiBUUNACABKAIAIAUgBEEIaigCABCUBAsgAigCFEEMQQQQlAQMAQsgAikDECINQv8Bg0IEUQ0AIA1CgICAgHCDIQwgDUKA/v//D4MhDgwBCyACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB8MbAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEBIAItABAhBAJAAkACQAJAIAFFDQAgBEH/AXFBBEcNAUG8yMAArUIghiEMQgIhDUIAIQ4MAgsgBEH/AXFBA0cNAiACKAIUIgEoAgAgASgCBCgCABEDAAJAIAEoAgQiBEEEaigCACIFRQ0AIAEoAgAgBSAEQQhqKAIAEJQECyACKAIUQQxBBBCUBAwCCyACKQMQIg1C/wGDQgRRDQEgDUKAgICAcIMhDCANQoD+//8PgyEOCyACIA1C/wGDIA6EIAyENwMgQfTBwABBKyACQSBqQaDCwABB+MbAABDAAgALAkAgAygCOCIBQf7///8HSw0AIAMgAUEBajYCOAJAIANBxABqKAIAIghFDQAgA0HAAGooAgAhCSAIQShsIQpBACEFQQEhBgJAAkADQCACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB8MbAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEBIAItABAhBAJAAkACQAJAAkACQCABRQ0AIARB/wFxQQRHDQFBvMjAAK1CIIYhDUICIQwMBAsgBEH/AXFBA0cNASACKAIUIgEoAgAgASgCBCgCABEDAAJAIAEoAgQiBEEEaigCACIHRQ0AIAEoAgAgByAEQQhqKAIAEJQECyACKAIUQQxBBBCUBAwBCyACKQMQIg1C/wGDQgRSDQELAkACQAJAAkAgCSAFaiIEQRBqKQMAIg2nIgFBA3EOAwIAAQILIAFBBHZBD3EiB0EITw0IIARBEWohAQwCCwJAENkEIgdBFGooAgAiCyANQiCIpyIBTQ0AIAcoAhAgAUEDdGoiASgCBCEHIAEoAgAhAQwCCyABIAtBxJXAABDLAgALIAEoAgQhByABKAIAIQELIAIgADYCDCACQRBqIAJBDGogAkEMaiABIAcQOCACLQAQQQRGDQIgAiACKQMQNwMgIAIgAkEgahC0AzYCIEH0wcAAQSsgAkEgakHAwsAAQajHwAAQwAIACyANQv////8PgyEMIA1CgICAgHCDIQ0LIAIgDCANhDcDIEH0wcAAQSsgAkEgakGgwsAAQZjHwAAQwAIACyACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB5MLAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEBIAItABAhBwJAAkACQAJAAkACQAJAAkACQAJAAkAgAUUNACAHQf8BcUEERw0BQbzIwACtQiCGIQ1CAiEMDAQLIAdB/wFxQQNHDQEgAigCFCIBKAIAIAEoAgQoAgARAwACQCABKAIEIgdBBGooAgAiC0UNACABKAIAIAsgB0EIaigCABCUBAsgAigCFEEMQQQQlAQMAQsgAikDECINQv8Bg0IEUg0BCwJAAkAgBEEYaigCACIBQQ9HDQBB3MDAACEHQQAhAQwBCwJAIAFBCUkNACABQX5xQQAgAUEBcWsgBEEgaigCAHFqQQhqIQcgBEEcaigCACEBDAELIARBHGohBwsgAiAANgIMIAJBEGogAkEMaiACQQxqIAcgARA4IAItABBBBEcNAiAGIAhJDQQgAkEEOgAQIAIgADYCGCACQQA2AjQgAkHcwMAANgIwIAJBATYCLCACQfTDwAA2AiggAkEANgIgIAJBEGpBlMjAACACQSBqEEchASACLQAQIQQgAUUNAyAEQf8BcUEERw0FQbzIwACtQiCGIQ1CAiEMDAkLIA1C/////w+DIQwgDUKAgICAcIMhDQsgAiAMIA2ENwMgQfTBwABBKyACQSBqQaDCwABBuMfAABDAAgALIAIgAikDEDcDICACIAJBIGoQtAM2AiBB9MHAAEErIAJBIGpBwMLAAEHIx8AAEMACAAsgBEH/AXFBA0cNAiACKAIUIgEoAgAgASgCBCgCABEDAAJAIAEoAgQiBEEEaigCACIHRQ0AIAEoAgAgByAEQQhqKAIAEJQECyACKAIUQQxBBBCUBAwCCyACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB3MfAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEBIAItABAhBAJAAkACQCABRQ0AIARB/wFxQQRHDQFBvMjAAK1CIIYhDUICIQwMAgsgBEH/AXFBA0cNAyACKAIUIgEoAgAgASgCBCgCABEDAAJAIAEoAgQiBEEEaigCACIHRQ0AIAEoAgAgByAEQQhqKAIAEJQECyACKAIUQQxBBBCUBAwDCyACKQMQIg1C/wGDQgRRDQIgDUL/////D4MhDCANQoCAgIBwgyENCyACIA0gDIQ3AyBB9MHAAEErIAJBIGpBoMLAAEHkx8AAEMACAAsgAikDECINQv8Bg0IEUg0BCyAGQQFqIQYgCiAFQShqIgVHDQEMBAsLIA1C/////w+DIQwgDUKAgICAcIMhDQsgAiANIAyENwMgQfTBwABBKyACQSBqQaDCwABB9MfAABDAAgALIAdBB0HUlcAAEKQEAAsgAkEEOgAQIAIgADYCGCACQQA2AjQgAkHcwMAANgIwIAJBATYCLCACQfTDwAA2AiggAkEANgIgIAJBEGpBlMjAACACQSBqEEchASACLQAQIQQCQAJAAkACQCABRQ0AIARB/wFxQQRHDQFBvMjAAK1CIIYhDEICIQ1CACEODAMLIARB/wFxQQNHDQEgAigCFCIBKAIAIAEoAgQoAgARAwACQCABKAIEIgRBBGooAgAiBUUNACABKAIAIAUgBEEIaigCABCUBAsgAigCFEEMQQQQlAQMAQsgAikDECINQv8Bg0IEUQ0AIA1CgICAgHCDIQwgDUKA/v//D4MhDgwBCyADIAMoAjhBf2o2AjgCQAJAIAMoAhxFDQAgA0EcaiEEAkAgACgCCCIBIAAoAgBHDQAgACABEO8BIAAoAgghAQsgACgCBCABakEsOgAAIAAgACgCCEEBajYCCCAAIAQQBAwBCwJAAkAgAygCCCIBQf7///8HSw0AIAMgAUEBajYCCCADQRRqKAIAIgFFDQEgA0EQaigCACEEIAFBAnQhBiAAKAIIIQFBASEHA0ACQAJAIAdBAXENACABIQUMAQsCQCABIAAoAgBHDQAgACABEO8BIAAoAgghAQsgACgCBCABakEsOgAAIAAgACgCCEEBaiIFNgIICyAAIAQQBCAAKAIIIgEgBUchByAEQQRqIQQgBkF8aiIGDQALIAEgBUcNAQJAIAVFDQAgACAFQX9qNgIIDAILQbTDwABBK0Hgw8AAEI0DAAtB/MLAAEEYIAJBOGpBlMPAAEGkw8AAEMACAAsgAyADKAIIQX9qNgIICyACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB9MPAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEAIAItABAhAQJAAkACQCAARQ0AIAFB/wFxQQRHDQFBvMjAAK1CIIYhDEIAIQ5CAiENDAILIAFB/wFxQQNHDQogAigCFCIAKAIAIAAoAgQoAgARAwACQCAAKAIEIgFBBGooAgAiBEUNACAAKAIAIAQgAUEIaigCABCUBAsgAigCFEEMQQQQlAQMCgsgAikDECINQv8Bg0IEUQ0JIA1CgICAgHCDIQwgDUKA/v//D4MhDgsgAiANQv8BgyAMhCAOhDcDIEH0wcAAQSsgAkEgakGgwsAAQfzDwAAQwAIACyACIA1C/wGDIA6EIAyENwMgQfTBwABBKyACQSBqQaDCwABBhMjAABDAAgALQfzCwABBGCACQThqQZTDwABBiMfAABDAAgALIAIgDUL/AYMgDIQgDoQ3AyBB9MHAAEErIAJBIGpBoMLAAEHswsAAEMACAAsCQAJAIANBHGooAgAiAUEPRw0AQdzAwAAhBEEAIQEMAQsCQCABQQlJDQAgAUF+cUEAIAFBAXFrIANBJGooAgBxakEIaiEEIANBIGooAgAhAQwBCyADQSBqIQQLIAIgADYCDCACQRBqIAJBDGogAkEMaiAEIAEQOAJAIAItABBBBEcNACACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB9MPAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEAIAItABAhAQJAAkACQCAARQ0AIAFB/wFxQQRHDQFBvMjAAK1CIIYhDEICIQ1CACEODAILIAFB/wFxQQNHDQcgAigCFCIAKAIAIAAoAgQoAgARAwACQCAAKAIEIgFBBGooAgAiBEUNACAAKAIAIAQgAUEIaigCABCUBAsgAigCFEEMQQQQlAQMBwsgAikDECINQv8Bg0IEUQ0GIA1CgICAgHCDIQwgDUKA/v//D4MhDgsgAiANQv8BgyAOhCAMhDcDIEH0wcAAQSsgAkEgakGgwsAAQbjEwAAQwAIACyACIAIpAxA3AyAgAiACQSBqELQDNgIgQfTBwABBKyACQSBqQcDCwABBqMTAABDAAgALIAIgDUL/AYMgDoQgDIQ3AyBB9MHAAEErIAJBIGpBoMLAAEGYxMAAEMACAAsCQAJAIANBHGooAgAiAUH+////B0sNACADIAFBAWo2AhwCQAJAIANBIGooAgAiAUEPRw0AQdzAwAAhBEEAIQEMAQsCQCABQQlJDQAgAUF+cUEAIAFBAXFrIANBKGooAgBxakEIaiEEIANBJGooAgAhAQwBCyADQSRqIQQLIAIgADYCDCACQRBqIAJBDGogAkEMaiAEIAEQOCACLQAQQQRHDQEgAyADKAIcQX9qNgIcIAJBBDoAECACIAA2AhggAkEANgI0IAJB3MDAADYCMCACQQE2AiwgAkH0w8AANgIoIAJBADYCICACQRBqQZTIwAAgAkEgahBHIQAgAi0AECEBAkACQAJAIABFDQAgAUH/AXFBBEcNAUG8yMAArUIghiEMQgAhDkICIQ0MAgsgAUH/AXFBA0cNBiACKAIUIgAoAgAgACgCBCgCABEDAAJAIAAoAgQiAUEEaigCACIERQ0AIAAoAgAgBCABQQhqKAIAEJQECyACKAIUQQxBBBCUBAwGCyACKQMQIg1C/wGDQgRRDQUgDUKAgICAcIMhDCANQoD+//8PgyEOCyACIA1C/wGDIAyEIA6ENwMgQfTBwABBKyACQSBqQaDCwABBhMXAABDAAgALQfzCwABBGCACQThqQZTDwABB5MTAABDAAgALIAIgAikDEDcDICACIAJBIGoQtAM2AiBB9MHAAEErIAJBIGpBwMLAAEH0xMAAEMACAAsgAiANQv8BgyAMhCAOhDcDIEH0wcAAQSsgAkEgakGgwsAAQdTEwAAQwAIACwJAAkAgA0EcaigCACIBQQ9HDQBB3MDAACEEQQAhAQwBCwJAIAFBCUkNACABQX5xQQAgAUEBcWsgA0EkaigCAHFqQQhqIQQgA0EgaigCACEBDAELIANBIGohBAsgAiAANgIMIAJBEGogAkEMaiACQQxqIAQgARA4AkACQAJAIAItABBBBEcNACACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB5MLAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEBIAItABAhBAJAAkAgAUUNACAEQf8BcUEERw0BQbzIwACtQiCGIQxCAiENQgAhDgwECyAEQf8BcUEDRw0CIAIoAhQiASgCACABKAIEKAIAEQMAAkAgASgCBCIEQQRqKAIAIgVFDQAgASgCACAFIARBCGooAgAQlAQLIAIoAhRBDEEEEJQEDAILIAIpAxAiDUL/AYNCBFENASANQoCAgIBwgyEMIA1CgP7//w+DIQ4MAgsgAiACKQMQNwMgIAIgAkEgahC0AzYCIEH0wcAAQSsgAkEgakHAwsAAQbDFwAAQwAIACwJAAkAgAygCKCIBQQ9HDQBB3MDAACEEQQAhAQwBCwJAIAFBCUkNACABQX5xQQAgAUEBcWsgA0EwaigCAHFqQQhqIQQgA0EsaigCACEBDAELIANBLGohBAsgAiAANgIMIAJBEGogAkEMaiACQQxqIAQgARA4AkACQAJAIAItABBBBEcNACACQQQ6ABAgAiAANgIYIAJBADYCNCACQdzAwAA2AjAgAkEBNgIsIAJB5MLAADYCKCACQQA2AiAgAkEQakGUyMAAIAJBIGoQRyEBIAItABAhBAJAAkAgAUUNACAEQf8BcUEERw0BQbzIwACtQiCGIQxCAiENQgAhDgwECyAEQf8BcUEDRw0CIAIoAhQiASgCACABKAIEKAIAEQMAAkAgASgCBCIEQQRqKAIAIgVFDQAgASgCACAFIARBCGooAgAQlAQLIAIoAhRBDEEEEJQEDAILIAIpAxAiDUL/AYNCBFENASANQoCAgIBwgyEMIA1CgP7//w+DIQ4MAgsgAiACKQMQNwMgIAIgAkEgahC0AzYCIEH0wcAAQSsgAkEgakHAwsAAQdDFwAAQwAIACwJAAkAgAygCNCIBQQ9HDQBB3MDAACEEQQAhAQwBCwJAIAFBCUkNACABQX5xQQAgAUEBcWsgA0E8aigCAHFqQQhqIQQgA0E4aigCACEBDAELIANBOGohBAsgAiAANgIMIAJBEGogAkEMaiACQQxqIAQgARA4AkAgAi0AEEEERw0AIAJBBDoAECACIAA2AhggAkEANgI0IAJB3MDAADYCMCACQQE2AiwgAkH0w8AANgIoIAJBADYCICACQRBqQZTIwAAgAkEgahBHIQAgAi0AECEBAkACQAJAIABFDQAgAUH/AXFBBEcNAUG8yMAArUIghiEMQgIhDUIAIQ4MAgsgAUH/AXFBA0cNBSACKAIUIgAoAgAgACgCBCgCABEDAAJAIAAoAgQiAUEEaigCACIERQ0AIAAoAgAgBCABQQhqKAIAEJQECyACKAIUQQxBBBCUBAwFCyACKQMQIg1C/wGDQgRRDQQgDUKAgICAcIMhDCANQoD+//8PgyEOCyACIA1C/wGDIA6EIAyENwMgQfTBwABBKyACQSBqQaDCwABBgMbAABDAAgALIAIgAikDEDcDICACIAJBIGoQtAM2AiBB9MHAAEErIAJBIGpBwMLAAEHwxcAAEMACAAsgAiANQv8BgyAOhCAMhDcDIEH0wcAAQSsgAkEgakGgwsAAQeDFwAAQwAIACyACIA1C/wGDIA6EIAyENwMgQfTBwABBKyACQSBqQaDCwABBwMXAABDAAgALIAJBwABqJAAPCyACIA1C/wGDIA6EIAyENwMgQfTBwABBKyACQSBqQaDCwABBoMXAABDAAgALjjACHX8EfiMAQcAKayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEpAwAiIVANACABKQMIIiJQDQEgASkDECIjUA0CICEgI3wiJCAhVA0DICEgIlQNBCADQRFJDQUgASwAGiEFIAEvARghASAEICE+AgAgBEEBQQIgIUKAgICAEFQiBhs2AqABIARBACAhQiCIpyAGGzYCBCAEQQhqQQBBmAEQwwQaIAQgIj4CqAEgBEEBQQIgIkKAgICAEFQiBhs2AsgCIARBACAiQiCIpyAGGzYCrAEgBEGoAWpBCGpBAEGYARDDBBogBCAjPgLQAiAEQQFBAiAjQoCAgIAQVCIGGzYC8AMgBEEAICNCIIinIAYbNgLUAiAEQdACakEIakEAQZgBEMMEGiAEQfgDakEEckEAQZwBEMMEGiAEQQE2AvgDIARBATYCmAUgAa3DICRCf3x5fULCmsHoBH5CgKHNoLQCfEIgiKciBsEhBwJAAkAgAcEiCEEASA0AIAQgARAlGiAEQagBaiABECUaIARB0AJqIAEQJRoMAQsgBEH4A2pBACAIa8EQJRoLAkACQCAHQX9KDQAgBEEAIAdrwSIBEDMaIARBqAFqIAEQMxogBEHQAmogARAzGgwBCyAEQfgDaiAGQf//A3EQMxoLIAQgBCgCoAEiCTYCuAogBEGYCWogBEGgARDEBBogCSAEKALwAyIKIAkgCksbIgtBKEsNBgJAIAsNAEEAIQsMCQsgC0EBcSEMAkAgC0EBRw0AQQAhDUEAIQ4MCAsgC0F+cSEPQQAhDSAEQZgJaiEBIARB0AJqIQZBACEOA0AgASABKAIAIhAgBigCAGoiCCANQQFxaiIRNgIAIAFBBGoiDSANKAIAIhIgBkEEaigCAGoiDSAIIBBJIBEgCElyaiIINgIAIA0gEkkgCCANSXIhDSAGQQhqIQYgAUEIaiEBIA8gDkECaiIORw0ADAgLC0Hr19EAQRxBiNjRABCNAwALQZjY0QBBHUG42NEAEI0DAAtByNjRAEEcQeTY0QAQjQMAC0H02NEAQTZBrNnRABCNAwALQbzZ0QBBN0H02dEAEI0DAAtBhNrRAEEtQbTa0QAQjQMACyALQShBiIbSABCkBAALAkAgDEUNACAEQZgJaiAOQQJ0IgFqIgYgBigCACIGIARB0AJqIAFqKAIAaiIBIA1qIgg2AgAgASAGSSAIIAFJciENCyANQQFxRQ0AIAtBJ0sNASAEQZgJaiALQQJ0akEBNgIAIAtBAWohCwsgBCALNgK4CiAEKAKYBSIOIAsgDiALSxsiAUEpTw0BIAFBAnQhAQJAAkADQCABRQ0BQX8gAUF8aiIBIARBmAlqaigCACIGIAEgBEH4A2pqKAIAIghHIAYgCEsbIgZFDQAMAgsLQX9BACABGyEGCwJAIAYgBUgNACAJQSlPDQMCQCAJDQBBACEJDAYLIAlBf2pB/////wNxIgFBAWoiCEEDcSEGAkAgAUEDTw0AIAQhAUIAISEMBQsgCEH8////B3EhCCAEIQFCACEhA0AgASABNQIAQgp+ICF8IiE+AgAgAUEEaiINIA01AgBCCn4gIUIgiHwiIT4CACABQQhqIg0gDTUCAEIKfiAhQiCIfCIhPgIAIAFBDGoiDSANNQIAQgp+ICFCIIh8IiE+AgAgIUIgiCEhIAFBEGohASAIQXxqIggNAAwFCwsgB0EBaiEHDAwLIAtBKEGIhtIAEMsCAAsgAUEoQYiG0gAQpAQACyAJQShBiIbSABCkBAALAkAgBkUNAANAIAEgATUCAEIKfiAhfCIhPgIAIAFBBGohASAhQiCIISEgBkF/aiIGDQALCyAhpyIBRQ0AIAlBJ0sNASAEIAlBAnRqIAE2AgAgCUEBaiEJCyAEIAk2AqABIAQoAsgCIhBBKU8NAQJAIBANAEEAIRAMBAsgEEF/akH/////A3EiAUEBaiIIQQNxIQYCQCABQQNPDQAgBEGoAWohAUIAISEMAwsgCEH8////B3EhCCAEQagBaiEBQgAhIQNAIAEgATUCAEIKfiAhfCIhPgIAIAFBBGoiDSANNQIAQgp+ICFCIIh8IiE+AgAgAUEIaiINIA01AgBCCn4gIUIgiHwiIT4CACABQQxqIg0gDTUCAEIKfiAhQiCIfCIhPgIAICFCIIghISABQRBqIQEgCEF8aiIIDQAMAwsLIAlBKEGIhtIAEMsCAAsgEEEoQYiG0gAQpAQACwJAIAZFDQADQCABIAE1AgBCCn4gIXwiIT4CACABQQRqIQEgIUIgiCEhIAZBf2oiBg0ACwsgIaciAUUNACAQQSdLDQEgBEGoAWogEEECdGogATYCACAQQQFqIRALIAQgEDYCyAIgCkEpTw0BAkAgCg0AIARBADYC8AMMBAsgCkF/akH/////A3EiAUEBaiIIQQNxIQYCQCABQQNPDQAgBEHQAmohAUIAISEMAwsgCEH8////B3EhCCAEQdACaiEBQgAhIQNAIAEgATUCAEIKfiAhfCIhPgIAIAFBBGoiDSANNQIAQgp+ICFCIIh8IiE+AgAgAUEIaiINIA01AgBCCn4gIUIgiHwiIT4CACABQQxqIg0gDTUCAEIKfiAhQiCIfCIhPgIAICFCIIghISABQRBqIQEgCEF8aiIIDQAMAwsLIBBBKEGIhtIAEMsCAAsgCkEoQYiG0gAQpAQACwJAIAZFDQADQCABIAE1AgBCCn4gIXwiIT4CACABQQRqIQEgIUIgiCEhIAZBf2oiBg0ACwsCQCAhpyIBRQ0AIApBJ0sNAiAEQdACaiAKQQJ0aiABNgIAIApBAWohCgsgBCAKNgLwAwsgBCAONgLABiAEQaAFaiAEQfgDakGgARDEBBogBEGgBWpBARAlIRMgBCAEKAKYBTYC6AcgBEHIBmogBEH4A2pBoAEQxAQaIARByAZqQQIQJSEUIAQgBCgCmAU2ApAJIARB8AdqIARB+ANqQaABEMQEGiAEQfAHakEDECUhFQJAAkAgBCgCoAEiDyAEKAKQCSIWIA8gFksbIgtBKEsNACAEQaAFakF8aiEMIARByAZqQXxqIQogBEHwB2pBfGohCSAEKAKYBSEXIAQoAsAGIRggBCgC6AchGUEAIRoDQCAaIRsgC0ECdCEBAkACQANAIAFFDQFBfyAJIAFqKAIAIgYgAUF8aiIBIARqKAIAIghHIAYgCEsbIgZFDQAMAgsLQX9BACABGyEGC0EAIRwCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBkEBSw0AAkAgC0UNAEEBIQ0gC0EBcSEdQQAhDgJAIAtBAUYNACALQX5xIQ9BACEOQQEhDSAEIQEgBEHwB2ohBgNAIAEgASgCACIQIAYoAgBBf3NqIgggDUEBcWoiETYCACABQQRqIg0gDSgCACISIAZBBGooAgBBf3NqIg0gCCAQSSARIAhJcmoiCDYCACANIBJJIAggDUlyIQ0gBkEIaiEGIAFBCGohASAPIA5BAmoiDkcNAAsLAkAgHUUNACAEIA5BAnQiAWoiBiAGKAIAIgYgFSABaigCAEF/c2oiASANaiIINgIAIAEgBkkgCCABSXIhDQsgDUEBcUUNAgsgBCALNgKgAUEIIRwgCyEPCyAPIBkgDyAZSxsiC0EpTw0BIAtBAnQhAQJAAkADQCABRQ0BQX8gCiABaigCACIGIAFBfGoiASAEaigCACIIRyAGIAhLGyIGRQ0ADAILC0F/QQAgARshBgsCQAJAIAZBAU0NACAPIQsMAQsCQCALRQ0AQQEhDSALQQFxIR1BACEOAkAgC0EBRg0AIAtBfnEhD0EAIQ5BASENIAQhASAEQcgGaiEGA0AgASABKAIAIhAgBigCAEF/c2oiCCANQQFxaiIRNgIAIAFBBGoiDSANKAIAIhIgBkEEaigCAEF/c2oiDSAIIBBJIBEgCElyaiIINgIAIA0gEkkgCCANSXIhDSAGQQhqIQYgAUEIaiEBIA8gDkECaiIORw0ACwsCQCAdRQ0AIAQgDkECdCIBaiIGIAYoAgAiBiAUIAFqKAIAQX9zaiIBIA1qIgg2AgAgASAGSSAIIAFJciENCyANQQFxRQ0ECyAEIAs2AqABIBxBBHIhHAsgCyAYIAsgGEsbIh1BKU8NAyAdQQJ0IQECQAJAA0AgAUUNAUF/IAwgAWooAgAiBiABQXxqIgEgBGooAgAiCEcgBiAISxsiBkUNAAwCCwtBf0EAIAEbIQYLAkACQCAGQQFNDQAgCyEdDAELAkAgHUUNAEEBIQ0gHUEBcSELQQAhDgJAIB1BAUYNACAdQX5xIQ9BACEOQQEhDSAEIQEgBEGgBWohBgNAIAEgASgCACIQIAYoAgBBf3NqIgggDUEBcWoiETYCACABQQRqIg0gDSgCACISIAZBBGooAgBBf3NqIg0gCCAQSSARIAhJcmoiCDYCACANIBJJIAggDUlyIQ0gBkEIaiEGIAFBCGohASAPIA5BAmoiDkcNAAsLAkAgC0UNACAEIA5BAnQiAWoiBiAGKAIAIgYgEyABaigCAEF/c2oiASANaiIINgIAIAEgBkkgCCABSXIhDQsgDUEBcUUNBgsgBCAdNgKgASAcQQJqIRwLIB0gFyAdIBdLGyIPQSlPDQUgD0ECdCEBAkACQANAIAFFDQFBfyABQXxqIgEgBEH4A2pqKAIAIgYgASAEaigCACIIRyAGIAhLGyIGRQ0ADAILC0F/QQAgARshBgsCQAJAIAZBAU0NACAdIQ8MAQsCQCAPRQ0AQQEhDSAPQQFxIR1BACEOAkAgD0EBRg0AIA9BfnEhC0EAIQ5BASENIAQhASAEQfgDaiEGA0AgASABKAIAIhAgBigCAEF/c2oiCCANQQFxaiIRNgIAIAFBBGoiDSANKAIAIhIgBkEEaigCAEF/c2oiDSAIIBBJIBEgCElyaiIINgIAIA0gEkkgCCANSXIhDSAGQQhqIQYgAUEIaiEBIAsgDkECaiIORw0ACwsCQCAdRQ0AIAQgDkECdCIBaiIGIAYoAgAiBiAEQfgDaiABaigCAEF/c2oiASANaiIINgIAIAEgBkkgCCABSXIhDQsgDUEBcUUNCAsgBCAPNgKgASAcQQFqIRwLIBsgA0YNCiACIBtqIBxBMGo6AAAgDyAEKALIAiIeIA8gHksbIgFBKU8NByAbQQFqIRogAUECdCEBAkACQANAIAFFDQFBfyABQXxqIgEgBEGoAWpqKAIAIgYgASAEaigCACIIRyAGIAhLGyILRQ0ADAILC0F/QQAgARshCwsgBCAPNgK4CiAEQZgJaiAEQaABEMQEGiAPIAQoAvADIh8gDyAfSxsiHEEoSw0OAkACQCAcDQBBACEcDAELIBxBAXEhIEEAIQ1BACEOAkAgHEEBRg0AIBxBfnEhHUEAIQ0gBEGYCWohASAEQdACaiEGQQAhDgNAIAEgASgCACIQIAYoAgBqIgggDUEBcWoiETYCACABQQRqIg0gDSgCACISIAZBBGooAgBqIg0gCCAQSSARIAhJcmoiCDYCACANIBJJIAggDUlyIQ0gBkEIaiEGIAFBCGohASAdIA5BAmoiDkcNAAsLAkAgIEUNACAEQZgJaiAOQQJ0IgFqIgYgBigCACIGIARB0AJqIAFqKAIAaiIBIA1qIgg2AgAgASAGSSAIIAFJciENCyANQQFxRQ0AIBxBJ0sNCSAEQZgJaiAcQQJ0akEBNgIAIBxBAWohHAsgBCAcNgK4CiAXIBwgFyAcSxsiAUEpTw0JIAFBAnQhAQJAAkADQCABRQ0BQX8gAUF8aiIBIARBmAlqaigCACIGIAEgBEH4A2pqKAIAIghHIAYgCEsbIgZFDQAMAgsLQX9BACABGyEGCwJAIAsgBUgNACAGIAVIDQAgD0EpTw0MAkAgDw0AQQAhDwwTCyAPQX9qQf////8DcSIBQQFqIghBA3EhBgJAIAFBA08NACAEIQFCACEhDBILIAhB/P///wdxIQggBCEBQgAhIQNAIAEgATUCAEIKfiAhfCIhPgIAIAFBBGoiDSANNQIAQgp+ICFCIIh8IiE+AgAgAUEIaiINIA01AgBCCn4gIUIgiHwiIT4CACABQQxqIg0gDTUCAEIKfiAhQiCIfCIhPgIAICFCIIghISABQRBqIQEgCEF8aiIIDQAMEgsLIAYgBU4NDwJAIAsgBU4NACAEQQEQJRogBCgCoAEiASAEKAKYBSIGIAEgBksbIgFBKU8NDSABQQJ0IQEgBEF8aiENIARB+ANqQXxqIQ4CQAJAA0AgAUUNASANIAFqIQYgDiABaiEIIAFBfGohAUF/IAgoAgAiCCAGKAIAIgZHIAggBksbIgZFDQAMAgsLQX9BACABGyEGCyAGQQJPDRALIBsgA08NDSACIBpqIQ4gGyEBQX8hBgJAA0AgAUF/Rg0BIAZBAWohBiACIAFqIQggAUF/aiINIQEgCC0AAEE5Rg0ACyACIA1qIghBAWoiASABLQAAQQFqOgAAIA1BAmogG0sNECAIQQJqQTAgBhDDBBoMEAsgAkExOgAAAkAgG0UNACACQQFqQTAgGxDDBBoLAkAgGiADTw0AIA5BMDoAACAHQQFqIQcgG0ECaiEaDBALIBogA0Hk2tEAEMsCAAtBmIbSAEEaQYiG0gAQjQMACyALQShBiIbSABCkBAALQZiG0gBBGkGIhtIAEI0DAAsgHUEoQYiG0gAQpAQAC0GYhtIAQRpBiIbSABCNAwALIA9BKEGIhtIAEKQEAAtBmIbSAEEaQYiG0gAQjQMACyABQShBiIbSABCkBAALIBxBKEGIhtIAEMsCAAsgAUEoQYiG0gAQpAQACyADIANBxNrRABDLAgALIA9BKEGIhtIAEKQEAAsgAUEoQYiG0gAQpAQACyAaIANB1NrRABCkBAALIBxBKEGIhtIAEKQEAAsCQCAaIANLDQAgACAHOwEIIAAgGjYCBCAAIAI2AgAgBEHACmokAA8LIBogA0H02tEAEKQEAAsCQCAGRQ0AA0AgASABNQIAQgp+ICF8IiE+AgAgAUEEaiEBICFCIIghISAGQX9qIgYNAAsLICGnIgFFDQAgD0EnSw0BIAQgD0ECdGogATYCACAPQQFqIQ8LIAQgDzYCoAEgHkEpTw0BAkAgHg0AQQAhHgwECyAeQX9qQf////8DcSIBQQFqIghBA3EhBgJAIAFBA08NACAEQagBaiEBQgAhIQwDCyAIQfz///8HcSEIIARBqAFqIQFCACEhA0AgASABNQIAQgp+ICF8IiE+AgAgAUEEaiINIA01AgBCCn4gIUIgiHwiIT4CACABQQhqIg0gDTUCAEIKfiAhQiCIfCIhPgIAIAFBDGoiDSANNQIAQgp+ICFCIIh8IiE+AgAgIUIgiCEhIAFBEGohASAIQXxqIggNAAwDCwsgD0EoQYiG0gAQywIACyAeQShBiIbSABCkBAALAkAgBkUNAANAIAEgATUCAEIKfiAhfCIhPgIAIAFBBGohASAhQiCIISEgBkF/aiIGDQALCyAhpyIBRQ0AIB5BJ0sNASAEQagBaiAeQQJ0aiABNgIAIB5BAWohHgsgBCAeNgLIAiAfQSlPDQECQCAfDQBBACEfDAQLIB9Bf2pB/////wNxIgFBAWoiCEEDcSEGAkAgAUEDTw0AIARB0AJqIQFCACEhDAMLIAhB/P///wdxIQggBEHQAmohAUIAISEDQCABIAE1AgBCCn4gIXwiIT4CACABQQRqIg0gDTUCAEIKfiAhQiCIfCIhPgIAIAFBCGoiDSANNQIAQgp+ICFCIIh8IiE+AgAgAUEMaiINIA01AgBCCn4gIUIgiHwiIT4CACAhQiCIISEgAUEQaiEBIAhBfGoiCA0ADAMLCyAeQShBiIbSABDLAgALIB9BKEGIhtIAEKQEAAsCQCAGRQ0AA0AgASABNQIAQgp+ICF8IiE+AgAgAUEEaiEBICFCIIghISAGQX9qIgYNAAsLICGnIgFFDQAgH0EnSw0DIARB0AJqIB9BAnRqIAE2AgAgH0EBaiEfCyAEIB82AvADIA8gFiAPIBZLGyILQShNDQALCyALQShBiIbSABCkBAALIB9BKEGIhtIAEMsCAAsgCkEoQYiG0gAQywIAC484Ag9/AX4jAEGgA2siASQAAkACQAJAQcABQQQQ/gMiAkUNACAAKAKAASEDIABBADYCgAEgASACNgKsASABQRA2AqgBIAFCADcDsAEgAw0BDAILQcABQQQQvAQACyADIAAgAUGoAWoQ1gEgAUG4AmogA0HEABDEBBogAUG4AWogAUG4AmoQ8QEgACABKQO4ASABLQDAARA+IANBxABBBBCUBAsgAEEBOgCmAiABIAAgAUGoAWoQqQEiAzYCuAICQCADDQACQCABKAK0AQ0AIABBCGohBCAAQRhqIQUgAEHsAWohBiAAQagBaiEHIABB8AFqIQggAEG0AWohCSAAQaQCaiEDIAFBuAJqQQRyIQIDQAJAQQAoAsiOUkEDTQ0AIAFBATYCxAIgAUHkvMAANgLAAiABQQE2AswCIAFBADYCuAIgAUEYNgK8ASABIAM2ArgBIAEgAUG4AWo2AsgCIAFBuAJqQQRB7LzAABCLAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADLQAADisSEgABGxEQAgMEBRsbBhsbGxsbGxsHCAkJCQkJCQoKCwsLCwsLCwsMDQ4PEgsCQAJAIAAtAOYBDQBBACEKQZS2wAAhC0EOIQwMAQtBASEKIAFBATYCxAIgAUGMtsAANgLAAiABQQE2AswCIAFBADYCuAIgAUEYNgKkAiABIAM2AqACIAEgAUGgAmo2AsgCIAFBuAFqIAFBuAJqEGIgASgCuAEhCyABKAK8ASEMIAEoAsABIQ0LIAEgDTYCyAIgASAMNgLEAiABIAs2AsACIAEgCjYCvAIgAUEGNgK4AiAAIAFBuAJqEOcBIAFCADcCvAEgAUEPNgK4ASABQTw2AqACIAFBuAFqIAFBoAJqQQEQHCACQQhqIAFBuAFqQQhqKAIANgIAIAIgASkDuAE3AgAgAUEDNgK4AiAAIAFBuAJqEOcBIABBADoApAIMGwsCQAJAIAAtAOYBDQBBACEKQZS2wAAhC0EOIQwMAQtBASEKIAFBATYCxAIgAUGMtsAANgLAAiABQQE2AswCIAFBADYCuAIgAUEYNgKkAiABIAM2AqACIAEgAUGgAmo2AsgCIAFBuAFqIAFBuAJqEGIgASgCuAEhCyABKAK8ASEMIAEoAsABIQ0LIAEgDTYCyAIgASAMNgLEAiABIAs2AsACIAEgCjYCvAIgAUEGNgK4AiAAIAFBuAJqEOcBIAFCADcCvAEgAUEPNgK4ASABQTw2AqACIAFBuAFqIAFBoAJqQQEQHCACQQhqIgogAUG4AWpBCGoiCygCADYCACACIAEpA7gBNwIAIAFBAzYCuAIgACABQbgCahDnASABQgA3ArwBIAFBDzYCuAEgAUEvNgKgAiABQbgBaiABQaACakEBEBwgCiALKAIANgIAIAIgASkDuAE3AgAgAUEDNgK4AiAAIAFBuAJqEOcBIABBADoApAIMGgsgAC0ApQIhCiABQgA3ArwBIAFBDzYCuAEgAUE8NgKgAiABQbgBaiABQaACakEBEBwgAkEIaiILIAFBuAFqQQhqIgwoAgA2AgAgAiABKQO4ATcCACABQQM2ArgCIAAgAUG4AmoQ5wEgAUIANwK8ASABQQ82ArgBIAFBLzYCoAIgAUG4AWogAUGgAmpBARAcIAsgDCgCADYCACACIAEpA7gBNwIAIAFBAzYCuAIgACABQbgCahDnASAAIAo6AKUCIABBBToApAIMGQsgAC0ApQIhCyABQgA3ArwBIAFBDzYCuAEgAUE8NgKgAiABQbgBaiABQaACakEBEBwgAkEIaiIKIAFBuAFqQQhqIgwoAgA2AgAgAiABKQO4ATcCACABQQM2ArgCIAAgAUG4AmoQ5wEgAUIANwK8ASABQQ82ArgBIAFBLzYCoAIgAUG4AWogAUGgAmpBARAcIAogDCgCADYCACACIAEpA7gBNwIAIAFBAzYCuAIgACABQbgCahDnASAKIAlBCGooAgA2AgAgAiAJKQIANwIAIABCADcDuAEgAEEPNgK0ASABQQM2ArgCIAAgAUG4AmoQ5wEgACALOgClAiAAQQU6AKQCDBgLIANBBToAAAwXCyAAQYUIOwGkAgwWCyAAQYUCOwGkAgwVCyACIAcpAgA3AgAgAkEIaiAHQQhqKAIANgIAIABCADcCrAEgAEEPNgKoASABQQI2ArgCIAAgAUG4AmoQ5wEgAEEAOgCkAgwUCwJAAkAgAC0A5gENAEEAIQpBwLbAACELQQ0hDAwBCyABQQI2AsQCIAFBsLbAADYCwAIgAUECNgLMAiABQQA2ArgCIAFBGDYCxAEgASADNgLAASABQRc2ArwBIAEgBjYCuAEgASABQbgBajYCyAIgAUGgAmogAUG4AmoQYiABKAKgAiELIAEoAqQCIQwgASgCqAIhDUEBIQoLIAEgDTYCyAIgASAMNgLEAiABIAs2AsACIAEgCjYCvAIgAUEGNgK4AiAAIAFBuAJqEOcBIABBFToApAIMEwsCQAJAIAAtAOYBDQBBACEKQZS2wAAhC0EOIQwMAQtBASEKIAFBATYCxAIgAUGMtsAANgLAAiABQQE2AswCIAFBADYCuAIgAUEYNgKkAiABIAM2AqACIAEgAUGgAmo2AsgCIAFBuAFqIAFBuAJqEGIgASgCuAEhCyABKAK8ASEMIAEoAsABIQ0LIAEgDTYCyAIgASAMNgLEAiABIAs2AsACIAEgCjYCvAIgAUEGNgK4AgJAAkAgAC0A6AENACABQfABaiAFIAFBuAJqIAApAxAQAyABLQDwASEKDAELIAFB2ABqEJ4DIAEgASgCYDYCwAEgASABKQNYNwO4ASABQaACaiAFIAFBuAJqIAApAxAQAyABQcgAaiABQbgBahCfAyABKQOgAiEQIAAgASkDSEKAlOvcA34gATUCUHwgACkDCHw3AwggASAQNwPwASAQpyEKCwJAIApB/wFxIgpBAUcNACABQfABakEEchD7AQwRCyAKDRAgAkEIaiAHQQhqKAIANgIAIAIgBykCADcCACAAQgA3AqwBIABBDzYCqAEgAUECNgK4AgJAAkAgAC0A6AENACABQfABaiAFIAFBuAJqIAApAxAQAyABLQDwASEKDAELIAFBOGoQngMgASABKAJANgLAASABIAEpAzg3A7gBIAFBoAJqIAUgAUG4AmogACkDEBADIAFBKGogAUG4AWoQnwMgASkDoAIhECAAIAEpAyhCgJTr3AN+IAE1AjB8IAApAwh8NwMIIAEgEDcD8AEgEKchCgsCQCAKQf8BcSIKQQFHDQAgAUHwAWpBBHIQ+wEMEAsgCg0PIANBADoAAAwSCwJAAkAgAC0A5gENAEEAIQpBlLbAACELQQ4hDAwBC0EBIQogAUEBNgLEAiABQYy2wAA2AsACIAFBATYCzAIgAUEANgK4AiABQRg2AqQCIAEgAzYCoAIgASABQaACajYCyAIgAUG4AWogAUG4AmoQYiABKAK4ASELIAEoArwBIQwgASgCwAEhDQsgASANNgLIAiABIAw2AsQCIAEgCzYCwAIgASAKNgK8AiABQQY2ArgCIAAgAUG4AmoQ5wEgAUG4AmoQ5gMCQCAAKALwAUUNACAAKAL0ASIKQRBJDQAgCkF+cSELAkACQCAKQQFxDQAgACgC/AEiDEEIaiIKIAxPDQFBACgCoLZRQQAoAqS2UUGossAAEO4CAAsgCyALKAEAIgpBf2o2AQAgCkEBRw0BIAsoAgQiDEEIaiIKIAxJDQoLIAsgCkF/akF4cUEIakEEEJQECwJAIAAoAoACRQ0AIAAoAoQCIgpBEEkNACAKQX5xIQsCQAJAIApBAXENACAAKAKMAiIMQQhqIgogDE8NAUEAKAKgtlFBACgCpLZRQaiywAAQ7gIACyALIAsoAQAiCkF/ajYBACAKQQFHDQEgCygCBCIMQQhqIgogDEkNCwsgCyAKQX9qQXhxQQhqQQQQlAQLAkAgACgCkAJFDQAgACgClAIiCkEQSQ0AIApBfnEhCwJAAkAgCkEBcQ0AIAAoApwCIgxBCGoiCiAMTw0BQQAoAqC2UUEAKAKktlFBqLLAABDuAgALIAsgCygBACIKQX9qNgEAIApBAUcNASALKAIEIgxBCGoiCiAMSQ0MCyALIApBf2pBeHFBCGpBBBCUBAsgCCABKQO4AjcCACAIQTBqIgogAUG4AmpBMGooAgA2AgAgCEEoaiILIAFBuAJqQShqKQMANwIAIAhBIGoiDCABQbgCakEgaikDADcCACAIQRhqIg0gAUG4AmpBGGopAwA3AgAgCEEQaiIOIAFBuAJqQRBqKQMANwIAIAhBCGoiDyABQbgCakEIaikDADcCACAAQQE6AKACIAFBuAFqEOYDIAJBMGogCigCADYCACACQShqIAspAgA3AgAgAkEgaiAMKQIANwIAIAJBGGogDSkCADcCACACQRBqIA4pAgA3AgAgAkEIaiAPKQIANwIAIAIgCCkCADcCACAIIAEpA7gBNwIAIA8gAUG4AWpBCGopAwA3AgAgDiABQbgBakEQaikDADcCACANIAFBuAFqQRhqKQMANwIAIAwgAUG4AWpBIGopAwA3AgAgCyABQbgBakEoaikDADcCACAKIAFBuAFqQTBqKAIANgIAIAFBADYCuAIgACABQbgCahDnASAAQQA6AKQCDBELAkACQCAALQDmAQ0AQQAhCkGUtsAAIQtBDiEMDAELQQEhCiABQQE2AsQCIAFBjLbAADYCwAIgAUEBNgLMAiABQQA2ArgCIAFBGDYCpAIgASADNgKgAiABIAFBoAJqNgLIAiABQbgBaiABQbgCahBiIAEoArgBIQsgASgCvAEhDCABKALAASENCyABIA02AsgCIAEgDDYCxAIgASALNgLAAiABIAo2ArwCIAFBBjYCuAICQAJAIAAtAOgBDQAgAUHwAWogBSABQbgCaiAAKQMQEAMgAS0A8AEhCgwBCyABQZgBahCeAyABIAEoAqABNgLAASABIAEpA5gBNwO4ASABQaACaiAFIAFBuAJqIAApAxAQAyABQYgBaiABQbgBahCfAyABKQOgAiEQIAAgASkDiAFCgJTr3AN+IAE1ApABfCAAKQMIfDcDCCABIBA3A/ABIBCnIQoLAkAgCkH/AXEiCkEBRw0AIAFB8AFqQQRyEPsBDA0LIAoNDCAAQQE6AKACIAFBuAFqEOYDIAJBMGogCEEwaiIKKAIANgIAIAJBKGogCEEoaiILKQIANwIAIAJBIGogCEEgaiIMKQIANwIAIAJBGGogCEEYaiINKQIANwIAIAJBEGogCEEQaiIOKQIANwIAIAJBCGogCEEIaiIPKQIANwIAIAIgCCkCADcCACAIIAEpA7gBNwIAIA8gAUG4AWpBCGopAwA3AgAgDiABQbgBakEQaikDADcCACANIAFBuAFqQRhqKQMANwIAIAwgAUG4AWpBIGopAwA3AgAgCyABQbgBakEoaikDADcCACAKIAFBuAFqQTBqKAIANgIAIAFBADYCuAICQAJAIAAtAOgBDQAgAUHwAWogBSABQbgCaiAAKQMQEAMgAS0A8AEhCgwBCyABQfgAahCeAyABIAEoAoABNgLAASABIAEpA3g3A7gBIAFBoAJqIAUgAUG4AmogACkDEBADIAFB6ABqIAFBuAFqEJ8DIAEpA6ACIRAgACABKQNoQoCU69wDfiABNQJwfCAAKQMIfDcDCCABIBA3A/ABIBCnIQoLAkAgCkH/AXEiCkEBRw0AIAFB8AFqQQRyEPsBDAwLIAoNCyADQQA6AAAMEAsgAUG4AWoQ5gMgAkEwaiAIQTBqIgooAgA2AgAgAkEoaiAIQShqIgspAgA3AgAgAkEgaiAIQSBqIgwpAgA3AgAgAkEYaiAIQRhqIg0pAgA3AgAgAkEQaiAIQRBqIg4pAgA3AgAgAkEIaiAIQQhqIg8pAgA3AgAgAiAIKQIANwIAIAggASkDuAE3AgAgDyABQbgBakEIaikDADcCACAOIAFBuAFqQRBqKQMANwIAIA0gAUG4AWpBGGopAwA3AgAgDCABQbgBakEgaikDADcCACALIAFBuAFqQShqKQMANwIAIAogAUG4AWpBMGooAgA2AgAgAUEANgK4AiAAIAFBuAJqEOcBIABBADoApAIMDwsgAiAJKQIANwIAIAJBCGogCUEIaigCADYCACAAQgA3A7gBIABBDzYCtAEgAUEDNgK4AiAAIAFBuAJqEOcBAkACQCAALQDmAQ0AQQAhCkGUtsAAIQtBDiEMDAELQQEhCiABQQE2AsQCIAFBjLbAADYCwAIgAUEBNgLMAiABQQA2ArgCIAFBGDYCpAIgASADNgKgAiABIAFBoAJqNgLIAiABQbgBaiABQbgCahBiIAEoArgBIQsgASgCvAEhDCABKALAASENCyABIA02AsgCIAEgDDYCxAIgASALNgLAAiABIAo2ArwCIAFBBjYCuAIgACABQbgCahDnASAAQQA6AKQCDA4LIAFB3QA2ArgCIAkgAUG4AmpBARAcIANBKDoAAAwNCyABQd0ANgK4AiAJIAFBuAJqQQEQHCABQd0ANgK4AiAJIAFBuAJqQQEQHCADQSg6AAAMDAsCQCAALQClAiIKQQFGDQAgAUIANwK8ASABQQ82ArgBIAFBPDYCoAIgAUG4AWogAUGgAmpBARAcIAJBCGogAUG4AWpBCGooAgA2AgAgAiABKQO4ATcCACABQQM2ArgCIAAgAUG4AmoQ5wEgACAKOgClAiAAQQU6AKQCDAwLIABBhQI7AaQCDAsLIAAtAKUCQQJJDQkLIAFBBTYCuAIgACABQbgCahDnASAAQdAAaiICKAIAIQMgAkEANgIAAkAgA0UNACAAQcwAaigCAEF8aiECIANBAnQhAwNAIAEgAiADaigCADYCuAIgAUG4AmoQ+wEgA0F8aiIDDQALCyAALQDoAUUNAyAAKALAASEDIAEgAEHIAWooAgBBACAAQcQBaigCACIAGzYC2AIgASAANgLQAiABIAM2AswCIAEgADYCwAIgASADNgK8AiABIABFQQF0IgA2AsgCIAEgADYCuAIgAUHwAWogAUG4AmoQUCABKAL0ASEFIAEoAvgBIQggASABQZgDajYCuAIgBSAIIAFBuAJqEBMCQAJAIAgNAEIAIRAMAQsgCEF/akH/////AHEiAEEBaiICQQdxIQMCQAJAIABBB08NAEIAIRAgBSEADAELIAVB+ABqIQAgAkH4////AXEhAkIAIRADQCAAKQMAIABBcGopAwAgAEFgaikDACAAQVBqKQMAIABBQGopAwAgAEGwf2opAwAgAEGgf2opAwAgAEGQf2opAwAgEHx8fHx8fHx8IRAgAEGAAWohACACQXhqIgINAAsgAEGIf2ohAAsgA0UNACAAQQhqIQADQCAAKQMAIBB8IRAgAEEQaiEAIANBf2oiAw0ACwsgASAQNwOAAiABQbgCakEMakEBNgIAIAFBuAJqQRRqQQA2AgAgAUHstMAANgLAAiABQcyxwAA2AsgCIAFBADYCuAIgAUG4AmoQqAEgAUG4AWpBDGoiAEECNgIAIAFBuAFqQRRqIgNBATYCACABQRo2AqQCIAEgBDYCoAIgAUGUtcAANgLAASABQQE2ArwBIAFBAzoA1AIgAUKAgICAgAQ3AswCIAFCgICAgMABNwLEAiABQoCAgIAgNwO4AiABIAFBoAJqNgLIASABIAFBuAJqNgK4ASABQbgBahCoASAAQQI2AgAgA0EBNgIAIAFBGjYCpAIgAUHAtcAANgLAASABQQE2ArwBIAEgAUGAAmo2AqACIAFBAzoA1AIgAUKAgICAgAQ3AswCIAFCgICAgMABNwLEAiABQoCAgIAgNwO4AiABIAFBoAJqNgLIASABIAFBuAJqNgK4ASABQbgBahCoASABKALwASEKAkAgCEUNACAFIAhBBHRqIQggBSEAA0AgAC0AACIDQStGDQEgAC0AASECIAEgACkDCCIQNwOQAiABIAI6AIkCIAEgAzoAiAIgASAQukQAAAAAAABZQKIgASkDgAK6ozkDmAIgAUEYNgLMASABQRs2AsQBIAFBGjYCvAEgASABQYgCajYCyAEgASABQZgCajYCwAEgASABQZACajYCuAEgAUEDOgCUAyABQoCAgICABDcCjAMgAUECNgKEAyABQoKAgIAgNwP4AiABQQM6APQCIAFBIDYC8AIgAUIENwPoAiABQgE3A+ACIAFCATcD2AIgAUEDOgDUAiABQoCAgICABDcCzAIgAUKAgICAwAE3AsQCIAFCgICAgCA3A7gCIAFBBDYCrAIgAUHYtcAANgKoAiABQQM2ArQCIAFB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IgMkAAJAAkACQAJAIAFBOGooAgAiBEUNACABQTRqKAIAIgVFDQAgBEECdCAFakF8aigCACIEQRhqLQAAQQRHDQECQAJAAkAgBEEoaiAEQTBqEP4CDQAgAUHdAGotAAANAUEAIQVBqKfAACEGQR4hBwwCCyABQShqKAIADQQgAEGDEjsBACABIAEtAGM6AGIgACACKQMANwMIIABBEGogAkEIaikDADcDACAAQRhqIAJBEGopAwA3AwAMBQsgAyACNgI8IANBzABqIgVBATYCACADQdQAaiIGQQE2AgAgA0HMhsAANgJIIANBADYCQCADQQ82AhQgAyADQRBqNgJQIAMgA0E8ajYCECADQSBqIANBwABqEGIgA0GDgMQANgJYIANBg4DEADYCTCADIAMoAiQiBDYCRCADIAQgAygCKGo2AkAgA0EQaiADQcAAahBvAkAgAygCICIHRQ0AIAQgB0EBEJQECyAFQQI2AgAgBkEBNgIAIANBEDYCDCADQZinwAA2AkggA0EANgJAIAMgA0EQajYCCCADIANBCGo2AlAgA0EgaiADQcAAahBiAkAgAygCECIERQ0AIAMoAhQgBEEBEJQECyADKAIgIQYgAygCJCEHIAMoAighCEEBIQULAkAgAUHUAGooAgAiBCABQcwAaiIJKAIARw0AIAkgBBDfASABKAJUIQQLIAFB0ABqKAIAIARBBHRqIgQgCDYCDCAEIAc2AgggBCAGNgIEIAQgBTYCACABIAEoAlRBAWo2AlQgA0EgakEQaiACQRBqKQMANwMAIANBIGpBCGogAkEIaikDADcDACADIAIpAwA3AyACQEEAKALIjlJBAkkNACADQcwAakEBNgIAIANB1ABqQQA2AgAgA0GYpcAANgJIIANBxJfAADYCUCADQQA2AkAgA0HAAGpBAkGgpcAAEIsCCyABQQE6AGcgACABQQYgA0EgahABIAFBADoAZwwDC0GsmcAAQRJBoJ3AABDuAgALQYSMwABBD0GUjMAAEMwDAAtBs6bAAEE0QeimwAAQjQMACyADQeAAaiQAC8EFAgZ/AX4jAEEgayICJAAgAUEobCEBIABBcGohA0EAIQQCQANAIAFFDQEgAiAAQRBqNgIEIAIgAEEIajYCACACQoKAgIAQNwMQIAJCgoCAgJA+NwMYIAIgAkEYajYCDCACIAJBEGo2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QQA6AAAgASABKAJUQQFqNgJUIANB0ABqJAAL0gMBBn8jAEHQAGsiAyQAAkACQCABQd0Aai0AAA0AQQAhBEHMnMAAIQVBECEGDAELIAMgAjYCHCADQTBqQQxqIgRBATYCACADQcQAaiIFQQE2AgAgA0HMhsAANgI4IANBADYCMCADQRE2AgQgAyADNgJAIAMgA0EcajYCACADQSBqIANBMGoQYiADQYOAxAA2AkggA0GDgMQANgI8IAMgAygCJCICNgI0IAMgAiADKAIoajYCMCADQRBqIANBMGoQbgJAIAMoAiAiBkUNACACIAZBARCUBAsgA0EMakEONgIAIARBAjYCACAFQQI2AgAgA0EQNgIEIANBvJzAADYCOCADQQA2AjAgAyABQeMAajYCCCADIANBEGo2AgAgAyADNgJAIANBIGogA0EwahBiAkAgAygCECICRQ0AIAMoAhQgAkEBEJQECyADKAIgIQUgAygCJCEGIAMoAighB0EBIQQLAkAgAUHUAGooAgAiAiABQcwAaiIIKAIARw0AIAggAhDfASABKAJUIQILIAFB0ABqKAIAIAJBBHRqIgIgBzYCDCACIAY2AgggAiAFNgIEIAIgBDYCACAAQQA6AAAgASABKAJUQQFqNgJUIANB0ABqJAALwAMBB38jAEHAAGsiAiQAIAIgATcDCAJAIAFCA4NQRQ0AIAGnIgMgAygCDEEBajYCDCACKQMIIQELAkAgACABEJoBQQFGDQACQAJAIABB3QBqLQAADQBBACEEQbCkwAAhBUEXIQYMAQtBASEEIAJBLGpBATYCACACQTRqQQE2AgAgAkGopMAANgIoIAJBADYCICACQRU2AjwgAiACQThqNgIwIAIgAkEIajYCOCACQRBqIAJBIGoQYiACKAIQIQUgAigCFCEGIAIoAhghBwsCQCAAQdQAaigCACIDIABBzABqIggoAgBHDQAgCCADEN8BIAAoAlQhAwsgAEHQAGooAgAgA0EEdGoiAyAHNgIMIAMgBjYCCCADIAU2AgQgAyAENgIAIAAgACgCVEEBajYCVCACKQMIIQELAkAgAUIDg0IAUg0AIAGnIgAgACgCDCIAQX9qNgIMIABBAUcNAEHMsNEAEIwDIgAgAC0AACIDQQEgAxs6AAACQCADRQ0AIAAgAUGAlOvcAxAbGgsgAEEEaiACKAII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NgJYIAIgAikDODcDUCACQTBqIAAgARACIAIoAjQhBCACKAIwIQUgAkEgaiACQdAAahCfAyACKQMgQoCU69wDfiACNQIofCAHIAApAwh9fCEHAkACQCAAKALEASIGRQ0AIAJB0ABqIAMoAgAgBiACQcgAahA6IAIoAlANACACKAJYIgZFDQAgBiACKAJcQQN0aiIGIAYpAwAgB3w3AwAMAQsgAkEQaiADIAItAEggAi0ASSAHEIABCyAFRQ0ACyAFQX9qDgIBAgELA0AgAkEIaiAAIAEQAiACKAIIIgVFDQALAkAgBUF/ag4CAQABCyACKAIMIQQMAQtBACEECyACQeAAaiQAIAQL0gICA38BfiMAQTBrIgIkAAJAAkACQAJAAkAgACgCACkDACIFpyIDQQNxDgMCAAECCyADQQR2QQ9xIgNBCEkNAyADQQdB3KzRABCkBAALAkAgBUIgiKciA0EHSw0AIANBA3RB/NPCAGohAwwCCyADQQhBzKzRABDLAgALIANBBGohAwsgAygCACEDCyAAQQRqIQQCQAJAIAMNACACQRRqQQE2AgAgAkEcakEBNgIAIAJBgK3RADYCECACQQA2AgggAkHeADYCJCACIAQ2AiAgAiACQSBqNgIYIAEgAkEIahDoAiEADAELIAJBIGpBDGpB3gA2AgAgAkEIakEMakECNgIAIAJBHGpBAjYCACACQfCs0QA2AhAgAkEANgIIIAIgBDYCKCACQeIANgIkIAIgADYCICACIAJBIGo2AhggASACQQhqEOgCIQALIAJBMGokACAAC+cCAgV/An4jAEHAAGsiAyQAAkACQCAALQAIRQ0AIAAoAgAhBEEBIQUMAQsgACgCACEEAkAgAEEEaigCACIGKAIYIgdBBHENAEEBIQUgBigCAEG179EAQb/v0QAgBBtBAkEBIAQbIAYoAgQoAgwRCgANASABIAYgAigCDBEHACEFDAELAkAgBA0AAkAgBigCAEG979EAQQIgBigCBCgCDBEKAEUNAEEBIQVBACEEDAILIAYoAhghBwtBASEFIANBAToAFyADQZTv0QA2AhwgAyAGKQIANwMIIAMgA0EXajYCECAGKQIIIQggBikCECEJIAMgBi0AIDoAOCADIAYoAhw2AjQgAyAHNgIwIAMgCTcDKCADIAg3AyAgAyADQQhqNgIYIAEgA0EY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IAJqIgIgAUkNACAAKAIAIgFBAXQiBCACIAQgAksbIgJBCCACQQhLGyICQX9zQR92IQQCQAJAIAFFDQAgA0EBNgIYIAMgATYCFCADIABBBGooAgA2AhAMAQsgA0EANgIYCyADIAIgBCADQRBqEJQCIAMoAgQhAQJAIAMoAgANACAAIAI2AgAgACABNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAEgABC8BAALEKADAAsgA0EgaiQAC9ABAQJ/IwBBIGsiAyQAAkACQCABIAJqIgIgAUkNACAAKAIAIgFBAXQiBCACIAQgAksbIgJBCCACQQhLGyICQX9zQR92IQQCQAJAIAFFDQAgA0EBNgIYIAMgATYCFCADIABBBGooAgA2AhAMAQsgA0EANgIYCyADIAIgBCADQRBqEJgCIAMoAgQhAQJAIAMoAgANACAAIAI2AgAgACABNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAEgABC8BAALEKADAAsgA0EgaiQAC9ABAQJ/IwBBIGsiAyQAAkACQCABIAJqIgIgAUkNACAAKAIAIgFBAXQiBCACIAQgAksbIgJBCCACQQhLGyICQX9zQR92IQQCQAJAIAFFDQAgA0EBNgIYIAMgATYCFCADIABBBGooAgA2AhAMAQsgA0EANgIYCyADIAIgBCADQRBqEP4BIAMoAgQhAQJAIAMoAgANACAAIAI2AgAgACABNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAEgABC8BAALEKADAAsgA0EgaiQAC+cBAQF/IwBBEGsiEyQAIAAoAgAgASACIAAoAgQoAgwRCgAhAiATQQA6AA0gEyACOgAMIBMgADYCCCATQQhqIAMgBCAFIAYQjgEgByAIIAkgChCOASALIAwgDSAOEI4BIA8gECARIBIQjgEhASATLQAMIQICQAJAIBMtAA0NACACQf8BcUEARyEADAELQQEhACACQf8BcQ0AAkAgASgCACIALQAYQQRxDQAgACgCAEG779EAQQIgACgCBCgCDBEKACEADAELIAAoAgBBuu/RAEEBIAAoAgQoAgwRCgAhAAsgE0EQaiQAIAALzgEBA38jAEEgayICJAACQAJAIAFBAWoiAUUNACAAKAIAIgNBAXQiBCABIAQgAUsbIgFBCCABQQhLGyIBQX9zQR92IQQCQAJAIANFDQAgAkEBNgIYIAIgAzYCFCACIABBBGooAgA2AhAMAQsgAkEANgIYCyACIAEgBCACQRBqEJMCIAIoAgQhAwJAIAIoAgANACAAIAE2AgAgACADNgIEDAILIAJBCGooAgAiAEGBgICAeEYNASAARQ0AIAMgABC8BAALEKADAAsgAkEgaiQAC84BAQN/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASAEIAFLGyIBQQggAUEISxsiAUF/c0EfdiEEAkACQCADRQ0AIAJBATYCGCACIAM2AhQgAiAAQQRqKAIANgIQDAELIAJBADYCGAsgAiABIAQgAkEQahCUAiACKAIEIQMCQCACKAIADQAgACABNgIAIAAgAzYCBAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIAAQvAQACxCgAwALIAJBIGokAAvkAQEBfwJAAkAgASgCJCICQYCAxABGDQAgACACNgIAIAAgAUEoaikCADcCBAJAIAEoAgBFDQAgASgCBCIAQRBJDQAgAEF+cSECAkACQCAAQQFxDQAgAUEMaigCACIAQQhqIgEgAE8NAUEAKAKgtlFBACgCpLZRQczfwAAQ7gIACyACIAIoAQAiAUF/ajYBACABQQFHDQEgAigCBCIAQQhqIgEgAEkNAwsgAiABQX9qQXhxQQhqQQQQlAQLDwtB3N/AAEEdQezgwAAQ7gIAC0EAKAKgtlFBACgCpLZRQczfwAAQ7gIAC84BAQN/IwBBIGsiAiQAAkACQCABQQFqIgFFDQAgACgCACIDQQF0IgQgASAEIAFLGyIBQQggAUEISxsiAUF/c0EfdiEEAkACQCADRQ0AIAJBATYCGCACIAM2AhQgAiAAQQRqKAIANgIQDAELIAJBADYCGAsgAiABIAQgAkEQahCYAiACKAIEIQMCQCACKAIADQAgACABNgIAIAAgAzYCBAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIAAQvAQACxCgAwALIAJBIGokAAvOAQEDfyMAQSBrIgIkAAJAAkAgAUEBaiIBRQ0AIAAoAgAiA0EBdCIEIAEgBCABSxsiAUEIIAFBCEsbIgFBf3NBH3YhBAJAAkAgA0UNACACQQE2AhggAiADNgIUIAIgAEEEaigCADYCEAwBCyACQQA2AhgLIAIgASAEIAJBEGoQ/gEgAigCBCEDAkAgAigCAA0AIAAgATYCACAAIAM2AgQMAgsgAkEIaigCACIAQYGAgIB4Rg0BIABFDQAgAyAAELwEAAsQoAMACyACQSBqJAAL4wEBAX8jAEEQayIHJAAgByAAKAIAIAEgAiAAKAIEKAIMEQoAOgAIIAcgADYCBCAHIAJFOgAJIAdBADYCACAHIAMgBBCrASAFIAYQqwEhACAHLQAIIQICQAJAIAAoAgAiAQ0AIAJB/wFxQQBHIQAMAQtBASEAIAJB/wFxDQAgBygCBCECAkAgAUEBRw0AIActAAlB/wFxRQ0AIAItABhBBHENAEEBIQAgAigCAEHA79EAQQEgAigCBCgCDBEKAA0BCyACKAIAQdzs0QBBASACKAIEKAIMEQoAIQALIAdBEGokACAAC9oBAQJ/AkACQAJAAkACQAJAIAAtAABBfmoOBAABAwQCCyAAKAIEIgFBEEkNASABQX5xIQICQAJAIAFBAXENACAAQQxqKAIAIgFBCGoiACABTw0BQQAoAqC2UUEAKAKktlFBnJnAABDuAgALIAIgAigBACIAQX9qNgEAIABBAUcNAiACKAIEIgFBCGoiACABSQ0FCyACIABBf2pBeHFBCGpBBBCUBA8LIABBCGoQVgsPCyAAQQhqEFYPCyAAQQRqEPsBDwtBACgCoLZRQQAoAqS2UUGcmcAAEO4CAAvJAQEDfyMAQTBrIgIkAEEAIQMCQCAALQAUIAEtABRHDQAgACkDACABKQMAUg0AIAJBCGogAEEIahBVIAJBGGogAUEIahBVIAIoAgwiASACKAIQIgAgAkEoahAOIAIoAhwiAyACKAIgIgQgAkEoahAOIAEgACADIAQQhwEhAyACQRhqEE0CQCACKAIYIgFFDQAgAigCHCABQShsQQgQlAQLIAJBCGoQTSACKAIIIgFFDQAgAigCDCABQShsQQgQlAQLIAJBMGokACADC/QBAQJ/IwBBIGsiASQAAkACQAJAAkACQEEALQDAj1IiAkECSQ0AIAJBfmoOAgQBBAtBAEECOgDAj1IgACgCACECIABBADYCACACRQ0BQYAIQQEQ/gMiAEUNAiACQQA6ABwgAkEAOgAYIAJBADYCFCACIAA2AhAgAkKAgICAgIABNwIIIAJCADcCAEEAQQM6AMCPUgsgAUEgaiQADwtBpLfRAEErQYzB0QAQjQMAC0GACEEBELwEAAsgAUEUakEBNgIAIAFBHGpBADYCACABQcjK0QA2AhAgAUHwttEANgIYIAFBADYCCCABQQhqQfzA0QAQsgMAC+MBAgN/AX4jAEEgayICJAACQCABKAIEDQAgASgCDCEDIAJBEGpBCGoiBEEANgIAIAJCgICAgBA3AxAgAiACQRBqNgIcIAJBHGpBqLbRACADEEcaIAFBCGogBCgCADYCACABIAIpAxA3AgALIAEpAgAhBSABQoCAgIAQNwIAIAJBCGoiAyABQQhqIgEoAgA2AgAgAUEANgIAIAIgBTcDAAJAQQxBBBD+AyIBDQBBDEEEELwEAAsgASACKQMANwIAIAFBCGogAygCADYCACAAQYzD0QA2AgQgACABNgIAIAJBIGokAAvvAQECfyMAQSBrIgUkAEEAQQAoAtiPUiIGQQFqNgLYj1ICQAJAIAZBAEgNAEEAQQAoAsiTUkEBaiIGNgLIk1IgBkECSw0AIAUgBDoAGCAFIAM2AhQgBSACNgIQIAVB1MPRADYCDCAFQfC20QA2AghBACgCyI9SIgNBf0wNAEEAIANBAWo2AsiPUgJAQQAoAtCPUkUNACAFIAAgASgCEBEGACAFIAUpAwA3AwhBACgC0I9SIAVBCGpBACgC1I9SKAIUEQYAQQAoAsiPUkF/aiEDC0EAIAM2AsiPUiAGQQFLDQAgBA0BCwALIAAgARCbBAAL7QEBAn8jAEEQayICJAAgAiAAQQRqNgIEIAEoAgBBiYfSAEEJIAEoAgQoAgwRCgAhAyACQQA6AA0gAiADOgAMIAIgATYCCCACQQhqQZKH0gBBCyAAQfSG0gAQjgFBnYfSAEEJIAJBBGpBqIfSABCOASEDIAItAAwhAAJAAkAgAi0ADQ0AIABB/wFxQQBHIQEMAQtBASEBIABB/wFxDQACQCADKAIAIgEtABhBBHENACABKAIAQbvv0QBBAiABKAIEKAIMEQoAIQEMAQsgASgCAEG679EAQQEgASgCBCgCDBEKACEBCyACQRBqJAAgAQvMAQECfyAAKAIAIgEgASgCAEF/aiIANgIAAkAgAA0AAkAgAUHIAGooAgAiAEEBakECSQ0AIAAgACgCBEF/aiICNgIEIAINACAAQdAAQQgQlAQLAkAgAUEUaigCACICRQ0AIAFBEGooAgAhAANAIAAQ+wEgAEEEaiEAIAJBf2oiAg0ACwsCQCABKAIMIgBFDQAgAUEQaigCACAAQQJ0QQQQlAQLIAFBGGoQESABQQRqIgAgACgCAEF/aiIANgIAIAANACABQdAAQQgQlAQLC8cBAQV/IwBBEGsiAyQAIAFBAnQhASAAQXxqIQQCQAJAAkADQEEAIQUgAUUNASAEIAFqIgYoAgAiACAAKAIAQQFqIgc2AgAgB0UNAiADIAA2AgwgA0EMahD7AQJAIAAgAkcNAEEBIQUMAgsgBigCACIAQRhqLQAAQQRHDQMgAEEoaiIHIABBMGoiABC9Ag0BIAcgABD8Ag0BIAFBfGohASAHIAAQqgNFDQALCyADQRBqJAAgBQ8LAAtBhIzAAEEPQZSMwAAQzAMAC9wBAQF/IwBBEGsiBSQAIAUgACgCACABIAIgACgCBCgCDBEKADoACCAFIAA2AgQgBSACRToACSAFQQA2AgAgBSADIAQQqwEhACAFLQAIIQICQAJAIAAoAgAiAQ0AIAJB/wFxQQBHIQAMAQtBASEAIAJB/wFxDQAgBSgCBCECAkAgAUEBRw0AIAUtAAlB/wFxRQ0AIAItABhBBHENAEEBIQAgAigCAEHA79EAQQEgAigCBCgCDBEKAA0BCyACKAIAQdzs0QBBASACKAIEKAIMEQoAIQALIAVBEGokACAAC9EBAAJAAkAgAkUNAAJAAkACQAJAAkACQCABQX9MDQAgAygCCA0BIAENAkEBIQIMBAsgAEEIakEANgIADAYLAkAgAygCBCICDQACQCABDQBBASECDAQLIAFBARD+AyECDAILIAMoAgAgAkEBIAEQ9QMhAgwBCyABQQEQ/gMhAgsgAkUNAQsgACACNgIEIABBCGogATYCACAAQQA2AgAPCyAAIAE2AgQgAEEIakEBNgIAIABBATYCAA8LIAAgATYCBCAAQQhqQQA2AgALIABBATYCAAvcAQEBfyMAQRBrIg8kACAAKAIAIAEgAiAAKAIEKAIMEQoAIQIgD0EAOgANIA8gAjoADCAPIAA2AgggD0EIaiADIAQgBSAGEI4BIAcgCCAJIAoQjgEgCyAMIA0gDhCOASEBIA8tAAwhAgJAAkAgDy0ADQ0AIAJB/wFxQQBHIQAMAQtBASEAIAJB/wFxDQACQCABKAIAIgAtABhBBHENACAAKAIAQbvv0QBBAiAAKAIEKAIMEQoAIQAMAQsgACgCAEG679EAQQEgACgCBCgCDBEKACEACyAPQRBqJAAgAAvFAQEFfyMAQRBrIgEkAAJAAkAgAEE0aigCACICIABBOGooAgAiAxDOAUUNAAJAIANFDQAgA0F/aiEEIANBAnQgAmpBfGohAyAAQThqIQUDQCADKAIAIgJBGGotAABBBEcNAyACQShqIAJBMGoQnQJFDQEgBSAENgIAIAEgAygCADYCDCADQXxqIQMgAUEMahD7ASAEQX9qIgRBf0cNAAsLIABCgoCAgKDYABB3CyABQRBqJAAPC0GEjMAAQQ9BlIzAABDMAwALwwEBBH8jAEEQayIBJAACQAJAAkAgAEE4aigCACICRQ0AIABBNGooAgAiA0UNACACQX9qIQQgAkECdCADakF8aiECIABBOGohAwNAIAIoAgAiAEEYai0AAEEERw0DIABBKGogAEEwahCrAw0CIAMgBDYCACABIAIoAgA2AgwgAkF8aiECIAFBDGoQ+wEgBEF/aiIEQX9HDQALC0GsmcAAQRJBoJ3AABDuAgALIAFBEGokAA8LQYSMwABBD0GUjMAAEMwDAAvDAQEEfyMAQRBrIgEkAAJAAkACQCAAQThqKAIAIgJFDQAgAEE0aigCACIDRQ0AIAJBf2ohBCACQQJ0IANqQXxqIQIgAEE4aiEDA0AgAigCACIAQRhqLQAAQQRHDQMgAEEoaiAAQTBqEKwDDQIgAyAENgIAIAEgAigCADYCDCACQXxqIQIgAUEMahD7ASAEQX9qIgRBf0cNAAsLQayZwABBEkGgncAAEO4CAAsgAUEQaiQADwtBhIzAAEEPQZSMwAAQzAMAC8MBAQR/IwBBEGsiASQAAkACQAJAIABBOGooAgAiAkUNACAAQTRqKAIAIgNFDQAgAkF/aiEEIAJBAnQgA2pBfGohAiAAQThqIQMDQCACKAIAIgBBGGotAABBBEcNAyAAQShqIABBMGoQ/QINAiADIAQ2AgAgASACKAIANgIMIAJBfGohAiABQQxqEPsBIARBf2oiBEF/Rw0ACwtBrJnAAEESQaCdwAAQ7gIACyABQRBqJAAPC0GEjMAAQQ9BlIzAABDMAwALywEBA38CQCAAQRhqLQAAQQRHDQBBACECAkAgAEEoaikDAEKCgICA8ABSDQAgAEEwaikDACABUSECCwJAIAFCA4NCAFINACABpyIDIAMoAgwiAEF/ajYCDCAAQQFHDQBBzLDRABCMAyIAIAAtAAAiBEEBIAQbOgAAAkAgBEUNACAAIAFBgJTr3AMQGxoLIABBBGogAxDQAiAAQQAgAC0AACIDIANBAUYiAxs6AAAgAw0AIABBABBKCyACDwtBhIzAAEEPQZSMwAAQzAMAC88BAQJ/IwBBEGsiAyQAAkACQCABQThqKAIARQ0AIAFBNGooAgAhBCADQQtqIAJBCGooAAA2AAAgAyACKQAANwADQdAAQQgQ/gMiAkUNASACQQM6ABggAkIENwMQIAJCADcDCCACQoGAgIAQNwMAIAIgAykAADcAGSACQQA2AkggAkEgaiADQQdqKQAANwAAIANBADYCACADIAI2AgQgAUHIAGogBCADEF0gAEEAOgAAIANBEGokAA8LQQBBAEGorsAAEMsCAAtB0ABBCBC8BAAL2gEBAn8jAEHAAGsiAiQAAkACQAJAAkACQCAAKAIAIgAoAgBBA3EOAwABAgALIAJB6KnRADYCCEEHIQMMAwsgAkHiqdEANgIIDAELIAJB3KnRADYCCAtBBiEDCyACIAM2AgwgAkEQakEMakEDNgIAIAJBJGpBAjYCACACQShqQQxqQd0ANgIAIAJBgKrRADYCGCACQQA2AhAgAkHeADYCLCACIAA2AjwgAiACQShqNgIgIAIgAkEIajYCMCACIAJBPGo2AiggASACQRBqEOgCIQAgAkHAAGokACAAC9oBAQJ/IwBBwABrIgIkAAJAAkACQAJAAkAgACgCACIAKAIAQQNxDgMAAQIACyACQeip0QA2AghBByEDDAMLIAJB4qnRADYCCAwBCyACQdyp0QA2AggLQQYhAwsgAiADNgIMIAJBEGpBDGpBAzYCACACQSRqQQI2AgAgAkEoakEMakHdADYCACACQYCq0QA2AhggAkEANgIQIAJB3wA2AiwgAiAANgI8IAIgAkEoajYCICACIAJBCGo2AjAgAiACQTxqNgIoIAEgAkEQahDoAiEAIAJBwABqJAAgAAu1AQEDfwJAAkAgAkEPSw0AIAAhAwwBCyAAQQAgAGtBA3EiBGohBQJAIARFDQAgACEDA0AgAyABOgAAIANBAWoiAyAFSQ0ACwsgBSACIARrIgRBfHEiAmohAwJAIAJBAUgNACABQf8BcUGBgoQIbCECA0AgBSACNgIAIAVBBGoiBSADSQ0ACwsgBEEDcSECCwJAIAJFDQAgAyACaiEFA0AgAyABOgAAIANBAWoiAyAFSQ0ACwsgAAvTAQECfyMAQcAAayICJAACQAJAAkACQAJAIAAoAgBBA3EOAwABAgALIAJBg5jAADYCCEEHIQMMAwsgAkH9l8AANgIIDAELIAJB95fAADYCCAtBBiEDCyACIAM2AgwgAkEQakEMakEDNgIAIAJBJGpBAjYCACACQShqQQxqQRI2AgAgAkGYmMAANgIYIAJBADYCECACQRM2AiwgAiAANgI8IAIgAkEoajYCICACIAJBCGo2AjAgAiACQTxqNgIoIAEgAkEQahDoAiEAIAJBwABqJAAgAAvVAQECfyMAQcAAayICJAACQAJAAkACQAJAIAAoAgBBA3EOAwABAgALIAJBnIDBADYCCEEHIQMMAwsgAkGWgMEANgIIDAELIAJBkIDBADYCCAtBBiEDCyACIAM2AgwgAkEQakEMakEDNgIAIAJBJGpBAjYCACACQShqQQxqQcAANgIAIAJBtIDBADYCGCACQQA2AhAgAkHEADYCLCACIAA2AjwgAiACQShqNgIgIAIgAkEIajYCMCACIAJBPGo2AiggASACQRBqEOgCIQAgAkHAAGokACAAC9YBAgV/A34jAEHQAGsiAyQAQQAoAriOUiEEQQAoArSOUiEFQQAoAsSOUiEGIAIpAgAhCCACKAIYIQcgAikCCCEJIAIpAhAhCiADQTBqIAE2AgAgA0HEAGogCjcCACADQThqIAk3AwAgA0EkaiAHNgIAIAMgCDcDKCADQQA2AkAgA0EANgI0IANBATYCICADIAApAhA3AxggAyAAKQIINwMQIAMgACkCADcDCCAFQfCRwQAgBkECRiICGyADQQhqIARB/JHBACACGygCFBEGACADQdAAaiQAC9UBAQJ/IwBBwABrIgIkAAJAAkACQAJAAkAgACgCAEEDcQ4DAAECAAsgAkG8q9EANgIIQQchAwwDCyACQbar0QA2AggMAQsgAkGwq9EANgIIC0EGIQMLIAIgAzYCDCACQRBqQQxqQQM2AgAgAkEkakECNgIAIAJBKGpBDGpB3QA2AgAgAkHUq9EANgIYIAJBADYCECACQeIANgIs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A4NCAFINACADpyIBIAEoAgwiAUF/ajYCDCABQQFHDQBBzLDRABCMAyIBIAEtAAAiAkEBIAIbOgAAAkAgAkUNACABIANBgJTr3AMQGxoLIAFBBGogACgCABDQAiABQQAgAS0AACIAIABBAUYiABs6AAAgAA0AIAFBABBKCwuMAQICfwF+AkAgACkDACIDQgODQgBSDQAgA6ciASABKAIMIgFBf2o2AgwgAUEBRw0AQcyw0QAQjAMiASABLQAAIgJBASACGzoAAAJAIAJFDQAgASADQYCU69wDEBsaCyABQQRqIAAoAgAQ0AIgAUEAIAEtAAAiACAAQQFGIgAbOgAAIAANACABQQAQSgsLjQEBAn8CQCAAQThqKAIAIgENAEEADwsCQAJAAkACQCABQQFHDQAgACgCECICDQELIABBNGooAgAiAEUNASABQQJ0IABqQXxqKAIAIQILIAJBGGotAABBBEcNASACQShqKQMAQoKAgIDwAFIPC0GsmcAAQRJBoJ3AABDuAgALQYSMwABBD0GUjMAAEMwDAAuWAQECfyMAQRBrIgIkAAJAAkACQAJAAkAgACgCACIDLQAAQX5qQf8BcSIAQQMgAEEDSRsOBAABAgMACyABQcWDwQBBBhD6AyEADAMLIAFBvoPBAEEHEPoDIQAMAgsgAUG0g8EAQQoQ+gMhAAwBCyACIAM2AgwgAUGQg8EAQREgAkEMakGkg8EAEP0BIQALIAJBEGokACAAC4ABAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEIakEMakEDNgIAIAJBHGpBAjYCACACQSBqQQxqQTA2AgAgAkGk09EANgIQIAJBADYCCCACQTA2AiQgAiACQSBqNgIYIAIgAkEEajYCKCACIAI2AiAgAkEIakG809EAELIDAAt9AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EIakEMakEDNgIAIANBHGpBAjYCACADQSBqQQxqQTA2AgAgA0Hg09EANgIQIANBADYCCCADQTA2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACELIDAAt9AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EIakEMakECNgIAIANBHGpBAjYCACADQSBqQQxqQTA2AgAgA0HU7dEANgIQIANBADYCCCAD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ADYCECADQcSXwAA2AhggA0EANgIIIANBCGpBAkGgpcAAEIsCCyABQQE6AGcgACABQQYgAhABIAFBADoAZyADQSBqJAALbgECfyABKAIAIQQCQCABKAIIIgVFDQAgBCAFayADTw0AQQAhBSABQQA2AgggAUEAOgAMCwJAIAQgA00NACABKAIEIAVqIAIgAxDEBBogAEEEOgAAIAEgBSADajYCCA8LIABCBDcCACABQQA6AAwLegEDfyMAQRBrIgIkAAJAIAEoAgQNACABKAIMIQMgAkEIaiIEQQA2AgAgAkKAgICAEDcDACACIAI2AgwgAkEMakGottEAIAMQRxogAUEIaiAEKAIANgIAIAEgAikDADcCAAsgAEGMw9EANgIEIAAgATYCACACQRBqJAALZwEBfyMAQSBrIgIkACAAKAIAIQAgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAiAANgIEIAJBBGpBrJXAACACQQhqEEchASACQSBqJAAgAQtnAQF/IwBBIGsiAiQAIAAoAgAhACACQQhqQRBqIAFBEGopAgA3AwAgAkEIakEIaiABQQhqKQIANwMAIAIgASkCADcDCCACIAA2AgQgAkEEakHY3sAAIAJBCGoQRyEBIAJBIGokACABC2cBAX8jAEEgayICJAAgACgCACEAIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAIgADYCBCACQQRqQai20QAgAkEIahBHIQEgAkEgaiQAIAELZwEBfyMAQSBrIgIkACAAKAIAIQAgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAiAANgIEIAJBBGpBwLbRACACQQhqEEchASACQSBqJAAgAQtnAQF/IwBBIGsiAiQAIAAoAgAhACACQQhqQRBqIAFBEGopAgA3AwAgAkEIakEIaiABQQhqKQIANwMAIAIgASkCADcDCCACIAA2AgQgAkEEakHYttEAIAJBCGoQRyEBIAJBIGokACABC2cBAX8jAEEgayICJAAgACgCACEAIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAIgADYCBCACQQRqQejQ0QAgAkEIahBHIQEgAkEgaiQAIAELZwEBfyMAQSBrIgIkACAAKAIAIQAgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAiAANgIEIAJBBGpBzPHRACACQQhqEEchASACQSBqJAAgAQtoAQF/IwBBIGsiBSQAIAUgAjYCBCAFIAE2AgAgBUEIakEQaiADQRBqKQIANwMAIAVBCGpBCGogA0EIaikCADcDACAFIAMpAgA3AwggACAFQbyGwAAgBUEEakG8hsAAIAVBCGogBBB0AAtuAQF/IwBBIGsiAiQAIAJB8LbRADYCBCACIAA2AgAgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwhBACACQZS30QAgAkEEakGUt9EAIAJBCGpBgMrRABB0AAtrAQF/IwBBIGsiAyQAIAMgATYCBCADIAA2AgAgA0EIakEQaiACQRBqKQIANwMAIANBCGpBCGogAkEIaikCADcDACADIAIpAgA3AwhBACADQeTt0QAgA0EEakHk7dEAIANBCGpBhNXRABB0AAtjAQF/IAEgASgCAEEBaiICNgIAAkAgAkUNAAJAIABBOGooAgAiAiAAKAIwRw0AIABBMGogAhDeASAAKAI4IQILIABBNGooAgAgAkECdGogATYCACAAIAAoAjhBAWo2AjgPCwALYQECfyMAQSBrIgIkACAAKAIEIQMgACgCACEAIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAAgAyACQQhqEEchASACQSBqJAAgAQtgAQF/IwBBIGsiAiQAIAIgADYCBCACQQhqQRBqIAFBEGopAgA3AwAgAkEIakEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQayVwAAgAkEIahBHIQEgAkEgaiQAIAELYAEBfyMAQSBrIgIkACACIAA2AgQgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakHY3sAAIAJBCGoQRyEBIAJBIGokACABC2ABAX8jAEEgayICJAAgAiAANgIEIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBwLbRACACQQhqEEchASACQSBqJAAgAQtgAQF/IwBBIGsiAiQAIAIgADYCBCACQQhqQRBqIAFBEGopAgA3AwAgAkEIakEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQdi20QAgAkEIahBHIQEgAkEgaiQAIAELZAECfyMAQRBrIgIkACAAKAIIIQMgACgCBCEAIAIgARDLAwJAIANFDQADQCACIAA2AgwgAiACQQxqQYDR0QAQqAQaIABBAWohACADQX9qIgMNAAsLIAIQvwMhACACQRBqJAAgAAtnAQF/IwBBMGsiAyQAIAMgATYCDCADIAA2AgggA0EcakEBNgIAIANBJGpBATYCACADQYTt0QA2AhggA0EANgIQIANBnwE2AiwgAyADQShqNgIgIAMgA0EIajYCKCADQRBqIAIQsgMAC2ABAX8jAEEgayICJAAgAiAANgIEIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBzPHRACACQQhqEEchASACQSBqJAAgAQtfAQF/AkAgAEEMaigCACICIAAoAgRHDQAgAEEEaiACEN8BIAAoAgwhAgsgAEEIaigCACACQQR0aiICIAEpAgA3AgAgAkEIaiABQQhqKQIANwIAIAAgACgCDEEBajYCDAuHAQIBfwF+QQAhAgJAIAApAwBCgoCAgPAAUg0AAkACQCABKQMAIgNCgYCAgMDPAFUNACADQoKAgICwFVENASADQoKAgIDQKFENASADQoKAgICQKVENAQwCCyADQoKAgICAhwFRDQAgA0KCgICAgIQBUQ0AIANCgoCAgMDPAFINAQtBASECCyACC3QBAX8jAEEQayICJAAgAiAAKAIAIgBBCGo2AgwgAUGSgsEAQQNBlYLBAEEEIABBFGpBnILBAEG/gcEAQQQgAEGsgsEAQbyCwQBBDCAAQRVqQciCwQBB2ILBAEEFIAJBDGpB4ILBABDuASEAIAJBEGokACAAC2kBAX8jAEEQayICJAACQAJAIAAoAgANACACIABBBGo2AgggAUHEqdEAQQcgAkEIakHMqdEAEP0BIQAMAQsgAiAAQQRqNgIMIAFBqKnRAEEKIAJBDGpBtKnRABD9ASEACyACQRBqJAAgAAtpAQR/IwBBEGsiAyQAQQAoAriOUiEEQQAoArSOUiEFQQAoAsSOUiEGIAMgAjYCBCADIAE2AgAgAyAANgIIIAVB8JHBACAGQQJGIgIbIAMgBEH8kcEAIAIbKAIQEQcAIQIgA0EQaiQAIAILXwECf0EAIQJBBCEDAkAgAUEFSQ0AIAEhAwJAAkAgAUF7ag4CAgEACyABQXlqIQFBASECQQYhAwwBC0EAIQFBASECQQUhAwsgACACNgIEIAAgAzYCACAAQQhqIAE2AgALZAICfwF+Qcyw0QAQjAMiASABLQAAIgJBASACGzoAAAJAIAJFDQAgASADQYCU69wDEBsaCyABQQRqIAAoAgAQ0AIgAUEAIAEtAAAiAiACQQFGIgIbOgAAAkAgAg0AIAFBABBKCwtvAQF/IwBBEGsiAiQAIAIgAEEwajYCDCABQbiBwQBBB0G/gcEAQQQgAEHEgcEAQdSBwQBBCSAAQRBqQcSBwQBB3YHBAEEJIABBIGpBxIHBAEHmgcEAQQwgAkEMakH0gcEAEO4BIQAgAkEQaiQAIAALbwEBfyMAQRBrIgIkACACIABBCGo2AgwgAUGSgsEAQQNBlYLBAEEEIABBFGpBnILBAEG/gcEAQQQgAEGsgsEAQbyCwQBBDCAAQRVqQciCwQBB2ILBAEEFIAJBDGpB4ILBABDuASEAIAJBEGokACAAC1sAAkACQCABRQ0AIABFDQAgAUECdCAAakF8aigCACIBQRhqLQAAQQRHDQEgAUEoaiABQTBqEPECDwtBrJnAAEESQaCdwAAQ7gIAC0GEjMAAQQ9BlIzAABDMAwALUgECfwJAIAAoAggiAyABTQ0AIAAoAgQgAUECdGoiAigCACEEIAIgAkEEaiADIAFBf3NqQQJ0EMEEGiAAIANBf2o2AgggBA8LIAEgAyACEMoCAAtgAQF/IwBBIGsiAiQAAkAgAQ0AIABBADYCBCACQSBqJAAPCyACQRRqQQE2AgAgAkEcakEANgIAIAJB/M/RADYCECACQeDP0QA2AhggAkEANgIIIAJBCGpB2NDRABCyAwALeAIBfwF+QQAhAgJAIAApAwBCgoCAgOAAUg0AAkACQCABKQMAIgNCgYCAgJA2VQ0AIANCgoCAgPACUQ0BIANCgoCAgIAYUQ0BDAILIANCgoCAgJA2UQ0AIANCgoCAgODJAFENACADQoKAgIDQO1INAQtBASECCyACC3sCAX8BfkEAIQICQCAAKQMAQoKAgIDwAFINAAJAAkAgASkDACIDQoGAgICQzQBVDQAgA0KCgICA0AVRDQEgA0KCgICA4AdRDQEMAgsgA0KCgICAkM0AUQ0AIANCgoCAgKDmAFENACADQoKAgIDQ8gBSDQELQQEhAgsgAgt7AgF/AX5BACECAkAgACkDAEKCgICA8ABSDQACQAJAIAEpAwAiA0KBgICAkM0AVQ0AIANCgoCAgNAFUQ0BIANCgoCAgIA3UQ0BDAILIANCgoCAgJDNAFENACADQoKAgICA0gBRDQAgA0KCgICA0PIAUg0BC0EBIQILIAILXAECfyABKAIAIQIgAUEANgIAAkACQCACRQ0AIAEoAgQhA0EIQQQQ/gMiAUUNASABIAM2AgQgASACNgIAIABB5JXAADYCBCAAIAE2AgAPCxDiBAALQQhBBBC8BAALUwEBfyMAQSBrIgMkACADQQxqIAJBCGooAgA2AgAgA0EBNgIAIAMgAikCADcCBCADQRBqIAFBABA7IAEgA0EQaiADEJECIABBADoAACADQSBqJAALXAECfyABKAIAIQIgAUEANgIAAkACQCACRQ0AIAEoAgQhA0EIQQQQ/gMiAUUNASABIAM2AgQgASACNgIAIABB5LLRADYCBCAAIAE2AgAPCxDiBAALQQhBBBC8BAALYgEDfyMAQRBrIgEkAAJAAkAgABDVBCICRQ0AIAAQ1AQiA0UNASABIAI2AgggASAANgIEIAEgAzYCACABEMoEAAtBpLfRAEErQfzC0QAQjQMAC0Gkt9EAQStB7MLRABCNAwALVgEBfwJAIAAoAggiAiAAKAIARw0AIAAgAhDfASAAKAIIIQILIAAoAgQgAkEEdGoiAiABKQIANwIAIAJBCGogAUEIaikCADcCACAAIAAoAghBAWo2AggLWgEEfwJAAkAgACgCBCIBIAAoAgAiAkYNAANAIAAgAUEQaiIDNgIEQQEhBAJAAkAgAS0AAA4DAAEEAAsgAUEEahCfAQ0DCyADIQEgAyACRw0ACwtBACEECyAEC1oBAn8jAEEQayICJAAgACgCACEDIABBADYCAAJAIAMNAEGI4sAAQStBtOLAABCNAwALIAJBCGogAEEMaigCADYCACACIAApAgQ3AwAgASACELIBIAJB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NAAgACgCACEAAkAgARCSBA0AAkAgARCTBA0AIAAgARCmBA8LIAAgARCxAg8LIAAgARCwAgs0ACAAKAIAIQACQCABEJIEDQACQCABEJMEDQAgACABEKYEDwsgACABELECDwsgACABELACCzQAAkAgACABEHgiAUUNAAJAQYSQ0gAQ6wRFDQAgARDPBBCeBA0BCyABQQAgABDDBBoLIAELNAAgACgCACEAAkAgARCSBA0AAkAgARCTBA0AIAAgARCnBA8LIAAgARCoAg8LIAAgARCpAgs5ACAAQYCAxAA2AiQgACABNgIgIABBADYCECAAQQA7AUAgAEKAgMQANwIwIABBADYCACAAQgA3AhgLKgEBfyAAIAAoAhAiAUENdCABcyIBQRF2IAFzIgFBBXQgAXMiATYCECABCzMBAX8CQAJAIAAtAKcCDQAgARCkASICQYCAxABGDQEgACACIAEQeRoPCyAAQQA6AKcCCws5AAJAAkAgAEGAgMQARg0AIABBgLADc0GAgLx/akH/j7x/Sw0BC0HM4cAAQStB+OHAABDuAgALIAALMwEBf0EAIQICQCAAKAIAKQMAIAEoAgApAwBSDQAgACgCBCkDACABKAIEKQMAUSECCyACCzUBAX9BASEBAkAgAC0ABA0AIAAoAgAiACgCAEHU79EAQQEgAEEEaigCACgCDBEKACEBCyABCzEAIAAgASgCACACIAMgASgCBCgCDBEKADoACCAAIAE2AgQgACADRToACSAAQQA2AgALLgEBfyMAQRBrIgEkACABIAApAgA3AwggAUEIakGovsAAQQAgACgCCEEBEPkBAAs8AgF/AX5BASECAkAgACkDAEKCgICA8ABSDQAgASkDACIDQoKAgIDw2QBSIANCgoCAgMDuAFJxIQILIAILOwIBfwF+QQAhAgJAIAApAwBCgoCAgPAAUg0AIAEpAwAiA0KCgICA8DFRIANCgoCAgMD1AFFyIQILIAILPAIBfwF+QQAhAgJAIAApAwBCgoCAgPAAUg0AIAEpAwAiA0KCgICAoPQAUSADQoKAgIDQyABRciECCyACCy4BAX8jAEEQayIBJAAgASAAKQIANwMIIAFBCGpB0LLRAEEAIAAoAghBARD5AQALLQACQAJAIAEQkgQNACABEJMEDQEgACABENQDDwsgACABELACDwsgACABELECCycAIAAgACgCBEEBcSABckECcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsoACAAKAIAIAAtAAhqIAAoAgRBgIC8f2oiAEEDIABBA0kbIABBAksbCzEAIABBAzoAICAAQoCAgICABDcCGCAAQQA2AhAgAEEANgIIIAAgAjYCBCAAIAE2AgALLQAgASgCACACIAMgASgCBCgCDBEKACEDIABBADoABSAAIAM6AAQgACABNgIACzIBAX8gASgCAEGM7dEAQQEgASgCBCgCDBEKACECIABBADoABSAAIAI6AAQgACABNgIACygBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAxDFBAALJQEBfyMAQRBrIgIkACACIABBABA7IAAgAiABEJECIAJBEGokAAsiACAAIABBIGpBgIDEACAAQb9/akEaSRsgAEGff2pBGkkbCygBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAxDHBAALJwEBfwJAIABBBGooAgAiAUUNACAAKAIAIgBFDQAgASAAQQEQlAQLCyYBAn9BACECAkAgACgCACIDIAFLDQAgAyAAKAIEaiABSyECCyACCygAAkACQCABQfz///8HSw0AIAAgAUEEIAIQ9QMiAQ0BCxDQBAALIAELIwAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgALHwAgACgCACIArUIAIACsfSAAQX9KIgAbIAAgARCdAQsoACABIAAoAgAtAABBAnQiAEHsicEAaigCACAAQeCJwQBqKAIAEPoDCyUAIAEgAC0AAEECdCIAQfyQwQBqKAIAIABBoJDBAGooAgAQ+gMLJQAgASAALQAAQQJ0IgBB5JHBAGooAgAgAEHYkcEAaigCABD6AwslACABIAAtAABBAnQiAEG8ztEAaigCACAAQZjN0QBqKAIAEPoDCx4AIAAgAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAsgAAJAIAENACAAIAM2AgQgACACNgIADwsgAiADELwEAAsgAQF/AkAgACgCCCIBRQ0AIABBDGooAgAgAUEBEJQECwsgAQF/AkAgACgCACIBRQ0AIABBBGooAgAgAUEBEJQECwsXACAAQVBqQQpJIABBX3FBv39qQRpJcgsjACABQfCCwQBB/YLBACAAKAIA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dC5sZW4oKbwAEABbAAAAHAcAAAUAAAC8ABAAWwAAAJwEAAAWAAAAvAAQAFsAAADcBAAAFgAAAGFzc2VydGlvbiBmYWlsZWQ6IGVkZ2UuaGVpZ2h0ID09IHNlbGYubm9kZS5oZWlnaHQgLSAxAAAAvAAQAFsAAADdAwAACQAAAC9ydXN0Yy85MGM1NDE4MDZmMjNhMTI3MDAyZGU1YjQwMzhiZTczMWJhMTQ1OGNhL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25hdmlnYXRlLnJzAAgCEABfAAAAWQIAADAAAAAIAhAAXwAAABcCAAAvAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvcGhmX3NoYXJlZC0wLjguMC9zcmMvbGliLnJzAAAAAAAAAAAAAABhdHRlbXB0IHRvIGNhbGN1bGF0ZSB0aGUgcmVtYWluZGVyIHdpdGggYSBkaXZpc29yIG9mIHplcm8AAACIAhAAXQAAADoAAAAFAAAAAQAAAAQAAAAEAAAAAgAAADwDEAAAAAAAAAAAAP//////////L2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnNgAxAAXAAAAB0AAAAuAAAAYAMQAFwAAABWAAAAOwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL3RlbmRyaWwucnMAANwDEABeAAAArgMAAD0AAABjaGlsZCBwYXNzZWQgdG8gYXBwZW5kIGNhbm5vdCBoYXZlIGV4aXN0aW5nIHBhcmVudC9ob21lL2ItZnVzZS9Qcm9qZWN0cy9naXQvZGVuby1kb20vaHRtbC1wYXJzZXIvY29yZS9zcmMvcmNkb20ucnMAAH4EEABAAAAAkgAAAAUAAABhbHJlYWR5IGJvcnJvd2VkAwAAAAAAAAABAAAABAAAAH4EEABAAAAAlwAAABkAAABkYW5nbGluZyB3ZWFrIHBvaW50ZXIgdG8gcGFyZW50YWxyZWFkeSBtdXRhYmx5IGJvcnJvd2VkAAMAAAAAAAAAAQAAAAUAAAB+BBAAQAAAAKEAAAAKAAAAaGF2ZSBwYXJlbnQgYnV0IGNvdWxkbid0IGZpbmQgaW4gcGFyZW50J3MgY2hpbGRyZW4hAH4EEABAAAAApwAAABEAAAB+BBAAQAAAAJ0AAAAhAAAAfgQQAEAAAACvAAAAFgAAAH4EEABAAAAAuAAAABkAAAB+BBAAQAAAALgAAAAmAAAAbm90IGEgdGVtcGxhdGUgZWxlbWVudCEAfgQQAEAAAADhAAAADQAAAG5vdCBhbiBlbGVtZW50IQB+BBAAQAAAAPAAAAASAAAAfgQQAEAAAAAUAQAALgAAAGFwcGVuZF9iZWZvcmVfc2libGluZyBjYWxsZWQgb24gbm9kZSB3aXRob3V0IHBhcmVudAB+BBAAQAAAADIBAAAwAAAAfgQQAEAAAAAzAQAAHQAAAH4EEABAAAAARgEAABkAAAB+BBAAQAAAACgBAAAOAAAAbm90IGFuIGVsZW1lbnQAAH4EEABAAAAAbgEAAA0AAAB+BBAAQAAAAGwBAAATAAAAfgQQAEAAAACBAQAAKgAAAH4EEABAAAAAggEAADQAAABkYW5nbGluZyB3ZWFrYXNzZXJ0aW9uIGZhaWxlZDogUmM6OnB0cl9lcSgmbm9kZSwgJnByZXZpb3VzX3BhcmVudC51bndyYXAoKS51cGdyYWRlKCkuZXhwZWN0KFwiZGFuZ2xpbmcgd2Vha1wiKSkAfgQQAEAAAACFAQAADQAAAH4EEABAAAAAhwEAADUAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAH4EEABAAAAAhwEAACIAAAB+BBAAQAAAAJUBAAANAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvbWFya3VwNWV2ZXItMC4xMC4xL3V0aWwvYnVmZmVyX3F1ZXVlLnJzAAAA1AcQAGkAAADVAAAAFQAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUABgAAAAEAAAABAAAABwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL3RlbmRyaWwucnMAAIwIEABeAAAAXQMAAB8AAAAAAAAA1AcQAGkAAADmAAAAFQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJzEAkQAFwAAAAdAAAALgAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3BoZl9zaGFyZWQtMC44LjAvc3JjL2xpYi5ycwAAAHwJEABdAAAAOQAAABoAAAAAAAAAYXR0ZW1wdCB0byBjYWxjdWxhdGUgdGhlIHJlbWFpbmRlciB3aXRoIGEgZGl2aXNvciBvZiB6ZXJvAAAAfAkQAF0AAAA6AAAABQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3N0cmluZ19jYWNoZS0wLjguMi9zcmMvYXRvbS5yczwKEABgAAAAjwAAABsAAAAIAAAABAAAAAQAAAAJAAAACgAAAAsAAAA8ChAAYAAAAAcBAAAfAAAAPAoQAGAAAAAFAQAALwAAAAgAAAAIAAAABAAAAAwAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlABYAAAABAAAAAQAAAAcAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy90ZW5kcmlsLnJzAAAwCxAAXgAAAF0DAAAfAAAAQmFkIERPQ1RZUEU6IAAAAKALEAANAAAAQmFkIERPQ1RZUEUARE9DVFlQRSBpbiBpbnNlcnRpb24gbW9kZSAAAMQLEAAaAAAARE9DVFlQRSBpbiBib2R5c3RhdGljaW5saW5lZHluYW1pY0F0b20oJycgdHlwZT0pCgwQAAYAAAAQDBAABwAAABcMEAABAAAAMAsQAF4AAABXAAAANQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJzQAwQAFwAAAAdAAAALgAAAG5vIGN1cnJlbnQgZWxlbWVudC9ob21lL2ItZnVzZS9Qcm9qZWN0cy9naXQvZGVuby1kb20vaHRtbC1wYXJzZXIvd2FzbS90YXJnZXQvd2FzbTMyLXVua25vd24tdW5rbm93bi9yZWxlYXNlL2J1aWxkL2h0bWw1ZXZlci1lMzg4OGViMTExMTM3YTI1L291dC9ydWxlcy5ycwAAAL4MEACHAAAACAAAABgAAABodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcnByb2Nlc3NpbmcgIGluIGluc2VydGlvbiBtb2RlIAAAAG8NEAALAAAAeg0QABMAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9odG1sNWV2ZXItMC4yNS4xL3NyYy90cmVlX2J1aWxkZXIvbW9kLnJzAABYDRAAFwAAAFgNEAAXAAAAoA0QAGoAAAA4AQAAVW5leHBlY3RlZCB0b2tlbiAAAAAoDhAAEQAAAHoNEAATAAAAVW5leHBlY3RlZCB0b2tlbmFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaHRtbF9lbGVtX25hbWVkKCZub2RlLCBuYW1lKQCgDRAAagAAAFsCAAAJAAAAoA0QAGoAAACJAgAAIAAAAGltcG9zc2libGUgY2FzZSBpbiBmb3JlaWduIGNvbnRlbnQAAL4MEACHAAAAYwYAABAAAAC+DBAAhwAAAFoGAAAsAAAAVW5leHBlY3RlZCBvcGVuIHRhZyAgYXQgZW5kIG9mIGJvZHkA9A4QABQAAAAIDxAADwAAAFVuZXhwZWN0ZWQgb3BlbiB0YWcgYXQgZW5kIG9mIGJvZHlleHBlY3RlZCB0byBjbG9zZSA8dGQ+IG9yIDx0aD4gd2l0aCBjZWxsY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAAAKANEABqAAAAIQUAADAAAABGb3JtYXR0aW5nIGVsZW1lbnQgbm90IGluIHNjb3BlRm9ybWF0dGluZyBlbGVtZW50IG5vdCBjdXJyZW50IG5vZGUAAKANEABqAAAA6gIAACMAAACgDRAAagAAAPwCAAAYAAAAYm9va21hcmsgbm90IGZvdW5kIGluIGFjdGl2ZSBmb3JtYXR0aW5nIGVsZW1lbnRzZm9ybWF0dGluZyBlbGVtZW50IG5vdCBmb3VuZCBpbiBhY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50cwAAoA0QAGoAAABeAwAALAAAAKANEABqAAAAXQMAABoAAACgDRAAagAAAFgDAAAaAAAAZnVydGhlc3QgYmxvY2sgbWlzc2luZyBmcm9tIG9wZW4gZWxlbWVudCBzdGFjawAAoA0QAGoAAABoAwAAEgAAAKANEABqAAAAUgMAABoAAACgDRAAagAAAAcDAAAlAAAARm91bmQgbWFya2VyIGR1cmluZyBhZG9wdGlvbiBhZ2VuY3kAoA0QAGoAAAAaAwAAHwAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuc2luay5zYW1lX25vZGUoaCwgJm5vZGUpAKANEABqAAAAFwMAABkAAACgDRAAagAAACMDAAARAAAAoA0QAGoAAAAkAwAAEQAAAKANEABqAAAADwMAACkAAACgDRAAagAAAOUCAAAsAAAARm9ybWF0dGluZyBlbGVtZW50IG5vdCBvcGVuAKANEABqAAAAyAIAACwAAACgDRAAagAAAAYDAABAAAAAVW5leHBlY3RlZCBvcGVuIGVsZW1lbnQgd2hpbGUgY2xvc2luZyAAAAASEAAmAAAAVW5leHBlY3RlZCBvcGVuIGVsZW1lbnQAoA0QAGoAAACBAwAAHQAAAKANEABqAAAAvQQAAE8AAACgDRAAagAAAKgEAAAlAAAAZm9zdGVyIHBhcmVudGluZyBub3QgaW1wbGVtZW50ZWR4EhAAIAAAAFgNEAAXAAAAWA0QABcAAACgDRAAagAAAH8EAABhc3NlcnRpb24gZmFpbGVkOiBtb3JlX3Rva2Vucy5pc19lbXB0eSgpoA0QAGoAAAB/AQAAFQAAAKANEABqAAAAewEAABUAAACgDRAAagAAAHcBAAAVAAAAVW5hY2tub3dsZWRnZWQgc2VsZi1jbG9zaW5nIHRhZ2Fzc2VydGlvbiBmYWlsZWQ6IHNlbGYucGVuZGluZ190YWJsZV90ZXh0LmlzX2VtcHR5KCkAoA0QAGoAAACKBAAADQAAAFVuZXhwZWN0ZWQgY2hhcmFjdGVycyAgaW4gdGFibGUAeBMQABYAAACOExAACQAAAFVuZXhwZWN0ZWQgY2hhcmFjdGVycyBpbiB0YWJsZQAAoA0QAGoAAACgAwAAKAAAAKANEABqAAAApwMAAB0AAABGb3VuZCBtYXJrZXIgZHVyaW5nIGZvcm1hdHRpbmcgZWxlbWVudCByZWNvbnN0cnVjdGlvbgAAAKANEABqAAAAqQMAABsAAACgDRAAagAAALADAAANAAAARm91bmQgc3BlY2lhbCB0YWcgd2hpbGUgY2xvc2luZyBnZW5lcmljIHRhZ21hdGNoZXMgd2l0aCBubyBpbmRleKANEABqAAAATQUAABIAAACgDRAAagAAAE0FAAAlAAAAoA0QAGoAAACoAQAAMQAAAG5vIGNvbnRleHQgZWxlbWVudAAAoA0QAGoAAADnAAAALwAAAKANEABqAAAAdQMAACoAAAC+DBAAhwAAAN0EAAB4AAAATm9uLXNwYWNlIHRhYmxlIHRleHRub3QgcHJlcGFyZWQgdG8gaGFuZGxlIHRoaXMhvgwQAIcAAACOAwAAEwAAAL4MEACHAAAAlQMAACsAAABpbXBvc3NpYmxlIGNhc2UgaW4gVGV4dCBtb2RlvgwQAIcAAAAaAwAAEAAAAL4MEACHAAAAFwMAAEcAAAC+DBAAhwAAAA8DAAA7AAAAQ2xvc2luZyB3cm9uZyBoZWFkaW5nIHRhZ05vIGhlYWRpbmcgdGFnIHRvIGNsb3NlTm8gbWF0Y2hpbmcgdGFnIHRvIGNsb3NlTm8gPHA+IHRhZyB0byBjbG9zZUZvcm0gZWxlbWVudCBub3QgaW4gc2NvcGUgb24gPC9mb3JtPkJhZCBvcGVuIGVsZW1lbnQgb24gPC9mb3JtPk51bGwgZm9ybSBlbGVtZW50IHBvaW50ZXIgb24gPC9mb3JtPjwvaHRtbD4gd2l0aCBubyA8Ym9keT4gaW4gc2NvcGU8L2JvZHk+IHdpdGggbm8gPGJvZHk+IGluIHNjb3BlaW1wb3NzaWJsZSBjYXNlIGluIEluQm9keSBtb2RlAAC+DBAAhwAAAAgDAAAQAAAATmVzdGVkIDxub2JyPm5lc3RlZCBidXR0b25zbmVzdGVkIGZvcm1zbmVzdGVkIGhlYWRpbmcgdGFnc25vIGhlYWQgZWxlbWVudAAAAL4MEACHAAAA1gAAAEkAAACgDRAAagAAALoDAAAKAAAAoA0QAGoAAAAdAgAABgAAAEluZGV4IG91dCBvZiBib3VuZHMAOBcQABMAAAAvcnVzdGMvOTBjNTQxODA2ZjIzYTEyNzAwMmRlNWI0MDM4YmU3MzFiYTE0NThjYS9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL3NvcnQucnMAAFQXEABOAAAAxgQAAA0AAABUFxAATgAAANMEAAAYAAAAVBcQAE4AAADUBAAAGQAAAFQXEABOAAAA1QQAACQAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAFQXEABOAAAAGQUAAEAAAABUFxAATgAAAD8FAABOAAAAVBcQAE4AAABNBQAAVgAAAGFzc2VydGlvbiBmYWlsZWQ6IGVuZCA+PSBzdGFydCAmJiBlbmQgPD0gbGVuVBcQAE4AAAC5BQAABQAAAFQXEABOAAAAygUAACgAAABhc3NlcnRpb24gZmFpbGVkOiBvZmZzZXQgIT0gMCAmJiBvZmZzZXQgPD0gbGVuAABUFxAATgAAAJsAAAAFAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnPMGBAAXAAAAB0AAAAuAAAAzBgQAFwAAABWAAAAOwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL3RlbmRyaWwucnMAAEgZEABeAAAAAAMAAD8AAABIGRAAXgAAAK4DAAA9AAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvc3RyaW5nX2NhY2hlLTAuOC4yL3NyYy9hdG9tLnJzyBkQAGAAAAAHAQAAHwAAAMgZEABgAAAABQEAAC8AAAAKVG9rZW5pemVyIHByb2ZpbGUsIGluIG5hbm9zZWNvbmRzCgBIGhAAIwAAAAogICAgICAgICB0b3RhbCBpbiB0b2tlbiBzaW5rCgAAdBoQAAEAAAB1GhAAHQAAACAgICAgICAgIHRvdGFsIGluIHRva2VuaXplcgp0GhAAAQAAAKQaEAAcAAAAICAlICAAAADMGBAAAAAAANAaEAACAAAA0hoQAAMAAAB0GhAAAQAAAFNhdyBFT0YgaW4gc3RhdGUgAAAA+BoQABEAAABVbmV4cGVjdGVkIEVPRlNhdyAgaW4gc3RhdGUgIhsQAAQAAAAmGxAACgAAAEJhZCBjaGFyYWN0ZXJnb3QgY2hhcmFjdGVycyBNGxAADwAAAGh0bWw1ZXZlcjo6dG9rZW5pemVyL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvaHRtbDVldmVyLTAuMjUuMS9zcmMvdG9rZW5pemVyL21vZC5ycwBkGxAAFAAAAGQbEAAUAAAAeBsQAGcAAAAzAQAAQXR0cmlidXRlcyBvbiBhbiBlbmQgdGFnU2VsZi1jbG9zaW5nIGVuZCB0YWdEdXBsaWNhdGUgYXR0cmlidXRlAHgbEABnAAAAYAUAABUAAABzdGF0ZSAgc2hvdWxkIG5vdCBiZSByZWFjaGFibGUgaW4gcHJvY2Vzc19jaGFyX3JlZgAATBwQAAYAAABSHBAALAAAAHgbEABnAAAAZgUAABYAAABCYWQgY2hhcmFjdGVyIAAAoBwQAA4AAABnb3QgY2hhcmFjdGVyIAAAuBwQAA4AAABkGxAAFAAAAGQbEAAUAAAAeBsQAGcAAAAXAQAAYXNzZXJ0aW9uIGZhaWxlZDogbWF0Y2hlcyEoc2VsZi5wcm9jZXNzX3Rva2VuKHRva2VuKSwgVG9rZW5TaW5rUmVzdWx0IDo6IENvbnRpbnVlKQAAeBsQAGcAAADyAAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IG1hdGNoZXMhKHNlbGYucnVuKCYgbXV0IGlucHV0KSwgVG9rZW5pemVyUmVzdWx0IDo6IERvbmUpAAB4GxAAZwAAAH4FAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogaW5wdXQuaXNfZW1wdHkoKQAAeBsQAGcAAAB/BQAACQAAAHByb2Nlc3NpbmcgaW4gc3RhdGUg4B0QABQAAABkGxAAFAAAAGQbEAAUAAAAeBsQAGcAAACzAgAAcHVibGljc3lzdGVtLS0hLS0h77+9LS0tLe+/vS3vv71kb2N0eXBlW0NEQVRBW3NjcmlwdHByb2Nlc3NpbmcgRU9GIGluIHN0YXRlIEweEAAYAAAAZBsQABQAAABkGxAAFAAAAHgbEABnAAAApAUAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaW5wdXRfYnVmZmVyLmlzX2VtcHR5KCkvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9odG1sNWV2ZXItMC4yNS4xL3NyYy9kcml2ZXIucnMAALYeEABgAAAAegAAAAkAAAAeAAAACAAAAAQAAAAfAAAAIAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUvcnVzdGMvOTBjNTQxODA2ZjIzYTEyNzAwMmRlNWI0MDM4YmU3MzFiYTE0NThjYS9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9uYXZpZ2F0ZS5ycwAAZx8QAF8AAACiAAAAJAAAAFNvbWVOb25lHgAAAAQAAAAEAAAAIQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJz8B8QAFwAAAAdAAAALgAAAHNlcmlhbGl6ZV9ub2RlIGZhaWxlZCB0byBwcm9kdWNlIHZhbGlkIFVURi04IgAAABQAAAAEAAAAIwAAAC9ob21lL2ItZnVzZS9Qcm9qZWN0cy9naXQvZGVuby1kb20vaHRtbC1wYXJzZXIvY29yZS9zcmMvbGliLnJzAACYIBAAPgAAAD0AAAAcAAAAWzEsAOggEAADAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQAkAAAACAAAAAQAAAAlAAAAmCAQAD4AAABxAAAAJgAAACYAAAAEAAAABAAAACcAAACYIBAAPgAAAHIAAAA7AAAALAAAAGAhEAABAAAAmCAQAD4AAABzAAAAJAAAAGFscmVhZHkgbXV0YWJseSBib3Jyb3dlZCgAAAAAAAAAAQAAAAUAAACYIBAAPgAAAHsAAAAtAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQCYIBAAPgAAAJMAAAAfAAAAXQAAAPAhEAABAAAAmCAQAD4AAACXAAAAJAAAAFs4LAAMIhAAAwAAAJggEAA+AAAAoQAAACYAAACYIBAAPgAAAKIAAABBAAAAmCAQAD4AAACjAAAAJAAAAFszLABIIhAAAwAAAJggEAA+AAAAmwAAACYAAACYIBAAPgAAAJwAAAA3AAAAmCAQAD4AAACcAAAASgAAAJggEAA+AAAAnQAAACQAAABbMTAslCIQAAQAAACYIBAAPgAAAKsAAAAnAAAAmCAQAD4AAACsAAAAPQAAAJggEAA+AAAArQAAACQAAACYIBAAPgAAAK4AAABCAAAAmCAQAD4AAACvAAAAJAAAAJggEAA+AAAAsAAAAEIAAACYIBAAPgAAALEAAAAkAAAAmCAQAD4AAABJAAAAKQAAAFs5LCIjZG9jdW1lbnQiLFtdAAAAICMQABEAAACYIBAAPgAAAEsAAAA2AAAAmCAQAD4AAABNAAAAKAAAAJggEAA+AAAAZQAAAB8AAABbAAAAbCMQAAEAAACYIBAAPgAAALkAAAAcAAAAmCAQAD4AAAC6AAAAFAAAAJggEAA+AAAAvgAAACAAAACYIBAAPgAAAL8AAABEAAAAmCAQAD4AAADAAAAAIAAAAJggEAA+AAAAwQAAAD8AAABdLAAA2CMQAAIAAACYIBAAPgAAAMQAAAAlAAAAmCAQAD4AAADGAAAAJAAAAJggEAA+AAAAygAAABwAAAApAAAADAAAAAQAAAAqAAAAKwAAACwAAABmb3JtYXR0ZXIgZXJyb3IALCQQAA8AAAAoAAAAL3J1c3RjLzkwYzU0MTgwNmYyM2ExMjcwMDJkZTViNDAzOGJlNzMxYmExNDU4Y2EvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAEgkEABKAAAAkgAAABEAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy90ZW5kcmlsLnJzAACkJBAAXgAAAFcAAAA1AAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnMUJRAAXAAAAB0AAAAuAAAAL3J1c3RjLzkwYzU0MTgwNmYyM2ExMjcwMDJkZTViNDAzOGJlNzMxYmExNDU4Y2EvbGlicmFyeS9jb3JlL3NyYy9jaGFyL21ldGhvZHMucnN0b19kaWdpdDogcmFkaXggaXMgdG9vIGhpZ2ggKG1heGltdW0gMzYp0CUQACgAAACAJRAAUAAAAE0BAAANAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnMQJhAAXAAAAB0AAAAuAAAAECYQAFwAAABWAAAAOwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL3RlbmRyaWwucnMAAIwmEABeAAAArgMAAD0AAABFT0YgaW4gbnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlRU9GIGFmdGVyICcjJyBpbiBjaGFyYWN0ZXIgcmVmZXJlbmNlYXNzZXJ0aW9uIGZhaWxlZDogbmFtZV9sZW4gPiAwL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvaHRtbDVldmVyLTAuMjUuMS9zcmMvdG9rZW5pemVyL2NoYXJfcmVmL21vZC5yc2AnEABwAAAAXQEAABEAAABgJxAAcAAAAF4BAAAkAAAAYCcQAHAAAABlAQAAGgAAAENoYXJhY3RlciByZWZlcmVuY2UgZG9lcyBub3QgZW5kIHdpdGggc2VtaWNvbG9uRXF1YWxzIHNpZ24gYWZ0ZXIgY2hhcmFjdGVyIHJlZmVyZW5jZSBpbiBhdHRyaWJ1dGUAAABgJxAAcAAAAIcBAAA+AAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQBgJxAAcAAAAIkBAABFAAAAYCcQAHAAAACJAQAALgAAAGAnEABwAAAAZQEAAEUAAABgJxAAcAAAAF4BAABTAAAASW52YWxpZCBudW1lcmljIGNoYXJhY3RlciByZWZlcmVuY2UgdmFsdWUgMHjgKBAALAAAAEludmFsaWQgbnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlSW52YWxpZCBjaGFyYWN0ZXIgcmVmZXJlbmNlICY3KRAAHQAAAEludmFsaWQgY2hhcmFjdGVyIHJlZmVyZW5jZU51bWVyaWMgY2hhcmFjdGVyIHJlZmVyZW5jZSB3aXRob3V0IGRpZ2l0c1NlbWljb2xvbiBtaXNzaW5nIGFmdGVyIG51bWVyaWMgY2hhcmFjdGVyIHJlZmVyZW5jZWNoYXIgcmVmIHRva2VuaXplciBzdGVwcGluZyBpbiBzdGF0ZSAAAADUKRAAJQAAAGh0bWw1ZXZlcjo6dG9rZW5pemVyOjpjaGFyX3JlZgAABCoQAB4AAAAEKhAAHgAAAGAnEABwAAAAfwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGUvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9zZXJkZV9qc29uLTEuMC42OC9zcmMvc2VyLnJzAABoKhAAXgAAADIGAAASAAAAaCoQAF4AAAAqCAAAOwAAAGgqEABeAAAANAgAADcAAABcdFxyXG5cZlxiXFxcImFwcGxpY2F0aW9uL3hodG1sK3htbC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJzABsrEABcAAAAHQAAAC4AAAAyAAAADAAAAAQAAAAzAAAANAAAADUAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5ADYAAAAAAAAAAQAAADcAAAAvcnVzdGMvOTBjNTQxODA2ZjIzYTEyNzAwMmRlNWI0MDM4YmU3MzFiYTE0NThjYS9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMA6CsQAEsAAADdCQAADgAAAHJlY3Vyc2lvbiBsaW1pdCBleGNlZWRlZHVuZXhwZWN0ZWQgZW5kIG9mIGhleCBlc2NhcGV0cmFpbGluZyBjaGFyYWN0ZXJzdHJhaWxpbmcgY29tbWFsb25lIGxlYWRpbmcgc3Vycm9nYXRlIGluIGhleCBlc2NhcGVrZXkgbXVzdCBiZSBhIHN0cmluZ2NvbnRyb2wgY2hhcmFjdGVyIChcdTAwMDAtXHUwMDFGKSBmb3VuZCB3aGlsZSBwYXJzaW5nIGEgc3RyaW5naW52YWxpZCB1bmljb2RlIGNvZGUgcG9pbnRudW1iZXIgb3V0IG9mIHJhbmdlaW52YWxpZCBudW1iZXJpbnZhbGlkIGVzY2FwZWV4cGVjdGVkIHZhbHVlZXhwZWN0ZWQgaWRlbnRleHBlY3RlZCBgLGAgb3IgYH1gZXhwZWN0ZWQgYCxgIG9yIGBdYGV4cGVjdGVkIGA6YEVPRiB3aGlsZSBwYXJzaW5nIGEgdmFsdWVFT0Ygd2hpbGUgcGFyc2luZyBhIHN0cmluZ0VPRiB3aGlsZSBwYXJzaW5nIGFuIG9iamVjdEVPRiB3aGlsZSBwYXJzaW5nIGEgbGlzdEVycm9yKCwgbGluZTogLCBjb2x1bW46ICkAAAAMLhAABgAAABIuEAAIAAAAGi4QAAoAAAAkLhAAAQAAADAxMjM0NTY3ODlhYmNkZWZ1dXV1dXV1dWJ0bnVmcnV1dXV1dXV1dXV1dXV1dXV1dQAAIgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAOQAAADoAAAA7AAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnNwLxAAXAAAAB0AAAAuAAAAZ2V0X3Jlc3VsdCBjYWxsZWQgYmVmb3JlIGRvbmUvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9odG1sNWV2ZXItMC4yNS4xL3NyYy90b2tlbml6ZXIvY2hhcl9yZWYvbW9kLnJzAAAA+S8QAHAAAABVAAAAFQAAAG5hbWVfYnVmIG1pc3NpbmcgaW4gbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZQAAAPkvEABwAAAAWwAAAA4AAAD5LxAAcAAAAGEAAAAOAAAAaW52YWxpZCBjaGFyIG1pc3NlZCBieSBlcnJvciBoYW5kbGluZyBjYXNlcwD5LxAAcAAAAPQAAAAZAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQD5LxAAcAAAADcBAAAzAAAAQm9ndXNOYW1lTmFtZWROdW1lcmljU2VtaWNvbG9uTnVtZXJpYwAAADwAAAAEAAAABAAAAD0AAABPY3RvdGhvcnBlQmVnaW4APgAAAAQAAAAEAAAAPwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJznDEQAFwAAAAdAAAALgAAAJwxEABcAAAAVgAAADsAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy90ZW5kcmlsLnJzAAAYMhAAXgAAAK4DAAA9AAAAaW5saW5lb3duZWRzaGFyZWRUZW5kcmlsPD4oOiAAAACZMhAACAAAAKEyEAACAAAAozIQAAIAAAApAAAAwDIQAAEAAABTb21lQgAAAAQAAAAEAAAAQwAAAE5vbmUtLy9hZHZhc29mdCBsdGQvL2R0ZCBodG1sIDMuMCBhc3dlZGl0ICsgZXh0ZW5zaW9ucy8vLS8vYXMvL2R0ZCBodG1sIDMuMCBhc3dlZGl0ICsgZXh0ZW5zaW9ucy8vLS8vaWV0Zi8vZHRkIGh0bWwgMi4wIGxldmVsIDEvLy0vL2lldGYvL2R0ZCBodG1sIDIuMCBsZXZlbCAyLy8tLy9pZXRmLy9kdGQgaHRtbCAyLjAgc3RyaWN0IGxldmVsIDEvLy0vL2lldGYvL2R0ZCBodG1sIDIuMCBzdHJpY3QgbGV2ZWwgMi8vLS8vaWV0Zi8vZHRkIGh0bWwgMi4wIHN0cmljdC8vLS8vaWV0Zi8vZHRkIGh0bWwgMi4wLy8tLy9pZXRmLy9kdGQgaHRtbCAyLjFlLy8tLy9pZXRmLy9kdGQgaHRtbCAzLjAvLy0vL2lldGYvL2R0ZCBodG1sIDMuMiBmaW5hbC8vLS8vaWV0Zi8vZHRkIGh0bWwgMy4yLy8tLy9pZXRmLy9kdGQgaHRtbCAzLy8tLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAwLy8tLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAxLy8tLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAyLy8tLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAzLy8tLy9pZXRmLy9kdGQgaHRtbCBzdHJpY3QgbGV2ZWwgMC8vLS8vaWV0Zi8vZHRkIGh0bWwgc3RyaWN0IGxldmVsIDEvLy0vL2lldGYvL2R0ZCBodG1sIHN0cmljdCBsZXZlbCAyLy8tLy9pZXRmLy9kdGQgaHRtbCBzdHJpY3QgbGV2ZWwgMy8vLS8vaWV0Zi8vZHRkIGh0bWwgc3RyaWN0Ly8tLy9pZXRmLy9kdGQgaHRtbC8vLS8vbWV0cml1cy8vZHRkIG1ldHJpdXMgcHJlc2VudGF0aW9uYWwvLy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDIuMCBodG1sIHN0cmljdC8vLS8vbWljcm9zb2Z0Ly9kdGQgaW50ZXJuZXQgZXhwbG9yZXIgMi4wIGh0bWwvLy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDIuMCB0YWJsZXMvLy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDMuMCBodG1sIHN0cmljdC8vLS8vbWljcm9zb2Z0Ly9kdGQgaW50ZXJuZXQgZXhwbG9yZXIgMy4wIGh0bWwvLy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDMuMCB0YWJsZXMvLy0vL25ldHNjYXBlIGNvbW0uIGNvcnAuLy9kdGQgaHRtbC8vLS8vbmV0c2NhcGUgY29tbS4gY29ycC4vL2R0ZCBzdHJpY3QgaHRtbC8vLS8vbydyZWlsbHkgYW5kIGFzc29jaWF0ZXMvL2R0ZCBodG1sIDIuMC8vLS8vbydyZWlsbHkgYW5kIGFzc29jaWF0ZXMvL2R0ZCBodG1sIGV4dGVuZGVkIDEuMC8vLS8vbydyZWlsbHkgYW5kIGFzc29jaWF0ZXMvL2R0ZCBodG1sIGV4dGVuZGVkIHJlbGF4ZWQgMS4wLy8tLy9zb2Z0cXVhZCBzb2Z0d2FyZS8vZHRkIGhvdG1ldGFsIHBybyA2LjA6OjE5OTkwNjAxOjpleHRlbnNpb25zIHRvIGh0bWwgNC4wLy8tLy9zb2Z0cXVhZC8vZHRkIGhvdG1ldGFsIHBybyA0LjA6OjE5OTcxMDEwOjpleHRlbnNpb25zIHRvIGh0bWwgNC4wLy8tLy9zcHlnbGFzcy8vZHRkIGh0bWwgMi4wIGV4dGVuZGVkLy8tLy9zcS8vZHRkIGh0bWwgMi4wIGhvdG1ldGFsICsgZXh0ZW5zaW9ucy8vLS8vc3VuIG1pY3Jvc3lzdGVtcyBjb3JwLi8vZHRkIGhvdGphdmEgaHRtbC8vLS8vc3VuIG1pY3Jvc3lzdGVtcyBjb3JwLi8vZHRkIGhvdGphdmEgc3RyaWN0IGh0bWwvLy0vL3czYy8vZHRkIGh0bWwgMyAxOTk1LTAzLTI0Ly8tLy93M2MvL2R0ZCBodG1sIDMuMiBkcmFmdC8vLS8vdzNjLy9kdGQgaHRtbCAzLjIgZmluYWwvLy0vL3czYy8vZHRkIGh0bWwgMy4yLy8tLy93M2MvL2R0ZCBodG1sIDMuMnMgZHJhZnQvLy0vL3czYy8vZHRkIGh0bWwgNC4wIGZyYW1lc2V0Ly8tLy93M2MvL2R0ZCBodG1sIDQuMCB0cmFuc2l0aW9uYWwvLy0vL3czYy8vZHRkIGh0bWwgZXhwZXJpbWVudGFsIDE5OTYwNzEyLy8tLy93M2MvL2R0ZCBodG1sIGV4cGVyaW1lbnRhbCA5NzA0MjEvLy0vL3czYy8vZHRkIHczIGh0bWwvLy0vL3czby8vZHRkIHczIGh0bWwgMy4wLy8tLy93ZWJ0ZWNocy8vZHRkIG1vemlsbGEgaHRtbCAyLjAvLy0vL3dlYnRlY2hzLy9kdGQgbW96aWxsYSBodG1sLy8AAOQyEAA0AAAAGDMQACoAAABCMxAAHwAAAGEzEAAfAAAAgDMQACYAAACmMxAAJgAAAMwzEAAeAAAA6jMQABcAAAABNBAAGAAAABk0EAAXAAAAMDQQAB0AAABNNBAAFwAAAGQ0EAAVAAAAeTQQABsAAACUNBAAGwAAAK80EAAbAAAAyjQQABsAAADlNBAAIgAAAAc1EAAiAAAAKTUQACIAAABLNRAAIgAAAG01EAAaAAAAhzUQABMAAACaNRAAKAAAAMI1EAA1AAAA9zUQAC4AAAAlNhAAMAAAAFU2EAA1AAAAijYQAC4AAAC4NhAAMAAAAOg2EAAjAAAACzcQACoAAAA1NxAAKgAAAF83EAAzAAAAkjcQADsAAADNNxAATgAAABs4EABFAAAAYDgQACQAAACEOBAAKwAAAK84EAAtAAAA3DgQADQAAAAQORAAHwAAAC85EAAcAAAASzkQABwAAABnORAAFgAAAH05EAAdAAAAmjkQAB8AAAC5ORAAIwAAANw5EAAoAAAABDoQACYAAAAqOhAAFQAAAD86EAAZAAAAWDoQACMAAAB7OhAAHwAAAC0vL3czby8vZHRkIHczIGh0bWwgc3RyaWN0IDMuMC8vZW4vLy0vdzNjL2R0ZCBodG1sIDQuMCB0cmFuc2l0aW9uYWwvZW5odHRwOi8vd3d3LmlibS5jb20vZGF0YS9kdGQvdjExL2libXhodG1sMS10cmFuc2l0aW9uYWwuZHRkLS8vdzNjLy9kdGQgeGh0bWwgMS4wIGZyYW1lc2V0Ly8tLy93M2MvL2R0ZCB4aHRtbCAxLjAgdHJhbnNpdGlvbmFsLy8tLy93M2MvL2R0ZCBodG1sIDQuMDEgZnJhbWVzZXQvLy0vL3czYy8vZHRkIGh0bWwgNC4wMSB0cmFuc2l0aW9uYWwvLy0vL1czQy8vRFREIEhUTUwgNC4wLy9FTmh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy1odG1sNDAvc3RyaWN0LmR0ZC0vL1czQy8vRFREIEhUTUwgNC4wMS8vRU5odHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNC9zdHJpY3QuZHRkLS8vVzNDLy9EVEQgWEhUTUwgMS4wIFN0cmljdC8vRU5odHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS1zdHJpY3QuZHRkLS8vVzNDLy9EVEQgWEhUTUwgMS4xLy9FTmh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMTEvRFREL3hodG1sMTEuZHRkYWJvdXQ6bGVnYWN5LWNvbXBhdEluZGV4IG91dCBvZiBib3VuZHN9PhAAEwAAAC9ydXN0Yy85MGM1NDE4MDZmMjNhMTI3MDAyZGU1YjQwMzhiZTczMWJhMTQ1OGNhL2xpYnJhcnkvY29yZS9zcmMvc2xpY2Uvc29ydC5ycwAAmD4QAE4AAADGBAAADQAAAJg+EABOAAAA0wQAABgAAACYPhAATgAAANQEAAAZAAAAmD4QAE4AAADVBAAAJAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAmD4QAE4AAAAZBQAAQAAAAJg+EABOAAAAPwUAAE4AAACYPhAATgAAAE0FAABWAAAAYXNzZXJ0aW9uIGZhaWxlZDogZW5kID49IHN0YXJ0ICYmIGVuZCA8PSBsZW6YPhAATgAAALkFAAAFAAAAmD4QAE4AAADKBQAAKAAAAGFzc2VydGlvbiBmYWlsZWQ6IG9mZnNldCAhPSAwICYmIG9mZnNldCA8PSBsZW4AAJg+EABOAAAAmwAAAAUAAABzdGF0aWNpbmxpbmVkeW5hbWljQXRvbSgnJyB0eXBlPSkAAAAjQBAABgAAAClAEAAHAAAAMEAQAAEAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy9idWYzMi5yc0xAEABcAAAAHQAAAC4AAABEb2N0eXBlbmFtZQBFAAAAEAAAAAQAAABGAAAAcHVibGljX2lkc3lzdGVtX2lkZm9yY2VfcXVpcmtzAABHAAAABAAAAAQAAABIAAAARW5kVGFnU3RhcnRUYWdUYWdraW5kAAAARwAAAAEAAAABAAAASQAAAEoAAAAIAAAACAAAAEsAAABzZWxmX2Nsb3NpbmdHAAAAAQAAAAEAAABMAAAAYXR0cnMAAABHAAAABAAAAAQAAABNAAAARG91YmxlRXNjYXBlZEVzY2FwZWRTeXN0ZW1QdWJsaWNTY3JpcHREYXRhRXNjYXBlZAAAAE4AAAAEAAAABAAAAE8AAABTY3JpcHREYXRhUmF3dGV4dFJjZGF0YURvdWJsZVF1b3RlZFNpbmdsZVF1b3RlZFVucXVvdGVkQ2RhdGFTZWN0aW9uRW5kQ2RhdGFTZWN0aW9uQnJhY2tldENkYXRhU2VjdGlvbkJvZ3VzRG9jdHlwZUJldHdlZW5Eb2N0eXBlUHVibGljQW5kU3lzdGVtSWRlbnRpZmllcnNBZnRlckRvY3R5cGVJZGVudGlmaWVyAE4AAAAEAAAABAAAAFAAAABEb2N0eXBlSWRlbnRpZmllclNpbmdsZVF1b3RlZERvY3R5cGVJZGVudGlmaWVyRG91YmxlUXVvdGVkQmVmb3JlRG9jdHlwZUlkZW50aWZpZXJBZnRlckRvY3R5cGVLZXl3b3JkQWZ0ZXJEb2N0eXBlTmFtZURvY3R5cGVOYW1lQmVmb3JlRG9jdHlwZU5hbWVEb2N0eXBlQ29tbWVudEVuZEJhbmdDb21tZW50RW5kQ29tbWVudEVuZERhc2hDb21tZW50Q29tbWVudFN0YXJ0RGFzaENvbW1lbnRTdGFydE1hcmt1cERlY2xhcmF0aW9uT3BlbkJvZ3VzQ29tbWVudFNlbGZDbG9zaW5nU3RhcnRUYWdBZnRlckF0dHJpYnV0ZVZhbHVlUXVvdGVkQXR0cmlidXRlVmFsdWUATgAAAAQAAAAEAAAAUQAAAEJlZm9yZUF0dHJpYnV0ZVZhbHVlQWZ0ZXJBdHRyaWJ1dGVOYW1lQXR0cmlidXRlTmFtZUJlZm9yZUF0dHJpYnV0ZU5hbWVTY3JpcHREYXRhRG91YmxlRXNjYXBlRW5kU2NyaXB0RGF0YUVzY2FwZWREYXNoRGFzaFNjcmlwdERhdGFFc2NhcGVkRGFzaFNjcmlwdERhdGFFc2NhcGVTdGFydERhc2hTY3JpcHREYXRhRXNjYXBlU3RhcnRSYXdFbmRUYWdOYW1lTgAAAAQAAAAEAAAAUgAAAFJhd0VuZFRhZ09wZW5SYXdMZXNzVGhhblNpZ25SYXdEYXRhVGFnTmFtZUVuZFRhZ09wZW5UYWdPcGVuUGxhaW50ZXh0RGF0YQgAAAAMAAAADAAAAONBEADXQRAAy0EQAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3N0cmluZ19jYWNoZS0wLjguMi9zcmMvYXRvbS5yc/hEEABgAAAABwEAAB8AAAD4RBAAYAAAAAUBAAAvAAAAL3J1c3RjLzkwYzU0MTgwNmYyM2ExMjcwMDJkZTViNDAzOGJlNzMxYmExNDU4Y2EvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAHhFEABKAAAAkgAAABEAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy90ZW5kcmlsLnJzAADURRAAXgAAAFcAAAA1AAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnNERhAAXAAAAB0AAAAuAAAAQWZ0ZXJBZnRlckZyYW1lc2V0QWZ0ZXJBZnRlckJvZHlBZnRlckZyYW1lc2V0SW5GcmFtZXNldEFmdGVyQm9keUluVGVtcGxhdGVJblNlbGVjdEluVGFibGVJblNlbGVjdEluQ2VsbEluUm93SW5UYWJsZUJvZHlJbkNvbHVtbkdyb3VwSW5DYXB0aW9uSW5UYWJsZVRleHRJblRhYmxlVGV4dEluQm9keUFmdGVySGVhZEluSGVhZE5vc2NyaXB0SW5IZWFkQmVmb3JlSGVhZEJlZm9yZUh0bWxJbml0aWFsTm90V2hpdGVzcGFjZVdoaXRlc3BhY2VOb3RTcGxpdEVPRlRva2VuTnVsbENoYXJhY3RlclRva2VuQ2hhcmFjdGVyVG9rZW5z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AAAABQAAAAEAAABMAAAAAAAAAAABAAANAAAAggEAAAAAAACYAAAAAAAAAAIAAAAAAAAAHAAAAAAAAACPAAAAAAAAAFUCAAABAAAAeAIAAAIAAACuAAAAAAAAAAMAAAAAAAAA7gAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEgAAAAAAAAADAAAAAAAAAI0AAAAEAAAAowEAAAAAAAAAAAAAAAAAAJwAAAAIAAAAXwAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAUQQAAAAAAAASAwAABQAAAB4AAAAAAAAAEwAAAAIAAAAvAQAAAAAAAGsAAAABAAAAFAEAAAAAAAABAAAAAAAAAFUDAAADAAAAjgAAAA4AAAC1AQAAAAAAAAACAAAAAAAAAQAAAG9uZHJhZ2VuZG5vbmVvbmtleXByZXNzY29udGVudFNjcmlwdFR5cGVjb250ZW50ZmVwb2ludGxpZ2h0cHJlc3RhcnRPZmZzZXRhcmlhLXByZXNzZWR2aWV3VGFyZ2V0YWRkaXRpdmVxYmdjb2xvcm5lcWxjbWZsb29kLWNvbG9yaWRmcmFtZWRpc3BsYXlhbmltYXRlQ29sb3JhbHBoYWJldGljYXJpYS1yZWFkb25seWV4cG1pKmZlTWVyZ2Vvbmxvc2VjYXB0dXJlb3RoZXJ3aXNlbWFza3VuaXRzeGxpbms6YWN0dWF0ZW1hbmlmZXN0ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHVsc2VwYXJhdG9ycnRjcG9seWdvbmZpbGwtb3BhY2l0eXpvb21BbmRQYW5zY3JvbGxpbmd1cG9pbnRlci1ldmVudHNmb3JtYXRhY3R1YXRlbGltaXRpbmdDb25lQW5nbGVmb250LWZhY2V0Ym9keW9uYmVmb3JlY29weXJvd3NwYWNpbmd0aGlubWF0aHNwYWNlbWF0aGVtYXRpY2FscGF0dGVybnVuaXRzb25lcnJvcnN0cm9rZS1saW5lam9pbmFsaWdubWVudHNjb3BldW5pb25oZWFkc2l6ZXNjb2xzYWN0aW9ucG9seWxpbmVzcGVlZG5vYnJ0ZW1wbGF0ZWcxaGFuZGxlcmZlc3BlY3VsYXJsaWdodGluZ2FyaWEtZXhwYW5kZWRjbGlwcGF0aGxlcXhsaW5rOnJvbGVmaWVsZHNldGFsdEdseXBoSXRlbWJib3h0YW5yZXF1aXJlZGZlYXR1cmVzb25kcmFnZHJvcGNsYXNzaWRkaXJlY3Rpb25vbmRyYWdsZWF2ZXNlY3Rpb25nbHlwaGFyaWEtc2V0c2l6ZWdyb3VwYWxpZ25rZXJuaW5nc3Ryb2tlLW1pdGVybGltaXRhcmNzZWNjb2RldHlwZWxpbmtyZWxvbnBhZ2VzaG93cmVsbmFyY2NvdGZsb29ya2V5VGltZXNjaGFycmVwZWF0Y291bnRyZXBlYXQtbWluZmVtZXJnZW5vZGVhc2lkZWNvbHVtbmFsaWdub25iZWZvcmVlZGl0Zm9jdXNvbmZpbmlzaGVsZXZhdGlvbm9ucmVzaXplc3Ryb2tlLXdpZHRoYXJpYS1pbnZhbGlkcHJlc2VydmVhc3BlY3RyYXRpb21heHBhcnRpYWxkaWZmc3RhcnRvZmZzZXRpc2luZGV4b25tb3VzZWRvd25vbmRhdGFzZXRjaGFuZ2VkeG1sOmJhc2VrMXN0cmluZ3N1YmRlZmluaXRpb25VUkxhcmFiaWMtZm9ybWlmcmFtZXN0ZW12c2NyaXB0Ymlhc2hvcml6LWFkdi14c3RvcC1jb2xvcmF0dHJpYnV0ZU5hbWVmb3JlaWdub2JqZWN0aXRlbXByb3BnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbGNvZGVmbG9vZC1vcGFjaXR5cmF0aW9uYWxzZmVDb21wb25lbnRUcmFuc2ZlcnRleHRwYXRoeGxpbms6dGl0bGVzaGFwZW1hcGNoYXJzZXR0YXJnZXR5b25kYmxjbGlja21wYXRob25kcmFnc3RhcnRoaWRlZm9jdXNlZGdlbW9kZW1nbHlwaG5vbmNlcmFkaWFsR3JhZGllbnRhbm5vdGF0aW9uLXhtbG1wYWRkZWRncmFkaWVudFRyYW5zZm9ybWZlZnVuY2FvbmZvY3Vzb3V0b25jaGFuZ2V2a2Vybm5vdHByc3Vic2V0Zm9udC13ZWlnaHRtYXRoc2l6ZWNvbG9yLWludGVycG9sYXRpb25zZWNocmVmZXJyZXJwb2xpY3lyZWFkb25seXBvaW50c2FjY2VwdC1jaGFyc2V0Zm9udC1zaXplY2FyZHJ0dW5pY29kZS1yYW5nZXBhdGhnY2RtYXJnaW5oZWlnaHRrZXlwb2ludHNoMmFjdGlvbnR5cGVyZXF1aXJlZEZlYXR1cmVzcnVsZWFyaWEtY2hlY2tlZGNsaXBwYXRodW5pdHNzcmNkb2NkaXNwbGF5c3R5bGVtdWx0aXBsZXZlcnNpb25udW1PY3RhdmVzbWF0cml4cm93b2Zmc2V0bWFya3ByaW1lc3N0cm9rZS1vcGFjaXR5aHJlZm1zcGFjZW9uYmx1cmJnc291bmRvbm1vdXNld2hlZWxtb2xhcmdlb3ByZXN1bHRhemltdXRoYWxpbmtzdG9wYXJpYS1idXN5Zm9udHdlaWdodHNwcmVhZG1ldGhvZGJldmVsbGVkeG1sOmxhbmdwb2ludHNBdFhhcmN0YW5ocnF1b3Rlb25tb3VzZW92ZXJjdXJzb3JzdXBlcnNjcmlwdHNoaWZ0Y29sdW1ubGluZXNmb250ZmFtaWx5eGxpbmtjbGlwLXBhdGhtYXNrc3VwdmFsdWVzcGFjaW5nZmVkcm9wc2hhZG93Zm9ybWFjdGlvbm9uY29udGV4dG1lbnV0b2dnbGVmaWdjYXB0aW9uc2VlZHBvaW50c2F0eWlkZW50bmFyZ3N2bGlua2FjY2VudGl0ZW1yZWZzaG93Y2hhcm9mZmhvcml6LW9yaWdpbi14ZWRnZU1vZGVzZW1hbnRpY3NhY2NlcHRsb2dhcmlhLWF0b21pY3NjYWxldW5pY29kZS1iaWRpb3JkZXJrYXJjcm9sZWRpdmlzb3JoYW5naW5nc2RldmF4aXNkb21pbmFudC1iYXNlbGluZWVuYWJsZS1iYWNrZ3JvdW5kb25sYW5ndWFnZWNoYW5nZXRyYWNrbm90c3Vic2V0cG9pbnRzQXRZbWVhbmZpbGxmZUNvbnZvbHZlTWF0cml4c3R5bGV0b290aGVydHJhbnNsYXRlbG9jYWxzYW1weGNoYW5uZWxzZWxlY3RvcnNwYWNlZXF1YWxyb3dzc3RpdGNoVGlsZXNmZWZsb29kZG5vdGFudW1iZXJtYXJrZXJIZWlnaHRsaW5ldGhpY2tuZXNzZGlzY2FyZGFsdEdseXBoRGVmdGFibGV2YWx1ZXNwcmltaXRpdmV1bml0c2ZlbmNlaW5maW5pdHlrZXJuZWx1bml0bGVuZ3RobGluZS1oZWlnaHR0YXJnZXRYYXJpYS1tdWx0aXNlbGVjdGFibGVjZWxscGFkZGluZ2RhdGFmb3JtYXRhc2tlcm5lbFVuaXRMZW5ndGhnZXFhbHRHbHlwaGVtYmVkcGF0dGVybkNvbnRlbnRVbml0c2FyY2NvdGhwcm9ncmVzc21mcmFjc3Ryb2tlYmFzZWxpbmVmb3JhbGxmZUZ1bmNHYW5pbWF0aW9ubm92YWxpZGF0ZXJ1bGVzc3JjaXRlbXNjb3Blb25iZWZvcmVhY3RpdmF0ZWJkaWZldHVyYnVsZW5jZWdseXBoUmVmY3NjbmFtZXNpbmNvbHNwYW5iYXNlb25iZWZvcmVwcmludHNvdXJjZWxvd2hzcGFjZXRpdGxlc2NyaXB0bGV2ZWxvbmN1dHJldmVyc2VkdGJyZWFrc2V0bWFya2VyLXN0YXJ0ZW5jdHlwZW1ldGFkYXRheENoYW5uZWxTZWxlY3Rvcm1vZGVzZXBhcmF0b3Jzb25pbnZhbGlkaDZjb25qdWdhdGVyZXF1aXJlZEV4dGVuc2lvbnNtdW5kZXJvdmVyaDVtZXRob2RtYXRoY29sb3JkaXZlcmdlbmNlZmFsc2VzcGVjaWZpY2F0aW9ub25yZWFkeXN0YXRlY2hhbmdlZG9tYWlub2ZhcHBsaWNhdGlvbm1hdGhiYWNrZ3JvdW5ka2VybmVsTWF0cml4bmF0dXJhbG51bWJlcnNkZXB0aHNjYWxhcnByb2R1Y3RvcGVyYXRvcmNsYXNzcG9pbnRzQXRaY29vcmRzYm9yZGVydGV4dGxlbmd0aHNjcmlwdHNpemVtdWx0aXBsaWVyb25zdG9yYWdlYXJpYS1jb250cm9sc29ucHJvcGVydHljaGFuZ2VpbWFnZXByb2R1Y3RjYW52YXNwcm9tcHRmZXRpbGVvbmZvcm1jaGFuZ2VhbmltYXRlbW90aW9ubWF4c2l6ZWFyaWEtbGl2ZWxpbWl0Zm9ybXRhcmdldGVxdWFsY29sdW1uc3JlY3RmZWNvbXBvbmVudHRyYW5zZmVyZmVEaXNwbGFjZW1lbnRNYXBkZWdyZWVvbmJlZm9yZGVhY3RpdmF0ZWJhc2VGcmVxdWVuY3lkeWN1cmxiYXNlbGluZS1zaGlmdGNsaXBhYXJpYS1kcm9wZWZmZWN0eGxpbms6dHlwZW9ubG9hZHJlZlhwcnN1YnNldHByZXNlcnZlYWxwaGFpbnB1dG1vZGVrNGdyYWRpZW50dW5pdHNhcmlhLXZhbHVlbWF4bG5hY3JvbnltYXJ0aWNsZXRzcGFuZmVibGVuZGNvbG9yLXByb2ZpbGVmb3JhcmlhLWRhdGF0eXBldmVydC1hZHYteW1zcXJ0dGhpY2ttYXRoc3BhY2Vtb21lbnRtaXNzaW5nLWdseXBodGRmb3Jtbm92YWxpZGF0ZWZvcm1mb250c2l6ZW1hc2tjb250ZW50dW5pdHNmb3JtbWV0aG9kYXJjY29zaG9ucGFzdGVpbnRlcnZhbG10ZHRhYmluZGV4YXJpYS1ncmFic3JjbGFuZ210YWJsZXJlcGVhdGNvbG9yLXJlbmRlcmluZ2ZvbnRzdHlsZWF0dHJpYnV0ZVR5cGVleHBvbmVudHBhdHRlcm5vbmRyYWdlbnRlcmFyaWEtdmFsdWVtaW5tb21lbnRhYm91dGRhdGV0aW1lc3ZndmFyaWFuY2VmZU9mZnNldG9uZXJyb3J1cGRhdGVkb3dubG9hZGFyY2hpdmVmeGV4aXN0c3N0ZXBidXR0b25tdGV4dGZlQ29tcG9zaXRlZGVmYXVsdHN0ZW1obWVudWl0ZW1mb250LXZhcmlhbnRvbmNvbnRyb2xzZWxlY3R0YWJsZXByb3BlcnR5Zm9udC1mYWNlLXVyaWljb252ZXJ0LW9yaWdpbi15b25oYXNoY2hhbmdleDJvbmtleWRvd25saW5lYnJlYWtyb290aXRlbXR5cGV0aW1lc3VyZmFjZXNjYWxlbGFtYmRhc3Jjc2V0Znlob3Jpei1vcmlnaW4teWNvZGViYXNldi1hbHBoYWJldGljYXJlYWFyaWEtbXVsdGlsaW5lcmVwZWF0LW1heGFic29uZW5kZm9vdGVydmVydC1vcmlnaW4teHRleHQtZGVjb3JhdGlvbmFiYnJtb3ZlcnRhcmdldHByaW1pdGl2ZVVuaXRzZmVmdW5jYnRleHQtYW5jaG9ybm9yZXNpemV4bWxuczp4bGlua2NlbnRlcmZvbnRtc2ZuazNwaWVjZWVsbGlwc2VyZWFsc25vZW1iZWRlbXB0eXNldGZlQmxlbmRycHdpZHRoc3htbG5zdGV4dExlbmd0aGVxdW5pdHMtcGVyLWVtYmFzZVByb2ZpbGVkYXRhdGVtcGxhdGViYXNlZm9udGRpZmZkeHR5cGVhcmlhLWNoYW5uZWxzeXN0ZW1sYW5ndWFnZXJlZnlyZWZ4YWx0aW1nZGlhbG9nb25zY3JvbGxhcmlhLXNlbGVjdGVkdmVjdG9ycnlwYXR0ZXJudHJhbnNmb3JtZm9udC1zaXplLWFkanVzdHRhcmdldHhtcm93cmVwZWF0Q291bnRhbHR0ZXh0bGVuZ3RoYWRqdXN0dmVyeXRoaW5tYXRoc3BhY2VtaW5sZW5ndGhtYXJrZXItZW5kZGF0YWZsZHBhcnNlY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzbmF2aGVpZ2h0cHJlZmV0Y2h3cml0aW5nLW1vZGVhcmlhLWRlc2NyaWJlZGJ5cGF0dGVybmNvbnRlbnR1bml0c2Rpcm5hbWV1MnhtbDpzcGFjZWRldGFpbHNuZXN0b25rZXl1cG11dGVkb25kcmFnb25pbnB1dG9uc2VsZWN0YWx0aHR0cC1lcXVpdmFjY2VudC1oZWlnaHRjb250cm9sbGVyY2hhbmdlY2VsbHNwYWNpbmdwYXRobGVuZ3RoYmFja2dyb3VuZGFyaWEtc29ydGZyYW1lYm9yZGVyZ3JhZGllbnR0cmFuc2Zvcm12ZWN0b3Jwcm9kdWN0Zm9udC1mYW1pbHlhcmlhLWhpZGRlbmFsaWdubWVudC1iYXNlbGluZWhpZGRlbmZpbHRlcnVuaXRzc2NyaXB0bWluc2l6ZXVzZW5vc2NyaXB0c3RyZXRjaHl2LW1hdGhlbWF0aWNhbGNvbXBsZXhlc2FyaWEtbGFiZWxsZWRieXJvd2FsaWducGljdHVyZXByZXNlcnZlQWxwaGFhcmlhLXJlcXVpcmVkeTJ1bnNlbGVjdGFibGVjb250ZW50ZWRpdGFibGV6c3RvcC1vcGFjaXR5b25tZXNzYWdlbHRmYWN0b3JpYWxmaWd1cmVsb29wY2FwLWhlaWdodGN5eHJlZmZlZGlmZnVzZWxpZ2h0aW5nb25hY3RpdmF0ZWxpc3Rpbmdvbm1vdXNlbW92ZWR0b3B0aW11bWZlRHJvcFNoYWRvd2ZpbHRlcnNtYWxsb25vZmZsaW5lcGFub3NlLTFtYXJxdWVlem9vbWFuZHBhbm1uYWRkcmVzc21hdGh4MW9uaGVscHdoZW5vcmFyaWEtdmFsdWVub3dhY2Nlc3NrZXlkZXNjZW50di1pZGVvZ3JhcGhpY2lycmVsZXZhbnRjaGVja2Vkb25iZWZvcmVwYXN0ZXRyYW5zZm9ybW5vZnJhbWVzY29zaG10cmZlSW1hZ2Vjb250ZXh0bWVudXZhbGlnbmdseXBoLW5hbWVvbmJlZm9yZXVwZGF0ZXNwZWN1bGFyY29uc3RhbnRkZWxhcmlhLW93bnNmZVNwZWN1bGFyTGlnaHRpbmd0aGVhZG9ubW92ZWVuZG1lbmNsb3NlbWFyZ2lud2lkdGh3b3JkLXNwYWNpbmdvYmplY3Rsb2diYXNlbWxhYmVsZWR0cmFuaW1hdGVNb3Rpb250ZXh0UGF0aGRyYWdnYWJsZWRmbnJlcXVpcmVkYXJjY29zYmlnaW50YXR0cmlidXRldHlwZWJhc2VmcmVxdWVuY3lzZXBoMWZlY29udm9sdmVtYXRyaXhsYW5naGdyb3VwZXVsZXJnYW1tYWNvc2JyZmVkaXNwbGFjZW1lbnRtYXBrZXlzcGxpbmVzd2lkdGhpbnRlcmNlcHR0ZW5kc3Rvb25zZWxlY3RzdGFydG1lcnJvcm1hY3Jvc21vemJyb3dzZXJvbmFib3J0bWF0cml4b25hZnRlcnByaW50bW92YWJsZWxpbWl0c3Ryc3Ryb2tlLWxpbmVjYXBub3RhdGlvbm9ubW91c2VlbnRlcmFubm90YXRpb25mcmFtZXNldGNyb3Nzb3JpZ2luaW52ZXJzZWhlYWRlcnNmZW1lcmdlZGF0YXNyY3NpbmhnbHlwaHJlZm9uZm9ybWlucHV0dmlzaWJpbGl0eW9uZHJhZ292ZXJzcGFjZXJvdmVybGluZS10aGlja25lc3N4b3JvbmRhdGFzZXRjb21wbGV0ZXBpbmdsZXR0ZXItc3BhY2luZ2xlbmd0aEFkanVzdHZlcnl0aGlja21hdGhzcGFjZW9ucmVwZWF0aW1ldGF2aWV3Ym94ZGVmc3JiYWxpZ25kYXRhc3ByZWFkTWV0aG9kZGVmaW5pdGlvbi1zcmNhc2NlbnR2YWx1ZXR5cGVvbnJvd2VudGVyb25zdG9wcnNwYWNlbWFya2Vyb3JpZW50YXRpb25lbmNvZGluZ3BsYWludGV4dHJlc3RhcnRzdGREZXZpYXRpb25udW1vY3RhdmVzbWFya2VydW5pdHNjbGlwUGF0aFVuaXRzc3RkZGV2aWF0aW9uY290cGFyaWEtZGlzYWJsZWRtaW5zaXplZmVTcG90TGlnaHRjZWlsaW5ncnkxZmFjdG9yb2Zic3RhdGVjaGFuZ2VrZXl0aW1lc2RpcmVuZG9wdGdyb3Vwb25yb3dzZGVsZXRlZmVnYXVzc2lhbmJsdXJsb3dsaW1pdGsyc3Ryb2tlLWRhc2hvZmZzZXR1cGxpbWl0eGxpbms6aHJlZmFuaW1hdGVUcmFuc2Zvcm1zbG9wZWZlRnVuY0Jwb2ludHNhdHh1bmRlcmxpbmUtcG9zaXRpb25ocmVmbGFuZ2NhcHRpb25tdWx0aWNvbHdicmRpc2FibGVkcXVvdGllbnRmZVRpbGV0cnVlYXJjc2luaGVxdWl2YWxlbnRmZW9mZnNldHZhbHVlc2NhbGNNb2RlYXJpYS1hY3RpdmVkZXNjZW5kYW50bWVudXhsaW5rOnNob3dzdWJzY3JpcHRzaGlmdG9ucG9wc3RhdGVhcmNzaW50ZXh0YXJlYXUxYXJpYS1zZWNyZXRrZXJuZWxtYXRyaXhvdmVybGluZS1wb3NpdGlvbm9uYmVnaW50YWJsZVZhbHVlc3Njb3BlZG9uc3VibWl0b25kcm9wbWFpbmdyYWRpZW50VW5pdHNjb2xncm91cGNhbGNtb2RlaGVhZGVyY290aGluc29uc3RhcnRpbWFnaW5hcnljb250ZW50c3R5bGV0eXBlYnZhcnZhcnJhZGlvZ3JvdXBleHBvbmVudGlhbGVvdXRwdXRrZXlQb2ludHNzZXRkaWZmb25vbmxpbmVibG9ja3F1b3RlY2l0ZWxpbmVhcmdyYWRpZW50Z2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbHBhcmFtaW50ZWdyaXR5aW1hZ2luYXJ5aW9uYm91bmNlb25tb3VzZXVwZmVjb2xvcm1hdHJpeGZlVHVyYnVsZW5jZWZpbHRlclVuaXRzcmVmWW9uY2VsbGNoYW5nZWlzbWFwZGV0ZXJtaW5hbnRub21vZHVsZXN1YnNldG1heGxlbmd0aHByZWxvYWRvbmRhdGFhdmFpbGFibGVyZXBlYXQtc3RhcnR2c3BhY2VvcGVuYXVkaW9hdHRyaWJ1dGVuYW1lZW1vbm1vdXNlbGVhdmVyYWRpdXNjbGlwLXJ1bGVvbmNsaWNrcGltc3Vic3VwYXN5bmNkb21haW5sb25nZGVzY2FyaWEtZmxvd3Rvdi1oYW5naW5nZmVkaXN0YW50bGlnaHRodG1sc3BlY3VsYXJDb25zdGFudGFsbG93ZnVsbHNjcmVlbm9ubW91c2VvdXRscXVvdGVhcHBseWhyYW1wbGl0dWRlZmVQb2ludExpZ2h0cG93ZXJhcmlhLXJlbGV2YW50cmVhbHJldmZlTWVyZ2VOb2RlZGVjbGFyZWFsdGdseXBoY2xvc2Vjb2xzdGFuZGJ5cmVwbGFjZWNvbHVtbnNwYW5pbjJtdW5kZXJkaWZmdXNlY29uc3RhbnRwb2ludHNhdHpvbm1vdmVtcm9vdHNwZWxsY2hlY2tzdXJmYWNlU2NhbGVldmVudHJvbGVoa2VybnJlcGVhdGR1cm1hbGlnbm1hcmthcmNjc2NzdW1tYXJ5a2V5U3BsaW5lc2JlZ2luY29udHJvbHNzbG90c2VsZWN0aW9uc3Ryb2tlLWRhc2hhcnJheWNvbmRpdGlvbmNvbG9ybWV0ZXJ2ZXJ5dmVyeXRoaWNrbWF0aHNwYWNlbGl1bmljb2Rlb25yZXNldGFyaWEtYXV0b2NvbXBsZXRlbGVnZW5kb25iZWZvcmVjdXRwbGFjZWhvbGRlcm1zdWJtZWRpYWFyZ2ZvbnQtc3RyZXRjaG5vaHJlZnVuZGVybGluZS10aGlja25lc3NkZWZpbml0aW9udXJscGF0dGVyblRyYW5zZm9ybWNvbHVtbndpZHRobG93c3Jjc2NoZW1lZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZG9ubW92ZXN0YXJ0b3B0aW9ucnVieXJvd2xpbmVzb25yb3dleGl0b2xvcmlnaW50YXJnZXRZaW5kZXhhcmNjc2NoZm9udC1mYWNlLW5hbWVzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc3ZpZXdkZXNjdmVyeXZlcnl0aGlubWF0aHNwYWNlcmVwZWF0RHVyZzJ0YW5oZHVybWFjdGlvbmxhYmVsdXNlbWFwZmVmdW5jcmludGVyc2VjdG1hbGlnbmdyb3Vwc2VsZWN0b3JiZG9mZWNvbXBvc2l0ZXNvbGlkY29sb3JjeG9uZmlsdGVyY2hhbmdlaW5pdGVtaWRtZWRpYW50Zm9vdGFyaWEtcG9zaW5zZXRyb3dzZGl2aWRlc3RpdGNodGlsZXNmb250LWZhY2Utc3Jjc3BhbmxpbmVhckdyYWRpZW50dHJlZm9wYWNpdHlsaXN0c3Ryb25nbWluZGRsaWdodGluZy1jb2xvcmJ5bWFza1VuaXRzbW11bHRpc2NyaXB0c2ZlQ29sb3JNYXRyaXhyeHhsaW5rOmFyY3JvbGVwYXRoTGVuZ3Rob25mb2N1c3RoYXJpYS1sZXZlbGNvbXBhY3RzdGFydG9udW5sb2FkYXV0b3N1Ym1pdGxhcGxhY2lhbmltYWdlLXJlbmRlcmluZ2d0aW5wdXRjb21wb3NlY2lvbmZvY3VzaW5nb3V0ZXJwcm9kdWN0dmlld0JveG1hcmtlclVuaXRzc2hhcGUtcmVuZGVyaW5nZm9udC1mYWNlLWZvcm1hdGJvZHlkaXZtYXJrZXJ3aWR0aGNsZWFyc3lzdGVtTGFuZ3VhZ2VyZXBlYXQtdGVtcGxhdGVtcHJlc2NyaXB0c2ltcGxpZXNzY3JvbGxkZWxheWFuaW1hdGV0cmFuc2Zvcm1hdXRvY29tcGxldGVjc3ltYm9sY29udGVudHNjcmlwdHR5cGV5c3RyaWtlbGluZXN1bWRlY29kaW5nZmVGbG9vZGZlRGlmZnVzZUxpZ2h0aW5na2JkZmVtb3JwaG9sb2d5Y25yZXF1aXJlZGV4dGVuc2lvbnNjbGlwUGF0aG5vdG1hcmtlci1taWRvbmFmdGVydXBkYXRlbm90aW5sYW5ndWFnZW1hcmtlcmhlaWdodGZlZnVuY2dmZUZ1bmNSd3JhcHRleHQtcmVuZGVyaW5nYXJjdGFuYXJpYS10ZW1wbGF0ZWlkYmFzZXByb2ZpbGV2aWRlb3Byb2ZpbGVzdHJpa2V0aHJvdWdoLXBvc2l0aW9ubXN1cHR0cmFkaWFsZ3JhZGllbnRzZWxlY3RlZGdyYWRub3NoYWRlc3BlY3VsYXJFeHBvbmVudGFuaW1hdGVhY3RpdmVtYXRodmFyaWFudG9uYmVmb3JldW5sb2FkdHJhbnNwb3NleWNoYW5uZWxzZWxlY3RvcnNhbmRib3hyb3RhdGVvbmRlYWN0aXZhdGVraW5kZmV0Y2hjb2x1bW5zcGFjaW5nYmxpbmtzZWNtc3R5bGVmZURpc3RhbnRMaWdodGF1dG9wbGF5b25yb3dzaW5zZXJ0ZWRtZmVuY2VkZmVpbWFnZXhtcHJlbmRlcmluZy1pbnRlbnRkaWZmdXNlQ29uc3RhbnRhY2N1bXVsYXRlbmV4dGlkc2NvcGV5Q2hhbm5lbFNlbGVjdG9yYWNjZW50dW5kZXJvbnBhZ2VoaWRlYWx0Z2x5cGhpdGVtc2VhbWxlc3Njb250ZW50U3R5bGVUeXBlY29kb21haW5tYXNrQ29udGVudFVuaXRzY2FydGVzaWFucHJvZHVjdG1waGFudG9tbWludXNzcGVjdWxhcmV4cG9uZW50YXV0b2ZvY3VzY2lyY2xlc2l6ZWRlZmVycmVtcGllY2V3aXNlcGx1c2Nsb3N1cmVhbmltYXRlY29sb3JvY2N1cnJlbmNlZnJvbWgzYW5kc3dpdGNoZmVHYXVzc2lhbkJsdXJkYXRhbGlzdGZvbnQtc3R5bGVhcHBsZXRkbG9uem9vbXgtaGVpZ2h0ZnJhbWVzcGFjaW5nbGltaXRpbmdjb25lYW5nbGVmZXNwb3RsaWdodHBhdHRlcm5Vbml0c21lZGl1bW1hdGhzcGFjZWltZ2VkZ2VvdmVyZmxvd2ZpbGwtcnVsZW9yaWVudHN2aWV3dGFyZ2V0aWRlb2dyYXBoaWNsaXN0ZW5lcmg0cG9zdGVyZmFjZW5vd3JhcGZpbHRlclJlc2FyY3NlY2hwcmVzZXJ2ZUFzcGVjdFJhdGlvZmVGdW5jQWludGVnZXJzbHNwYWNldGltZXNrZXlnZW5hcmlhLWhhc3BvcHVwcm93c3BhbmFsdGdseXBoZGVmZm9ybWVuY3R5cGVmaWx0ZXJyZXN4Zm9yZWlnbk9iamVjdHN5bWJvbHN5bW1ldHJpY29uY29weWNzY2hzZWxlY3R0ZXh0YXBwcm94aGlnaGZlTW9ycGhvbG9neW1hcmtlcldpZHRoCFAQAAkAAAARUBAABAAAABVQEAAKAAAAH1AQABEAAAAwUBAABwAAADdQEAAMAAAAQ1AQAAMAAABGUBAACwAAAFFQEAAMAAAAXVAQAAoAAABnUBAACAAAAG9QEAABAAAAcFAQAAcAAAB3UBAAAwAAAHpQEAADAAAAfVAQAAsAAACIUBAAAgAAAIpQEAAFAAAAj1AQAAcAAACWUBAADAAAAKJQEAAKAAAArFAQAA0AAAC5UBAAAwAAALxQEAACAAAAvlAQAAEAAAC/UBAABwAAAMZQEAANAAAA01AQAAkAAADcUBAACQAAAOVQEAANAAAA8lAQAAgAAAD6UBAAGQAAABNREAACAAAAFVEQAAkAAAAeURAAAwAAACFREAAH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b3RDb25ncnVMZXNzU2xhbnRFcXVheGk7bHRyaWU7YXJpbmc7TnNja29DaXJjbGVEb3Q7bGF0O25vdG5pTnRpbGRlbWFwO3N3bndhclNob3J0UmlnaHRBcnZCYXJ2cnBwb2xpbnN3QXJDYXBpdGFsRENpcmNsZVRpbWxwYU5vdFRpbExhckRvdWJsZVZlcnRpY2FsQmFjY2VkaXNlYVNxdWFyZUludGVyc2VjdGlzaW1lcXR3b2hlYWRiYXJ2ZURTY3lMYW1iZGE7Tm90VGlsZGVUaWxyaWdodHJpZ2h0dWNpcmM7Q2xvc2VDdXJseVF1b3RlO0NvdW50ZXJibGFja3RyaWFuZ2xlbFVuZGVyQmFhbmdydHZiO3VkYmxhY2JvcHJpZ2h0bGVmdGFybnJpZ2h0YWF3aXJicmtlcGhpdjtsZWZ0cmlnaHRhcnJvd3M7Z3RyZXFsaW9wQW1Eb3duVGVlb2d0aW1lc2Jhck5vdEVsZW1jaXJjZW1lYXN1cmVkYW9taW51cztTdXBlcnNUaWxkZUZ1bGxFcXVhbDtucHJlTm90VmVydGljYWxCU2NpcmM7aXNpbnN2dGNhcm9uO0FhY2hlY2ttYXJrO3dwO0Rac2N5O2ludHByb0VhbGFycmhrO3VjaXJjUmhqc2VyaWdyYXZlO0xvd2VyUmlnaHRBcnJzbXRlbGludGVWZXJ0aWNhbFNlcGFzb2ZnbkU7Ymlnd2VMZWZ0UmlnaHRBcnJvdztOb3ROZXN0ZWRHcmVhbnJBTG9uZ0xlZnRSaWdodEFycm93O1JldmVyc2VVRG93bkxlZnRWZWN0b3JEY2Fyb1JpZ2h0QXJyb3dCbnN1cHNldGVxO3N1cGVkUmlnaHRUcmlhbmdsZUJhclVkYmxhY2xkcXVvcmVyTEplcHNpQnVtc3VibXRpSHVtcERyY3lyY2VkdXBhcnF1YXRlcm5pb25zTm90U3Vic2V0RXF1YWw7c2NpcmNOb3RMZXNzVGlsT2N5O25lZG9iZWJpZ3VwcnVyZXNhY2N1ZGFycmxGaWxsZWRWZXJ5U21hbGxTcXVhcmU7b3Njcjt4d2VkZ2dhbW1hZEhmcmN1bGFycnBEb3duTGVmdFJpZ2h0VmVjdEVsZW1lU2NyQXRhaWFuZ2U7UnJMZWZ0RG91YmxlQnJhc2hvcnRtaWRWRGFzQW1hY3I7SUVjY29sdHNjeTtsamN5cGFyc3N1YnJhcnI7Ym5lUmNlR3NjclVwYXJyb3c7RW9nb29yZGY7ZHRyaWZzd25yc2FxdVdvcGY7bnNpdmFyc3Vic2V0bmVxcTtuc2NjbmFwRXR3aXh0QXRpbGRlO3h2ZWdzY3ZhcnByb3B0Y2VkaURvdWJsZVJpZ2h0QXJyb3dOZXN0ZWRHcmVhdGVyR3V0ZG90O3Zhcm50aGV0YXY7cHJvZmFsSW50ZXJzZWN0aW9uO2xvcGRhZ2dzdXBzRGNzdWJtdWx0dXRpbGRlO1N1Y2NlZWRzRXFsbGhhcmNvbmludFJpZ2h0VHJpQ2lIaWxiZXJ0U3BvZWxpZ2x2c29sYmZvcmFsbDtsb25nbGVmdHJpZ2h0RG93blJpZXNkYm94dlI7ZG90ZWdzY3I7b2Rzb2xkO25kYXNoZG93bmF5c2Njd2lubEFycm52RGFzaHJhcnJmcztEb3VibGVDZUREb3Q7WnNjdGlub2xjcm9zc2NpcmNsZWRjaXJpbm9kb3Q7bGVmdHJpZ2h0YXJyb3c7TGVmdEFuZ2xlQnJhY2tlbWVhc3VyZVlmcmRvd25kb3duTGVzc0dyZWF0aXF1ZWd0cmVyaWdodGhhcnBvb251bG9uZ2xlZnRhTGVmdFZlc2NuUGFydGl2RGFzaDtJbWFjcjtUYXVlZkRvZm9ya3Y7WmNhcm9uO0djaXJjYmZyYmVwc2k7Ym94Vkw7ZXFzbGFudGNvbXBsZVJFbmRhc2g7YnNlbWljaXJjbGVkZGFYZnI7RG91YmxlVXBEb3duQXJ0aWxHSmN5cm90aU5vdExlZnRUcmlhbmdsZUVxcHJ1c21hbGxPbWlqY3VsYXJyZXBzaXZHcmVhdGVyVGlsZGVjb2xvbjtzbGFib3htaW51S2ZyO1JldmVyc2VVcEVxYW5nbGU7Q29udG9yYWRvbWludXNMc2g7VXBBcnJvd0Rvd25BcnJvdztxdW90O0V4aXN0aGJTcXVhcmVJbnRlcnNWZXJ0aWNhbFRpbHJhZW1wdHlOZXN0ZWRMZXJhcnJ0bDtOb3RIdW1wRG93bkh1bW1sbGJhcnJMZWZ0RG93blZlY3RvckJhRG93bkxlZnRWZWN0b3I7VnZkYXNuc3ViO2FuZ3pUaWxkdHJpYW5nbGVyaWdodGVxO2hhcnJjcmlnaHRsZWZSY2xkcnVzaGFyY3VyYXJybTtUaWxkb3RwcnBhcjtFbXB0eVZlcnlTbWFsbFNxdWF1aGFybGxzY3I7dnppZ3phZ2NhY3V0UGFydGlhbFNxdWFyZVN1cGVyc2V0RXF1YUh1bXBaSGN5O0hzdHJvaztyb3RmcmFjY3NjcjtBb3BmbG9ucmlnaHRzcXVpZ2FybndhcmhrO0dyZWF0ZXJHcmVhZXhpc3RzdWJzZXRlcXE7Q291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JudHJpYW5nbGVyaWdwdW5jc3A7RXF1YWxUYWxlZnNpYWN1dXJjbGxjb3JuZXJ3Y2lyTm90UHJlY2VkZXNTbGFDb3VudGVyQ2xvY2t3aXNlQ29udG91cnBzY0xvbk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyTGFycmJjb25nO29yb3JzbWlkO2FuZGFuZDtUaWxkZUVxdWFsO250cmlhbmdsRmlsbGVkU21hbGxTcXVhclByaW1jb21wbHRsd2VkYmFjdXJybG9uZ21hQUdyZWF0ZXJFcXVhY2lyc2NpcjthbmRzbG9wc2hvcnRzcnJlYWxpbmVtYWx0ZXNQcm9kdWN0O0xlZnREb3duVGVpbnRsYXJob3JzbG9wU2hvcnREb3duQXJyb0RpYWNyaXRpY2FsRG91YlJpZ2h0VHJpYW5nbGVFcXVOb3RTdXBlTm90VGlsZGVGdWhrc3dhckV4cG9wcm9mc3Vsb25nbGVmdHJpZ2h0YXJybG9uZ21hbmdydGltYWdlc3N0ZXRoO3RoZXRhc3hoQXJyO0NjZWRQZnI7Ym93dGllRW1wdHlWTm90TmVzdEVwU21hbGxlc3NhdHJpYW5oYXJJbXBsaWVzRG93blJpZ0Rvd25SaWdodFZlY1N1Y2NlZWRzU0xlZnRDZWltaW51c2Q7dWZpc2h0O3RlbHJTYWN1dGU7ZnJvd0Rvd25BcnJvd1VwQXJyb3dNaW51c1BsdXNzY2FwO3Nxc3ViZTtnRURpYWNyaXRpY2FsVGlseHZlZTtwcm5hcE5vdExlc3NFcmlnaHR0aGxhcnJmc25vdGludmFVb2dkbGNvcm47ZGVtcHpldGE7dGVudHJpYW5nbGVuTGVmdHJpZ2h0YXJyb3dMc3Ryb2s7YW9nb0RvdWJsZVVwQXJyb3c7Y3NjS2N5O3N1YkVib3hoVXBBcnJvZG90ZXFIYWNlaztMb25nbmRhc3Vic2ltO2d0bFBhclZlcmJhbGVmdGxlZnRhTm90U3VjY2VlZHNFcXVzdWJzZXRlcXFrYXBwYTtIYWNNZWxsaW50cm5sZXFxYm94dEJjeTthcGVTaG9ydExlZnRBcnJob2JpZ3RyaWFDaXJjbGVUaXRyaWFuZ2xlcmlnaHRlcU1zY3JvcmRlcjtnamN5RGlhY3JpdGljYWxEdmFuZ3J0O2hmQ2RveWljQ291bnRlckNjYXJldDtkb3duaGFycG9vbnJpZ2hvb2tyVmJhcnNxc3VidGhoYXJyY2lyO2NpcmNsZWFycm93bGVmdDtkc2NyO2ltYWNibGFja3RyaWFuZ2xlQ2xvYmJyaztic29sO3JkcXVvcjtzaW1sRTtVcGRvd25hcnJvd25jb25nZG9yZHNoTG9uZ2xlZnRhcnJvd2JveGJveDtmZmxsaXZhcnRyaWFuZ2xlbG5wYXJhVW5kZXJCcmFja2VOb3RTcXVhcmVTdXBlVXBFcXVpbGlicmxhcnJscERpYWNyaXRpY2FBcHBseUZ1TmVzdGVkR3JlYXRlckdyZWF0ZWJlcm5vdTtIdW1wRXF1YWxyZGxkaGFyaW1hZ3BhcnREb3duTGVmdFRlZWd0cXVlc2d0cXVwcmVjbmFwcGNpcmNsZWFycm93bGVmd3JlYXRoO2NlbXBidWxyZmlFYWNmYWxsTGVmdERvd25WaW1hdGhuYW5HSmN5O05vdExlc3NHcmVhdGVybHN0cm9wbHVzO2JpZ29kb3Q7R2ZyO2RhZ2dlcm5zdXBzZXRlcWN1cGxyaG5ocHZ6aWdscmFMb3dlclJpdXJpbmc7d2ZyS0hjeW9tZWdhTGVmdFVwVmVjdG9yQnhvcGZHcmVhdGVyU2xhbnRFcXVhbExlZnRUZWVWZWN0b2dyYXZlblJpZ1RSQUREc3Ryb2s7bGF0YXNtYWxsc2V0bWluUHJlY0xvbmdSaWdodEFyaWdodGxlZnRPcGVuQ2xlc2RvQWJyQWJyZXZlWUljeVJpZ2h0QW5nbGVCcmF6Y2Fyb247Z3RyZXFxbGRpYW1vbmRzdXRpbGRlbmVMZWZ0VHJpYW5nbGVCYXRjZWR2YXJ0cmlhbmdsZWxlZWRvbG9icmtkaGFycmRvd25kb3djaXJjZXE7ZGJsdmFyc3Vic2V0bHRjSXRpQ3Njcjtsb25ncmlzY3BvbmFwb3NqbWF0aGRyYmthcm93WmZBZ3JhS2NlTG9uZ0xlZnRSaWdodEF6d25qO2pjaXJjaXByb21pZGZlbWpzY3J2YXJrYXBwdmVydGJpZ29wU2Z2YU5vdFB1b3BmbnZydHJpZW9pbkRvd25SaWdodFZlY3RvcjtMZWZoc3Ryb21pZGFzUHJpVEhPUk5wbHVzc2lyYXJyZnNwaGk7c3VwaHNvbDtsZWZ0dGhyZWV0aW1Ob3RTcXVhcmVTdWJ0ZWxyZWNzemxpZ0lKUHJvZHVjdHJpcGx1c1ZlcmJhcjtiY3k7bGVmdHRoTGxlZnRhcnJVcHBlaWlpbk5vdEdyZWF0ZXJGdWxsRXFuc21pVmVydGljYWxUaWxkZVJhY3V0ZTtwcmVjYXB1YXJWZXJ0aWNhbFNlcGFyYW9sYXJycm9hbmdzcWN1cHNzaHk7aW9nb247bmhwYUdib2hob29rcmlnaHRhcnJvd2JhY2tjb25zY2VkZG90ZXE7bm9wZjtCdWN1cGJyQ29sb247SnNlVXJkYWdnZWR6aWdPbVNob3J0TGVmdEFycm9SaWdodERvd25WTGVzc0dyZWF0ZVVwc2lsb247TmVnYXRpdmVWZXNhY3V0ZTtjdXJ2ZWFyckRvcGY7Y2Fyb247Tm90RXFCckRvdWJsZUxvbmdSaWdodEFycm9SaWdodEFycm93TGVmdXBzaUNPUFlwbU5vdFRpbGRlRXF1YWxTdXBsdXNhY2xyaGFyO2xvbmdsZWZ0cmlnaGFwcHJvb3RpbGJwcmltZTtudmdlO0NlbnRlUmlnaHRBcnJvd0xlZnRpbm9VbmRlckJyYWNEb3VibGVEb3duQXJyb3dlcXVhbGxybTt5Y2lyYztEb3VibGVDb250b3VySWNkb3Q7UkJhcnI7dkJhcnY7VGhlcmVmb3JlO2Jzb2xhZW1wdHl2O05vdERvdWJsZVZlcnRpY2Fsc3Vic2V0bmVxY2lyY2xlYXJyb3dsRGlhY3JpdGljYWxHcmF2ZTtOb3RMZXNTaG9ydFJpZ2h0QXJyb0NlbnRlckRkZGFnVHJpcGxlRG90U2hvcnRVcEFycm93O05vQnJsZWZ0ZWZob29rcmlQcmVjZWRlc1NsYW5ib3hEbDtOb3RSaWdodFRyaWFuYmlnb3RpbWVzO1N1YnNldEVxdWFsO2lpbmZpbjtsZXNzc05vdEVxdWFsVGlsZGU7UWZyO2tqbGVmdHJpZ2h0YXNxY2F0b3Bib3Q7dG9lbGx0cmlKb25ydHJpZTtDb3VudGVOb3RFeGluZ2VxO3R3b2hlYWRsZWZ0YXJydHJpYW5nbE5vdFN1cGVyc2V0RXF1YWw7ZXhwZWN0YXRpb25Vb2dvZnJhYzM4O0xvbmdyaWdocmF0aU5vdFJpZ2h0VHJpYW5nbGVFcXVhbERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvU3F1YXJlSW50ZWJuZTtFZmJyZXZlO0xlZnREb3duVGVlVmVjdExlZnRBcnJvd1JpZ2h0QXJycnRpbWd0ZG90O0FicmVuc3Vwc2V0ZXFxO29hc3RJZkxlZnRyaWdodGFsb3RpbWVzO2hzdHJva3N3amNpcm11bWFUaWxkZUZ1bEhhdDtsbGNvcm5sbWlkb3RkaXZpZGVsSGFydm9wZnJhYzE2ZWU7ZnNRc2NyaGFycmNpbGNlZGxlZnRoYXJwb29uVXBBcnJvd0Rvd25PYWN1dGU7UmNlZGlsanNlcmNMZWZ0UmlnaHRWZ3Ryc2ltZG93bmhhcnBvb25yaWdodHJhdGFpbDtudmRhc2xlZnRyaWdodHNxdWlnYWJpTm90VGxvem5vdGluO2xmbG9vcjtOb3RMc3Vwc2V0bmVxYW5kc2xvcGU7TG1paWlpaW5wcnVyZWxBYnJldmU7UmlnaHRBbmdsZUJyTm90RG91cmF0aW9ucGk7cnRocmVlaHNsYXNxdWFhZ3JhdmU7RG93blJpZ2h0VGVlVmVjdG9yVnNVdGlsZGV3ZWRiYXJzZWFycm9Ob3RMZXNzTGh5YnVsbGN3Y29uR3JlYXRlckdyZWF0dWZFcXVhbFRpbG9wTXNjbGxjb2d0cmxlc2x2ZXJ0bmVwcmVjbmVxcTt3ZWRiYXI7UmFjdVVwVEludmlzaWJsZVRpdmFydHJpYW5nbGVya2N5O0xlZnRBbmdsZUJydmVlYmFJb3Buc3Vwc1hzZ2Vxc2xhbnRuYnVtcG5MZWZ0YXJyYXBvbnNob3J0bWlkSmNpcmNyY3ViO0Rvd25MZWZ0UmlnaHRWZWN0b3I7Y3VydmVhcnJvd3J2YXJ0cmlhbmdsZXJpZ2h0O2JveHY7bEJhcmJlbXB0eXZhbmR2bGN1UmlnaHRVcFZlY3RvcjtKc2Jsa2N1cmx5dmVlY2x1YnNkdERpYWNyaXRpY2FsVGlsZGU7Z2ZFZ2NpcmNsZWFycm93bGVSaWdodEFycm93TGVyYW5nbGFtYnhvdGltZTtuYXBFO0d0RG93bkxlZnRWZWN0b2JveHZyO1ByZWNlZGluZmluO252YXA7cGFyc2ltbWludXNkdTtyaWdodHRocmVldGltZXNzdHJhaWdodGVwc2lsTm90TGVzc0dyeHV0cmlxdWF0TGVzc0VxdWFsR3JlYXRlcmRsY29ybmhzY3JuR3RkaXZpZGU7ZmVtYWxMZWZ0VUhzdGJsYWNrdHJpYW5rY0REYm94aHU7emRvdExlZnRGbG9vcjtsdHF1ZUxhY3RlbHJlYztzdXBzdWJEb3Q7c2xhcnJ2YXJzY2FwY3VwTmVnYXRpdmVUaGluU3BhY2U7UmlnaHRBcnJvd0JhcjtpdGlsc2NuYXBHcmVhdG1hY3JsYXJyO05vdERvdWJsZVZlcmlnaHRsZWZ0aGFycG9vbkxlZnRBbmdsZUJmcmFjMzRwcm5SaWdodFRlZVZlR3JlYXRlckZEaWFjcml0aWNhbERvdWJsZXBsYW5Ob3RTdXBlcnN0YnJrbGFlbXBuamNTdWNoVGhvckNvbmdyaWdodGFycm93dGFTcXVhcmVTdXBlcnNldGltcGVkO0xlZnRDZWlsaW5nbGJyYWNlUWZycmJibGhhcnN0cmFpZ2h0ZXBzaWxvbjtPbWVkYmtndHJhcHByb3hzdWJkb0dicmV2ZTt0aGluTm90VGlsZGVGdWxsRXF1Tm90TGVzc1NWZGFzcG9tYXJrZXJjd2NvZmZsbGlnbGU7b2dhbmdydHZiZDtpbmZpbnRpUm9wZjtvcnNsb3NoY1ZlcnRpY2FsQnJlYWx2YXJzdWJzZXRuZXE7UkJib3hib3hIdW1wRG93bkh1bVRoaWN1bG5hcHByb3hOb3ROZXN0ZWRHcmVhdGVyR3JlYXRuc3VjY0Rhc2h2dmZyb2FjdXRlZW9nb25tYWNpbnRjYXFvcHVwaGFycG9SaWdodFVwRERpYWNyaXRpY2FsRG90O0hpbGJlcnRTaW50O05lc3RlZEdyZWF1bXZhcnJob01lbGxpbnRVcHBlclJpZ2hkaXY7YnJ2YmFyY2lyY2xlYXJyb3djc3VwZVN1Y2hUaGFWZXJ0ZW1yb3Bmc3FzdWJzZXRlYWFjdXRFcXVhcmF0YWlWZGFzaE5vdEV4aXN0Y2lyY2xlYXJyb3dyaWdodG1hcHN2YXJ0aGV0YXRyaXBsc3FDbG9ja3dpc2VDb1VuZGVyUGFyZXVsY29ybmVtY3k7RG93bkxlZnRSaWdoYmxhY2t0cmlhbmdsZXJpZ2Fjd2lMZWZ0VXBEb3duVmVjdG9yRXRyb2JqY3lTbWFsbEdmcnR3b2hlYWRyaWdodGFycm93O1pIcHJvZmxpbmRsZ2VzbDtQaTthbmRhbmdlcXFMZWZ0VXBUZWVWZWN0b3I7cnJhcnI7c2Nhcm9uO09wZW5DdXJseURvdWJsZVFCZWNhdUljaVRvcFJldmVyc2VFbGVib3h1clByZWNlZGVzU2xhbnRFcXVhYnVtcFJpZ2h0RG91YmxlQkdKY2N1ZXNjO1dvcGZOb3REb3ViTmVnYXRpdmVNZWRpdW1TcGFjZWxyYXJyYXJpRGZybnN1YnN0aW1jc2NyT2ZyQ29udG91c2NpcmM7RXNjcjtOZWdhdGl2ZVRoaWNrU3BhY2U7Zmx0bnM7RW1wdHlWZXJ5U21hbGxzaW1sVmVydGljYUNvbnRvdXJJbnRlZ3JBYXJydWRoYUFwcGx5RnVuY3RlbGNhcDticHJpT3NDcm9zcztwaXZzdXBzaWNpVW1TY3k7d2VkZ2U7VmVlO0RvdWJsVGlsZGVUaWxkZTtwcmVjY3VybHllcTtpc2luZG9lcXNsYW5BcHBhbWFuTGVmdHJpZ2h0YXJybnByZWNlcWx0cXVlc05vdExlZnRUcmlhblJjYXJvc2ltcHh2ZWVwY2ltb2Y7emZyO1N1cGVyc2VlcWNJZnI7YmlndmlxdWVzdDtsZXNuZWFycm9kb3RzcXVOYWNucmlnaHRhcnJvd2Rvd3BjeWpzVW9wQWN5Y2FwYnJjdXNmcm93bnByZWNuYWRvdDtMb25nUmlnaGJveHVSO2ltYWdwYXJ0O3JhbmdlO3JiYnJrO25SU0hjckJhcnI7bHRpbWVzO0hBUkRjeXJlTWZMb25ncmlnaHR0cmlhbmdsZXJpcmJya3NsZDt4bGFycjtEb3VibGVVcERvd25BcnJvd3Jtb3VzdGFTdWJzZXRFcXVhcmlnaHRsZWZ0YXJyb3dzRGlmZmVyZWdsRXFpbmNpcmNsZWRhc2RlbXB0eXZwbHVzdHdib3hWSDtCZWNhdXNlO05vdEh1bXBEb2xlc3Nkb3N0cmFpZ2h0ZXBwb3VuZDtOb3RFcXVhbFRpbGROb3RTcXVhcmVTdXBlcnNldHBlcmNYaW5WRG53YXJyYXRhTm90U3VjY2VlZHNTRG91YmxlVmVydGlzdWJtdWNpcm1tRERvdG1ucHdlZGdlcTtOZXdzd0Fycjt2YXJrYXBwYTtTT0ZUTGVmdFJpZ2h0VmVjdG9ybWFwc3RvZG93bjtOb3RTcXVhcmVTdXBlcmR0ZG90O0xtaWRvdGdpT3RpbWVBcHBseUZ1bmN0aW9uUHNjcjtFbGVCZXJ2QXRvcGZvcmtsZWZ0cmlnaHRoYWNjdXBzVXBBcnJpZ2h0bGVmdGhydWx1aGFFZ3JhdmVubGVmdGFycmRvdWJsZWJhcnZCYVBzaWVsaW50bWFwc3RvdXN1cGVkb3Q7ZG90c3F1cmNybGVmdGxlZnRhcnN1Y2NjdXJseWVxO3BhcmFjaXJjbGVkZGFzaHZhbmdydGxvb3BhcnJvd2xzY25zaW07U3VjY2VlZHNFcXVhUnJpZ2h0YXJyb3duc3FzdXBlbWlkY2lyckJhVFNjeVJpZ2h0QXJyb3dMZWZ0QXJ2YW5hbmdtc2RhZU5vdEVxdWFsVGlsZGViYWNrZXBzaWxvbmRvbGxhcnBybnNEaWFjcml0aWNhbERvdWJsZUFjdWFhY2RpZ2FmcmFjMThsYXJyYmZzbnVtc0xlZnRyaWdodGFycm93O0NoaTtOb3RQcmVjTm90VGlsZGVGdWxFbGVtZW5jdWRhdnN1cG5FSWRvdGxvbmdsZWZ0cmxlZnRyaWdodHNxdWlnYXJic29sYjtubGVxcTtjb3B5bGJhb2dyYXZlO0VtcHR5U21hbGxTcXVhcm9wYXJjZWlsbG9vcGFycm93bGVmcmFxdURvd25MZWZ0UmlMZWZ0VXBUZWVWZWN0b3JyYW5nbGVEZWw7Z3REb3VibGVSaWdodENpcmNsZVBsdXNMZXNzRnVsbEVxdWFyaWdodHRocmVnZXNkb3Q7SXVtbGJhcnd1ZGFwaWQ7TGVzc1RpbGlvcGY7YW5nbGFtYWxnO2dpbWVFbXB0eVNtYWxsU2dlcXE7TmVnYXRpdmVUaGRia2FyRmlsbGVkU21hSW52aXNpYnBsdXJmaXNoTm90RG91YmxlVmVydG9zc3Vwc3Vudmx0O1VwRXF1Q29uZ3J1ZW50O0tjZWRpZ2ZycHJvZmFob29rbGVmdGFyTGVmdHJmcmFzbDtGc2Nycm1vdXN0YWNoZTtSaWdodERvd25UZWVWZWNhYztDbG9ja3dpc2VDb250bHNFY2Fyb1JvdW5kSW1wbGFtRGlhY3JpdGljYWxBY1FVT1REb3duQnJldmU7bmxlTm90RG91YmxlVmVydGljYWxCYU5lc3RlZEdyZWF0ZXJHcmVhdGVyO2Jicmt0Y2VudGVyZG91b3BzdXAzZURvdDtjdXJseWVxc3NyYXJKc2NyO2RibGFjY2lyY2xlYXJWZXJ0aWNhbFRpbGRzcXN1cHNldGVic2ltO3NwYWRlc0RvdWJsZVVwRG9ERG9sdXJkc0JhTG9uZ0xlZnRBc2NuYXA7SWdyTG9uZ0xlZnRSaWdodEFybkxlZnRhcnJvd3ByY3VlO1VicmV2ZWdvcGxBdGFpUmlnaHRGbG92YXJwaUZpbGxlZFZlcnlTbWJzaW1lO3Zuc3VwYm94RHI7c3ViZWRvcGhpdkxlc3NkaGFtZnI7a3NjckNjb25pbnQ7SG9yaXpvcmFjdXRlO05vdFJpZ2h0VHJpYW5nbGVCVXBzaWxvTm9CcmVhazt0cHJpbWVkc2NEaWFjcml0aWNhbGRvdWJsZWJiTm90O250bFRyaXBsZURvbHNoO2NvbXBsZW1lU3Vic2V0RXF1bG5lcXF2bnN1Tm90TmVzdGVkR3JzaGN5T2NpcmNFb3BiaWd0cmlhbmdsZWRUaWxkZVRpbGRlU3VwZXJzZXRFcXVhVWFycm9jaXJhbmRhYm5lcXZ6aWd6YXhuaXM7RERvdHJ2YXJ0TGVmdERvdWJsTGVmdFRyaWFuZ2xlRXF1Tm90UHJlY2VkZXNTbGFuQWdyYXZldmFybm90aGluZztkZG90c2VxYkxlc3NTbGFudEVxTXNjcjt1ZnI7YW5nbXNkYWdsbGNvcm5lc29sYmFEb3VibGVMb25nUmlnaHRBcnJMZWZ0UmlnaHRBcnJvdmRhc2hvbXJhbmc7Tm90TGVzc0xlZGRhcmxhZ3JOZWdhdGl2ZU1lZGloYXJydztsRWc7bGVzc2dJbnRlcnNlYnVsbGVOZXN0ZWRHcmVhdGV1cGx1cztGaWxsZWRTdmxldnByb3A7dHJpc2JJb2dubWlsQmFyclRoZXRhO3h3ZWRnZWh5YkxlZnRUcmlhbmdsZU5vdExlc3NUaWxkZTtEb05lc3RlZEdyZWF0ZXJxb3BmYmxhY2t0cmlhbXVscHJuc2ltO2NoZWNrO3BybkVtaWRhc3RjdWxhcnJwO0Rvd25UZWVBcnJvZXVnbmU7bWFwc3RvbGVmdDtSZXZlcnNlRWxlbWJsb2NDbG9ja3dpRG91YmxlUmlnaHRBcnJvdztwZXJ0ZWxlc3NhcHBkaWdhbW1zbWVwYXJJbnZpc2libGVUYWJyZXZlO2VuZzt0b2VhO2xtb3VzQ2NhckZvdXJpZXJ0cmZsbmFwcHJvbmdlcztFcXVpbGlibmxhckRvdWJsZURvd25BcnVwaGFycG9vRW9nVXBFcXVpbGlicml1UHJlY2VkZXNTbGFMZWZ0QW5nbGVCcmFja2V0Ym94VlJOb3RHcmVhdGVyVGlsZGV2c3VibkU7Y3Rkb0NvcHJvZHVjdGRyY0xvd2VyTGVmdEFycm93bGhibGtJbWFnaW5hcnlJO3Nxc3Vic2V0ZXE7bm90aW5jYXBicmJveHRpbW1vZGVsc0JzY1RpbGRlRXF1YU5vdFZlcnRpY0xvbmdsaGNpcmM7Y2N1cHByZWNlcVpldGE7Tm90VmVydGljYVNob3J0TGVmdEFPdGltZXM7TGVmdERvd25WZWN0bnRnQ2xvc2VDdXJseURvdWJsYnNvbGJyYXF1bztDb3BmbWludXNHY2lvcGx1V2NlUGx1c0RvdWJsZUxvbmdMZWZ0UmlnSU9jeW5hdHVyYXZlZTtVcGRvd25hcnJvdztGb3VEb3duUlRjZWNoaTt0cmltaXJhcnJhQ3VwQ2FwTG9uZ1JpZ2h0QXJkZW1wdHl2O25wcmVjO0xlZnREb3duVGVlVmVjdG9yO05vdEh1bXBFcW5vdGluZG90bHRyaWVTcXVhcmVVbml5ZnI7SmZyO3JlYWxpbmU7ZGl2Ym94cGx1c0tjZWRpbGhlcmNsb3BhcmR1aGFySW50ZVRoaW5TcHJyYXJpZ2h0YXJwbHVzdHdvO0NpcmNsZVRpbWVOb3RSaWdodFRyYWZyO2xhcVdzY3I7dHdvaGVhZHJpYmZsZXFMZWZ0RG91YmxlQlNob3J0TGVmdEFycm93ZXF1aXZERFN1Y2hUaE5lc0xhbWJPY2lyRXhibGFja3RyaWFuZ2xlZElKbGlnVXBBcnJvd05vdFN1cGx2ZXJ0c2ZXc2NybGVzZG90ZXhwZXJpZ2h0c3F1aWdhdUFOb3RTdWJzZXRmcGFydGlTdWI7Tm90SHByZWNuYXBwcm94Tm90VGlsZGVUU3Njcm9jeTtEb3duYXJyb3dubHRyaXJwYXJubGVmdGFycm9ucnRTT0ZUY3k7WkhjbnNxc3ViZUVtcHR5U21Ob3RHcmVhdGVyRkNlVG9wZjtVcERvd25BcnJvd3RpbWVzZGhrc2Vhcm93Q291bnRlckNsb2Nrd2lzZUNvbnRjaXJtaWQ7ZG90ZXFkb3Q7ZW9wcmFycmI7ZGJsYWM7bXU7Tm90SHVtcEVxdWFsaW50cHJvZGNpcmNsZWFycm9SZXZlcnNlRXF1aWxpYnJlemFjTGVmdERvd25UZWVWRG91YmxlTG9uZ0xlZm9oYmFyO05vdE5lc3RlZExlc3NMbGFuZ2Q7bmdzaW1hc3ltcGVxO2xjZWlsbGVmdGxlZnRhcnJwcmVjYXBwckVxdWlsUGZybHVydWhhdG9wO2xvd2FzdHZhcnRobG9vcGFycm93Y3VybHllcXByZWNydWx1dHJwZXppdW07RGlhY3JpdGljYWxBY3VMZWZ0QW5nbGVCcmFjaW1hZ2xpbmU7Tm90TGVmdFRyaWFuZ2xlRXF1YWxOb3RWZXJ0bG9vcGFyQXBwbHlGYW9nT3BlbkN1cmx5UWJpZ3N0YXI7ZXF1YVByb2R1QWxjdXJ2ZWFycm93bGVpaW5maW9kaXY7bGVzc2VxZ3RyaXVtbGVxdWl2cGxhbmNraDtOZnNxdWFyZm5lYXJyb3dDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGxhdGFpaW50ZXJibGFja3RyaWFuZ2xlbGV0cmlhbmdsZWRvd2JsYWNrbG96ZW5pb2dvYWN1dElPY3k7TGVmdFVwVmVjdG9yO2R6Y0ZpbGxlZFNtYWxsU0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxsdmVydG5lcXFwb3VucmRsbnBvbGlsQWFyY29wZjtsbDtQcm9wb3J0aW9udWRic2Vhck5lc3RlcmVhbHBiaWdzdGFyTm9uQnJlYWtpbmdTcHZhcmVwc2lsb01hcDtsYXJyaGt0b3BmO2duc2duZXFudHJpYW5nZG93bmhhcnBvWWN5Q2lyY2xlTWludXM7RG93bkJ0aGlVdGlsZGU7RG93blJpZ2h0Vk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVVwRXFhYnJlc3VjY2N1ck5vdFNxdWFyZVN1cGVyc2V0O05vdExlc3NFcXVhbHRzYXBwcmFycmxVYWN1dGVUc3Ryb1JpZ2h0QW5nbGVCcmFja2VzdWJzdXF1YXRpbnRERG90cmFibGFja3RyaWFuZ2xpb2N5SGF2ZWVOb3RTdWJzZXRFcXVhUmlnaHRVcFZlY3ROb3ROZXN0ZWRHcmVhdGVMb25ncmlnbnZyQWFuZ3phdHdvemNhcm9ubGVmdGhhcnBvb251cDtjc3ViZTtsb3plbmVncmF2SmNpcnRpbWVzbmdlcXE7cmJya3NsdVlvR2FtbWFkO21hcHN0b2xlZnROb3RTdWNjZWVkbHNxYjtudmluVWJyY1BmUmZycXVhRG93bmFycm9Ob3RSaWdodFRyaWFuZ2JuZXF1dGJyaztMZWZ0Rmxvb3JkYmthcm93O2ZyYWMyNTtyQXJyTGVzc0VxdWFsR3JlYXRjeWxjdHk7Tm90TGVzc1NsYW50RXF1YWxDb3VudGJzaW1jdXJseWVxcGxjZWRpbDttYXBzdG9saXNpbnNMb3dlclJpZ2h0QXJib3hVcmZsdG50d29oZWdhbW1hZDttbGNwdHJwZXlvcE5lZ3JvcGFyRG93bkxlZnRWZXFzbGFudGd0Tm90RXF1YWJvd3Rhc3Q7anNjQ2xvY2t3aXNlQ29udG9kZWx0YTtuc2hEaWFjVWFjdW5zdXA7Tm90R3JlYXRlckdyZG93bmhhcnBvb25sZWZTaG9ydFJSY2F5YWN5cmVhbHM7VXBzRG91YmxlTGVmdEFycm9scmNvcm5lU0hjeTtkcmNyb3BvdGltZXNhc3VwYXJyTmNhcm9wbGFjdXJseWVxc3VDbG9ja3dpc2VyQWFycjtzaG9yTG9uZ0xlZnRSaWdoRXF1YWw7bG90aW1lc2hvcnRtaW5WcmxoYXN1Y2Nuc3NxY3VwO0RvdWJsZVJpZ2h0QXJyb25WZExjZXBvaXJlYU5lZ2F0aXZlTWVxY29sRGVsdGFkcmJjdXJhcnJtbmVhcnJvdztMZWZ0RG93blZlY3RvckJSaWdodERvd25UZWVWZWN0b3Jub3RpbnZjYXBwclJvdW5oYXJkbnZkYWJsYW5rO2FuZGFuZFJpZ2h0VHJpYW5nbGVFY2VwZXJpb2Q7RG93blJpZ2h0TGxlZnRBTVA7bmN1cDtyaXNlZWJlbXBPdmVyUGFyZW50aGVzaWVxY29sb247Rm91cmllRG91YmxlVXBEb3duQXJyb3c7T3ZlckJyUmlnaHRBcnJvd0xlZnRBcnJvdztuZXF1aXhvZG90O3Nob29mRG93bkxlZnRUZWVWZW5jb25nZG90O3ByZWNjdVJpZ2h0RG91YmxlQnJhYmFja2VlcXVpdjtsaGFydXBsdXNjdHJpZG90cmFlbXBDdXBDYW5wYXJhbGxlR3JlYXRlclNsYW50dnJ0cmlWb3BmO3ZBcnJlbGluVmRhc2N1cGNhcHNjYXJvbmxvejtVcmluanVrY3k7bGVzZG90b3I7Tm90U3Vic2V0RXF1YWxCZnI7V2VkaW50Y0VjYXJvbkRvdWJsZVJpTm90U3VwZXJzZXRFcXVhbHZhcnN1cG9jaXI7dm9wZjtkaWdhbWJveHBsdXJpbmdSaWdodFZlY0thYmxhY2tzcXVSaWdodERvd25UZWVWZWN0Tm90UHJlY2VkZXNTbGFudEVxdWFzdXBkb09mcjtycnRoaW5zb2hiRmZ2YXJzaWdtcW9wZjthcDtEaWFjcml0aWNhbEFjdXRlZXVyaG9va2xldXBoYXJwb29uTG9uZ0xlZnRSaXlhY3V0bnZydHJpT29wZjtESmN5TnRpbGRlO3JzaDtEc2NyYm94cGx1VXBUZWVBcnJvdztsYXRlO1VwRXF1aWxpYnJpdW07Y3V3ZUNycGFyZ1ZlcnRpY2FsTGluZXFwZWdyT21lZ3RwcmlFbXB0eVZlcnlTbWFsbFNxZGFsZXRTb0hvcmljdXJseWVxcHJlYztnZXFuZUFycjtjY2FwczthbmdzcGg7aG9hcnNob3J0cHJicmFja2JveGhVO1N1Y2NlZWRzVGlsZHJBdEFhY3V0c2NjdWVVcFRlZTtEb3VibGVSaWdodEFsc2ltbnRyaWFuZ2xlcmlnaHRTcXVhcmVJbnRlcnNlY2hmcjtjYXBkb3Q7TWllY3lBY2lsZWZ0YXJyb3c7SWZyZnJhYzU4O1BvaW5jYXJlcGxPcGVuQ3VybHlRdW90TGVmdFRyaXBoaXN1cGRhZ05vdFN1cGVyc2V0RXFaYWN1dGVZQW5hdHVyYWxzO2xicmtlO05vdFN1cGVyc2V0RXF1YU5vdEdyZWF0ZXJHcmVhdERpYW1vaWluc3VjY2FwcHJlY2FDb2xvbmVEb3VibGVSaWdodFROZWdhdGl2ZVRoaW5TcGFjZWluZmlzbWVwYU9ncmF1ZmxhdDtFY2Fyb247QWxwaGdzaW1saGVhcnRzQ29udG91ckludG9sY2lyO1plcm9XaWRsbGhhdXBhVmN5Tm90UHJlY2VkZXNFcXVhU3F1YXJlU3Vic2V0ZXVtbENpcmNsZURSb3VsdGxhcnI7TGVmdFVwRG93blZlY3RaZXJvV2lkdGhrc2Vhcm93O0RvdWJsZURvd25Ba2FwY2lyZm5pbnQ7Y2lyY2xlZGRhc2FuZ3N0O3phVXBwUmlnaHRUZWVBcnJvbGVmdGhhcnBvb25kdHJwZXpudW1lVXVtbExlc3NUaWxkZTtVZGJsYUxlZnREb3VibGVCcmFja1VwcGVyTGVmdHNoY3k7QXNzY3lob29rbGVmdHJhZWxlZnR0aHJlZXRpbWVJZG90O3N1Y2Nuc2lOb3RSaWdodFRyaWFuZ2xlRXF1YWw7RG91YmxlRG93bkFycnJhdGlvbmFsc2N1cmx5d2VkZ2U7ZHpjeTthc2NycmNlaWw7a2ZyO1Byb3BvRGlhY3Jsb25nbGVmdHJpZ2h0YXJwYXI7cmxhYmVjYXVzZWN1cmx5ZXFzdWNjO3ZkckFhckxvd2VyUlJpZ2h0VGVlQXJpbnRsYXJoa1RjZWRpbGVzc2FwcHJSZXZlcnNlVXBGaWxsZWRWZXJ5U21hbGxTT3BlbGRyZGhhcjtBZ3JhdmRvdG1ubEFyclN1cGVyc2V0RVNxdWFyZVN1cGVyc2V0RXF1YWxlcmFycnNjdWFycjtybGFyck9jaXJjO05vdERvdWJsZVZlcnRpY2FsQmFyeGNpcmM7dHJpYW5nbGVsZWZ0bG93YmFyO2xhZ3Jhbjt2YXJzdXBzZXRuY3VwY3N1cDJrZ3JlR2ZoZXJFcXVpbGlicml1bWJpZ3NiZXJub2xhdGVzO1JyaWdodG11bWFwRG91YmxlVmVydGljYXR3b2hlYWRyVXBEb3duQXJSaWdodFVwRG93blZudmx0cmZhbGxpY2Nhcm9uO01mcjtpdGlsZEx0cGZyO3ZzY3I7SWdyYXZib3h0aW1lcmlnaHRsZWZ0aGFudmFmcmFjMnF1YXRlckNvbnRvdXJJbnRlZ3JramNoQWJlY2F1c0RvdWJsZVVwQXJyb3dpbXBlYmZyO05vdEdyZWF0ZXJTbGFudERvd25MZWZ0VmVjdG9yQmFuTGVwcm9mbGluZTtLZkxlZnREb3duVmVjdG9yQ29Jc2NzdWNjbmFwcHJyaWdodGhhcnBvb25kb3duO0Nsb2Nrd2lzZUNvbnJpZ2h0cmlnaHRhcnJvWmN5O3VsY29ybnBtO2J1bGxhbmdtaW51cztSaWdodERvd25WZWN0b3JCb3JkbXJwcG9hbGVmc3lzdXBwbHVyaWdodGhhcnBvb251cDthb3BmZXF1YWxzO1JldmVyc2VVcEVxdWlsaXNldG1ueHdlZGFtYWxSYWN1dERvdWJsZUxvbmdMZWZ0UmlnaGNvcGZQcmVjZWRlc0VxdWFSaG87TG93ZXJSaWdoZWdzZG9lYWN1dG5sZTtuUmlnaHRhZW9nb09tYWNsZXNjYztUaWxkZUVxdWFsYnNvbENvdW50ZXJDbG9ja3dpc2VDb250b3V1ZGhhcjt0ZG9TdWNjZWVkc1NsYW50RXF1YWZjeU5vdExlc3NTbGFudEVxdWFuaEFycjtQcjtHcmVhdGVyR3JlYXRlZXBsTmFjdXRSaWdodFRlZVZlY3RvclRpbGRlRnVsbEVxb2N5bG9wbHVlY2Fyb25ydHJpZXRycE5vdFJldmVyc2VFbGVzZXR0c2NyVWJyZWxhbmdsZTtucGFydGFuZ21zZGFhO3JjZWRpbDtwZXJwbm1pZDtiYWNrZXBzaWxvbjtDY252bEFyQ2ZSaWdodFVwRG93blZlY3Rvb2NIdW1wRG93bkh1bXA7bHJtbGVxc2xOb3ROZXN0ZWZyYWM3YXdOZWdhdGl2ZW53YUNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7TGZybHNpbWdpbnRsYXR3b2hlYWRsZWZ0YXJyb3c7Q29uaW50ZHN0clJ1bGVEbWRhc2g7Tm90R3JlYXRlclNsYW50RXFIb3Jpem9udGFsTGlpc2luaW1hZ3BhQ3NjclNjaXJjZm9ybXA7WXNjcmxhbWJkYTtiaWd0cmlhbmdsZXVwc2NuRWdjaXJjO3RoaWNrc2ltR3JlYXRlckZ1bGxFcXVhbGx0bGFycmlxdXRyaXNiO3JpZ2h0cmlnc3dhcnJvd25hcG9zO1JpZ2h0VXBWZWN0b3JCYXI7UmlnaHRVcFRlZVZlY3plZXJwcG9saWxlZnRoc3psRW95Y3k7U3VwZXJzZXRFcXVhbDtjaXJFR3JlYXRlclNsYW51Z3JQYXJ0aWFudW1zcHRyaWFuZ3BlcmlSaWdodEFycm93TGVmdEFIb3Jpem9udGFsTGluZTtib3hVUjtDb25pbnQ7T2Rib3JvREQ7U09GVGN5Tm90SHVtcERvd25oZXJjb250d29oZWFkcmlnaHRhcnJ1c2NyWG9wZmdlcTtQcm9wb3J0aW9uYWw7cXByaW1lO253bmVhcmxlc3NhcHByb3g7Rm91cmllcnRybmxBcnI7dXVhUGx1c01pb3BsbHJ0c3VwbnJpc2luZ2RvUmlnaHRBbmdseGxhY29tcGZuO0dyZWF0ZXJFcWJveHZlc2NyO0lKbGlnO21pZDtlcXNpbWh5cGhEb3VibGVDb250b3VySW5pbnRlZ2xmaXN4c3Vic2lwcmVjbnNpbTt4aGFycjtiaWd0cmlHcmVhdGVyTGVkSGFzdXBuZWNpcmR3UkVHO3JkY2JveGhETnNsZXNzYXBwcm94SW50ZXJzb3VtbGRvd25hcnJvRW1wdHlWZXJ5U0NIUG9wZjtXZWRnZW9pbnRvdnVsY29ybmVyO0NvbnRvdXJJbnRlZ3JhbDtSaWdodFVwVGVlVnZkYXNoO3NjY3V0cmFkZTtmYWxsaW5nZG90Y2ZyO05vdFNxdWFyZVN1cGVyc3VsdHJpTm90VGlsZGVGdWxsRXFMZXNzRmJveHZIdHdvaGVhZGxlZnRhcnJvVXBzaWxvbkFFbGlrZ3JlZW47bHRyUFZlcnRpY2FsVGlramN5O0xhY3V0ZXN0cmFpZ2h0ZXBzaWxvblJpZ2h0Rmxvb3I7RW1wdHlTbWFsbGlvdGE7YXBwcm94RG91YmxlTHplZG91YkRpYW1vbmQ7Zm9ya3NjY3VlO2x1cmRMZWZ0VXBEY2NpcmNyc2hMZWZ0RG93blZlY3Rvcjtsb3dhbmhWZnN3YXJoVW5pb247V29Mb25nUmlnaHRBcnJvdztwcmlFcXVpbGlDaXJjbGVNaW5qY2ltb2RlZmVtYWxlZG93bmhhcnBvb25yaWdodDtWZXJ0O1FzY3NlQXJWZGFzaGw7bnZydHJTdWNjZWVkc1NsYW50RXF1blZkYXNoc3FjUmlnaHREb3duVmVjdG9yQmFybHJ0cmh5YnVjdXA7SHVtU2hvcnREb3duQXJyb3c7c3ViZWRuc3Vwc2V0SmN5aXNpbmRidW1wRURvdWJsZUNvbnRvdXJJbnRlZ3JhbHNleHRudkhhVmJEb3duYXN0cmFpZ2h0R3JlYXRlclRzdXBwbHVzO05lZWNvbHF1YXRlRmlsbGVkU21hbGxTcURvd25MZWZ0VGVlVmltYWdsT3BlbkN1cmx5RG91YmxlUXVvdGU7T2ZsbHRybHNxdW9yYmthcm93dmFycGk7b2FzdDtFeGlzdHNMZXNzRXF1YVNxdWFyZVN1YnNldDtlcmFycjtkamN5VGhlcmVmb3JldmFycjtNZU5vdExlZnRUcmlhbmdsZWFuZGRvbGNyb3NyYXJyYXBTaG9ydExlZnRBcnJvdztjd2Nuc3VjY2VxdGlsZGN1bGFyRmN5RG93bkFQcm5lc2VhcmJhY2twcmlDbG9ja3dpc2VDb250b3VydGNlZGlsO3VoYmxOb3RHcmVhdGVyTGVzcztib3hEUjtMZXNzU2xwcm9wdG87cGl0Y2hmb3JrO2dicmVMb3BmO2NjYXB6Y3k7Y3VydmVhcnJvaGNsYXJyc2ZmbGlQb2luY2FyZXBsYW5lO0F0aWxlbXB0eXNIb3Jpem1lYXN1cmVkYW5nbHNjaXJib3hVbDtsYXJycGxmbGF0cmlhbmdsZXByaW1TcXVhcmVTdWJzRFNjeTtFcXVhbFRpbGRlO2JlY2F1c2U7ZXF2cHhvcGFjaXJjU09hY2NhcnhvcGx1cztOb3RFbGVtZW50Ym94aHVMYXBsYUltTUVtcHR5U21hbGxTcXVhaG9tdGh0O1ZlcnRpY2FsU2VwYW5nc05vdEdyZWF0ZXJGdWxsRXF1YWxoZXJjb0lvbnBhcnQ7RG93bkFycm93RG91YmxlRG93bkFycm9uTHR2O2x0aHJlZTtDYXBpdGFsRGlmZmVyZW50ZHppT3Njck5vdExlZnRUcmlhbmdsZUVxdXNtZU5vdFNxdWFyZVN1YnNldEVxdWFuanJhcnJoazttY29tbVRvTG93ZXJMTm90RXF1YWxUaWxTdWNjZWVkc0VxdWFsTm90Q29uZ3J1ZW50O3hyZGVtY3VwYnJjYXA7TGVmdFZzdXBlZG9taWNnamNOb3RMZXNzR3JldHdvaGVhZHJpZ2hFY2lib3hoZDtwb2ludHZhcm5vdGhuYXRUY2Fyb247Tm90SHVtcERDbG9zZUN1cmx5RG91YmxlR3JlYXRlckxlc2x0aGN1dmVlTm90SHVtcEVxdWFsO250cmlhbmdsZWxlZnRlTm90U3F1YXJwcjtiYWNrcHJ0aGlja2FlZG90bG9icm5hcGlvYXNvdmJhcjtKdWtjeTtydHJpO3N1YnNldGVxQXBwbHlGdW5jdGljb25nYW1tYU9tYWNyO3ZzdXBubnBhcnNsO1djaXJjb21pYnVtcGVpaWludDtsdGRvY2FjdXRlUHJlY2VkZXNTbGFudFJpZ2h0RG93blRlZVZlY3RvRG91YmxlVXBEVXBBcnJvd0JhcjtvY2l2YXJ0cmlhbmdsZWxlZnBobW1hdDt1dGlsZGVXc2NDb3VudGVyQ2xvY2t3aXNlQ29udG91ckluQ2xvc2VpbWFnbGluZUVsZW1lbnRlcWNpcmNrZnN6dnpvb3BmRWdyaHlwaGVuRG91YmxlTGVmdFJpZ2hudGlMZWZ0VXBEb3duVmVjdG9lb3BmO2Jick5jYXJzZG90TGVzc1NsYW5SaWdodFRlZVZMYW5nVWZ2YXJzdWJUU2Nuc3Vic2V0ZXFxR3JlYXRlckxlc3M7emFjdXRlcmlnaHRsZWZ0aGFycFJ1bGVEZWxhU3VtO2ZsbGlJdGlsZGx1cm5jZWRpbGxIYW5hcHBubGVzO2Rzb2xEb3duQXJ1d2FuZ2xlO2h5cGhlRHNhY2ROb3ROZXN0ZWRMZXNzTGViZXRoO25WRGFzaDtleHBlY3RhdGlvU2ZyTGVmdGFycm9VbmRlckJyYW5nbXNkYWhsb3plU2Nhcm9uO2x1cmRzaGFib3htaW5tbGNiZWNhdXM7ZnJhc2x2YXJwcm9Sc2NyO2N5TGVzc1NsYW50eHVwRG91YmxlTG9uZ1JpZ2h0QXJOSmN5UmlnaHRybG1wcnVyZWw7SW50ZXJzZWN0aW9uTm90U3VjY2VlZHNTbGFudEVxdWFuY2VkbkxsO25lYXJoaztDaXJjbGVUaW1lcztsb3dhc3Q7cGVyY25XY2lybnNob3J0cEFwcGx5RnVuRG93bkxlZnRSR2NlZExvbmdMZWZ0UmlnaHRscmhhcmRpbnRlZ2VBbHBiaWd1cGx1c3N1cHBsdXNsb3pmQ2x0aGlja2FwcGR1YXJybmV4aXN0c29kc29Mb3dlckxlZnRBcnJvdztib3hqb3BmRXhwb25lbnRpYWxFO09FbGlnO0dyZWF0ZXJGdWxsRXFaZXJvV2lub3RpbmRvdDtJbXBsaWV1bGNvQ29udG91ckludGVic29saGluY2FyZUxlZnRSaWdodFZlY2VwYW50cmlhbmdsZXJpZ2h0O0ZpbGxlZFZlcnlTbWFsYXBhY2lyYm94dmw7QmVjYXVzZU5vdFByZWNlZGVzU2xhbnRFcGVydGVua2hiYXJQYVRIT1JlcXNsYW50bEludGVyc2VjbnNxc3ViZTtuc3Vic3VjY2N1cmxSZXZldG9lYXJiTWludXNQbHVzO3JmbG9vcjtHcmVhcmZycmFybG1vdXN0YUlFY3lsZXNnZXNyaWdodHNxRmlsbGVkVmVyeVNtYWxsc3RyYWlnaHRwRG91YmxlTG9uZ0xlZnRSaWdodEFycm93O0RvdWJsZUxlZnRSaWdodHJ0cmllO3JpZ2h0bGVmdGhhcnBvb2xvb0Nkb3ROZXN0ZWRHcnBsdXNiO2JOT3RpbWRBZ3RyYXBwbHZlcnRuZXFub3RjbHVic3VpdDt1QXJlcGx1Q29wcm9kZ2pjeTtuZXNlYXI7ZW1wY29sb247bGFjbGc7RG93bkJyZXZDYXBpdGJsYWNrdHJpYW5nbGVkb3duZXNkb3RjaXJFO1VwcGVyTGVmdEFOb3RTcXVhcmVTdXB1ZGJsbGVnO05vdFJpZ2h0VHJpYW5nbGVFWHNjcmJsYWNrdHJzZXhnZXNjYztOb3RFeHZhcnRyaWFuZ2xlcmlnaGxBYWhhbWlvYWNoZWNsc2FxdW87c2lnbWF2RmlsbGVkTG9uZ1JpZ2h0Z2xqTGVzc0VxdWFsR3JlYXFzY3I7Tm90U3Vjc3VicHNkb3RlO29saW5nYnJ1Z3JhdmU7Y3VldmFycHJvcHRvVWJyZXZlO3B1bmNzcFVhcnI7Y3Rkb3Q7dWxjcmFybmxzaW07anNlbGVmdGFycm93dGFpbGRzdEdjaXJSaWdodEFuZ2xlQmd0cXVlc3RWZXJ0aWNhbFNlbGRyc3VjY2FwcEJyZVVwcGVyc3Vwc2V0ZXFxUmlnaHRUZWVBYmlnd2NoZWNrbWFHcmVhdGVyR2xuZXE7YWFhcHByb3hlcTtzbWFsbHNldG1pUmFycjtyaWdodGxlZnRhcnJvc2R2bnN1YnN1Y2NlcTtOb3RUaWxkZUVxdWFsO2N1cnJlYm5lcXVpdnJpbndlaXN1Y2Nuc2ltO25wb2xyc2NyO3JhZGljQ2NpcmM7RGFnZ2VyO0dhbW1hY3N1cFlhY3VEb3VibGVMb25nTGVmdEFycm93O1RyaXBsZURvdDtMb25nbGVsb2Jyaztkb3duaGFycG9vbmxlZnQ7dGNub3ppZ3JhcnVwaGFycG9vbmxlZG9sbGF2YXJzdWJzZXRuZXFxT2dyYXZlO2NvbG9uZXFMZWZ0Q2VpbGluQWdTSENIY3k7YW5kRG93blJpZ2h0VGVlVmVjdG9mcmFjNzhsdHF1ZXN0Q2VkaWxsR3JlYXRlclNsZHNjeW5yaWdodGFydXBoYXJwb29ucmlnaEFjaXJ5dW1sO0FhY3V0ZWNvbmc7ZnBhcmJzaW1lSnNlcmN5YmFja2Nvbmc7eHJBcnJMZXNzRXF1YWxHcmVhdGVyO0REb3RyYWhkO1RoaW5TcGFicnZiYXI7U2hvcnRMQWZyO3Zhck5vdFJpZ2h0VHJpYW5nbGVFcXVhc2VhcmhrO29taWNyb25hYmxhO0RvdWJib3hVTDtzdWNjc2ltO2l0O0JhcnZOZWdhdGl2ZVZlcnlUZWdzZG52ZG9yZGVyb2Y7bG90aW1ucGFyYWxsZWw7UmlnaHREb3duVmVjdG9yQmFMZXNzTENpcmNsZVBsdXByZWNuYXBwcm94O1RmckNsb2Nrd2lzZUNib3dPbWFjcmdicmV2TG93ZWN1cmFycjttRHJvYnJrTm90UmV2ZXJzZUVsZW1lUmV2ZXJzZVVwRWVxdWl2REQ7YmlndXBsVXBwZXJSaWdodEFycm93bHRkQWN5O3Bob25jd2NvbmluaW50TmVnYXRpdmVUY2hlVGlsZGVUaWxka2dyZWVOZWdhdGl2ZHVoc3VjY2N1cmx5ZXFVYnJjeTtVbmlubGVzc2JveGRMO3BvdW5kZG90c3F1YXJTaG9ydFVwQXJyb3d1cHNpaDtUU2N5O2lzY3I7TnU7T2FkdGRvY2lyY2xlZFI7TG93ZXJMZWZ0QXJyb05vdFJldmVyc2JveHVSUGx1c01pbnNjbnN1cGRva3NjZXNoeWx0Y2NtbGRyUmlnaHRBbmdsZXVhY3VsYWZzY3JOZWdhdGl2ZVRoaWNrU3BhY2VUaWxkZUZ1bGxtc2NyO2d0bFByaWdodHNxdWdlcztwbGdzaW07UnJpZ2hlbWFjcjtTdWNjZWVkc1NsYW5yc3F1b0pjaXJjO05vdEdyZWF0ZXJUaXZlcmJTdXBlcnNldDtSaWdodFVwVGVlcGx1c2NpUmlnaHRBbmdsZUJyYWNrZXRuaWNpcmNsZWRTO2NjYUNvbnRvdXJJbnRlZ3JhZWdzZG90VGhpY2tnZTtMZWZ0QW5ubGRybHREc3R2YXJ0cmlhbmdOb3RHcmVhdGVyR3JlYXRlY2VtcHR5djttZWFzY3VkYXJybDtEY2FydmNidU5vdEdyZWF0ZXJTbGFudEVxdWJsYWNrc3FjdXBjdXA7emV0YU9jeXhyYXJybmhwYXJsbmVxcTtzdWJzdWI7ZmxsaWdMZWZ0RmxUaGRhc1JmcjtjeWxjbWFsdXRyaWY7SWdyYWxlc3NldGltZXNiO25oQXJybG5zaW07Zm9wY2lyZlRzdHJva29mY2lyO0V4cGxlZnRyaWd0b3Bib3N0cm5zO25SaWdodGFycnJpZ2h0cmlnaHRhcnJvd3M7bnN1Y2NlcTtDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVnUmlnaHRWZWN0b3JCYXJjd2JhcndlZENhY2JveHZodmFyc3Vic2V0bmVOb3ROZXN0aGVyZWZvck9wZW5DdXJseUtjRG91YmxlQ29sbmFwcHJveG1oZ3RjYWNFbmx0ZGRhcnJTSEN0aW50O2JyZXZtZWFzdXJlZGFuZ2xlbmxlZnRyaWdOZWdhQUVsTGNhcnNmcnF1ZXN0ZXFzY0RvcGZpbnRlZ2VycztOb3RQcmVjZWRlc1NsYW50RXF1TGVmdERvdWJsZUJyYWNjb21wbGVtYXdpbnRoc2xhc2hkb3BkcmJrTGVmdFRyaWFuZ2xEb3duQXJyRG90VGlsZGVUaW1vYmxhY2t0cmlhbmdsZTtTdWNoVGhhdDtib3h1bWlkZG92bHRyYmlndXBsdXM7Z3RjaXJuR3R2Tm90SHVtcEhpbGJlcnByc2ltO2NvbG9uZTtudkludmlzaWJsZUNvbW1hO05vdFN1cGVyc2V0d3JVbmRlclBhcmRvdWJsZWJhcndsaGFyZHBvcGY7dUFycjtsZWZ0dGhyZWl1a2NIdW1wRG93bkhwcm9mc3Vic2V0ZWNhcGNhcGxnRTtWRGFzaDtvdGltZXNhcztsZHJ1c2hMYW5nO2lzaXpjYVJldmVyc2VVcEVxdWllcXZwYXVicmV2cmRxY2VudDtJZGVzaW07YmxrMW52bEFkaWFtc05lZ2F0aXZlVmVyeVRjdHJpbWluUmlnaHREdmVlZWxlZnRyaWdodHNxdWlnYXJyb3c7SW50O2ZsdG5zZ3Rkb3RlcWNvbG9sb29wYXJyZG93bmFycm93O29sdDtjZWRpbDtPcGVuQ3VybHlEb2VsaW50ZXJzO25HdDtVbmlvblBsdXNzcWN1cHM7TGVmdFJpZ2h0VmVjdG9yO2R0ZG1ob0RvdWJsZUxlZnRUZWU7bmxlZnRyaWdodGxlZnRsZWR6aWdyYXJTcXVhcmVJblpmcjttaWRkb2xhck5vdExlcWZhc3ltcGVxc3FzdWJzZUxvd092ZXJQYXN1YnNsZWZ0cmlnaHRoYXJSaWdodFRyaWFuZ2xlRXFvdGltZWNvcHJvZDtubXNpZ21hdjtSaWdodFVwRG93blZlY3NjbkU7SmN5O05lZ2F0aXZlVGhpbnF1YXRlcm5pb25zO3N0cmFpZ0xlZnRWZWN0bHNoU3VjY2VlZHNTbHNvcGdhY3VHcmVhdGVyTGVzc0Rvd25BcnJvd0JhcjtVcFRlZUFJSmxDbG9zZUN1cmx5RG91Yk9hY3V0ZUxsZWZvbWljUnVsZURlbGF5ZWQ7TGVmdEFyRG91YmxlVmVydGljYWxCeWlsZXNzZ3RTcXVhcmVTdWJzZXRFcW5hdHVyTGVmdFVwRG9uamN5R3JlYXRlckdyZWF0ZXI7UmV2ZXJzZVVwRXF1TG93ZXJLSmNwcmVjYXBwcm9Eb3BiaWdzcWN1cDtDYXlkbGNyb3BzcWN1cHhtRG91YmxlTGVmdFJpZ2h0QXJyb3JCYXJyTm90U3VjY2VlZHNFcXVhY2FjdXNlYXJodmFycGhkdHJpbnZsdEF0aWxkZVVwQXJyb3dEb3duQXJyb3Nxc3Vwc2V0ZXFuY0VxdU5vdExlZnRUcmlhbmdsZUJhcnRvcGNpckxlZnREb3ViemlncmFMZWZ0VGVlQXJyb25lc2ltTm9wZjtudmdlc21hbGxzaGFycjtpamxpZ0V4cG9udGN5O2R6aWdyYXJyO3BybnNpU21hbGxDcGFyYWxsZWxBcHBseUZ1bmN0aW9uO25sZWZ0c2hjaGNVYXJyTGxlZnRhcnJvbGVzc2d0cjtycnRock5lZ2F0aXZlVGhpY2tTcGF0d29oaWlvdGFzY0U7bGFlbXB0UmV2ZXJzZUVsc3VicmlnaHRzcXVpZ2Fycm9CZXJub05vdEdyZWF0ZXJKb3BkcmNvaEFyckNhcGl0YWxEaWZmZXJlbnRpYWxEO25lZG90TmNlZGlzaW1sRW1hcHN0bztTaG9ydFJpZ2h0QXJyb3c7c3VwMjthbWFsZ2hhcnJjaXJleHBvbmVudGlhbGU7TGVmdFRyaWFuZ2xlRW5zdXBzZUxvbmdyaWdodGFycm93O1JpZ2h0RG93blZlY3RvcnJtb3VzdGFjaGVnZXNkb3RvbE5vdFNxdWFyZVN1YnNuZXhpdGhpbnNwO1NIQ0hjQnNjcmd2ZXJ0bk5vdFN1ZmFsbGluZ2RJRWN5O3VydHJpO3ZwcmxmbG9tYXBzdG9kb3duYmlndHJpYW5nbGVkb3duO0Rvd25MZWZ0UmlnaHR0cmllb1NpZ3Jsb25nbWFwc3ROZXN0ZWRMZXNzTGVzcztzcXN1U21hbGxDaXJjbGU7dnN1cHpjYXJvQmVybm91bGxpc2xuTG9uZ2xlZnRhcnJkZmlzaHQ7Ym94dGltZXNib3R0b0VhY3V0ZTtNZWxsc2xhcmxuc2l4bWFzb2Z0bWlkY2lyaXNpRGlhY3JpdGljYWxEb3VmamxpZ0NheWxleXNJY2lyYzt1dHJpZm5sZWZ0cmlnaHRhckNhcGl0Y2FybmFjdUdyZWF0ZXJGdWxsRXF1YWw7a3Njcjt2ZWxsaXBBb3BzcWNhcGVtYWNoZWFydHN1aUdyZWF0ZXJGdXZhcnRoZXRCZXRhO05vdEdyZWF0ZXJTbGFuQWNyZmlzaHRFeHBvbmVudGlhbEVramN5bnJhcnJhdGFpbGx1cmRzaGNjZWRpbDt6d25VbmRlckJhcnN0cm5zZWNpcnJkbGROb3RHcmVhdGVyTE5vdEdyZWF0ZXJFcXVhbDtVZ3JhdmU7d3NjdmFycHJvcHRvO3NzY3N1cG5lO3N1Ym11bHlvTm90TGVzc0xlc3NVbmlvbkFwcGx5bHVydWhsb3BsdXM7ZGVsdExsZWZ0YXJyb3dndHJQYXJ0aWFsRDtGaWxsZWRWZXJ5RG91YmxlVmVydGljYWxCYXI7Y2lyZm5pbk5vdEdyZWF0ZXJGdWxsRWZqbHhoYUxlZnREbnVtc3A7TGVmdHJpZ2hSaWdodFVwSHNjTGVmdFVwRG93blZlY0xlc3NFcUhjaXJjcm9hcnJOb3REb3VibGVzbWVwYXJzQ09Eb3duQXJyb3dVcFZkcGVyY250O092ZXJOb3RSaWdodFRyaWRoYXJDZW50ZXJEb3Q7c2ltcmFUaGVyZWZHcmVhdGVyRnVsbEVxdWlhb2ZjaU5vdExlc3NHcmVhdGVjb25nZG90TGVzc1NsYW50RXF1YWw7Y3Vwc2Vuc3ZhcnRyaWFuZ2xlbGVmdFJCYXJyb2xpbmU7bmxlZnRyaWdodGFycm93ZXBsdXM7bmlzZ3NjckRhc2h2O2Vtc3N3YXJoaztEb3VibGVWZXJ0T3BlbkN1cmxjaXJjbGVhcnJvd2xlZnRuYWJFcXVpVmVydGljYWxTZXBhcmF0b3JscmFyY3VybHl3ZWROb3RIdW1wRG93bkh1bXByaXNpbmdkc3VjY2VOb3RSZXZlcnNlaG9yYmFyO3ljaXJFZG90aGVhcnRzdWl0O3VoYXJyO0RvdWJsZUxlZnRSaWdodEFycm93O3ZydHJuc3Vic2V0ZXE7VXBEb3duQU5lc3RlZEdyZWF0ZXJHckxlZnRyaWdjb21tYTtSZXZlcnNlRWxlbWV1aG5ndHN0cm9reHJBcnI7UmlnaHRBbmdsZUJyYWNrTm90U3VwZXJzZXRFVW5kZXJQY2FwYnJjdXB0d1RpbGRlRXF1Q29udG91cklub2Rhc2xicmRsY29yTG9uZ0xlZnRBcnJvdztBc3NpY29weXNyY3VybHllcXByUnJpUmlnaHRhcnJCZmJveHBPdmVyQnJhVXBwZXJMZWxmaWxhZ3JhR2NyaWdodHJpdkFycjtvZFJpZ2h0VGVlO29oYmFyc2Nwb2xpbkFvZ29uTGVmdEFycm93O0dzb2Rhc2hjdWVwcjtQbGNjYm94bWludXM7VGhpY2tTcHJzcXVvcktvZ3JhdWJOb3RSaW52RGFzaDtiaWdvdGlVYnJHcmVhdGVyRXF1YWw7d29wZjtQb2luY2FyZXBJbnZpc2l1dGRvQ2xvc2VDdXJseURkaWFtb25zY2FscGhpb2N5O2Jicmt0YnJmcmFhbXA7bnVtZXJBcHBseUZ1bmNjaXJjbGVkY2ljYXBhbmQ7Y29tcGxiaWdvbnZndEJldHN6bGlnO3N1Y2NlcXVwdXBhcnJvd3NzaW1yYXJybG9wbHVwYXJyb3dQc2k7YmxhY2tzcXVhclJpZ2h0VHJpYW5nbGU7R2N5O252bENpcmNsZURvZm9yYWxsZ3Ryc2ltO21kYXNoRG91YmxlTGVmdFJpZ2h0QXJhZWxpZztMZWZ0Q2VpbGhvcHJubWl0cmFyaXNpbmdkb3RlcWNpcnNpbXJhck5vdFNxdWFyZUxjeTtzZWFycm93O29sc3FjYXA7TGVzc1RpbGRlZURvaG9va2xlZnRhcnJvd01lZGllYXN0ZXI7UHJlY2VkZXNFbnZpbmZpemlnZ29wZlJjYXJvbmNpcmZuY29uZ0NvbmdyZGNudGlsZGNpcmNsZWRhc3Q7TG9uZ0xFbXBsdHJpO25zaW1Ob3RDdXBDYXBJbnRlcnNlY3Rpb3Jtb3VzdGN1cGRvdDtTcXVrb3BmO0VtcHR5VmVyeVNtYWxsU3F1cmJya3NscnRyaTtUY2FSaWdodFRyaWFuVXBwZXJMZWZ0QXJydXRkb3Rib3hIVTtTY2VkaWxsb25ncmlnaGR1YXJ0aGlja2FwcHJveHZhcnN1cHNlRG91YmxlTGVmdFJTaG9ydERvd25Bcm5zdWJFTm90TmVzdGVkR3JlYXRlckdyZXFwcmltZVZlcnlUaGluU3BhY2dlc2RvdG87QnJldmJpZ2NhdWFjdXRIb3Jpem9udGFsTHZhcnN1YnNldG5lcU5vdEdyZWF0aXVzcXVEb3duUmlnaHRWZWN0b3JOb3ROZXN0ZWRHcmVMZXNzRXF1YWxHaWZmT3BlbkN1cmx5RG91YmxlUXVMZWZ0VmVjdG9yQmFMZWZ0VXBvZWxpZzt1d2FuZ2xTbWFsbENpcmNsbGxjb3JuZXI7b2xjaXJEaWFjcml0aWNhbFRSdWxlRGVsYXlOb3RMZXNzU2xhbnRFcXVhbDtsZWZ0cmlnaHRzcXVpZ2JsYWNrdHJpYW5nbGVyaXNtYWxsc2V0bWludWptYWRjYXJvbnNlc3dhckVtcHR5VmVyeUNsb3NlQ3VyVmVydGljYWxCYXI7THN3ZWRkemlncmFycnRhdTtMYXJyO21pZGNDYXBpdGFsRGlmZmVyZW50aWFib3hVTGJveHZMUmlnaHREb3VEc2NyO05vdFJldmVyc2VFcmlnaHR0aHJlZXRpbWVzO1Nob3J0Umlac2NyO3JhZ2VzbGVzbmxlcXNsYW5yaW5nO1NxdWFyZVN1cGVyc2V0RXFvbGNyb3NzO3RyaXBsdXM7c3FjYXBzQ2Nhcm9uO25lcXV1cGhhcnBTdWJNaW51c05vdExlZnRUcmlhbmdsZUJhT3ZlclBhcmVuT3ZlclBhcmVudFBvaW5jYXJlcGxhbmVOdGlsc3dhcnJwc3VwZG90O21pUmN5SHN0cm9Eb3VibGVDb250b3VySW50ZWdySWNpcmNwZXJpY2lyYztib3h0aWhlbGxyaGFydVVyaW5nO1NxcnRzYztFbWFjU0hDSGN5UG9wbG9uZ3JDSGN5O1NmcjtucmlnaHRuY29uZ2RvdHRoa2FiYWNrTm90R3JlRG93bkxlZnRUZWVWZWN0Q2lyY2xlVHVncmF2c2ltZExvbmdsZWZ0cmlnaHRhcnJvd09yO1JpZ2h0VXBWZWN0b3JCYXhzTm90VmVycm9hbmc7TGVmdEFycm93UmlnaHRBemVldHJmO1JpZ2h0VGVlQXJyb3diZW1ybm1zdWNjYXBwcm94O0xlZnRVcFRlZVZndHJhcnI7a2NlZGlsO2NpcmNsZWRhbGFycnNpbUxtaWRvbGVmdHJpZ2h0YXJyeHJhUmlnaHRVcERvd25WZWN0b3JubEVMZWZ0UmlnaHRWZWN0b0djZWRpbG1vdXN0O25nZU5vdEdyZWF0ZXJFZW9nb247Z25hcHByb25zdWJzZXRlcXNlQXJydXB1cGFOY25nRXZzdWJuZTtQcm9wb3J0aW9uYW9wZU5vdEdyZWF0ZXJMZXNzRG90RXF1YWw7bG93YmRxTGVmdFVwVmVjdG9yTm90R3JlYXRlckVxdWFydWx1aGFyO1ZlcnRpY2FsQmFyeHNxY3VwZXRhO2NyY3VkYXJyck5vdFNxdWFyZVN1cGVyc2V0RXF1YWw7ZWFjdXRlTmVnYXRpZGRhZ2dlcnN1Y2NuZWxvbmdsZWZ0YXJycHJuRTtFb2dvbjtDYXBpdGFsRGlmZmVyZW50aWFsRGd0cU5vdEN1cENhcDt0b3BjaXN0cmFpZ2h0cGhpO2ljeWV4cGNlZGlsQ2VudGVyRG9hcGFjaXI7cGhvbmU7RG91YmxlVXBEb3duQUxlZnRUZWVWQXJpbmJpZ29kY2NhcmxkcGxhbmNtSWFjdUVtcHR5U21hbGxTcVVuZGVyQmFwcHJveGVOb3RHcmVhdGVyRXF1RGlhY3JpdE5vdEdyZWF0ZXJTbGFudEV2ZWViY2lyY2xlZGRhc2g7Y2FwY2FSaWdodEFyRXF1aWxpYnJpdW07cmlnaHRoYXJwb2FuZ21zTm90TGVmdFRyaWFuZ2xlO3dmcjtwcm9mYWxhcjtEb3duQXJyb3h3ZWRnZTtOb3ROZXN0ZWRHcmVhdGVyR0tvaXNsZmlzaE5vdFN1Y2NlZWRzRXF1YWN1RG91YmxlTGVmdFRlZWVkRG91YmxlTG9uZ0xlZnRSaWdodEFycmxvdGluaGF0c2hjU3Vic2V0RXFudnNjdXJ2ZWFycm93cmlnaHRMZWZ0Q2VpbGluZztsSGF1bnNob3J0cGFzY2Fyb0RpYWNyaXRpY2FsQXBhbnByY0ljaXJhb2ludGVnZXJhY3lpc2lucztMZWZ0cmlnaHRhcmNOb3RUaWxkZVRpbGRIb3Jpem9udGFsdXRyaTtSaWdodFRlZUFycm93O0ludGVyTm90TGVmdFRyaWFuZ2xzdWJzZXRuZXFxaXVrdGhldHZEYXN1cHNpbG9uO2Vxc2lDbG9ja3djdXBvcjtUY2VkaWxJbkFicmV2U3F1YXJlaW50Y2FsbmhhcnI7bnNob3J0cGFyYUNvbmdydWVucGx1c21uY2hlY2tzaGFycDtEaWFjcml0aWNhbERvdHByb0xvbmdsZWZ0YXJyb2tmcnJlZztScmlnaHRhcnJvdztyb3BmO0Vwc2lsb3pjVmVyeVRoaW5TYXRpbGRlZm9yaztzdXBzZXRldXBkb3duYXZhcm5vdGhpTGFwbGFjZWZlbWFIdW1wRURvdWJsZXJpZ2h0dGhyZWV0aWxlZnR0aHJoeWJ1bGRzdHJvaztjdXBvcnRoZXJlZm9QaWxtb3VzdGFjaGNjYXBzTmNlR2JyZUludGVnclRoaWNrU3BhY2U7RG91YmxlQ29udG91ckludGVncmFsO2ltYXRzZXRtaW51c25ndFZjb29sdm5Eb3duUmlnaGhhbWlsdHJhcnJiZmJhcndlZGdlO2NzdWJlbGFuZztOb3RQcmVjZWRlc1NsYW50TG9uZ0xlZnRSaWdPcGVuQ3VybHlRdW9tZEdkb3RwZXJwO1N0YXI7bnJhcnJjYm94RFJMZWZ0QXJyb3dSaWdodEFyaWdyYXJhcnJmZ2FwO1Nob3J0TGVmR3JlYXRlclRpbGRlZHRyZG93bmhhcmNvbmlkZG90bEFhcnJubGFwbGFua2FjaW1pZGFzdDtyY2Fyb09ncm5HZ2xhbmdsVmVyeVRiYWNrY29mcGFydGludFVmcjtiaWd3ZWRnZWludGVyY2F0aGV0YXN5bVByb3BvcnRpb3JhZW1wdGxzcXVvdXdhbmdlcXVlc3NvbGJhcjtHcmVhdGVyckhhdXBzaWx0cmlhbmdsZXJpZ2h0aXNpbkVvZ29uO0dKbG9vcGFycm93cmlnaGxhcXVvYW1wRG93bkxlZnRSaWdodFZlY3RvbWFwc3RvbGVmYmlnb3RpbWViaWd0cmlhbmdsZWJveHZoO3N1YmRvdGlpb3RtYXJ0d29oZWFkbGVndHJkb3RGb3JDYXlsZXlDbG9zZUN1cmx5RG91YmxlUXVvdGU7T21pY3Jvbkd0djttbk5lc3RlZExlc3NMZXJwYXJndExlZnRSaWdodFZlY3RzdGFyZjtCZWNhdXNsZWZ0bGVmYWJyZXZlcmJya2U7c3VwbGludGNhbDtmZmlsUmlnaHRBcnJvd0xlZnRBcnJOb3RTdWNjZWVkc1RSQnVtcGVxO2JveG1pbnVzSGNpcktIY3k7T2RzcGFydHJpYW5nbGVsZWZ0O3NyYXJybmZpY2l0cnBleml1bXNjcG9saW50eHNxY3VwaGFyZ25lcXFzZnJvcGx1c2R1O2NvcHJSZXZlcnNlVXBFcXVpbGlicml1bTtsZHNBcGJveEh1eG9wbHVyYmFycjtTbWFsbENpQ2xvc2VDdXJseWljO0Rvd25BcnJvd1VwQXJyb09wZW5DdXJseURvdWJsZWNhcm9uO3VoYmxrO2JhY2tzaW1lcWJldHdlZW5yYWRpYztvcnZOb3REb3VibGVWZXJ0blZkYXNoO25jb2d0cmxlc3NFVEhzdXBoc29wcm5zaW1zcWN1Z3Jhdm5vdG5pdmNzaW1lcTtPc2NzaW1uRmlsbGVkU21hbGxzcXVvcjtBbHBoYU5ld0xpZGl2b3hkdHJpbmxzaW1udHJsc3Ryb2JpZ3dlZGdOb3RMZWZ0VHJpTmVnYXRpdmVWZXJ5VGhpblNwbnZyQXJOb0JJbnRlZ2tzY0hzdHJOY2VkTGVmdFRlZVZlY3RvcmFwRTtOb3RMZWZ0VHJpYW5nbGVFUmlnaHRUcmlhbmdsZUJhTXNSaWdodFZlY3RvckJuc2hvcnRwYXJhbGxMb3dlckxlZmxIYXI7ZmpxdWF0aW5uY2Fyb3N1YnNldG5lcTtwcmVjbmFwRWNhYm94VVJQcmVjZWRlc1RpbGRwYXJ0RGludWJvdHR3ZWllcnA7Tm90UmV2TEpjeU50aWxkT3RpbWVzRG91YmxlUmlnaHRBcmpzY3I7bGJyYWNlO0Rvd25UZWVpbmNhcnVyY3JvcGJpZ2NVcHBlclJpZ2h0QURvd25SaWdodFRlZVZlaW1hZ2U7RG93bkFycm93VXBBcnJzdHJhaWdodGVwc2lOb3RTdWNjZWVkc0VxdWFsO1FvcGY7RG91YmxlUmlnaFNtYWxsQ2lyY2xlRWRJbnRCb1Nob3J0UmlnaHRzcXN1cHNldDtjaXJjbGVkY2lyYztFbXB0eVNtYWxsU3F1eWFjeTtsYnJrc0RvdWJsZUxvbmdSaWdodEFycm93cmVhbGluVW5pb25QbEF1bUdyZWF0ZXJFcXVhbExlc21pbE5vbkJzY2U7WmZyZWdyYXZlbHRjYztucHJjdWVHcmVhdGVyRXF1YWxMZXNzO3NpZ21hZm9TO2V4cG9uZW5sYWN1ZnJvd247R2NlZGlsO3JzcWJOb25CcmVha2luZ1NwYU5vdFNxdWFyZVN1cGVyc2V0RXFzZXRtaW51Y2VtcHR5c2lnbWFNaW51c1BsUmlnaHREb3VibGVCcmFjbGFycnNpc3ViZG90O2VtcHR5bG9uZ2xlZnRhcmNhcGFpZXhjbG5kVXBBcnJvd0JhYm94Vmw7dHJpYW5nbGVkb092ZXJQYXJOb3RMZXNzRXNpTHNjcjtubGVxO3JjeTtsb3plbmducHJlY2VxO2VmRHlpY3k7cXByaW1ub3BmbGZyO3JhbmdkdGhrYXA7Ym5lcXVpT3ZlckJyYWNlZnBhcnRpbmJpZ29kb3RSZXZlcnNlRXF1aWxpYmVwc2l2O05vdEdyZWF0ZXJTbGFudEVxdWFwbHVzc2ltO0ZpbGxlZFZlcnlTbWFsbFNxdWFyZUJyZXZlVXBzaWxsZXM7d2VpZXJlYWw7Z3Rkb1JpZ2h0Q2VpbGluZztvc29sU2hvcnRSaWdoTmVnYXRpdmVWZXJ5VGhpblNwYWVhc3RlcmRibGFDY29uaW5uaEF1c3RjYXJvbnJmcjtOb3NjaWlzaW5zdjt5YWN1dGU7bnNjY3VlY3VsbnRsZ25HTGVmdFVwVGVlVmVjdG1mcm9taWRnZXNsR29wZkltYWdqbWF0TGVmdEFycm93QmFyO2R1Q2xvc2VDdXJsYm94Vjtob3JiYXJnYWNsaGFyZDt5YWN1ZXF1ZXN0RG91YmxlVXBBcnJpZ2h0aEVtYWRsY2xhZW1wdHl2U21hbGxDaXJjc21pTGVmdEZsb05vdEdyZWF0ZXJGdWxsRXF1YWw7RG91YmxlTGVmdEFMY2Fyb25lY29Pc2NyO1RjYXJvUmNhcm9uO25zaW1lYmlnTm90U3VwZXJzZU5lc3RlZEdyZWF0ZXJHcmVhdFpzY3JjYXJvY2VtcHR5dnBjeTtLYXBwZG93bmRvbGVmdHJpZ2h0aGhlYXJ0U3F1YXJlU3VwZXJzZW1wdHlzZXQ7Z3RsUGFyO05vdExlZk5vdENveGxBTG9uZ1JpbHBhclV0aWxoZWlvZ29sZWZ0cmlnaHRhcnJvbGVmdHRHb3BmO2VvcG9pbnRpbmRyY3JvcDt0aGlja0NvbG9uZTtVcGRvd25hcnJMZWZ0RG93blZlc3VwbXVscmFxdW9DdXA7ZGFzaHZuc3FzdXBOb3RTdWNjZWVkc1RpbERvdWJsZUxlZnRSaWdodEFDZG90O2hzY0xlZnRSaWdoSHByZWNlcTtGb3FkcmNyb3ZhcnNpZ21hb2VsZEFycmJhcnVydHJpcmlzaW5wZXJpb0xjc2NuYXVyY3JvcDtwcmN1c3FzdXBlY3VlcHN1YnBsdXNHcmVlbXNwMTQ7Ymlnb3RQcmVjZWRlc0VxdWFsO2xtaUxlc3NTbGFzdXBlO2NoZWNrbWFyaW1wZWRDSGN5TWVkaXVtU3BhY1JpSHNjcml1bWw7bGFuc3N0YXJmcGx1c2RvO2duYWxlZnRyaWdodGhhcnBvb25zO0Rvd25MZWZ0UmlnaHRWZWN4ZnJjYXBzO25wcmU7Tm90RXhpc2NhcGRvUmlnaHRUcmlhbmdsZUVxdWFsYnVsbGV0O2JhY2twcmltZTtzZG90YnNob3J0cGFyYWxsZVNjaXJZY2lyaW5maW50TmV3TGluZXZlbGxpYmlnc3RhbHRkb3Q7ZGxjcm9wO1J1bGVEZWxheWVQcmVVdWRyYmthSG9wZjtzb2Z0Y3lVcHBlckxlZnRMZXNzR3JlYXRlcjtWdmRpdmlkZW9udGltZXM7WmFjdXRMYWN1dGU7bnZpbmZpbjtob29rcmlnaHRhclJpZ2h0RG91YnZhcnRyaWFuZ2xMZWZ0RG91YmxlQnJSaWdodEZjdXJseXdwdW5jc25nZXFzbGFoYWxmO1JldmVyc2VFcXVpbGlicml1Um91bmRJbXBsaWN1cnZlYXJOb3RTdWNjZWVkc1NsZG93bmhhcnBvb25yaWdoZXBzaWxvbjtob29kdWhhcjtucmFycnc7U2FsZGN2ZXJuc21pZFpjeWJlcm5yaWdodHRocmVlU2FjYmVybWhvO2xhdGFpbHRyaXRjZG9sZXNkb3Q7TmVzdGVkR3JlYXRlckdyZWF6d25qZWdyYXZlO2xuYXBwcmxlZnRhcnJvd05vdEN1cENhbWludXNkbG9uZ2xlZnRyaW9zbGFzaDt0c3RvY2lyY25vdGludmE7bGVmdHJpZ2h0c3F1cHJhdmZ0b3BjZXhjbENoaUNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYUxlZnRBbmdsZUJyYWNrZXQ7ZnJhYzNiZXJub3VhbmR2O1RoaW5VcERvd25BcnJvQ291bnRlckNsb2NrZ25FcGx1c2RvTXU7WmVyb1dpZHRoU3BTY2Fyb25Ob3RUaWxkZUVxdWFyaGFyZG5lZG90O3N1cHBXZnI7c2hjeTtTcXVhcmVTdWJzZXRFcXVhbExvbmdsZWZMc3RuZWFybnNjcnN1cDt0cmFkRG91YmxlVXBEb3duQXJyZXFzbGFudGxlc3M7ZHJjclVwQXJyb3dCZ3NpbWw7Q29wcm9kdWNOb3REb3VibG5jeTtHcmVhdGVyRXF1YWxMaXNjblJpZ2h0Q2NpcnJhZW1wdHl2cmFycmJmc3N3YXJyb2xzcWx1cmRzaGFyO2lub2R1aGJsa0ZvdXJpU3VjY2VlRERvdHJhaHRyaXRpbURvdWJsZUxvbmdMZWZ0UlRpbGRlRnVsbEVEaWFtb25kUmV2ZXJzZUVsZW1lbnQ7dmFya3JhcnJzaW07bnJ0cmllTm90SHVtcERvd0dhbW1hO2J1bXBlO2VmRG90c21hbGxzZXBhcmFsbHJkbGRoYXI7YnNvbGhzdWJyYW5nbGU7eHNxcGVybWlsO0NvcGY7T3ZlclBhcmVudGhlc2lzb3RpbWVzO3NzbWlsTGVzc0V0cmlhbmdsZXJpZ2h0O0xhbWJkdHJpbWludXNDb3VudGVyQ2xvY0xlZnRyaWdodGdyYU5vcGZuZ3NpbTtoYW1pbHQ7Tm90UmV2ZXJzZUVsVXBwZXJMZWZ0QXJyb2N1clZmcjtTdWJzZXQ7c2ltZVJpZ2h0VGVlVmVjYW9wU3VjY2VlZHNFaGVsbGlwO3RyaXNtYXBzdG9sZXZEUHJpbWVndm5FO2xhcnJzaW07endqO25lYWthcHBhdnZhcnN1cHNwbGFuY2s7RG93bkFycm93VUNlZGlzZXh0O21wbGFuZ2xlYW5kZDtoYWlkYXNodjtkb3duaGFzdXBzZXRuZWVxY2lyYztvcGVybnZEYWJydmJhWmVyb0xlZnRBdXRpbGR4bWFwTWVsaHNsRG91YmxlVmVydGljYWxOb3RMZXNzRXFEY2Fyb25Ob3ROZXN0ZWRMZXNzTGVzcztyaXNpbmdkb3RzRmlsbGVkVmVyeVNtYWxsU3FOb3RUaWxkZUZ1bGxEb3duUmlnaHRWZWN0b3JCYXI7bGFyck5lc3RlZGRvd25kb3duYU5vdFN1Y2NTYWN1bmFjdXR1cmNvcm5lYW5nbXNkYWQ7RWNpcmM7U3VjY2VlZHNyYWN1T3RpbGRlZ2VzbGVzO0Rvd25BcnJvd1VwQXJyb3c7bGVmdHJpZ2h0YXJyb3dzZWxzZHJpZ2h0YXJyb05lZ2F0aXZlVGhpY2tTZ2JyZXZlY2NlZGlsc3RhcmZpbjtyaWdodGxlZnRhcnJvd3M7UmlnaHREb3VibGNvbmdkdnN1Ym5lRG91YmxlTG9uZ0xlZnRBQmVjdHJpYW5nbGVsZWZ0ZXFSY2VkWmVyb1dpZHRoU3BhY2Nhcm9uZG90c3F1YXJlbmVhcmhvcmRmbmN5cmFycnBsY3VydnZsdHJpO3N0cmFyaWdodGhhcnBvb25kTm90RG91YmxlVnRoa2Fwc3RyYWlnaHRlcHNsZHNoQ2NlZGlsO0RvdWJsZUxlZnRSaXVwYXJyb3c7ZG90ZXFkb3Rsb3BmRERvdHJhaGRjYXBjdXA7Z25lVmVydGljYWxTZXBhck5vdExlc3NTbGFudENsb3NlQ3VybHlEb3VibGVRdW90ZUdzY3I7VmVydGlzcXN1YmVndHJzYnVtc3FzdXBzZXRlcTtHYnJuc3BhcjtZYWNEb3VibGVDb250b2JzaHlidWxsO3plZXRyZnZhcnN1YnNib3d0aWU7ZUREbG90aW1lc1NxdWFyZTtOb3RMZXNzO3BpdjtPcGVuQ3VybHlEb3VibGVEaWFjcml0aW5yYWJicmt0Yk5lZ2F0aXZlTWVkaXVxdWF0aW50O05vdFNxdWFyZVN1cGVyc2V0RXF1YUJyZXZlO3dzY3I7bGVmdGxlZnRhcnJvd2F1bXBybnNob3J0cGFyTm90R3JlYXRlckZ1bGxFcXVWb3BmYmxhY2t0cmlhbmdsZWRvd247TmVzdGVkR3JlYXROb3RTdWNjZWVkc1NsYW50RXF1YWxSaWdodEFycm93TGVmdEFycm93TG93ZXJMZWZ0cm9wbHVzRG93bkxlZnRWZWN0b3JCYXJTcXVhcmVJbnRzaG9ydHBhcmFEb3duUmlnaHRWZWN0b3JCZG90bWlMb3ZlcmJhcnN3bndlZkRvdDtMZWZ0Q2VQcmVjZWRlc1NsYW50RXFaYWNsc2ltZztkb3duYXJzdWJuU3F1YXJlU3Vic2V0RXF1bHJoYXJwcm9kO2JveHRpbWVzO2NpcmNsZWRhc3RzdW5nbGNlZGlBbnVsdHNwbGxhcnJMc3RycmFycmh0aGtzaUxlZnRVcFRlZVZlY1RhdTtsdmVydG5lcXE7VmVyYmFycmlnaHRsZWZ0aGFycHJuYXA7bnJpZ2FjdGF1YXJyTmVnYXRpdmVNZWRjcm9zc25nc25taWRSaWdodENlaWxpZGlzcnRocmVlO05vdExlc3NFcXVDYWN1dGVsRXhkdHJpO2RkYWdnZVJpZ2h0VXBUZWVWZW5yaWdodGFycm9ubGVxc2xCb3BmZGllbWVhc3VyTGVmdEZuc2NlO25jZWRpbDt1cGRMZXNzU2xhbnRFcXVnbmFwO2xtb3VzdGFjaGU7RG91YmxlTG9uZ1JpZ2h0QXJyb3c7c3N0aGtzaW07U2hvcnREb3dubGN1Yk90bGVmdHJpZ2h0aGFycG9lbnNwO29ib3hIdTtSaWdodFVwRG93blZlRGlmZmVyZW50aWFsRDt1ZGhhcmxvYW5kcmV0aHlhY3V0ZW50cmlhbmdsZXJ0cmlhbmdsZXFzcXN1cHNybW91c3RhY0Nsb3NlQ3VybHlEb3VibGVRdW90aXVrY3lsZXNzZXFndFVuZGVyUGFyZW50aGFjaXJjO2hBcnJicmFjTmZyO0Rvd25BcnJvd0JzdWNjbmFwTmVnYXRpdmVUaGlja1NwYWNrY2VkT3NsYXNodERpZmZlcmVuTm90TmVzdGVkR3JlYXRlckdyZWF0ZUVsUW9wZkpjcmlnaHRoYXJud25lYXI7TGxvcmFycjtibGFja3RyaWFuZ0RvdWJsZURvdDtiZW1wdHl2O0FyaXNwYWRlc3VpbnBhcnNtaWxlO05vdE5lc3RlZEdyZWF0ZXJMZWZ0UmlnaHRBcnJvd0xhY3VDb3VudGVyQ2xvY2t3Z3RjaWRvdG1pbnVzO0RvdWJsZUNvbnRvdXJJbnRlZ3JhZ2VzY3RoaWNrYXBuYXBwcm9uUmlnaHRhcnJvdztyZGxkaHVvcGY7UUhmcjthd2NvbnRyaW1pbnVuc3VwZTtuZXNGaWxsZWRTbWFsbFNxdWFyZTtleHBvbmVmYWxsaW5Ob3RDdXBDc3VicmFOZXN0ZWRHZnJhYzU4Z2FtbWE7c3VjY25QYXJ0RG93bkxlZnRUZWVWZWN0b3I7VW5pb25QbHVzO092ZW90aW1lc2d0cmRrZ3JVcFRlZUFyc3BhZGVzO3Nxc3VwZTtWZGFzaGxybERvd25CcmdlcXNHYW1jZW5jaXJjbGVkZGNoY3k7YWJzaW1nO21sZHI7VFNIY3lyaWdodHRub3RpbnZjO25hbmd0YXVBYWNPY2ltc3Rwb3M7b2hiYWJveGRMTGVmdERvd25WZWN0b25wb2xpbmRzb2w7Q2xvY2t3aXNlQ29udG91ckludGVncmFsO3N0YUVzY2xjYXJvbjtsb3BsdXNTdWNjZWVkc1RpbGRlU3F1YXJlU3Vzd2Fycm93O0RTcmJhcnJhbmdtc2RhZTtob3BmO2RmaXBvcGZJbWFmZnI7cHJlY3NkaXZpZGVvckF0YWlsO2xlc3NlcXFndHI7ZGVsQWNpcmNsYXJyYmxvd2JhaGFyZGNjaXJjbGVkUlVhcnJvY3ZhcmthcHBhbG1pZG90O0dyZWF0ZXJTbGFkemlncmFjY2lOb3RMZXNzR3JlYXRlcjt1cGhhcnBvb25sVmVyeVRoaW5TcGFjZTtOb3RHcmVhdGVyRnVsbHJsYXJndHJhcHByb21pY3JvbGJya3NsdTt5ZnJleHBlY3RhdGludGlsSW9nb247dmRhc2h2RGFzaGNvbG9zcXVhcmVpaW9wcmVjY3VybHllVW5pb21hbHRlc2U7Q2xvc2VDdXJseURvdWJsZVFEY3k7ZHpzdWJlam9uc3VwYm94Vmg7SW52cnRyaWV4cG9uZW50aWFsbnN1YmVOZXdMaW5lO1JpZ2h0VmVjdG9yY2lyY2xlZFNVZGJuZ3RyO3NpbWRvdDtlcXNsYW50bGVOZWdhdGl2ZVZlcnlUaGludGdsZG90cGx1Z3RsUGFjb21tYXQ7bEFjY3VidW1wO3lhY1pudGlsZGVVcGRvd25hcnJvdGltZXNiYXI7am9wZjtBZmduYXBwcm94O2xzcWJ1bWxiaWdjaXJjO3ByYXA7ZmVtYWxlO01pbnVzUFN1Y2NlZWRzVGlsZGU7c3ViZTtVb3BmO3Jtb3VzdDtyc2FxcmlnaHRhcnJMZWZ0RG93blRlZXJtb2NvcHJvSHVtcERvd25IdW1wZ2c7Q29uaW5TdGFuZHNseGN1cDtyaWdodGhhaWpEb3VibGVSaWdodFRlZG93bmFycnRoZXRhdmxvbmdyaWdodGFVbmlvblBsdWlxc3VwbXVsdDtkb1VuZGVyQnJhTGVmdEFuZ2xlQnJhY2tOZWdhdGl2ZVRoaW5TcGFjRG91YmxlVXBEb3dlcGFyc2xzdWJyYXJyYW5nc3BzdWNjc2lndHJkb3ljaXJjQ2NvbkRvd25MZWZ0VmVjeHVmZmlsaWc7ZGl2aWRlb250ZHVkYXJyO2RlbXB0eWRhcnJQcm9wb3J0Q2lyTGVzc0VxdWFsR3J1b2dvbmJsYWNrdHJpYW5nbGVyaWdodDtwbHVzYWNpcjtjdUVOTGVmdEFycm93UmlkaWxyYXJyO2d0cmVxZXNjcmN1cGRvUmlnaHRVcFZlY3RvRG91YmxlTG9uZ0xtaW5tb3BubGVmdHJpZ2hOb3RTcXVhQWxwaGE7enNjcjtOb3RTcXVhcmVTeGhhcnVvYmxvbGVzc2VxcWR6Y3lEb3duUmlnaHRUZWVWUHJlY2VkZXNFcUxlZnRUZWVWZWNkb3duaGFycG9vbktjZWRpbDtSZXZlcnNlRWxlbWVuZ3NpbWVTcXVhcmVJU09GTm90U3VibGVzc2VxcWdQcm9wb3J0aW9uO3ZlcnQ7c3dhcmhrT21hTGVmdGFycm93dXRpbGV4cGVjdGVERG90aWpsaWc7YXN5TG9uZ3JJdWt2YXJzdXBzZXRuZXFxO2xlZnRhcmJveERMZ2xFO2N3aW50dmFyc3Vwc2V0bmVxO0tIY3VwaGFycG9vbnJpZ2h0O0JhcndlZDtOb3RDb25ncnVlbnNob3J0cGFyYWxsZWxjaXJjbGVhcnJvd3JpZ2hsbGNyYXJyc2ltb2NpcmVEb3RpbWFncERvdWJsZUxvbmdMZWZ0QXJycmFlbXB0eXY7VkRhbndBcnJuZXNlTmVnYXRpdmVWZXJ5VGh1d2FmcGlwbGFycmJmcztOb3RUaWxkZUZ1bGxFZWNvbG9scGFyO21lYXN1cmVkYW5nbGU7dWJyZVVwQXJyb3dEb3duQXJ1cHVwYXJlbXB0eXZ2YXJlcGFmO250cmlhbmdsZXJpcnNjcmthcHBhdjtHcmVhdGVyU2xhbnRFcWlmaW50cHJvZDt1cHNpbG9tYWx0aW50bGFyUHJlY2VsZWZ0aGFydGhpY2thcHByb3g7Rm9wRG91YmxlVmVydGljYWxCYXJnY2FsZWZzeW1FbXB0eVZlcnlTbWFsYm94RGxjdXBiam1hdGg7Tm90RXF1YWxUaWFwb3M7Zm5vYW5nbXNkYWI7TGNlZGlsO0xlZnRBcnJvd2xvb3BhcnJvd3JpZ0RvdWJsZUxlZnRSaWdodEFycm93c3VwbXV5Y3lwZXJjbnRMb25nTGVmdEFybnRyaWFuZ2xlbGVmdGVxcmRsZGhhQ2FwaXRhbERpZmZlclVjeWZub2ZWY3k7Tm90RWxOb3ROZXN0ZWRHcmVhdGVyR3JidW1wZXE7UVVPVDtzdWNjc2ltbWFwc3RvZGZjeTtOb3RMZXNzVGlnbDtsb25nRG93bkxlZkNvdW50ZXJDbG9ja3dpc2VDb250b3N1Ym5lO0NpcmNsZURvdHJhcnJscExlZnREb3VWZXJ0aWNhbFRVcGRvd1RSQUl1Z2NpcmNOb3RQcmZudXJjb3JuO3NoY2hjeVVwcGVyUmlnb3VtdWJyY3k7Tm90TGVzc0dVdW1sO0xvbmdsZWZ0cmJveHZMO0NheWxleXM7ZUR6ZnJzd253YU1lbGxpbnRyZmF3aW50O1phU3F1YXJlU3VwZXJzZXRFbGVxO2V4cG9uZWNpcmNubGVmdHJpZ2h0YXJybmN1Q2VudGVyRG90c2NhUmlnaHRhcGhvbmVsbHRyaTtpZWN5O0RvdWJsZVJpZ2h0VGVlcmFycnNpY2x1ZW1wdHlzZXRsbmV4dXBsdXNTT0ZUY2ptTm90TmVzdGVkaG9va3JpZ2h0YXJyb01mcm9kYlJpZ2h0VXBUZWVWZWN0b3I7Y29sb25lU3F1YXJlVW5pb2JubmhBcmFwcHJveGVxeWFBc2N0d29oZWFkcmlnaHRMZWZ0YXJyUmFuVkRaZXRhTm90VmVjdWRhcnJyO3VhY3V0ZUtzY3I7dW1hY3JQb2luY2VzZG90O092ZXJCYXI7Tm90VGlsZGVUaXVtbDtZQWN5O3JpZ2h0aGFycG9vbG9uZ2xlZnRhcnJvdztpaWludEFNUEh1bXBFcW5leGlzdG5sZWZ0YWxtb3VDb3VnRWw7TG9uZ1Jib3hETDtvZ3JhdmVubGVzSXRpbGRlbGVmdGhhcnBvZnJhYzE0a2Fac2NvbXBsZW1lbnQ7dHdvaGVhZHJpZ2h0YXJyb3dib3htb3NjYmFja3NpbWV5Y2lpcmZsb29CZXJub3VsbGlzO3JsbTt0b3B0aG9yamN5O2RjYXJyc2xvb3BhRW1wdHlWZXJpZXhjbDtwb2lubnZnVFJBREU7ckJhcnNpbW5lcmJyYWNrO3N1cHNldG5lcXF0YnJyQXJyO29kb3ROb3RQcmVjZWRlcztpdGlsZGU7R3NjT3NsYXNoO3NicXF1SGNpcmM7SXNjcmRvbE5vdEV4aXN0c3JpZ2h0aGFycG9vbnVwRmlsbGVkVnhkdHJ2YXJzaWdnbGE7RG91YmxlTGVmYmxvY2t0cmlhbmdsZWxlc21lcFN1YnNldEVxdWFsQ29uZ3J1ZW50YmFja2Vwc2lsamN5O0xlZnRWZWN0b3JCYXJOb3RIdW1wRG93bkh1dmFybm90dW1hY3I7RGlhY3JpdGljYWxUaWxkZW5sZXFzbGFmcmFjMjM7YnNjT2FjdXRMZWZ0QXJyb3dScmlnaHRzcXVpZ2Fycm93bG9uZ2xlZnRyaWdodGFycm9uYW9zb05vdFRpbGRlRnVsbEVxdWF0b3Bmb3JrO0xlZnREb3FpemREb3duUmlnaHRWZWN0b3JpZ2h0cmlnaHRhcnJ1aGJwYXJzaWxlZnRyaWdodHJpZ2h0bGVmdGhhcnBvb25zcHJlY2N1cmx5bGhhdGNlZGlsRXBzaWxvbjtzY2VkaWxtdW5jYXJMZXNEb3VibGVEdGhldGFzeVNpZ21hVGhpU3F1YXJlU3VwZXJzZXQ7Tm90RG53bG5lcWJlcGJsYVN1Y2NlZWRzO2RpZ0ludmlzbm90bnZhcm5vY2FwYW5TaG9ydFVwQXJuYWJsb3ZiYXBvc05lZ2F0aXZlVGhpblNwbG5hcHByb3g7Wm9wZnZsc210ZTtsdHF1ZXN0O05vbkJyZWFraW5nU0xvbmdyaWF3Y29uaW52c3VwbmViZXR3ZWVnYVJpZ2h0VHJpYW5nbGVFcXVhT21pY3JvbmxzYXF1ZG90bWludXZzYmVtcHR5Q2xvY2t3aXNlQ29udG91cklOb3ROZXN0ZWRMZXNzTGVzc25pdjtBRWxpZztVbmRlckJhcjtmcmFjNURvd25MZWZ0VGVlVmVjdG9zdHJhaWdodGVkdWF1ZGhTaG9ydFVhbmRzZ2xqO3JlY3Rjb21zcGFkZXN1aXQ7YmFja3NpbXJjV29wU2hvcnRET3ZlckJyYWNrZXQ7UG90b3Byb2ROb3RMZWZ0b3JpZ2ZyYWMxNXh2RG91YmxlQ29udExlZnRVcFZlY3RvaW1hdGg7dUhhVWFjdXRlO3ByZWNucmlnaHRzcXVpTGFjdXRhc2NyO0Rvd25UZWU7ZmN1cGhhcnBvb25sZWZ0RG93blJpZ2h0VmVjdG9yQmFJbWFnaVRTSENlZGlsbmNvbmdkbnduZWFBb2dvZ2VsO0NvbmlzdXBzZXRuZXFxO25wcmN1ZTtPdGlsaW5vZG9kb3RlcWRYc2NFbXB0eVNtYXJjZXJicmFjZTtmaURvdERvdGRIYmlndHJpYW5nbGdzaW9nb3N1cGVkb3RndHJlcWxlc3NzbXRlcztmbGxpZzt2YXJlcHNpbE5vdEdyZWF0ZXJGdWxjaGN5WmVyb1d5ZkxhcGxhY2JibnVtc21hc2JlY2FSaWdodFRyaWFuZ2xlQmFyO1VuZGVybW9wZnZhcnRyaXJpc2luZ1dzcXVhdGVybm92YmFyTm90U3VjY2VlZHNsb25nbGVmdHJpZ2h0YXJyb3dlcXZwYXJzRm9wZjtiaWdjdXA7YmVtcHRpZ3JhdktIR2dyc2FxdW9EaWZmZXJVdGlPbWljcm9uO0Vkb2xlcXE7VWFycm9jaWxmbHRzY3lMY2VkaWV1bWw7SmNpcnZvVXBhcnJubHNpT3BlbkN1cmx5RG91YmxlUXVvdENPUFk7Ym94SGRzdXBoc2FvZ29uO0xzdHJvTmVzdGVkTGVzc0xlc2ZsYXRpbWFnbGl3cmVhdGh2YXJwTm90UHJlY2VkZXNsYnJrc2xkZ3RyZXFxbGVzc3pzZ2Vxc2xhbmxlcXNsYW50Tm90R3JlYW5sZHI7YmlndHJpYW5nTGVmdFJpZ2h0QXJyY2xmaWxEb3VibGVMb25nTGVmdFJpZ2h0b21hY3JUaGluU2dqYXN5bXBlVmVydGljYWxTZXBhcmF0b3I7SW52aXNpYmxlY3JhcnI7RXVhbmdtc2RhY05vdFJldmVyc2VFbGVtYWJyZXZVYWNMZWZ0RG93blRlZVZlY3RvdWxjb3JuZXJvbGNyU2hvcnREb3duQXJyb3dVcHBlckxlZnRBcnJvd0JjeWFhY3V0ZTtPb3B1Y2lybGRxdURpZmZlcmVudGlhbERsYWdJbWFnaW5hcnlJQ2xvY2FuZ3phcnI7TGVmdFVwVGVlbGFycmZzY3NhcGlEb3VibGVMb25nTGVmdEFyZXFzbHNjcG9saWxvbmdyaWdodGFyclNoY2Fwc0ludmlzaWJsZVRpbWVzO2FlYmFja3NOb3RQcmVyYnJhY2VDbG9ja3dpc2VDb250b3VySW50ZWdyRXRhO3NpemFjdXRMZWZ0RG91YmxlbHNpbWU7c3NldHN1cGhvbWFjZWdzYnF1bztsQXJyO3NlYXJyb3dBb3VoYXJOdGhpY2thcHByb2xvd2FzbGx0TG9uZ0xlZnR4b3BsdXNsb29wYXJyb3dsZWZ0YXN5bXBsdXN0VXBBcnJvd0RvU2NlcmlnaHR0aHJlZXRpbWV1bHRyYmxhY2t0cmlhbmdsZWRvbGVmdHJpZ2h0aGFycEdyZWF0ZXJHcnN3QWZyYWM1NjtsZXFzbGFudDtuZUFyaGVhcnJpZ2h0dGhyZWV0TGVmdERvd2Vsc3pzY2NhY3V0ZTtyY3VyaWdodHJpZ2hwb2ludGludFNvcHVncmF0cmlhbmdsZWxlZm1hcHN0b2Rvd0xvbmdyaWdodGFybm90aW5kVW1hY3JDbG9ja3dpc2VDb250b3VySW50Y29tbWF0VXBFcXVpbGlicHJvZnN1cmZnZGxzY1VwVGVlQXJyYXRpbHJpZ2h0c0tKY3k7Z3RyZXFsZXNzO3hoQXJyRG91YmxlVmVycW9TcXVhcmVTdXBlcnNlc2JxdWRzdHJvbWVhc3VyZWRhbmdOb3RUaWxkcHJlY25lSW50ZXJzZWN0ZGRhQUVsaWdSaWdodFRyaWFuZ2xlVWRibGFjO3RyaXRpbWU7bEJhcnI7bEJNZWRpdW1TcGFjZWN1cGJyY2FjdGRjZW50ZXJkTWVkcmRHYnJldlJldmVyc2VFcXVpbGlicml1bTtGb3JBbGFicnJob3Zhbmdlb3JpZ29MZWZ0VGVlQXJsdHJpZjtPYWN1VXVtcm90aW1Eb3VibGVDb250b3VySW50ZWdDaXJjTG9uZ2xlZnRyaW5sZWZ0YXJyb3c7bG1pZG9BRUludGVncmFWZXJ1cmNvcm5lcnNwYWRlbG9vcGFycm9Ob3RTdWJzZXRFUHJlY2VkZXNFcXVhbGxhZXNjYXBFY3k7cmxhcnI7YmlnY2lydHN0cm9uZWFycjtvbWVnYTtTc2N6b2djeW5sdHJpZXpvcGZ2YXJlcHNpYmVjYXVpZWN5dW1hbnRyaWFuZ2xlbFVwYXJoYWlyc3BsdGNpVGhpY2tTQ2FjdXRlO0RlbHRhO3ZzY3JSaWdodFVwVGVlVmVjdG9mcGFydHJvYXJMZWZ0VHJpYW5nbGVCYXI7YXVtbG5wYXJhbGxlbEZpRG93bkxlZnRUZ2JyZXZlO3ZlZWVxO1Nob3J0VXBBU3F1YXJlU3VwZWlpaWlzdWJFO05zY3I7Tm90RXF1YWxUR3JlYXRlckVxdWFsTGVzc3JjYXJGaWxsZWRWZXJycHBvbGludDtvZVVuZGVyUGFyZW50aGVzaXM7RG91YmxlTGVmdEFycm93O2dzaW1lO2ZwYWVmcjtiZWNwaW9taW5sQXRhZ2FtbXdlZGdjaERvdWJsZVVlbXB0eXY7ZnNjbmxlZnRyaWdodGFycm9MZWZ0VGVyaW50cmlhbmdsZWxlZnQ7cmlnTm90R3JlYXRlckZ1dmFyZVNIVWFZQWNsb2FycmNvbXBsZXhlc0Vwc3Nob3J0cGFyYWxudnJ0cmllO092ZXJCcmFjZTtUY2VkYmlnb3BsdXNQc3JvYnJjd2NvbmlQcmVjZWRlcztub3RuaXZhaG9yYkRmYW1hY0xvbmdMZWZ0QXJyb3dtb3BmO2NvbG9uZXE7UHJvZEVjRXF1YWxUaWxkd29wZnNpZ21nZXNsZVNjYXVyY3JvdXJjb3JuZXI7b2htSU9MZXNzVHByY3VlRG93bkFycm93O3ZsdEludmlzaWJsZUNvUmV2ZXJzZUVsZW1lbnR3cE9zbGFzYm94VXI7U3F1YXJlSW50ZXJzZWNpcnNjaXJucmFycmM7dHJpZG9yYnJrc2Vzd2Fsb3didHJpbWludXM7Y3VwY2FwO2dhcG5hcHByb3g7RGlhY3JpdGljYWxEb3VibGVBY3V0ZU5lc3RlZExlc3NMRGFyTGVmdEFycm93QmFUaWxkZTtOb3RMZXNzU2xhblljbkxscXVlR29sakxlZnRDU3VjY2VlZHNUaWxucnRybndhcnJyYXJycE5vdFNkaXZpZGlnZWNpcmM7ZWFMb25ncmlnaHRhcnJvd1JpZ2h0QXJyb3dMZWZ0QXJyb0dyZWF0ZXJTbGFudEVxdWFOb25CcmVha2luZ3JvYXJyO0RvdWJsZUxlZnRSaWd2YXJ0cmlhbmdsZU5vdEdyZWF0ZXJFcXVhbE5vbkJyZWFraWRhc2g7UHJlY2VkZXNTbGFudEVxdWFsYmxrMTQ7WXNsYWVtUmlnaHREb3VibGVCcmFja2JsYW5iZHF1b1VwYUJhY3RwckJvcFJzaDtMbWlkQ291bkNhY3VTcXVhcmVTdWJzZXRFcXVhVXRpbGRhcGFyYnJrc2xkYmV0YTtSaWdodFZlY3RvckJhcjtibGFja2xvemVuZ1VwcGVyUmlnaHRnZWxMZWZ0VHJpYW5nbGVFcXVhbGxsaGFyZDtTaWdtYTtFY2lydGhrRWFjdUlvZ29SaWdoTm90TGVzc0VxdWFsO2RibGNlaWFuZ3phcnJlYWxwYXJ0c3ViZWRvdEJhY2tzbGFvc2xhbkxlZnRhbG9uZ3JpZ2h0c3FzaW5jYW9hY3VzcXN1YnNldDtudmxlRGlhY3JpdGljYWxHaHlwaXByZXhwb25lbnRpc2NhcnN1YnJhcmVxc2xhbnRsZXNzZXFjb2xvbk1lZGl1bVNwaEFycjtOZXN0ZWRMc3NtaWxlO3VyaXZhcm5vdGhpbkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWFscGhhO1VyaW5nTGVmdERvd25UTG93ZXJSaWdodEFycm93eGZyO0xlZnRWZWN0b3I7VmVyeVRoaW5TcGFjZURpYWNyaXRpY2FsRG91YmxlQWN1dGU7SG9ySWdsZXNkb3RvclBvaW53QXJtb3VzZG93bmhhcnBvb25sc3VwZHN1YjttZWFzdXJlZG53YXJyb3doZWFDZEh1bXBFcXVuTHROb3RMZXNzU2xhbnRFcXJ0cmJsYWNrdHJpYW5nbGVyaWdoZmZpbGlnZGZlbXNwMTM7TGw7YmFja2Vwc2lsb090aWxkZTtyaWdodHRoclN1Y2hUaGF0Y2FyZXRmaWxpZ1lvcFVicmN5TGVmdFRyaWFuZ2xlRXF1YWw7RGlhY3JpdGljU3VjY2VlZHNTbGFudFVuZGVvbWFDYWN1dEZpbGxlZFZlcnlTc3RyYWlnaHRwaGduYXBwck5vdEVsZW1lbnQ7bmNvbmc7RHN0cmRsY290c2NyO2RhbGVWZXJ0aWNhbExpbm5sZXNzZHJvcE5vdFRpbGRlRnVsbEVxdWFsO2FuZ3NwaHdjaWJveEhEO3V1bWxUaWxkZXVicmV2ZW5sdHJkY3llc2RvcmlnaHRhcnJvd3RhaVNob3J0UmlnaHRBVmVydGljYWxMTGVmdERvd25UZWVWZWNib3h2cmZvcGY7b3JkZW5wb2xpbnRkYWxldGg7Y3VybHllcVJpZ2h0RG93blZlY3RvcjtMb3dlckxlZnRBcnJubGVmdGFycm93bGVmdHJuYnVtcDtOZWdhdGl2ZVZlcnlUaGluU2JveGg7ZXFzbGFudGxlc0xjZWRhd2NvbmludDtiYWNrZXBzbmxBckNsb3NlQ3VybHlEb2RpYW1mZnJjdXJ2ZWFycm93cmlnaHQ7c3VjY25lcXE7dGJNZWRpdW1udmx0cmluZUFycmxjYXJvdHN0cm9rO2xlc2RvdG87cmxoYXJDb2xvbHNpbWVwYXJhbGxlZnRoYXJwb29udXBVcFRlZUFycm9hbmdydHZuY2FtZVJFR05lZ2F0aXZlVGhpY2tib3hIZDtHckxlc3NUaWNvQ2xvc2VDdXJseVFJYWN1dGU7VGlsZGVGdWxsRXF1YURvdERvdDtib3h1bDtjdXJseWVxcHJlY3djb25pbnQ7VXBkVm9wcHJzaW1jY2Fyb2JldHdlZW47R2NlZGlsbGJyYWJveFZscmlnaHRhZGZpc2hydGltZXM7aGtzd3NpbWw7bG5zaW1PcGVuQ3VybHlEb3VibGVRdW9vbGlkb3duZG93bmFyT3BlbkN1ZGl2aWRlb250aW1lc3JoYXJ1bDtyZHNyb3BhcjtzZXN3YXI7c3Vic2ltbm90O0VncmF2ZTtVbWFyb3RpbWVkb3duaGFycG9vbmxlZnRFcXhvdGlsb3BmO2xhbWJkYWRvd25kb3duYXJyb1ZzY0Fzc2lnbnpoZnJhYzM1O2Rvd25kb3duYXJyb3dzckFhb3J2O0VtcHR5VmVyeVNtVW5kZXJQYXJlbmN1ZXNMZWZ0QXJyb3dSaWdocmlnaHRyaWdodGFyZGNhcm9uO05vdERvdWJsZVZlcnRpZXBhcjtkYWdnZXI7bGVzc2VxUGx1c01Ob3RTdWNjZWVkc1NsYW50YmxsYWVtcHR5QU1wbGFua3ZmamxpbGVmdHRocmVldERKY0Rhc2JzaVVwQXJIYXJOb3RSaWdoZWFydHN1aXR1ZmljeWxjdHluYnVtcGU7c2RvY3lsYm94SDtyYXJyY2x2bkVoa3NlYXJyZmxMZWZ0QXJyb3dSaWdodEFycm93O250cmlhbmdsZWxlZlNxdWFyZVVpbnRlcmNhbDtndHJhRGN5cG9wTm90TGVmdFRyaWFuZ2xlQmFyO2xyaGFyZDtFb3BmO3V1bWw7YmlndXBpcXVlc2JveHBsdXM7VnZkYmlndmVlO0RhcnJubGRHZG90O2RoYXJsO1BjeTtEb3VibGVEb3duQXJyb3c7Tm90Q3VwZW1zcDtuZ3Q7bnNpbWVxO2x2ZXJkb3VibGViYXJ3ZWROb3RTcXVhcmVTdWJzZXRFcXVzZXRtSW9wZjtUU0hjYmFjTG9uZ2xlZnRhQ2xvc2VDdXJseVF1b3RldGNhTFQ7VnNjcjtVc3ByZWNjdXJseWVxYmxhY2tsZXNzZXFxZ3RyeGhBRXF1aWxpYnJpc2VBZWN5O0h1bXBEb3dGY3k7YW9wZjt4aERpYWNyaXRpY2FsR3JhdmViaWd0cmlhbmdsZXVwO25yaWdodGFycm93O1BOYWxkcXVvY2lyZU1hcG5zdXBzZXRlcXVlc3RlcUxlZnRSaWdodEFyeGxBcnI7bHVydW53bm50aWxkZTtQcmVjZWRlc1RzdXBtdWx0aWpsQ2FwRGViaWd3ZWRnZTtjcm9zcztjdGN1cnZlYW51bWVybztzZXN3c3RybmJOb3RSYWNub3BzYWN1dGVjY3Vwc3NtUkJhbGJya2VDaXJjbGVUaW1lc0JhY2tEb3VibGVWZXJ0aWNUaXVwbHVVdE5vQnJlYWtOb3RTcXVhcmVTdXBlcnNldEVxdWZhbGxpbmdkb3RzZU1pbmFuZ21zZGFmO3dvcERvd25BcnJvd0JhckdyZWF0ZXJMTmV3TGlubmxhcnJzaW1kb1NxdWFyZVN1YnNldEVxdWFsO2dhY3V0ZVJhcnJ0R3JlYXRlckVxdWFsTGVzYm94bWlhYWN1Q291bnRlckNsb0ZvdXJVcG5pdmJpZ3VwbHVVcGRvbG5FQ291bnRlckNsb2Nrd2lGaWxlcXVlc3Q7bmdlcXNsYW50O0lKbGlmcm9zbGFzRG91YmxlTG9uZ1JpZ2h0Q2xvY2tEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dzaG9ydG1pZDtVcFRlZUFycm93QmFja3NsYXNoTm9uQnJlYWtpbmdTcGFjZTtOb3RHcmVhdGVyU2xhREpjeTtubGVmdHJzdWNjY3VybHllbkxlZnRyaWVsc2RvdHFwcml0b3NhY3NrY2VkaWxMYXBsYWNldHJmaGtzd2Fyb3c7S3NlcWNpendqc2JuTERvdWJsZUxvbmdMZWZ0QXJyb2NpcmU7UmNhcmRBcnI7ZmZsaWc7QmV0YVRoaW5TcGFjZWpmcjtHcmVhdGVyU2xhbnRFcXVhbDtVcGFycm9Ob3RHU3VjY2NvbXBsZXhIb3Jpem9udGFsTGluYmlndGxicmFjRGlhY3JpdGljYWxUaWxkY3VybHl2TG93ZXJSaWdodEFycm9Eb3RFcXV1cGFycm9Pc2xhc3Vic2V0O3RoaWNrc2ltO2VxdnBhcnNsYWxlcGhMZWZ0QW5nbGVCcmFwcm9wdExvbmdMZWZ0UmlnaHRBcnJvbnNob3J0bWluYXA7U21lcXVhbHNuYWNhdFNzY3I7bGVmdGFyaWdodHNxdWlnYXJyTGVmdGFycm93O2NlbnRlckZvdXJpZXJMb25nTGVmdFJpZ2h0QXJycGx1c2xBYXJyO3Jpc2luZ2RvdHNldHJpYW5nbGVkY2FwY2FwO0RpYUVUbXVtYXA7Z2VzZG9Eb3dubGVzc2VxcWd0YmxhY2t0cmlhbmdsZXJpZ2h0bG9uZ2xlTXVSaWdodFRyaWFuZ2xMZU1jeTtlY2JpZ2NpcmNiYWNrY29uZ2RkYXJyO3NtYWxsc2V0eG5pU21hTm90U3VjY2VlZHNTbGFudEVxcHJvZnN1cmY7RXhpZ3NVcERvZXhpQ2FwaXRhbERpZmZlTGVzc0Z1Z3RyYXBwcm94O2JldHdsdmVydG5ndGNpcjtzdW07ZXhmcmFjMjNVc2NwcmVjZWdydXJpbmZvcmFsbnJpZ2hwcmNDb25ncnVsZWZ0dGhyZWV0aWRkb3RzZXE7YmlndmVDYXBpdGFsRGlmZmVyZW5lbWFTaG9ydFJpZ2h0QXJyb3dib3BmZGlnYW1tYTtldXJvO0ZpbGxlVmVyeVRoaW5TcFZkYXNoO3N1cHNpbXZsdHJpZG91YmxlYmFyd2VkZ3VsY3JvcDtSaWdodFRyaWFjd2ludDtmc2NyO1JpZ2h0RG91YmxlQnJhY2tlc3NldG1uO1J1bmxlZnRhcmJrYXJSaWdodERvd25UZWVWbGhibGs7dHJpYW5nbGVkb3duc21hbGxzZXRtbGJhcnN1YnNldG5vcmlBcnhkdG50cmlOb3RMZWZ0VHJSaWdodERvd25UZWVWZWN0b3I7bnN1YkU7bnN1cHNldGVxcWV4aXNOb3RFbGVtZW5iaWdvcGx1VW9iaWd0cmRzTGVmdFRlZVZlT2RibGF0c2hjeXN1Y2NjWWFjdXRpbnRlcmNPcmJveERMb3dlckxlYmlnc3FVcHNpVW5kZXJCcmFja2V0ZGRlcHNoZWxsaUxlZnRUcmlhbmdyaG92O1N1Y2NlZWRzU2xhbnRFcXVhbENmcjtyYW5SYXJydGxuc2NlRG90RXFJdW1sO25zdWNjZXByb2ZsaW5lc3VwbGFmaWxpR2FtbWhjaXJ3b2FvZ29uZGllO2l0aWJhcndldGltZUxvd2VyUmlnT3ZlclBhcmVudGhBbWFjcllVY3pkb250cmlhbmdsZXJpZ2h0ZXFkcmNvcm5sZWZ0YXJyb3d0cGFyU3VwZXJSZnN1cGVtaWNyUnNoY2lyY2xlYXJyb3dyaWd0aW50cGhtbUREb3RDbG9zZUNtYXBzdG91cDtJZ3JhdmVrY3lOYWN1cmhhcmQ7QW9nb247UmlnaHRBbmdhY3V0R3JlYXRlckZ1bGxkdXRycHJlY2FwcHJveDtsb2FydXBsdXN2YXJzaWdtYTtydGlob29rbERvd25hcmxlc2d4bnN1cGRzdW9yRGlmZmVyZW50aWFBYWN1ZGVhdW1sO2xiYnRyaWRyZmlzaHQ7TGVmdFRlZVJ1bGVEZWxMb25nTGVhbmdtc2RhZztyYXJyd2d2ZXJ0bmVCZXJub3VsbGl1YWN1dGU7UHJlY2VkZXNUaWxkZTt2cnRpZWNYaTtOb3RWZXJ0aXJuc2Nwb2xpbnQ7Tm90VGlsZGVUaWxkZXBpdGNoZm9ya21jb21tYTttZlJpZ2h0RG93blRVbmRlclBhcmVudHRzdHJkZG90c2VUc2NyO2N1cmx1cHNpbG9udXRpc3VjY25hcHByb3J0aW1ldnByb3Boc2lhY2lvdGFwbHVzZHVQcmVjZWRlc1NsYW50RXF1YWw7dXBscmRzaDtjYWNnZ2dkemlncnN1cHNldG5lcTtjdXJseWVxc3VjcmZsb29yRGlhbW9ucmlnaHRhcnJvd3RhaWxSaWdodENlaWxlbXNwMTNOb3RQcmVjZWRlc0VxdWFsO2d0ZERvdWJsZUxvbmdydHJpZjtkYXNoTm90U3F1YXJlU3Vic2V0aG9va3JpZ2h0YVhmZ3RyYXJyZWFsaUxlc3NHcmVwaG1tYXdlZGdlRG91YmxlTGVmdEFyT3BlbkN1cmx5UXVuaHBhcjt3Y2lyYzttbGR6YWN1TG9wZmN1ZGFyeG9wbGhlbGxpcHBsdXNlO2xBdGhzdHJIb3Jpem9udFVwQXJyb3dEb3duQXNxdTtxcHJ4bGFyc3VjY3ZhcnRyaWFuZ2xlcmlnaHRwcmVjbmVxdXRsdHJQYXI7dXBoYVN0YXVBcnJibG9jaztzdWNjbmVxcmFjdXRydHJpbHROb3RMZWZ0VHJpYW5nbGVFcXVhbDtNZWRpdW1TcGFscGFybHRpYWN1dHNob3J0cGFyYWxsZWw7bHN0Y2x1Ym52Z3Q7YmlndHJpYW5TYWN1dFpkTm90UmV2ZXJzZUVsZW1lbnQ7Um9wZmNvbmdkb2N1cnZlYXJyb3dyaWdoaW50ZWdlcnNiaWdzcWN1cE5vdFRpbGRlRXF1Z3RyZXFxbGVFbXB0eVNtYWxsU3F1YXJlVGN5O3BsdXNkbnNjO2ludGxhcmhrO05vdFRpbGRlVGlsZGU7RG93blJpZ2h0VGVlTGVmdFVwVGVVcEVxdWljaXJjbGVkY25oYXJybGF0YWlsO05vdE5lc3RlZEdyZWF0ZXJHcmVhbmxzYmlndHJpYW5nbGVkb3dubWNvbWduYXBwcm94WG9wZjtsZmlzaHRyaWdodHNxdWlnc21pbGVjb25pbnQ7bXVsdGltYVplcm9XaWR0aFNwYWNlO0Rvd25BcnJvd0JhY2VudGVzYWN1Y3Vwb1lVY3k7UmlnaHRBbmhhbUxlZnREb3VibGVCcmFja2V0ZHdhbmdFeHBvbmVudE9wZW5DdXJ0cmFkZWVuc3B4Y3VndHJlcXFJbnZpc2libGVDb21tYXJhZGlEb3duTGVmdFZlY3RsZWZ0bGVmdE5lZ2F0aXZlVmVyeVRoaW5TcGFjZTtEb3duTGVmdFJpZ2h0VmVjdG9yQ29wTmVnYXRpdmVWdHByaW1lO3VwaGFycG9vbnJpZ2h0VEhPUk47aXRzdXBzZXRubHNhbHBQcm9wb3J0aWFjZDtyY2VkaWx1d2FuQ2FwaXRhbERpZmZ1bWFjaGtzZU5vdE5lc3RlZEdaY2FEWmN5R3JlYXRlclNsYW50RXBvdW5zcXN1Ymhvb2tyaWdodGlub2RvdGJvdDtTcXVhcmVTdXBOb3RQcmVjZWRlc0VxdXNldG1pbnVzO2ZhdGhrc2ltcmhhcnU7YnNlbWd2ZXJ0bmVxeWVuO2xjYXJvbnRyaUFzY3I7T3Vtc3VjY25hcHByb3g7bWludXNiO0VtcHRQb2luc2ltbmU7RG91YmxlTG9uVWFySHVtcERvd25IdUVzY3JrZ0NhcGl0YWxEaWZmZXJlbnRpYWxtaWNybztyaWdodGxlZnRhcnJvd1VnckxlZnRVcFRlZVZlY3RvRW1hY3I7cnhuc3VjTGVzc0Z1bGxFcWVhY1BoaXJzYXF1bzt5Y2d2ZXRyaWFuZ2xlcmlnaHR3b2hlYWRyaWdodGFOb3RTcXVhcmVTdWJzZXRFcXVhbDt0d29oZWFkbHJicmtzbHU7UmlnaHRVcERvd25WZWN0ZXFvcmRVZGhlbHVwdXBhcnJvRmlsbGVkU21hbGxTcXVOb3B0cmlhbmdsZWxnYWN1dHVsY3JvcEludmlzaWJsZVRpbXBlcnR0ZnJzcGFkZXN1TGVmdENlaWxpZ2VzY2NRZm9yZDtudGdsO2xlZnRyaWdodGhhcnBvb3ZhcnNpc3Vwc2V0bnBhcmFsbG1pZGFOb3RQcmVjZWRlc1NsYW50RXF1YWxia2FVbmRlclBhcmVudGhlc3N1Y2NjdXJseWFyaW5nTGVmdHJpZ2h0YXJyb3dud0FybmNhcDtCZnJQb2luY2FyZXBsYU5vdFNxdWFyZVN1cmFycnRsTm90SHVtcEVxdWFyYnJhZGlhbW9uZHN1aXRJbWFnaW5hcmlmcm5WRGFzc3Vwc3VwRmlsbGVkU21hbGxTcXVhcmVOb0JyZW5hdHVyYWxzeGxsbW91c3RhY2hlSmZybnZkYXNoO0ljeW52SHhzY3I7R3JlYXRlckZ1bGxFcXVhc3Vwc2V0ZXFxO3JhcVByb3N0UnVsZWZhbGxpbmdkb3RzbnZydHN3YXJwcm9mc2lhY3V0ZTtySHVjaWFwYWNEaWFjcml0aWNhbFRpbGNhS2FwcGF1ZnJib3h2Umhvb2tsZWZSaWdodFRlZVZlY3RvT2dyYXZlTG9uZ2xlZnRyaWdodEJhcnY7UmlnaHRVcFZlQ29udG91ckludGVncmFsdmVyYmFyO2xsY29ycGhubHRyaTtkb2xsbnNjY3VkaXZpZGVvbnRpbWVOb3RSZXZlbnBleHBvbmVudGlhbGVDaXJjbGVNbGhlYXNMZWZ0VmVjdG9yT3ZlclBhcmVudGhlc2xvYXJyO3JlYWxwYXJzdXBzZXRlcTtFeHBvbmVudGlhVXBwZXJSaWdodEFycm9Ob3RMZXNzU2xhY29uZ2RvdDt1dXZlcmJhYWxlZk5KY3k7UVVGaWxsQ29wckFyaW5nc3RyYW1Tb3BmO2F3aW51bHRyaTt0aG9ybjtib3hoVXNjbnNpRG91YmxlVXBBTm90VmVydGljYWxCYWlwcm9kO25vdG5pdmJ0cmlhbmdsZWRvd247bnZsQXJyVGNhcm9uWXNjcjtDbG9zZUN1cmx5RG91YmxlUXVvZWxzZG90O3JhdGlvbmFsTm90VGlucG9kamN5O0dyZWF0ZXJUaWxUaWxkZUZ1bGxFcXVhbG9kb3Q7bHRpbWVpY2JsYWNrbG96ZVplcmxvb3BaZWRvdHNxdWF0cmltZ3RybGVzczthbmRzbG9wZXV1YXJyY2VudGVyZG90O05vdFN1cGVyc2V0RXF1T3ZlckJhcGFydDtiTm9waG1zaWdtYWY7bGVzc2FwcHJvTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI7bHN0cm9rO2F0aU5vbkJyZWFraW5nU3BhY0FyaW5nO3RvcGJMZWZ0bGVmdGhhYnJ2YlRzRm9wZnRjZU5vdFRpbGRlUHJvcG9yZG07Tm90U3F1YXJlU3Vic2V0O0xvbmdsZWZ0cmlnaHRhcnJvdzt4dXRtaW51c2JvaXJtb3VzdGFjaE9ncmFycmJmcztWZnJHZztlbmdzY2VkaWw7dGRvdHhvcGY7TGVmdFRlZVZlY3RUc3Ryb2s7dUh0aW1lcztzZW1pO05vdFN1Y2NlZWRzVGlhbGVwaDtyYXRpb2RhckNlZGlsbGFMZWZ0VXBWZXBsdXNzTm90TGVzc1NsYW50RXF1Tm90R3JlYXRlclNsYW50RXF1YWw7bGhibmN1cGduc2ltcmFyQ3VwQ2FwO09FbGlyaWdodGhhcnBvb25kYWd0aW1lc2Q7aGFpckpvcGZzZUFycjtSaWdodEFuZ2xlQnJhY05jYXFmcjtyZWFscGFydDt6ZWV0cm1jeXNicXVvTm90UmV2ZXJzZUVsZW1lbkdjZUhBUkRjeTtOZXN0ZWRHcmVhdGVyR3JldGlsZGU7dWRhTm90TGVzc0xlc3M7UmlnaHRBcnJubHQ7aG9tdGhiY05vdExlZnRUcmlhbmd0YXJnZW5zaW1lcVJpZ2h0Q2VpTGVzc0Z1bGxlcXNpbTtkd2FuZ2xlO25wYXJzT3ZlckJkb3dubmdlcXFFTkc7Y2lyY2xlZGNpcmNOZXN0bnByZWNleHNjcnNzdGFycXVhdGVybmljc3VibHRkb3Rob2FycjtkaWFtb25kc3Vpc2hvcnRtbnRsZztob29rbGVmdGFycm9XZnJMZWZ0RG93blZlY3RvckJhcjtmZmlSaWdodFVwVnNldG1uO0hpbERvd25BcnJvd1VwQXJuTGVmdHJpZ2h0YXJyb0xlc3NMZXNzVXBzaTt0cnBlemlzdWJuRTtzcXN1YnNldGVxZnJhYzE0O2lmZjt2ZU5vdERvdWJsZVZlcnRpY2FsQmFyO2xjZWlsO2V1bUh1bXBEb0RvdWJsZUxvbmdMZXJpZ2h0aGFycG9vbmRvUmV2ZXJzZVVwRXF1aWxpYnJpdWRvdGV4cG9vbGluZU5lc3RlZExlc3Nsb25nbGVmdGFycm9SaWdodERvd2ltYWNyT3BlbnJoc2NlZGlMb25nTGVmdEFycmxhcGlqbGlyb3BsdW5hcHByc2VtaUNvcHJvZHVuaTtwaG9Ob3RSaWdodFRyaWFyYWVtZW1wdHk7c3dBcnJzcXVhcmU7dWRibGF0d29oZWFkcmlnTG9uZ1JpZ2h0QXJyb2RibGFucmFycnduc3FzdXBlO3RjeWJpZ290aW1lc2VzY1NpZ21WdmRhcGx1c3R3b2Vnc2RvdDtjdXJ2ZWFycm93cmlnZ2Vxc2xhbmxlZnR0aHJlZXNmcm93bjtoY2lyY2N1cnJlbnN1cHNldDtMZnI7bmdFO1VuZGVyUGFEb3VibGVMZWZ0QXJycmlnaHRoYXJwb29uZG93Y2VudGVyZG90Tm9uQnJlYXZlZWJhcjtrb3BmTmVnYXRpdmVNZWRpdW1tc3Rwb3N2YXJ0aGVMb25nbGVmdHJpZ2h0YWxiRG93blRlZUFycm93O0V1bUxlZnRWZWN0b3JCYXI7bnZIYXJTdXBlcnNldEVxdW5wcjtzdXBoc3ViO2pjaXJjO2RyY29ycmVhbHN0YXJnZXRwaXRjaGZvcm11bHRpZXBzaTtkc2NydG9wYm90bnZyY2lyY2Vxc2VzUHNjcmhvb2tyaWdobGNlZGRhZ2dnbmFwRWZyO1VuZGVyQnJhY2tsZHJkaGFjaXJjbGVzbXRlb2ZjaXJuZ3NpU3VjY2VlZHNTbGFudEVxdWFsO25leFVkYmxVYmhlcmNvbjtSZXZlcnNlVXBFcXVpbGliclByb3BvcnRpb25hbGxhcmFwRUN1cExvbmdSaWdodEFycm93dnN1cG5lO1JpZ2h0VWhmckRvd25hcnJScmlnaHRhVGlsZGVGc3VtY2FwZHZhcnN1YnNldG5ud2Fycm9SaWdodERvd25WZWNuc2ltO2RpdmlkZW9udGltblJpZ2h0YXJyb2lvY2xuYXA7Y3VyYXJySGNpYXBhY2luc3VjYztyb3BscmFycnNib3hib09wZW5DdXJseVF1b3RlblZEYU5vdFJpZ2h0VHJpYW5nbGVFcXVyaWdodGxlZnRhcnJTdGFydmFyc3Vic2VvdGlsZGJhY2tzaW1lcTt2YXJwaGk7Q2FwaXRhbERpZmRIYXI7b2d0Tm90RVRoZXJlTm90VmVydGljYWxib3hWSE5hY3V0ZWNhcGFuZFN1cGVyc2V0RXFiZXBzaWRlZztTdWNjZWVkc1NsYW50RW9tZWdWb3JkZXJvbmVxdWl2O3BlcnRlbnRvc2E7Tm90RG91YmxlVmVydGljYW5yaW9mY0VtcHR5U21hbGxTcXVhcmU7bW9kZWxzO3ByZWNVcHBlclJpZ2h0QXJyU3F1YXJlVW5pb247bEFyTm90TGVzc0dyZWF0bGF0Tm90Q3JwYVVwYXJyb3dsamNTdWNjZWx0Y2lyO25WRGFzaFpvcFJpZ2h0RG93bnJhdGlvbmFic29saHN4dXRyaTt5ZW5Fc2ltO21hbGU7cGl0Y2hzZWFyaGt1ZmlzVm9Eb3VibGVVcEFycnByb2ZhbGFyaWdobnNob3J0bWlkO2JsYWNrdHF1b1lVY3lpZXhjY3VybHl3ZWRnZWxpbnRlcnNkdWhhTGVmdFRyaWFuZ2xlO25nZXFzbFlJY3NoYURvd25MZWZ0VGVlVmVjdG9yRG93blRlZUFycnVsY3JvbGRydXNoYXI7dXNjcjtzaW1nRW5MZWZ0cmlnTG93ZXJSaWdodEFycm93O3Vyc3Vic2V0bmVxcTtVY3N1cGRzVWdyYWltb2ZlbGluc3Vic2V0bmV6aXJhcnJoa0Fmck5vdEdyZWF0ZXJHcmVhdGVyO0NvbG9uc3NtaWxlTm90SHVtcEVsZWNhcmhvcGx1c2J0d29oZWFkbGVmbGVmdGxlZnRhcnJvd3NWZXJ0aWNhbFNlcGFyYXRkb3VibGViYW5SaWdodGFyVmVydGljYWxTZXBhcmF0b1RjdXJ2ZWFycm93Ym94dUw7Ymlnb3BsU2hvcnRVcEFycnN1Y2NuZXFxbmxFO1VjeTtJdGJpZ29wbHVzO2JpZ3NxY25zaG9ybXN0cG9TY2Fyb2Vxc2xhbnRnaG9va2xlZnRhcGx1c3NpbW52bEFycjtMZWZ0VXBEb3duVmxlZnRsZWZ0YXJyb3dzO0Rvd25MZWZ0VGVlVmVjYmlnc3FjdXF1ZXNiZXRoZXBhcnNyaWdodGxlZnRoYXJwb29ucztjbHVic3VpdFVwREV4cG9uZW50aWFscHJlY2NsYWdyYW54dXRyeGlkb3VibGVvZGJsYWM7YWNpckRhZ2d1Z250cmlhbmdsZWxlZnRucnJhbmdsUmlnaHRDZU5vdExlZnRUcmlhaGFsZXFzbGFudGd0cjtjdXZlZTtOb3RQcmVjZWRlc1NCb3BmO0xlZnRWZWN0b3JCendib3hkcm5taWQ7RG91YmxlTGVWZUxlZnRSaWdodFZlc3VjY2FwcHJsYWduYXBwbGVzZG90b2xhcnJiO2FjdVVuZGVyUGFyZW50aGVndGltZXNmbm9mO2toY3k7bmlzZDtsc2NySWFjdXRlcmlnaHR0aHJlZXRpbXB1bkZpbGxlZFZlcnlTbWFsbFNxdWFEb3REb0ltYWdpbmFyeWZvc3ViclZlcnRpY3JicmtzbHNtYXNobWFsdGVaZXJvV2lkdGhTaHN0cm9rO3ZhcnN1TmVnYXRpdmVUaGluU3JjYXZhcm5vdGhpbmdSaWdodFRyaWFuZ2xlQnJjZWRpcGl0bGVzZ2VVbmRlckJyYWNlO2VjaXI7Tm90UHJlY2VBc3Njb21wZm5wcnVyc3VwbGFycnNpbXJwb2ludGludDtIb3BDY2FpdGlsZGV0cmlhbmdsZXJpZ25idWxlc2NEb3duQnJlUm9oYXJybmU7YW5ncmthcHBhZG93bmRvd25hcnJvd25zaG9ydG1VY2lBdW1hcmtpb3Rsb25ncmlnaHRhcnR3b2hlYUxlZnRBcnJuY29uTHNjcm52aW5maW5jb21tYU5vdFByZWNlZGVzU2xJZG9uZ2U7RG93bkxlZnRSaWdodFZKc2NyaXByb2RoYW1pbEZzY3I7aWNpcmNyYXJyO2xoYXJ1O3dlaWVycHRyaWU7TmVnYXRpdmVWZXJUaWxkZUVib3hVbHByc3N1cHNlbmZydmFyZXBzT3ZlclBhcmVudGhlSnVrY0FncmF2ZTtvbWFjcjtzdWJzdXA7Q2lyY2xlUGxvYW5nO2ZyYWMxcGVybXJBdGFpbGRpYW07TG93ZXJMZWZ0QXJzcXN1YnNqb3BzdXBkb3RuZXNlYVJpZ2h0VmVjdHBlcm1pbGxtb3VzdGFjYm94aGRVbmRlckJyYWNrZXQ7TGVmdERvd25UZWVWZWN0b3JSZXZlcnNlRXF1aWx0ZnI7Y3V3ZWROb3RMZXNzU2xhbnRFY2lyY2xlYXJybWludWxkcmRSQmFyTGVzc0VxdWFsR3JlYXRlTnVvcmRlcm9mSnNlcmN2YXJzdXBzZXRuZWJsYWNrbG96ZW5nZTtzbGFycjtsY2FyUmV2ZXJzZVVwRXF1aWxMZWZ0VGVlQXJyb3duZ2Vxc2xhbnRVb2dvbjthbmdtc2RhYzt2RGFkb3duaGFycHN1YjtqdU5vdFByZWNlZGVzRXF1YWxkaXZvbm1hcmtlcHJvcHRvcm90aW1lc0lncmF2ZTtWYmFyO2Jub1JpZ2h0Q3BlcmlvZGV4cG9uZW50aWF1cHNia2Fyb3VydHByb2ZsZnJhc1RpbGRlRnVzdWJzdXBIc2NyO1ZzY3JsZHJ1bEF0YWlsO2N1cmx5ZXFzdWNjQmFyU2hvcnRVcEFycm92Y3k7Ym90dG9tO05vdFZlcnRpY2FsQmFySGFjZXBsdXM7ZXJEb3RMZWZ0VHJEb3VibGVMb25nUmlnaHRBc3NldG1ub29wZjt6aWdycXVvdE5jZWRpbGFuZDtMb25nTGVmdEFycm9sYnJrc2x1SW9wZkJlY2Fsb25nbWFwc3RvO25yQXJyZHJia2Fyb3c7c3VwaHN1YmNvbXBsZW1lbkhjY2FCZXJubmpjeTtzY3BjdXJseXZlZTtjaXJmbmludEZpbGxlZFZlcnlTbWFsbFNxdWFybWFwc3RvWmV0RXhwb25lRGVsQ2xvY2t3aXNlQ29udG91ckludGVwcmVjYXBwcm94TGNlZGlsT3RpbGRJbXBsaWd0Y2M7aG9va3JpZ2h0YXJyb3c7c3VjYztFcHNpbG9uS2N5aWluZmludXBkb3duYXJzY3NpYmxhY2t0cmlhbmdsZXJJY3k7VkRhc2hndmVydG5lcXFOb3RQcmVjZWRlc1NsYW50RXFaZG90O29kaWxkcnVzaGFDZW50VXBEb3d0aGVyZTQ7YmFja2VwbG9uZ21hcExlZnRVcFRvdGlsZGVyaWdodGFycm93dGFpbDtMZXNzRnVsbEVxdWFsO3VmaXNodFJldnZlZWJhcnJpZ2h0YXJyb3d0bmVBc3VwRUxtUVVPb21pbnV3Y2xBdGFpbHNkb3Q7cnJhcnJhbmdydHZiYW5nO1RSQURFSHVtcERvd25hbmdtc2Q7S29wZlVwZG93bmFyeHJBcnRoZXJIdW1wRXF1YWw7c2ltZTtMZWZ0VXBWZWN0b3JCYXJiaWdvdGltY2FwZG90Q291bnRlckNsb2Nrd2lzZXVkYmxhYztubGVmdHJpZ2h0YUdyZWF0ZXJFcXVMZWZ0VHJpYW5nbGVFcWxlcXFMb25nbGVmdGJsYWNrdHJpTm90R3JlYXRlckdyZWFlcXNZSXN1YnBsSXVrY1JjZWRpYnNvbGhzdXJ0cmlmcHJlY3NpbXN1YnBsdXM7Tm90U3VjY2VlZHNFcXVhbHZhcmVwc2lsb247aHN0cGx1c2NpcjtUaWxkZUZ1bGxFcXVlbHNkb0ZvckF1cGhhcnBvb25sZWZjYXBicmN1cDtsc2FxdW9vZGF1aGFycmZhbGxpbmdkb0xlZnRhVGhpblNwYWNlO2JkcXVzdWNjYXBwcm9KdWtjeXpjYXJIb3Jpem9udGF2YXJyaG87ZmZsaWdsdHJVcEFycmhrb2d0O2RpYU5vdExlc3NURG93blRlZUFycm93U3F1YXJlU3VwZXJSc2NDcm9zY3V2eG90YW5kc2xvSEFSSWFjbmNhcm9ubnJBcmJsYWNrdHJpYW5nbGVsZWZ0O0l1bWxvb3BhcnJvd2xlZnQ7YmFja3ByaW1lcXVhdGVybmlvbk5lZ2F0T29FbXB0eW9yc2xvcGVjdXJ2ZWFycm93cmluc3VwRXNlbWhhaXJzcDt1ZGFycnRyaWFuZ2xlcmlnaHRlbGVnZGxjcm9sb25nbWFwc2lpaWludDtnZ2c7UmNlZGlsO0xlZnRST3RpbG90cmJicmt3c2NyRWZycGxhbmNrc3VibXVsdDtraGNuc29sdGF0aWxkZTtuTGVmdHJibGsxMjtnZWRvdWJsZWJhcndlZGdlUm91bmRJbXBsaWVzY2FyZVZlcnlUaGluU3Bhc2NFUmlnaHRWZWN0b3JCYXhjYXBVcHBlclJpZ2h0QXJyb3c7YWxlZnN5bTtFb2dvbmR0ZG90U3FydDtMb25ncmlnaHRhcnJOb3RDb25ncnVlSW52aXNpYmxlQ1ZlcmJOdGl4Y1pkb3ByZUV4cG9uZW50aVFzZGVnb2ludDt0aGluc3BOb3RSaWdodFRyaWFuZ2xlO3JicmxjeTtOb3RTdWNjZWVkc1NsYWJldHdlRG93bkxlZnRWZWFwaWR2YXJ0ck5vdFNxdWFyZVN1cGVyc2V0RU5vdFN1Y2NlZWRzVGlsZGU7b2RpdkRpYWNyaXRpY2FsRG9MZXNzTGVzcHJlY25hcHByb253YXJocHJFa2NldXBkb3duYXJyb3RvcGNpcjtyaWdodGxlZnRhTmN5T3NsUmlnaHRGbGxlcXNsYW52ZWxsaXA7ZWdyYWxyY29ybmVyO1ByZWNlZGVzVGlsZGVTcXVhcmVJbnRlcnNlY3Rpb25uZGFzanVrY3lnZ3NvcGZOY3k7Y3VkYXJyZ2N5O0VxdWFsVGlvbWlkO1ZlcnlUaExlc3NFcXVhbFN1Y2NlZWRzU2xhR1Q7bWVhc3VOb3RHcnNpbXBsdXM7aWN5O3JiYnJEb3duUmlnaHRUZWVWZWN0b3I7WWZpZXhUcmlwbGVDb3Byb2R1Y3Q7Tm90R3JlYXRlclRpbGRlO2xlc3NzaW1ub3RpYWxlRGFzaERpYWNyaXRpY2FsRG91Ymx2YXJ0cmlhbmdsZXJpZ2RjYXJvYmJya3Ricms7bmlzZEVsZW1ub3RuaTtlZ3M7UHJlY2VkZXNDSGNnZG90O2hiYVJpZ2h0RG91YmxlQnJhbHBoYVJpZ2h0Q2VpbGluZ2hvbXRUcmlwbGhhcmRjeTtkb3BmUmV2ZXJzZVVwRXF1aWxpYnJpdW12eml6c2NyQ09Qc21hc2hwO3VsY29ybjtsZWZ0cmlnaHRoYXJwb29uU3FsdHJQYVJpZ2h0VGVlQXJybGVmdGxlZnRhcnJvb3RpbWVzYW9wZXJwO2ZvcmFSc2h5VGlsZGVFcWlzaW52YmlnY2FwO1VjaXJDY2Fyb25Eb3VibGVMb25nUnN6bGlGaWxsZWRTbWFsbFNxdWFsdGltZGJrYXJvbHVsZWZ0aGFycG9vbnVVbmRlclBhcmVudGhlc2lOb3RSaWdodFRyaWFuZ2xlQmFyYm93dGlCYWNrc2FuZ21zZGFVY2lyYztWdmRhc2hob2FndHJhcHBycmlnaHRoYXJwb29uZG93bk5vdE5lTm90TmVzdGVkTGVzc0xlc3NzdGFpbmZEb3duUmlnaHRWZWN0b3JCYXJuc3FzVW5lb3BmdmFycHJvcHRBcHBseUZ1bmN0aW9DbG9ja3dpc2VDb250b3VySW50ZWdyYWxEb3duUmlnaHRUZWVWZWN0bkxlZnRhck5vdEdyZWF0ZXI7Z3NpbWZmbGxpZztndkRvdWJsZURvd25kaXZpb2xjcm9UZnI7b21lY2lyY2xlYVJpZ2h0RG93blZlY3RvT3ZlckJyYWNrTGVmdFVwVlVuaW9uUEZzUmV2ZXJzcng7QmFyd2VkbmlzO3ByZWNzaVJpZ2h0Rmxvb0l0aWxHcmVhdGVyVGlsZGU7bGFycnRsO3N1Ym5lZGhhcmxOZWdhdGl2ZVRoaWNTcXVhcmVJbnRlcnNlY3Rpb25wYXI7QmFja3Nsa2NlZGlkaGFycjtVcERvd25BcnJsZHF1b3I7dkJQY3licnZnbGFydWxvbmdyaWdodGFycm9lZG90O2xiYXJyO3Byc2lpc2luZG90QmN0cnBleml1ZWdzdW9nb3NldG1pa2hjeVNjZWRpdXVtcHJvZnN1ck5vdEVxdURvdWJsZUNvbnRvdXJVcEFycm93O0xhbnJoYXJ1bGN1cmx5d2VQcmVjZWRlc1RpbERvdW53YXJoa3dlZGdlcXBhcnNpbTt1dHJpTmNlZGlsO2VhY3V0ZTtybGhhcjtSaWdodEFudkRhc2ZyYWM0VHNjcmJhcnZndHJhcFlhY3V0ZTt1YWNEb3VibGVMb25nTGVmdFJpZ2h0QXJOb3RTdXBlcnNldDtpaTtzcXN1YnNldHJzcWI7Y2lyc2NpbnZzaW1ucnRyaTtkaWdhbW1hbGVmdHJpZ2hhbmd6YXJyZnJhYzE2O3V0ZG5hYmxhTm9uQnJlYWtpbmdTcGFjZVJpZ2h0VXBUZWVWZWN0b3JyYXJyYztub3RuaXZiO1hvbGVmdGFycm93dGFpbDtmcmFjNDVDbG9zZUN1SGlsYnVwaGFycG9vbnJpZ0xvd2VyUmlnaHRubGVxc1JpZ2h0VXBWZWNzdXBzZXRlcWxlZnRsWXVtbnZzaXZzdXBuRTt4cmFycjtzc2NyO3NvbGJhcmNvbXBmcmlnaHRyaWdodGFycm93bGJicms7RGlmZmVyZW50aXNvZ3RjY25hdHVyYWxJYVljaXJjO0RhZ2dlQ2xvY2t3aXNlQ29udG91ckluTmVnYXRpdmVNZWxlZnR0aHJlZXRpbWVzTGVmdFRyaWFuZ2xlQlNxdWFyZVN1YnNldEVvcm9yO2RhcnI7Y2N1cHNzb2Rhc2g7WVVmYWxmcmFjMTJkb3RtaW5MZWZ0QXJyb3dSaWdodGFtYWNyTm90U3F1c3Vic2V0ZXE7Q2VudGVyRG91YmxlTG9uZ1JpTG9uZ3JpZ2h0YXJyb2JicmtwZmxlcXNsYW50c2VhcnJ2c3ViRXF1aWxpYnJuYnNwO2JrYXJvdzttaW51c2R1SnVuYXR1ZnJhYzEyO25zdWJzZXRlcXE7QXNzaWdsZWZ0cmlnaHRhcnJvd3Nob3J0cGFybGVmdHJpbnJBcnI7cmhhdXBocnBwb2xucGFOb3RHcmVhdGVyU2xlcmFycmRvd25kb3duYXJycGVybWlsc2ltO2Ria2FnY2lydHdvaGVhZGxlZnRhcmNjZWRyc3F1bztEb3VibGVMb25nTGVmdFJpZ2h0QXRwcmltYXN5bXA7cHJlY3NpbTtubGVzcztJc05vQnJlYUNjb0RDdXBsdXNjaXJ1cFVuZGVyQnJhY2Vob3BmYmFydmVlYW1hY3I7c21hbFVwRXF1aWxzZG90YjtCdW1wZXFDZWRMZWZ0VE5vdFJlbGN5cXN0cmlhbnlVZ05vdFN1Y2NlZWRzU2xhbnRFQ3NwcmVjY3VyS3NjRXhpc3RzO2x0cmljdXBicmNMZWZ0cmlnaHRhcnJvY2N1cHNzbTtFZG90O05vdFN1YnNldDtuc2hvcnRwYXJhbEVtcHR5VmVyeVNtYUNvbnRvdXJJRm9yQWxsO2luZmludGllO1ljeTtsZWZ0cmlnaHRzcXVpUmlnaHREb3duVGVlYXdjb25pdGhpY2tzaVJvdW5kSW1kb3duYXJyb3dsZHJkaE91Z3ZuRXRyaXRpVW1hY3I7Q2F5bGJhcndlZGdlQ291bnRlckNsb2Nrd2lzZUNvblNxdWFyZVN1YnNlcnRyaWx0cmlMZWZ0UmlnaHRuYWN1dGU7Tm90U3VjY2VlZHNFbGJiclhvcHJ0aHJlRWNpcmNMc2hwcmVjYXBwTGVmdFRyaWFuZ2xlQmFyUmlnaHRhcnJvd0NoRGFnZ2VybnN1YnNlR3JlYXRlckVJb2dvbmxuYXB5c2NybGJyYWNrO0RmcjtnZXNkb3R2cHJvcGxhbmt2O0RvdEVHZFJlUmV2ZXJzZVVwRXF1aWxpYnJpUGx1c01pbnVpaW5mc3VwRTtlbXNwUmlnaHRVcERvdXBkb3duYXJyb3dxc2NyY3JvcXVlc3Q7dWxjb3J2emlnemFnO3RoZXRhc3ltO1VvZ29uRGFnQ3JvemhjbWlkY2lyO250cmlhbmdsZWxlZnRlcTtlcHNpbG9ueHVwbGJpZ3ZlZWN1cGNhZXhwZWN0YVNob3J0bmxlZnJhbmdlRmNVcHBlclJpYmlnY3VwTm90Q3VSZXZlckxlZnRUcmlhcmFycmJ2YXJwck5vdFN1YnNldEVxdVVSYXJydGw7TmVnYXRpdmVNZWRpdW1TcGFHZG9FZ3Jhdm5MZWZ0cmlnaHRhcnJvdztkb3duaGxhcDtTcXVhcmVTdXBlcnNldEVxdWFsO0ZmcjtkaWFtb25TdWNjZWVkc1NsYW50RXFpbWFncGFySXVrY3lsYXJycGw7QW9nbm90bml2YTtzdGFyO3NpbXJhcnI7TFROb3RQcmVjZWRlc0Vuc2hvcnRwYXJhbGxlbG11bXNkb3RlcGl0Y2JpZ2N1Y29tbWd0cXVlRGlhY3JpdGljYWxBY3V0ZTtsb29wYXJyb3dyaWdodDtsYXJybHNtdGVzYW5nbXNkYWRzcmFycjtQbHVzTWludXM7dm5zTHByb2ZsaUVhY3V0ZHdhU3VjY2VlZHNUaWxlc3NndHJlYXN0ZUlvdGFEb3VibGVSTGVmdEFuZ3JobztSZXZlcnNlRXF1RG93bkFycm93VXBBY3VsYXJyO2x1cnVoYXJsZXNzZXFnU2NhcmN1ZXByYmNvbmdkc292YW5ncnF1YXRpSnNlcmN5O3N1cGhzb2xSaWdodFRlRG91YmxlTG9uZ1JpZ2hidWxsZXRDY29uaW5MZWZ0YXJyb3h3ZWZsaG9yYmFDYXBpdGFsRGlmZmVyZW50aXJzcXVzcGFEb3duTGVmdFZlY3RvckJhcjtOb3RTcXVhcmVTdWJzZXRFcXVhbGJveEhMZXNzR0NvbnRibGszcm9hd2NOc2NyVGZFbXB0eVZlcnlTbWFsbFNxdWFydGhlcmVmb3JlVG9wZmV4aXN0O2RkO2xmbG9vY2FwYm5zaG9ydEltO1Jhcmx0cXVMYVZiYXVwdXBVcEVxdWlsaWJyaVNob3J0RG9uZWFyaGtyYWNlcGx1c2FsdGxhVWNpcmNSaWdodFVwRG93blZlY3RvcjtIaWxiZXJ0U3BhY2U7cmlnaHRhcnJvdztQcm9kdWN0YnByaW1SaWdodFVwVGVCYWNrc2xhc2g7bWNvZHVhcnI7RmlsbGVkVmVzaGNoY3k7Y2lyY2xlYXJyb3dyaWdodDtjdGRvdGdlcXNscmVnVEhDb25ncnVlYW5nbXNkYnNjcjtsZWZ0dGhyZWV0aW1lcztsYXF1YmxhY2t0cmlhbmdsZWxlZnRsYXF1bztndHJlcXFsZXNzO3BybmFZZnI7SHN0cm9raW1hY3I7SUVmaWxpZztzdWJzZWZyYWMxNTtudTtsYXJybHA7ZGFsZXRoTm90UHJlY2VkZUxlZnRBcnJvd0JhckRvdERMb25nbGVmdGFyV0NjZWRpbWFsZUxlZnRUZWU7cmZsb1JpZ2h0VmVjdG9yO1VwQXJyb3dEb3duQXJyb3d2ZWVlcXBhcmE7Y3V2ZVNjeWNlbnRzdXAxVHNjdXB1cGFycm93cztkd2FuTm90UmlnaHRUemZOb3RTcXVhcmVTdWJzZXRFcWxkc2g7VGlsZGVUbHJjb1plcm9XaWR0aFNwYWNMZXNzRXF1YWxHcmVuZ2Vxc05vdFNxdWFyZVN1cGVyc2VzcXN1YjtVcFRlbGhhcnVsY2N1cHM7U3VwZXJzZXRFcXVhbEF1bWw7Ym94SFVIYXRwc2NyO2hzY3I7Y3VydmVPdm5sdHJpZTtsb25ncmlnaHRhcnJvdztTdWNjZWVkc1Rib3hkUlNxcm9sY0dUbmFuZztuc2NyO25vdG5pdmVmckdyZWF0ZXJFcXVhbGN1cmFjdXJseXZlUmV2ZXJzZUVxdWlsaWJyaWJhY2tlcHNpbGxvbmdsZWZ0cmlnaHRhT3VtbExjYXJvYmxhY2t0cmlhbmdsZWRvd3RpbWVzYmxhcnJ0bFN1YnNldE5vdFRpbGRlRXFjdXJ2ZWFycm93bGVmdHNsQ2xvY2t3aXN5c3RoaWNrYXBwcnhvZG90bmxlZnRyaWdodGFycm93O2NjaXJjO3JkcXVvYmFsc3Ryb2tjb21wbGV4ZXM7Tm90UmV2ZXJmcmFjNzg7Z2ltR2JyZXZlQ2NlZXFzbGFudGd0cmx0aHJwbHVzbW47WmNhcm9ub3JzbG9wZTtzaG9ydHBhTG9uZ2xlZnRyaWdodGFycm11bHRpbUNsb3NlQ3VybHlRdW9vdW1sO0NvdW50ZXJDbG9ja3dpc2VDb250b3VySWx0aHJlRG91YmxlQ29udG91cWZyZWNpTmVnYXRpdmVWZXJ5VGhpblNwYWNTaG9ydFJpZ01lZGl1bVNEaWFjcml0aWNhbEdyYXZUcmlwbWFwc3Rndm5Mb25nTGVmZ3RyZXFxbGVzTm90SHVtcEVxdXVjeTticmV2ZU5lZ2F0aXZlVGhpblNwYWFlbGlnRXhwb25lbnJhbmdkO2hiYXI7U3VwZU5vdExlZnRUcmlhbmdsZUVxdWFub3RpbkU7YW5nbXNkYWF4d3VvZ0xvbmdSaWdodEFycm9FdW1sO2JhcndlZDtSaWdodENlaWxpbm50cmlhbmdsZXJpZ2h0ZVJldmVyc2VzdWNjc2N1cGN1cHl1YW5Eb3duUmlnaHRUZWxhcnJodXVhcnI7bWRhc3BsdXNhY2lOb3RUaWxkZTtiZERvd25MZW5sSGlsYmVkdHJpO2dseWVuZXFvbGNpYmFja3Npb3JkZXJzcXVmO3RyaWFuZ2xlbGVmdGVxO0xvbmdsZWZ0cmlnaG9sYXJyO0RpYWNyaXRpY2FsRG91YmxlQWN1dHJmaXNpZ3JhdmV0aG9MZXNzR3JlYXRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ1JhcnJucGFyYWxMZWZ0cmlDY2Fyb2FuZ2xlcnNhb3VMZWZ0UmlSZXZlcnNlRWxlZnRoYXJwb29uZG93ZWRiTW9kc2N5O1JpZ2h0VXBWZWN0b3JCb21pY3JvbjtkdHJpZjtibGsxNGFjRTtUc3RyZXF1ZXhjYXA7bWFsdDtuZ2Vxc2xhbnduZXF1aXZIc2ZsbE1lbGxpbkF0aWxkdm5zdXA7cGxhbmNraFNxdWFyZG90cGx1cztudkhhcnJCbW5wbGJveFZoUmlnaHRUcmlhbmdDaXJjbGRjYU5vdEdyZWF0ZXJTTm90U3Vic2V0RXFsdGhyZWVMZWZ0RG93bnN1cHBsSW52aU92ZXJCcmFja2V0c3VjY2N1c3VibkVDaXJjbGVQbGxlc3Nkb3RpbmNhcmU7bG5FO2VuSW50ZWdyYWw7UHJlY2VkZXNTbFBoTGVmdFRyaWFuZ2xlRXF1YURpYWNyaXRpY2FsRG91YmxlQWNmZmxsbWRhUmlnaHREb29nb25pdWtjeTtoZWFydHM7RG91YmxlUmlnc29sYjtlc2ltaW50ZVBzY2JveGhEO1JpZ2h0Rmxvb3JNZWRpdW1TcGFjZTtpbnRlcmNhbExzY1BvaW5jYU5vdEdyZWF0ZXJMZXNzbWl2cG5mcjtEb3VibGVMZWZ0UmlnaHRBcnJPZ3JhdmRqY21ERG90O21zY1N1cHNldGV4cGVjTm90U3F1YXJlU3VwZXJzZXRFcXVhbG1sY3A7Q2NlZGlsTGVmdFRyaWFubkxlZnRhcnJvdztEWmNEaWFjcml0aWNhbEFjdXR3ZW5jb25nckF0YUFtYWNvdGltU3VjZ3RybExlZnRhckF1bWxib3hWbm90aW52YmJpZ29kb2Jicmt0YnJraWlvdGE7WHNjcjtyaWdodGxtc3RwQ2xvc2VDdXJseURvdXRkb3Q7eHVwbHV4ckFaZXJvV2lkdGhCdW1waW9nb250cmlhbmdsZXE7UmV2ZXJzZUVxVFNvdGlUYWJyb2JyaztOb3RTcXVhcmVTdWJzZXRFaXVtcnBVbmRlclBhcmVudGhlc2lzRXF1YWxUaWxkZW5zdXBFO2JveHZIO3htYXA7c2VhcnI7bWNvbW1hTm90TGVzc0dyZWFwcmltZTtJbnZpc2libGVUaW1lemN5Tm90R3JlYXRlclRpbGRtbnBsdXNsYXJyZnM7bG1vTmVnYXRpdmVUaGlja1NweXVjeTtsZXNzc2ltO2pmZGl2b254Ym94ZFI7aGtzZWFyb0xlZnREb3VibGVCcmFja2V0O2ZyYWMzOGdhbWFmbnNob3J0cGFyYWxsZXVwdXBhcnJvd2V4Y2ZwYXJ0aW50O3hzcWN1RG93blJpZ2h0VHR3b2hlYWRsZWZ0YXJyb3dwZnJQbHVOb3RFeGlzdHM7bGRxVXNjcjtpc2NyZGl2b254O3NvcGY7SW1wbGRjeTtjbHVic3VpY2lyO0xlZnRVcFZlY3RvckJhcjtzdXBoc3VvZnI7ZGlzaW5sZXFzbGFUY2FyTWludW5yaWdodGFycnZzdURvd25SaWdodFZlbHRxRm9yQWxsTm90SHVtcERvd25IbWFya2VyO2V1cm9VcERvd25BcnJvdzt5dW1sYWdyY3V3ZWQ7ZG90c2dlcXNsYW50O0NhcDtoa3NlYVVtYWNlY2Fyb0NvdW50ZXJDbG9ja3dpc2VDb2xhY3V0ZTtib3hWclZ2ZGFzaDtsZkp1a2ltYWdEb3VibGVMb25nUmlnUmlnaHRBcnJvdztOb3RTcXVhcmVTdWJzZVN1Y2NlZWRzRXF1YWw7RGFsb25nbGVmdHJpZ2h0YXJyb3c7TW9wZlJvdW5kSW1wbE5vdFJpZ2h0VHJpYW5nbGVFcW53YXJyO092ZXJQYXJlbnRoZXNpczt6aWdyYXJyO0RvdWJsZVZlU2M7dXBzaWhQcmVjZWRlc1NvcGFyO2x1cmRzaGFycWludGVwYXJzbDtOb3RMZXNzTGVzWW9wZlJjeTtIaWxiZXJ0U3BhY2xyY05vdFRpbGRlRmludGxFdGFjeWxjdGVtYWNyTm90VmNzdWI7ZXBhcmxvcGFyO2VzaXN1cGRzdWJyYmF5dWNCYXJ3ZXBhcmFsbGVvcmlnb2Y7cHJlYztOb3REb3VibGVWZXJ0aWNhbEJHcmVhdGVyR3JlU3Vic2VuTGVmZmNyYXJOb3RTdWNjZWVkc1RpbGRpbmJhY2twUmlnaHRUZWVWZWN0b3I7c21pZFRjZWRpbDtOb3RDb25ncm5zcHRvcGZvcnRyaXRpbWV4bEFyZ3RybGVzY3BvbFhmcmVscztndDtsb25nbWFwc3RvcmlnaHRsZWNoZWNrbWhzbGFzaDtxdWVzdGVxO3hvZGduZXFxO250aW1DbG9zZUN1cmx5UXVvdEZpbGxlZFNtYWxsVmVydGljYWxyZHF1b3JsYWN1dGVQcmltZTtSaWdodFRlZW11bHRpbWFwO2N1cnZlYXJyb3dsSXRpbGRlO1NIY3lLb3BQcm9wb3JOb3RQcmVjZWRlc0VxdmFydHJpYW5nbGVsZWZ0O3lvcGZsQmFMb25nUmlnTm9uQnJlYWtpblpvcGY7ZGl2aWRlb250dGhlcmVmb3JlO0VncmFZdURvdWJsZUNvbnRvdXJJbnRleHBvbmVudHJzcVRoZXRoa3N3YXJvaWNpcm51bTtleHBlY3RhdGlvbjtzaW1PRU9tZWdhO3h1cGx1cztvc2NyVGFiO2dFO3N1cHN1Yjt2QmFyZHdhbmdsZWxkcnVzb3RSaWdodERvdWJsZXByaW1lc3dhcnI7T3ZlckJyYWNrZW52ckFyckxzdHJva0h1S0pwZXJ0ZW5rO0ZpbGxlZFZlcnlTbWFsbFNxdUxlc3NTZWxsTm90R3JlYXRlckZ1bGxFcXVhY2VkZnJhYzEzO0V1bWxYbmxlcXNsYW50O2Rvd25oYXJwb29ucmlkb3RwbHN0cmFpc3FzdXBzZXR4c2NMZWZ0RG93blZlY0xhcGxMZWZ0VXBEb3dSaWdodERvd25WZWN0aXNpbmRvdDtiZXRhcmFycnc7d2VpZXJzdXdmTm90U3VjY2VlTm90R3JlYXRlckVxR2FtbWFkbnNtaWQ7c3Njcll1bWw7Z2VzZG90b2w7cHJFO05vdExlc3NTbEFncmN3Y29uaW50TGZVcEFycm93RG93UmlnaHRhcmV0YURvdWJsZUxvbmdMZWZ0QXJyb3d0ZWxhc0xlZnRUZWVBUmlnaHRBcnJvd2VxdWlmcmFjMTg7c2VjZHN0cm9rSGlsYmVydFNwYWNlZ3Ryc2lOb3RQcmVjZWRIb252bHRyaWVOZXdMYmFydmVlO0Rvd25MZWZ0bGRyZGhhcmN1cGN1RXBzaWxMbWlkb3Q7c3RhcklvdGE7Ym94VkxuY2VkaWJsYWNrbG96ZW5nZW1pZGRvdDtscnJhdE5vdFN1YnNmZmxkZmlzcnVsdWhhclVwRXF1aWxpc2hjaHhjdXBzcXVhcmY7WWFjYXBjdWFjdXRlUmU7dXNjZG91YmxSaG9SaWdodFVwVGJveGRsO25zaW1lO1BvaW5jYXJlcGxhbkxlZnRSaWdodEFOb25CcnNzdGFyZjtTY2VkaWw7Q29udG91cmNmTm90UmlnaHRUcmlhbmdsZUJhcjtSaWdodFZDYXBpdGFsSW90UmlnaHRWZUx0O3RzaHpIZlJvcGFuZ3J0dmJkSGFjZWtuYXBvS2Zydm5zdWI7YW5nc3R4Y2lob29rbGVmdGFycldlZGdzaW1wbHVzYm94VWZyb1JpZ2h0VXBWZWN0b3JCYXJDZWRpbGxhO2xuYXBwbGVmdGhhcnBibGFja2xEb3VibGVVcERvd25BcnJvcnRyaWxQYXJEc3Ryb2tOZXN0ZWRMZXNtY25wb2xpbnQ7cXVlc3RiaWd0cmlhbmdsZWRvcmNhcm9uO21hcGtoT3Bhc2NDaXJjbGVQbHVzO0xvbmdMZWZ0UlBjc2Nuc2ltc2ltZ0U7bnRyaWFuc3FjYXBzO3NpbXBsdVN1Y2hjbHVic3VlckRvYmV0SnNjU2hvcnREb3duQXJyY3JhcnJiYWNrY0RpYWNyaXRpY2FsRG91YmxlQVRoZXJlZm9ya2FwcERpYWNyaW5wcmN1dWJyY2xlZnRyaWdodHNxb3JhcnJvdGlsZGU7Tm90UmlnaGN1ZXNjcm9wYU9taWNyYXJyYXA7Tm90R3JlYXRlckdyaWdodHJib3h1TENhcGl0YWxEaWZmZXJlUmlnaHRUcmxjZWRpbE5vdFN1cGVyQ2xvc2VDdXJseVF1aWFjdXRlVWFycm9jaXI7dUhhcmxoYXJ1bDtkaWFtb25kc3VpdDtTcXVhcmlnaHRyaWdodGF6aWdyYXJyc21hbGxzZXRtaW51c0xvd2VyTGVmdEFlcHNpbG9Ob3RWZXJ0aWNhbEJhcjtmbHRPQXNjcmNvbXBsZW1lbnRvZGJsWm9TcXVhcmVVbmlvbk5vdG1zTWNsZWZ0YXJyb2JhY2twcmltTm9ueGZsYnJhY2t6aGN5O1dlZ3RxdWVzdDtsb2JSZXZlcnNlRXF1aW9mckdjaXJjO0thcFJzY3JzdWNjbmFwcHJveGdyYXZlO3hoQXJlY29sb25nb25vdG5pdmM7blJpZHJia2Fyb0ltYWdpbnVkYXJOb3RSZHJjb3JuO05vdFN1Y2NlU3F1YXJlU3VwZXJzZXRFcXV0aW1lc2JhSHVtcEVxdWFBdEdyZWF0ZXJGdWxsRXJvcGx1cztwc2NyYm94ZHI7bGVmdHJpZ2h0c3F1aWdhcnJvd0Nmcnpkb3Q7aGFJT2NMZWZ0VXBWZWNjaXJjbGVzc3NpdXBoYXJwb29ucm5wYXJzbExlZnRBbmdsZW1hcHN0b3VwUmlnaHRBbmdsZUJyYWNrZXQ7Ym94dXI7dWNOYWN1dGU7RG91YmxlTGVmdEFycm93Y29weXNkaXNpbjtQaGk7Tm90VGlsZGVFY2lyc2NsZXNjY0NheWxlS2NlZHB1c21hRG93bkJyZXZlcnNxdW9yO3NvZnRjaWlpaW50YWN5O2NvcHlzcjtvaG07ZmVTdWNjZWVkc0VxdW5lZGJzZW1pO2JuZXF1aXY7VGhpY2tTcGFVYXJyb25jYXBDY2lOZWdhdGl2ZU1lZGl1bVNwYWN1cGRvd25hcnJvdztudnNpbTtib3hWcjtsb25nbFNPZm9ya3ZXY2lnaW1lbDtuc3Vwc2V0O2xhY3V0ZG91YmxlYmFyd2VkZ2U7UGx1c01pbnVzamNOb3RHcmVhdGVyU2xhbnRFcXVhbE5vbkJyZWFrdnppZ3pPdmVyUGN1d0Nsb2Nrd2lzZUNvbnRvdWJsYW5rU21hbGxDaXJvcnNsb3NsdXdvcmFwbHVzZW1hbHRlc2VzdWJzZXRVcHBlckxIQVJEY0VtcHR5U21hbHNtYXNocENyb3NzVXBwZXJMZWZ0QXJzdXBuRTtidWxsO2V4cGVjdGF0UmV2ZXJzZUVxdWlsaWJybG9uZ3JpZ3V1YXJkb3duaGFycG9vbnJsRTtwaG1tYXRzbWFsbHNldG1pbnVzO2JveGRyUmFuZztuc3ViZTtlRERvY3N1bGFtYmRzaW1kb3Rjb21wbGV4ZWFscFJpZ2h0RG93blZlY29uaW5zZWN0VXBUZWV5c2NyO1lJY3k7ZXJEb3Q7TGVzc0xlTmNhcm9uO29wZXJwVXBkb3duYXZub3JhckpvcGY7aGtzd2FzdHJhaWdocHNpO2dkb0licHJpbWVOb3RHcmVhdGVyR3JlYXRlcmFncmF2ZXRjYXJvZXF2cGFyTm90RXF1YWxhc3RScmlnTGVmdFJpZ2ZhbGxpbmdkb3RzZXFLYXBwYTtzb2w7VmVyeU5vdEdyZWF0ZXJUcm1TdWNjZWVkWUFjeW52ZGFzaE5lZ2F0aXZlVGhpdm9wZkxsZWZ0YXJyb3c7Z2RvdExlZnRUZWVWZWN0b3I7cHJlY25zYmxhY3N0cmFpZ2h0ZXBzaWxvZnJhYzM0O25lc2l0aGljbmxhcnI7Q3NjZGxjcmluZmluTGVmdEFuZ2xjdXJ2ZWFycm93bGVmdDticHJsZXNzYXBiaWd0cmlhbmdsZWRvd1VhY3V0cmlnaHRhcnJvd2FsZXBQcmVjZWRlc1NsYW50RU1lbGxpSnNlcmxsaFVmcnJjZWl0d2l4Q2FwaXRhc3FzdXA7c2NjbXVsdGltYXBvZHNvbEdyZWF0ZXJTemV0c3JhdW9nb247RmlsbGVkVmVyeVNtYVJvdW5kSW1wbGllcztjdXJyZW47Q29uZGJrYXJvd25hdHVyYWw7ZG90bWludXNPRWxpZ2lmcjtscmNvcnNjc2ltO21vZFRoaW5TcGFjYXBlO2RmcmRvd25kcmRxdWxtaWR2cnRyaTtMb25nbGVmdHJpZ2h0YXJyb0Jlcm5vdWxwcmVjbmVxcUJzY3I7Ym94SERMb3BkZnI7aW9wZlNob3JwcmU7dnNjaW50cHJ0Tm90TmVzdGVkTExlc3NGdWxsRXF1YmN5bnZpbmZuZXNpbTtkaXNpQ2FScmlnaHRhcmNjaXJsYXRlc3J0cmlsdHJpO0VtcHR5VmVyeVNtYWxsU3BsdXNhY2lyTGVzc0xlc3M7VGlsZGVUaWxuZXhpc3RzO2xvbmdsZWZ0cmlnU2hvcnREb3dOZXN0ZWRMZXNzTGVzc05lZ2F0aXZlTWVkaXVtU0VtbGVmdHJpZ2h0c3F1aWdhcnJ1cmNvcnN1cG5FTm90U3VjY2VlZHM7bGVmdGFycm93dGFpdXB1ZXBOb3RSaWdodFRyaWFuZ2xlTEpjUnVsZ3RyZXFsZXNTaG92clJ1bGVEZWxheWVkbndBcnI7amZycmNhcm9uTm90RG9Eb3VibGVSaWdodFRlZTtMYXB1YnJjeWJvY2lyY2xlYXJyb3dyeGNpcmN4b2RvVWdyYXZndmVydmFya2FwbnN1dkJhcjtib3hEcnBhcnNsSGlsYmVydFNwYWxlc2RsdmVMZWZ0QXJyb2lpaURvd25UZWVBTGVmdFZlY3RvT21lZ2FsZGNhO2xlZnRoYXJwb29kaGxlZnRhcnJvd3RhdHdvaGVhZGxlZnRhUmlnaHRUYmxhY2tzcXVhcmV1Z3JhdmVjaXJtaURpZmZuc3Vic2V0O3R3b2hlYWRyaWdodGFybnNob05vdFN1Y2NlZWRzVGlsZGVEWmN5O3VyY29MYW1jb21wO1N1cHNlZXBsdXNMZXNzRnVsY2FwY2N1cGRpbXBzcXN1cE5mcmhrc3dhcm93SW1hY2xlc3NlcWd0cjtTdXA7YmlnY2l0cmxwYXJscnVsbmxlZnRyaU5vdE5lc3RlZExlc3NscGFybHQ7TG93ZXJSaWdodEFHcmVhdGVTaWdtYUdvcGV0dWhhc2hrZ3JlZW5HcmVhdGVyRnVsVXBFcXVpbGlicml1bWJjb2x0Y2lybXNjcnBlTm90R3JlYXRlY3Vkc3F1ZmFwcHJveDt6aGN5dmFyc3Vwc2V0bmVxbGxhcnI7bGFuZ2Ryb3RpbWVzO2xhdGVIb3BmbmxBVXBFdGVscmVscmNvcm5PbWljckFzc2lnbjtsZmlzaHQ7YmxhY2tzbmV4aXN0O2ZvcGZOb3RMZWZ0VHJpYW5nbGVCTG9uZ2xlZnRyaWdjdXJ2ZWFycm93bGVmbWlkZG90cnRyaWx0cm1ucGx1czt1aGFybDtSb3VuZEltcGxpZXJpZ2h0YWZyc2ltO05vdFJldmVyc2VFbGVtZW50d3JlcGFyc2w7cmFjZTtGaGFsZkRvdWJsZUxlZnRzbXQ7bnNxc3VCZXJub3VsbHNlY3Q7S3NjcnZhcnJoZ2FjdXRlO3JlY3Q7Tm90U3FsZWZ0aGFycG9vbmRvd250aGlja3NUaGVjY2VFc05vdFJpZ2h0bGZsb29yQ2lyY2xlTWludXNiZHF1bztJbnZpc2libHJhcnJFb3BmdWxjTGVmdFVwVmVjdG9yQmFtZWF2Y3lEc2NlcmF0cmlhbmdsZXJjdXBkb3R4bEFycmVxc2xhRGVsdGRIYXJEb3RFcXVhcnVsdWhLSmN5bnNob3J0cGFyYWxsZWw7dG9wZmRpdmlkZW9udGlOb3RIdVJpZ2h0RG93blZlY3RvckJhcjtuYXByaXNpbmdkb3RzZXFuYXR1cjtOZWdhdGl2ZVZlcnlUaGluR3JlYXRlclRpRGlmZmVyZW50aWFsbG9uZ2xlZnRVcEFycm93RGF0aWxkV2NpcmM7dmFyc3Vwc2V0c2ltcGxMZWZ0QXJyb3dSaWdodEFycm9Eb3duVGVlQXJtYWNyO0Rvd25MZWZ0VmVjdG9yQkRvdWJsZUxvdHNjU3F1YXJlSW50ZXJzZWN0aW9uO2FjdXRlO25yYXJyO0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhQ2lyY2xlRG93bkxyY3VidGhlbHRpbWVzTGFtYmRhSG9yaXpvbk5vdENvbmdydWVudG9ncmF2YWVsaWp1a1N1cHNFQnVtcGVyaW5nTGVmdERvd25WZWN0b3JCYXJBYWN1dGU7Ym90dG9tY3VybHllZGRvdHNyZGNhO0JhcndEY2F0d29oZWFkbGVmdEludGVyc2VjdGlsbnNUaGlja1NwYWNlb2xhbHZuRTtsc3F1bGVmdHJpZ2h0aGFycG9vbnNsYXJydGlxdWVzdHRoZXJlNHRmTm90SHVtcERvd25IdW1wO3l1bW5vdGluRXF1YXRlcm5pb25MZWZ0eW9wZjtOb3RMZXNzVGlsZGJsazM0O0xjYVRoZXRhaW50cHJ0cmlkb3Q7bGNzdWNjYUNsb3NOb3RTdWJzZVJvdW5kd3I7c2ltZ2xzcXVvO05vdEVsZUNvbGRpYW1vbmRzdmFyc3Vwc2V0bmVxcU5vdFJpZ2h0VHJpYW5nbERvdWJsZVZzdWNjbmFwcE5KY29zbGFzaHV3YW5nbGVsb29wYXJyb3dyaWdodFVuZG9kb1phY3VJc2NyO29vcE9wZW5DdXJseVF1b3RlO2hlcHNpbE5vdEdyZWF0ZXJMZXNFcXVhbFRjeW5zcGFhZ3JhdnJvYW50YXJQb3Bmc2lndXB1cGFyclVncmF2ZXN1cEpmR3JlYXRlckdyZWF0ZXJyZWN6b3BmO01hSWNsRWdmamxpZztOb3REb3VibGVWZXJ0aWNkb3VibGViYXJ3ZU5vdFN1Y2NlZWRzU2xhbm53YXJyb3c7UmFjdXRlZ25zaW07YW5nbXNkYWZTaG9ydERvd25BSW52aXNpYmxlVGltZXNtbnBsdWJyY2lyY2x4b2x0cmlmdXBoYXJwb29ucmlTcXVhcmVJbnRlcnRyaWFuZ2xlbGVmdGVJbnZpc2libGVDb21zdW5nO3ZhcnRyaWFuZ2xlcmljZnJob29rc3FzdXBzZXN1cDM7bGJicmtWZXJ0aWNhbFNDaXJjbGVNaVJldmVyc2VVcEVxdWlsaWJQcmVjZWRlc1RpdXBkb3duZGFsb3NvbDt0b3Bmb1N1cGVyc2V0SW52aXNpYmxlQ29tbWJveFZSO2N1cmx5d2VkZ2VsbW91c3Rib3RMZXNzRnVsbEVmcm93bm5ic2xlc3Nkb3Q7bmxlcVpIY3ljZG90bmFwaWRleGNsO21ERGNpcmM7SW1wTGVmdEFycm93UmlnaHRBcnJvd0xlZnRVcFZlY3RzZnJvd2RvbGxhcjtkZG9MbGVyQlZlcnlUaGlwcmVjY3VybEl1a2N5O2FlbG52bGU7c2V0bWluTGVmdFVwRG93blZlc3NtUnVsZURlTm90Q29uU3Vic2V0RUNlbmNpcnNnZXNkYXN5bXBvbXlpY3lUU0hjeTtPcGVuQ3VybHlEb3VicGl0Y2hmdGhlcmV0aG9ybnN1Y2Nuc2ltZG91c3dhY2hjU3Vwc2V0O0RvdWJsZURvd2RvdHBsdXNyQXNhRGlhY3JpdGljYWxHckxlc3NTbGFudEVxdWFsY2VtcmF0aW87UG9pbmNhckNybG96ZW5nZTtTc0RpYWNyaXRpY2FsR3JhckhhcjtzdHJhaWdodHBoaXJiYXJsb29wYXJyb3dyRG93blJpZ2h0VGVlVmVjU2hvcnRMZWZ0QXJTdXBuTHR2RFNjTGVmdEFycm93QlZlcnRpY2FsTGluZTtndmVydGZhbGxpbmdycGFyZ3Q7dmFyZXBzaWxvbm5ndHJRb2RlbXB0RXNpbWVsO0ZvdXJpZXJ0b2RzQmVybm91Y29weTtuY2V2YW5ncHJvZmFsYXJzcGFkbGdEb3duUmlnaHRWZWN0bnZsdHJpZTtsZWZ4c3FjdXA7ZW1zcDFBbmROb3RFbGVtZXZhcnBoaURhcnI7bmNhcm9uO2RlbHRhVmVydGljYWxUaWxkZTtSaWdodFVwVmVjdG9yWXNjdHBjaGlzcGFkZXN1aXRsb2FuZ3NjdHdpeHQ7UmlnaHRWZWN0b2JhcndlZGdQcmVjZWRla29wUmlnaHRhcnJvdztjdXBicmNhcHNoYXJ0aGV0YTt4b3RpbURvdWJsZUxvbmdMZWZ0Umllc0ltYWdpbmFDb3VudGVyQ2xvY2t3aXNlQ05vbkJyZVJpZ3N1YnN1Yk5vdEh1bW9wbHVzSGlsYmVydEVtcHR5U25MZWZ0cmlnaHRhZWNhclVwQXJyb3dCYXJOb3RMZXNzVGlsZGVVcERvd25EaWZoYXJkY3libGFja3NxdWFyZTtHY3lvZ3JvbWljcm9ucmhhcmFuZ3J0O0tvcGY7RGlhbURvdWJsZURvZG9wZjtFYWN1dGVMZWZ0VXBEb3duVmVjdG9yO29jaXJjO1pjYXJvZGFic29saHN1Yjtwc2lyZHF1bztsZnJTcXVhcmVTdWJsb2Fqc2VyY3k7b2FjdXRlO2N1cmx5RWNhcmhvb2tyaWdodGFyclNob3J0TGVOb3RFcXVhbDtGc2NIQU91bWw7UmlnaHRBcnJvd0Jhck5lZ2F0aXZlTWVkaXVtU3BNaW51c1BsdUd0O2JpZ2NhcE9FbGd0cmRvdDt3cmVhdWN5VXBwZXJSaW5maW50aWVzd253YXI7U2hvcnRSaWdodEFyckVtcHR5VmVyeVNtYWxsU3F1YXJlO3ByZWNuc2lwcmVjbmFwcHJEY2Fyb247YW5nbXNkYWJlcXZhcFByZWNlZGVzU2xhbnRFcXV1cnRyY2Fyb25vZHNvbGRSaWdodFVwRG93U2Npc1ZlcnRpY2FsQmFTYWN1dGVDYXBpdGFsRGlmcmFjNDU7aGFycnduYXBpZDtVb3BmeGhhcnJidW1wRTtuTGVmdHJpZ2hHcmVhdGVyU2xhbnRFcXVjbHVicztTaXVicmdlc2RvdG9jb3BFbWFjcnJBck1vcGY7TGVmdERvd25UZWVWZUxlc3NFcXV0d2lPZGJsYWM7bnNxZ3ZlcnRuZXFxO3Byb3A7RG91YmxlVXBEb3duTGVzc1RpbGRMZWZ0VGVlQXJyZEFybnByZWNsZXNnZXM7YmxhY2t0cmlhbmdsZWxlZnRyaXBsdWhvbXRodEFuZDtsY3ViO0xlZnRyaWdodGFycmxsYUludGVncmFsbm90aW52b3JzbHRpVmVyeVRoaW5Ob3RSaWdodFRyaWFuZ2xlQmFEb3VibGVMb25nTGVmdERpZmZlcmVudGJvcGY7bGRjYUhBUkREb3duTGVmdFJpZ0Rvd25MZWZ0VGVaZXJvV2lkdGhTcGFjZWxuZTtSaWdodFVwRG93blJpZ2h0VXBUZWVWZWN0c3NlaW1hZ2xpblFzY3I7ZGRhZ2dlcjtOZWdhdGl2ZU1lZGl1bVNwYWNlO21hcHN0b2RvR2FXZWRnZTt4Y2lybHRsYXJzdXAxO3huaXNybW91cmFjbGxhcmJwbnNwYXJOb3RUaWxkZUZ1bGxFcXVhbExhcGxhY2V0cm5zdXBlbmV4aXNoc2xhc3ZhcnRyaWFvZGJsYWNibGsxMnJwcG9saW50ZnJhYzEzYm94dmxsc2FxTmVzdGVkR3JlYW5nbWRmaXNodGJzY3JudkhhcnI7bnZhcHN1cG1uc210aGV0YXJubWlkc2hhcnBScmlnaHRhcnJwcmltZXM7b2Fjbmdlc2NvbG9ucmRjYUxvbmdMZWZ0UmlnaHRBcnJvd0VUSDtscmhhcmlnaHRoYXJwT2NoY2lscnRyaWVxdnBhcnNsO0Nsb3NlQ3VybHlEb3VibGVRdWNvcHJvZGdlc0RzdHJvQ29wcm9UaGVyZWZveGxhcnJhYWN1dGVucHJEb3VibGVMZWZ0VGVMZWZ0VGVlQXJyb3c7c3VicGx1SW1hY3JRb3BlbXNwMTRib3h1bHNpZ21hO09wZW5DdXJseURvdU1vcHhkUmlnaHRUZWVWZWN0b3ZiYXBpdGNoZm9PcGVuQ3VybHlEb3VibGVRdW90ZXVwaGFycG9vbmxlZnQ7Tm90TmVzdGVkTGVDY29uaW50bnVtZXJvemFjdXRlO1JpZ2h0RG93blRlZVZlUm91bmRJSlphY3V0ZTtnbmVxO25MZWZ0cmlnaHRhcmJrdHdvaGVhZHJpZ2h0YXJyb2hvb2tyaWdlYWN1TWN5UmlnaHRhcnJvTGNhcm9uO25lYXJyUmlnaHREb3VibGVCcmFja2V0SGlmZmRvd25oYXJwb29ubGVic2VJbXBsaWVzO2xicmtzbGNpcm1pZEN1cENFY3lwcmVjbnNpbWd0cmFycm5MZWZ0cmlnaHRnbkJhY2tzbGFzbG5hTmNhcm9uQ291bnRlckNsb2Nrd2lzbGRxdW87bG93YmFycm9hcmlnaHRzcXVpZ2Fycm93O2ZyYWMyNWJjb252c3VibkVsdHJQYXJsdXJ1aGFyO01lbGxpbnRyZjtzdW5Ob3ROZXN0ZWRMZXNtRERvaW1vTG9uZ2xlZnRhcnJvdztudkRzcXVhcnN1cGxhcnI7Y2lyY2xlYXJyb3dyaU5vdFN1Y2NlZWRzU2xhbnRFcXVhbDtucnRyaW52ckFycjtibGszNHZhcnRyaWFuWmNhcnVwc2k7VHJpbW9kZWxzbWVwYXJzbDthbmdtc2RhaDtsbVVwZG93bnZhcnRoZXRhO2Rvd25kb3duYXJyb3dzO3ZlbGxkakRvdWJsZURvdFJpZ2h0RG93blRldGhrc0hvcml6b250YWxMaW5lZWc7RG93bkxlZnRSaWdodFZlRW1wdHlWZXJ5U21hbGxTcXVhcmVsYXJyYmZpb3JsaExhcGxhY2V0RG91YmxlVXBzdWNOb3RMZWZ0VE5vdEdyZWF0ZXJUaWxOb3RDb25nTm90TkVsZW1lbnQ7cmlzaW5nZG90c2VxO1NxdWFyZVNUc3RaZG90bGVmdHJpZ2h0YXJUaGlja1NwYWNFcHNpbGVzc2J1bXBlcVljaXJjYWdyYWVxY29Eb3VibGVVcEFycm9UcnhjYVJhUmlnaHRBcnJvd0JhU2hvcnRMZWZ0Z2JEb3VibGVDb250b3VySW50ZXBvaW50aXZBcmhlYXJ0c3VOb3RHcmVhdGVyR3JlTGVmdEFycm93UmlnaGFyY3JhUmlnaHRUcmlhbmdsZUVxdWFsO2NhcGJyY3RyaWFuZ2xlO1BhcnRpYWxEbGVmdGFyckRKRmZyWW9wZjt1cmNvcm5ucmFycnBzcmZyaXNpbjtBcHBsc21lcGFyc2xwdW5jZGlhbW9uZDtsYnJrc2xkO2VxdWxvbmdyaWdodGFycm93Ym5vdDtHbG9uZ2xlZk5KY2RDaXJjbGVNaW51RW1wdHlWZUxhcGxhY2V0cmY7Y3N1cDtMSmN5O2xvbmdsZWZ0YXJyb3djZWRpc3ViZWRvdDtsb3BhRG91YmxlTGVmdFRsb3plbmdlTm90TmVzdGVkR3JlYXRUUnZkYW50cmlhbmdsZXJpZ2hMb25nbGVmdHJpZ2h0YXJ2YXJyZWFzdGxlZnRyaWdodHNxdWlnYXJyb2JveGJob29rbGVmdGFycm93O2NpcmZuaW9lbGlzdXBsYXJuYnVtcGVOb3RMZXNzRXF1YVNxdWFyZUludGVyc2VjdFJpZ2h0QXJyb3dMZW1wdHlzZXJhcnJwbDtWZGF4b3RpbWV0YXJneXVjeXRoZXJlZm5vdGluZG9oeXBoZW47U29wZmRyYmthckJzb3Bhck92ZXJCcmFjbGVmdGhhcnBvb25kb3duO0Rvd0FvcGY7cHJvcHFpbnQ7aGFpcnNnRWxibm90TGVmdFVwVGVlVmVudHJpYW5vdGludmI7Z3RyZXFsZXplZXRjdXBzO3N1cHNpbTtVc2NyTG9uZ3JpZ2h0YVBvaW5jYXJlb3I7VXJpVWJyZXZkaWFtcztaY2lzaW5FO2xzaXZmcjtud25ld3NMZXNzR3JiaWdzdG9taWNycHJpbWVzdmVsbGFycnBpc2ludjtEb3VibGVSaWdodEFycm5nZXFlcXVpdkRzb2Z0Y3k7blJpZ2hqc2VyY3lSYW5nYXdjb1VwcGVyUmlnaHRBcm9yaWdvZm5MdDt1ZmlzaGxhbmdWZXJ0aWNhbExpU2NlZGxvb3BhcnJvd3JpbHQ7bnZpbmFjdXRldWJyZXZlO1ZlZVlhY3V0ZWduc2lkd2FuZ2xMY3lPcGVuQ3VybHlEY2FwYmxhY2tzcXVhc3Vwc3VwO2xvemY7TGVmdFVwRG93blJpZ2h0RG91YmxlQnJhY2tldDtyZWFscGF6b3BMZWZ0Rmxvb3JpZ2h0cmlnaHRhcnJvd3NjaGVja21hcmtzaG9ydHBhcmFsbE9kYmxhY05vdFByZWNlZGVzU2xhbnRFcXVhbDtkb3RlcWRvUnJpZ2h0YXJyb2hvYXJyRG90RXF1YWxiYWNrc2ltO2ZyYWM1NkxlZnRWZWNsZWZ0aGFycG9vbmRvd09kYmxUaGVybmJzcHBhcmFsbGVsO01lZGl1cHJhcGJsYWNrbG96TGxlZnRhcnNtc3Bhcjttc3RBYm11bHRuYnVtdmFya2FMZXNzR3JlYWVtcHRpbmN4cmFyQ2NpcmNiZXBza3NFcXVpbGlicml1dUhhcjtwbHVzbWNzdXBlO1RyaXBsZURpbWFGaWxsZWRTbWN1cmFybnRyaWFuZ2xlbGVOb3Q7cmFycnRTSENIZ2ZyO2xvc29sTm90U3VjY2VlZHNTbGFudEVxdWVyRGdpbWVsU3F1YXJlVW5Eb3duYXJyb3c7ZGlhbW9uZGFsY2VtcHRhcmluRXhpc3VwZG93bmFycnN1YmRMZXNzRnVsbEVxdWFsYXdjb25pbnRsb29wYXJyb3dsZWxsQW1hWWNpblJpZ2h0YXJyb3d0cmlwTGVzc1NsYW50RWxoYmxycHByaWdodGxlZnRoYXJwb3djaXJjc3VjY2FwcHJveFVwcGVyTGVmdEFycm93O3JhY3V0ZWVsaW50ZXJCZXJhcnJscDtydGhyYXRpb25hbHM7Ym94ZGxBY2lyYztnb3BmO2p1a2NTdW1mZmlsaVdm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JyB0eXBlPSkAAADvVBQABgAAAPVUFAAHAAAA/FQUAAEAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9zdHJpbmdfY2FjaGUtMC44LjIvc3JjL2F0b20ucnMYVRQAYAAAAAcBAAAfAAAAGFUUAGAAAAAFAQAALwAAAFNvbWVgAAAABAAAAAQAAABhAAAATm9uZXN0YXRpY2lubGluZWR5bmFtaWNBdG9tKCcnIHR5cGU9KQAAAMNVFAAGAAAAyVUUAAcAAADQVRQAAQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3N0cmluZ19jYWNoZS0wLjguMi9zcmMvYXRvbS5yc+xVFABgAAAABwEAAB8AAADsVRQAYAAAAAUBAAAvAAAAe306AGxWFAABAAAAbVYUAAIAAACwVRQAAAAAAFF1YWxOYW1lcHJlZml4AABjAAAACAAAAAgAAABkAAAAbnMAAGUAAAAIAAAACAAAAGYAAABsb2NhbAAAAGcAAAAEAAAABAAAAGgAAABBdHRyaWJ1dGVuYW1lAAAAaQAAABgAAAAIAAAAagAAAHZhbHVlAAAAZwAAAAQAAAAEAAAAWwAAAGlubGluZW93bmVkc2hhcmVkVGVuZHJpbDw+KDogAAAAHVcUAAgAAAAlVxQAAgAAACdXFAACAAAAKQAAAERXFAABAAAAb25lLXRpbWUgaW5pdGlhbGl6YXRpb24gbWF5IG5vdCBiZSBwZXJmb3JtZWQgcmVjdXJzaXZlbHlQVxQAOAAAAE9uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAkFcUACoAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL3J1c3RjLzkwYzU0MTgwNmYyM2ExMjcwMDJkZTViNDAzOGJlNzMxYmExNDU4Y2EvbGlicmFyeS9zdGQvc3JjL3N5bmMvb25jZS5ycwDvVxQATAAAAJUAAAAyAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvbGF6eV9zdGF0aWMtMS40LjAvc3JjL2lubGluZV9sYXp5LnJzAABMWBQAZgAAAB4AAAAQAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvcGFya2luZ19sb3RfY29yZS0wLjguNS9zcmMvcGFya2luZ19sb3QucnMAxFgUAGsAAABTAQAAFwAAAMRYFABrAAAAbgEAABcAAABrAAAACAAAAAQAAABsAAAAbQAAAG4AAAAIAAAABAAAAG8AAABQYXJraW5nIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybS9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3BhcmtpbmdfbG90X2NvcmUtMC44LjUvc3JjL3RocmVhZF9wYXJrZXIvd2FzbS5yc5pZFAByAAAAGgAAAAkAAACaWRQAcgAAAB4AAAAJAAAAmlkUAHIAAAAiAAAACQAAAJpZFAByAAAAJgAAAAkAAACaWRQAcgAAACoAAAAJAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvcGFya2luZ19sb3RfY29yZS0wLjguNS9zcmMvcGFya2luZ19sb3QucnMAXFoUAGsAAAAyAQAADAAAAFVURjhWYWxpZGF0aW9uRmFpbGVkT3V0T2ZCb3VuZHN0ZW5kcmlsOiBvdmVyZmxvdyBpbiBidWZmZXIgYXJpdGhtZXRpYwAAAPdaFAAmAAAAdQAAAAQAAAAEAAAAdgAAAHcAAAB4AAAAdQAAAAQAAAAEAAAAeQAAAHoAAAB7AAAAdQAAAAQAAAAEAAAAfAAAAH0AAAB+AAAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpdQAAAAQAAAAEAAAAfwAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAcFsUAAAAAABsaWJyYXJ5L3N0ZC9zcmMvaW8vYnVmZmVyZWQvbGluZXdyaXRlcnNoaW0ucnMAAADYWxQALQAAAAEBAAApAAAAdW5jYXRlZ29yaXplZCBlcnJvcm90aGVyIGVycm9yb3V0IG9mIG1lbW9yeXVuZXhwZWN0ZWQgZW5kIG9mIGZpbGV1bnN1cHBvcnRlZG9wZXJhdGlvbiBpbnRlcnJ1cHRlZGFyZ3VtZW50IGxpc3QgdG9vIGxvbmdpbnZhbGlkIGZpbGVuYW1ldG9vIG1hbnkgbGlua3Njcm9zcy1kZXZpY2UgbGluayBvciByZW5hbWVkZWFkbG9ja2V4ZWN1dGFibGUgZmlsZSBidXN5cmVzb3VyY2UgYnVzeWZpbGUgdG9vIGxhcmdlZmlsZXN5c3RlbSBxdW90YSBleGNlZWRlZHNlZWsgb24gdW5zZWVrYWJsZSBmaWxlbm8gc3RvcmFnZSBzcGFjZXdyaXRlIHplcm90aW1lZCBvdXRpbnZhbGlkIGRhdGFpbnZhbGlkIGlucHV0IHBhcmFtZXRlcnN0YWxlIG5ldHdvcmsgZmlsZSBoYW5kbGVmaWxlc3lzdGVtIGxvb3Agb3IgaW5kaXJlY3Rpb24gbGltaXQgKGUuZy4gc3ltbGluayBsb29wKXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZGlyZWN0b3J5IG5vdCBlbXB0eWlzIGEgZGlyZWN0b3J5bm90IGEgZGlyZWN0b3J5b3BlcmF0aW9uIHdvdWxkIGJsb2NrZW50aXR5IGFscmVhZHkgZXhpc3RzYnJva2VuIHBpcGVuZXR3b3JrIGRvd25hZGRyZXNzIG5vdCBhdmFpbGFibGVhZGRyZXNzIGluIHVzZW5vdCBjb25uZWN0ZWRjb25uZWN0aW9uIGFib3J0ZWRuZXR3b3JrIHVucmVhY2hhYmxlaG9zdCB1bnJlYWNoYWJsZWNvbm5lY3Rpb24gcmVzZXRjb25uZWN0aW9uIHJlZnVzZWRwZXJtaXNzaW9uIGRlbmllZGVudGl0eSBub3QgZm91bmRFcnJvcmtpbmQAAHUAAAABAAAAAQAAAIAAAABtZXNzYWdlAHUAAAAIAAAABAAAAIEAAABLaW5kT3Njb2RlAAB1AAAABAAAAAQAAACCAAAAgwAAAAwAAAAEAAAAhAAAACAob3MgZXJyb3IgKXBbFAAAAAAAZF8UAAsAAABvXxQAAQAAAGFscmVhZHkgYm9ycm93ZWR1AAAAAAAAAAEAAAAEAAAAbGlicmFyeS9zdGQvc3JjL2lvL3N0ZGlvLnJzAKhfFAAbAAAA6gIAABQAAABmYWlsZWQgcHJpbnRpbmcgdG8gOiAAAADUXxQAEwAAAOdfFAACAAAAqF8UABsAAAD7AwAACQAAAHN0ZG91dAAAhQAAAAwAAAAEAAAAhgAAAIcAAACIAAAAZm9ybWF0dGVyIGVycm9yACxgFAAPAAAAKAAAAIUAAAAMAAAABAAAAIkAAACKAAAAiwAAAGxpYnJhcnkvc3RkL3NyYy9zeW5jL29uY2UucnNgYBQAHAAAANAAAAAUAAAAYGAUABwAAADQAAAAMQAAAGxvY2sgY291bnQgb3ZlcmZsb3cgaW4gcmVlbnRyYW50IG11dGV4bGlicmFyeS9zdGQvc3JjL3N5bmMvcmVtdXRleC5ycwAAAMJgFAAfAAAAkQAAAA4AAABtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAAD0YBQAFQAAAAlhFAANAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzKGEUABgAAABVAQAACQAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnNQYRQAHAAAAEECAAAeAAAAUGEUABwAAABAAgAAHwAAAIMAAAAMAAAABAAAAIwAAAB1AAAACAAAAAQAAACNAAAAjgAAABAAAAAEAAAAjwAAAJAAAAB1AAAACAAAAAQAAACRAAAAkgAAAHUAAAAAAAAAAQAAAJMAAABVbnN1cHBvcnRlZEN1c3RvbWVycm9yAAB1AAAABAAAAAQAAACUAAAAVW5jYXRlZ29yaXplZE90aGVyT3V0T2ZNZW1vcnlVbmV4cGVjdGVkRW9mSW50ZXJydXB0ZWRBcmd1bWVudExpc3RUb29Mb25nSW52YWxpZEZpbGVuYW1lVG9vTWFueUxpbmtzQ3Jvc3Nlc0RldmljZXNEZWFkbG9ja0V4ZWN1dGFibGVGaWxlQnVzeVJlc291cmNlQnVzeUZpbGVUb29MYXJnZUZpbGVzeXN0ZW1RdW90YUV4Y2VlZGVkTm90U2Vla2FibGVTdG9yYWdlRnVsbFdyaXRlWmVyb1RpbWVkT3V0SW52YWxpZERhdGFJbnZhbGlkSW5wdXRTdGFsZU5ldHdvcmtGaWxlSGFuZGxlRmlsZXN5c3RlbUxvb3BSZWFkT25seUZpbGVzeXN0ZW1EaXJlY3RvcnlOb3RFbXB0eUlzQURpcmVjdG9yeU5vdEFEaXJlY3RvcnlXb3VsZEJsb2NrQWxyZWFkeUV4aXN0c0Jyb2tlblBpcGVOZXR3b3JrRG93bkFkZHJOb3RBdmFpbGFibGVBZGRySW5Vc2VOb3RDb25uZWN0ZWRDb25uZWN0aW9uQWJvcnRlZE5ldHdvcmtVbnJlYWNoYWJsZUhvc3RVbnJlYWNoYWJsZUNvbm5lY3Rpb25SZXNldENvbm5lY3Rpb25SZWZ1c2VkUGVybWlzc2lvbkRlbmllZE5vdEZvdW5kb3BlcmF0aW9uIHN1Y2Nlc3NmdWx0aW1lIG5vdCBpbXBsZW1lbnRlZCBvbiB0aGlzIHBsYXRmb3JtM2QUACUAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvdGltZS5ycwBgZBQALwAAAA0AAAAJAAAAY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXigZBQAIAAAAGxpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC9sb2Nrcy9tdXRleC5ycwAAyGQUADYAAAAUAAAACQAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5EGUUADgAAAAQAAAAEQAAABIAAAAQAAAAEAAAABMAAAASAAAADQAAAA4AAAAVAAAADAAAAAsAAAAVAAAAFQAAAA8AAAAOAAAAEwAAACYAAAA4AAAAGQAAABcAAAAMAAAACQAAAAoAAAAQAAAAFwAAABkAAAAOAAAADQAAABQAAAAIAAAAGwAAAA4AAAAQAAAAFgAAABUAAAALAAAAFgAAAA0AAAALAAAAEwAAAPVeFADkXhQA0l4UAMJeFACyXhQAn14UAI1eFACAXhQAcl4UAF1eFABRXhQARl4UADFeFAAcXhQADV4UAP9dFADsXRQAxl0UAI5dFAB1XRQAXl0UAFJdFABJXRQAP10UAC9dFAAYXRQA/1wUAPFcFADkXBQA0FwUAMhcFACtXBQAn1wUAI9cFAB5XBQAZFwUAFlcFABD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CzEEewE2DykBAgIKAzEEAgIHAT0DJAUBCD4BDAI0CQoEAgFfAwIBAQIGAQIBnQEDCBUCOQIBAQEBFgEOBwMFwwgCAwEBFwFRAQIGAQECAQECAQLrAQIEBgIBAhsCVQgCAQECagEBAQIGAQFlAwIEAQUACQEC9QEKAgEBBAGQBAICBAEgCigGAgQIAQkGAgMuDQECAAcBBgEBUhYCBwECAQJ6BgMBAQIBBwEBSAIDAQEBAAILAjQFBQEBAQABBg8ABTsHAAE/BFEBAAIALgIXAAEBAwQFCAgCBx4ElAMANwQyCAEOARYFAQ8ABwERAgcBAgEFZAGgBwABPQQABAAHbQcAYIDwAABBtI7SAAsI8EgQAPxIEAAA3umCgAAEbmFtZQHT6YKAAIoFAANub3cBSmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnN0ZXA6OmgxZmEzOTQwZjUwMGM4NTEyAj5odG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+OjpzdGVwOjpoMDlkZmZiOWFlNjNiOWY1OQODATxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+IGFzIGh0bWw1ZXZlcjo6dG9rZW5pemVyOjppbnRlcmZhY2U6OlRva2VuU2luaz46OnByb2Nlc3NfdG9rZW46OmhhZjRkMmUxYjlhZDNiMWY1BCdjb3JlOjpzZXJpYWxpemVfbm9kZTo6aDA4MGIyYWJiN2JmYzU0NjIFSGNvcmU6Om51bTo6Zmx0MmRlYzo6c3RyYXRlZ3k6OmRyYWdvbjo6Zm9ybWF0X3Nob3J0ZXN0OjpoZjUxODAxMGQ1NmUxNDM2YQY9aHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6ZW5kOjpoZmFlYWFiNjkzYmE3Y2NlZAdFY29yZTo6bnVtOjpmbHQyZGVjOjpzdHJhdGVneTo6ZHJhZ29uOjpmb3JtYXRfZXhhY3Q6Omg2ZTRiMGY5OGE3ZDFjN2RlCFVodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjphZG9wdGlvbl9hZ2VuY3k6OmhhYWM2ZjY2OGQ2ZjljNzk3CTpkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjptYWxsb2M6OmgyMWNkMDgyMzk2NTIzZDkyCjR0ZW5kcmlsOjpzdHJlYW06OlRlbmRyaWxTaW5rOjpvbmU6OmhjOWUyNzkyMGNiZjkzNjUwC4QCYWxsb2M6OmNvbGxlY3Rpb25zOjpidHJlZTo6bm9kZTo6SGFuZGxlPGFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6Om5vZGU6Ok5vZGVSZWY8YWxsb2M6OmNvbGxlY3Rpb25zOjpidHJlZTo6bm9kZTo6bWFya2VyOjpNdXQsSyxWLGFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6Om5vZGU6Om1hcmtlcjo6TGVhZj4sYWxsb2M6OmNvbGxlY3Rpb25zOjpidHJlZTo6bm9kZTo6bWFya2VyOjpFZGdlPjo6aW5zZXJ0X3JlY3Vyc2luZzo6aDVjNjMzMDY4ZDg1ODA2OGYMS2NvcmU6Om51bTo6Zmx0MmRlYzo6c3RyYXRlZ3k6OmdyaXN1Ojpmb3JtYXRfc2hvcnRlc3Rfb3B0OjpoMzJhMTZlYmE4ODcyMjFhZQ1JaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpzdGVwOjpoYjJiYzJiNzllNjk1MmI1Mg4wY29yZTo6c2xpY2U6OnNvcnQ6Om1lcmdlX3NvcnQ6OmhjZTQ2NDZmNDc3M2FiOWU0D0BoYXNoYnJvd246OnJhdzo6UmF3VGFibGU8VCxBPjo6cmVzZXJ2ZV9yZWhhc2g6Omg5MWNhOTUzMDdmZjUxZmRiEEpodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6ZGF0YTo6ZG9jdHlwZV9lcnJvcl9hbmRfcXVpcmtzOjpoZDRlMDI2YTExMmQ1ZmFkYhFCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6OnJjZG9tOjpOb2RlRGF0YT46Omg2YjZiYWU1NjUxMjUwN2E5ElFodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6OmZpbmlzaF9uYW1lZDo6aGE2YjZhN2EyYzRiOTMwYmITMGNvcmU6OnNsaWNlOjpzb3J0OjptZXJnZV9zb3J0OjpoOTA5NjllODc3ZDQzYmZmYxREbWFya3VwNWV2ZXI6OnV0aWw6OmJ1ZmZlcl9xdWV1ZTo6QnVmZmVyUXVldWU6OmVhdDo6aGQ5NTI4ODY5Y2VjNzQxNTEVazxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208U3RhdGljPiBhcyBjb3JlOjpjb252ZXJ0OjpGcm9tPGFsbG9jOjpib3Jyb3c6OkNvdzxzdHI+Pj46OmZyb206Omg5NjljYTEzMjE2ZmNhZjU3FltodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjphZGp1c3Rfc3ZnX2F0dHJpYnV0ZXM6Omg1ZjQyNTkwZGQ2NWYxZDljFzdjb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk11dDo6Y2FsbF9tdXQ6Omg2OTNkNGFhZjVlMGU1MDVkGDdjb3JlOjpyY2RvbTo6YXBwZW5kX3RvX2V4aXN0aW5nX3RleHQ6OmgwNzQ1ZDE0YWU1MzAzZjQ3GTFjb3JlOjpzdHI6OnNsaWNlX2Vycm9yX2ZhaWxfcnQ6OmgyNzEyOTVjMGY3ODA3YzFmGkdtYXJrdXA1ZXZlcjo6aW50ZXJmYWNlOjp0cmVlX2J1aWxkZXI6OmNyZWF0ZV9lbGVtZW50OjpoY2NmZjI2ZjRmZTBlNjRjMBs+cGFya2luZ19sb3Q6OnJhd19tdXRleDo6UmF3TXV0ZXg6OmxvY2tfc2xvdzo6aDkyYjI3NmRiNTg3ODI2MGYcUHRlbmRyaWw6OnRlbmRyaWw6OlRlbmRyaWw8RixBPjo6cHVzaF9ieXRlc193aXRob3V0X3ZhbGlkYXRpbmc6OmhmZWMzMGMyYTY3OTg0ZTE0HVB0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPEYsQT46OnB1c2hfYnl0ZXNfd2l0aG91dF92YWxpZGF0aW5nOjpoZmVjMzBjMmE2Nzk4NGUxNB5QdGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDxGLEE+OjpwdXNoX2J5dGVzX3dpdGhvdXRfdmFsaWRhdGluZzo6aDk2YjQxYzEwNDAyM2ZhYjQfVGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46Omluc2VydF9lbGVtZW50OjpoZDQ1ZjAwM2UyMTY0MTEyMSBXaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Zm9yZWlnbl9zdGFydF90YWc6OmgxZDkzMzUxMjZhNjhjNmJiIV1odG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojpwcm9jZXNzX2VuZF90YWdfaW5fYm9keTo6aDAyMDRhMmIwMDljYmU4NTgiOGRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6Omg0ZWQ4M2U5M2JkMDc0NDIwIypwaGY6Om1hcDo6TWFwPEssVj46OmdldDo6aGE4NWYyMWY2ZmNlYjlhYWMkQWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0YWdfc2V0czo6c3BlY2lhbF90YWc6OmgzNDFmOWFmNTc3MDU5NjhiJThjb3JlOjpudW06OmJpZ251bTo6QmlnMzJ4NDA6Om11bF9wb3cyOjpoZmQ0MTVhMzY3ZDIxNjEzNCZKaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6ZmluaXNoX2F0dHJpYnV0ZTo6aGJiODYzYjcyYTUzM2ZkMmInYjxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBhbGxvYzo6dmVjOjpzcGVjX2V4dGVuZDo6U3BlY0V4dGVuZDxULEk+Pjo6c3BlY19leHRlbmQ6Omg0M2FkOTZhZWE4N2VjM2MxKEhjb3JlOjpudW06OmZsdDJkZWM6OnN0cmF0ZWd5OjpncmlzdTo6Zm9ybWF0X2V4YWN0X29wdDo6aGVlYzYzMWMyNTUzNGZjZTApcDxjb3JlOjpyY2RvbTo6UmNEb20gYXMgbWFya3VwNWV2ZXI6OmludGVyZmFjZTo6dHJlZV9idWlsZGVyOjpUcmVlU2luaz46OmFwcGVuZF9iZWZvcmVfc2libGluZzo6aDllMGMwOTQxNDJiZDA0NzcqLGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWQ6OmhjODY3MGEwOWIyNmU2MjE3KzNjb3JlOjpzdHI6OmNvdW50Ojpkb19jb3VudF9jaGFyczo6aGI0ZTNlNDFjMDZlNjMxMWIsMTxzdHIgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGEzYTAxNjQzZDExNDU0OTItXWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmhhbmRsZV9taXNuZXN0ZWRfYV90YWdzOjpoMTRlNmI1NzkxYzlkYmExMS5QbWFya3VwNWV2ZXI6OnV0aWw6OmJ1ZmZlcl9xdWV1ZTo6QnVmZmVyUXVldWU6OnBvcF9leGNlcHRfZnJvbTo6aDM4ZjliYzc2MDJhYWQ1MjEvSmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmVtaXRfY3VycmVudF90YWc6Omg5ZmZmMjk4ZjYxYTFiYjQ5MA1fX3JkbF9yZWFsbG9jMVxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpyZWNvbnN0cnVjdF9mb3JtYXR0aW5nOjpoZjk3MGZmMWIwOWZhZTllMzJRPGh0bWw1ZXZlcjo6dG9rZW5pemVyOjpzdGF0ZXM6OlN0YXRlIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhjZmVmZjI5NDFhODVlMWMyM0Jjb3JlOjpudW06OmZsdDJkZWM6OnN0cmF0ZWd5OjpkcmFnb246Om11bF9wb3cxMDo6aDZjOTVhOGZlZDk0MTM0NWI0QmNvcmU6OmZtdDo6ZmxvYXQ6OmZsb2F0X3RvX2RlY2ltYWxfY29tbW9uX2V4YWN0OjpoYjIzNTBiNzMzNTQ0Mjg0NDVIPGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg2ZmVmNjQxMjEyZWYwZjc0NlZodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpuZXdfZm9yX2ZyYWdtZW50OjpoNTY0NGExZDAwMDFkMzk1Mzc6Y29yZTo6bnVtOjpiaWdudW06OkJpZzMyeDQwOjptdWxfZGlnaXRzOjpoMjhiOTVlMjBjMjhmZDg3ODg2c2VyZGVfanNvbjo6c2VyOjpmb3JtYXRfZXNjYXBlZF9zdHI6OmgzOTQxYjkxYjBkNWE2M2M0OTVjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjpoNGU5ZDY3YWVjOGQxMTJlZjq6AWFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6OnNlYXJjaDo6PGltcGwgYWxsb2M6OmNvbGxlY3Rpb25zOjpidHJlZTo6bm9kZTo6Tm9kZVJlZjxCb3Jyb3dUeXBlLEssVixhbGxvYzo6Y29sbGVjdGlvbnM6OmJ0cmVlOjpub2RlOjptYXJrZXI6OkxlYWZPckludGVybmFsPj46OnNlYXJjaF90cmVlOjpoZDVkNDE1M2E1MTUyOWJmMjtlaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6YXBwcm9wcmlhdGVfcGxhY2VfZm9yX2luc2VydGlvbjo6aDYzY2I0NjU3OTBhMWVmMGM8MWNvcmU6OnN0cjo6Y29udmVydHM6OmZyb21fdXRmODo6aGU5NzgyZjlkNDZhZTJlYTY9MmNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbW1vdmU6OmhkYTczNTk2NjZiMTk5YjYyPkpodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+Ojpwcm9jZXNzX2NoYXJfcmVmOjpoZTU2MTQzNmY0ZTdiNzVmOD9UaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y2xvc2VfdGhlX2NlbGw6OmgxYjhmZmFkZGUxM2FlOTIxQGNodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpjcmVhdGVfZm9ybWF0dGluZ19lbGVtZW50X2Zvcjo6aGE1MDE4ODAxMzUxNzM2MmJBXGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnByb2Nlc3NfY2hhcnNfaW5fdGFibGU6Omg5Y2Q5ODUxMmYyMmExNDhlQlRodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppc190eXBlX2hpZGRlbjo6aGY0ZmVlNzlmMDdlMWVkNjFDaDxjb3JlOjppdGVyOjphZGFwdGVyczo6bWFwOjpNYXA8SSxGPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46OmZvbGQ6Omg4Njc1NWM1ZjY4N2Y4NTFhREVjb3JlOjpmbXQ6OmZsb2F0OjpmbG9hdF90b19kZWNpbWFsX2NvbW1vbl9zaG9ydGVzdDo6aGE1MDNkMjcxNGM5MmJlYmRFPmNvcmU6OmZtdDo6Rm9ybWF0dGVyOjp3cml0ZV9mb3JtYXR0ZWRfcGFydHM6Omg3NDExYmYwMzZmN2U5ZDczRlg8YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmhhYjdkZGZkMWJkZjU3YTdmRyNjb3JlOjpmbXQ6OndyaXRlOjpoZWMxNTg4YTJmZWNiMzY3NkgvY29yZTo6c2xpY2U6Om1lbWNocjo6bWVtcmNocjo6aGEyN2FjMDgzZTk2YzU2OTlJWmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnJlc2V0X2luc2VydGlvbl9tb2RlOjpoNGZiYTNhZTQxZWQxOWVjYUpAcGFya2luZ19sb3Q6OnJhd19tdXRleDo6UmF3TXV0ZXg6OnVubG9ja19zbG93OjpoY2MwZWJiNmE4NmJkNTg5MUs8Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZF9mb3JtYXR0ZWRfcGFydHM6OmhlYzk2ZTdiYmUyMTExNTNkTEF0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPEYsQT46OnBvcF9mcm9udF9jaGFyOjpoZWNmZmJmMDQwOTY5YTMyZE1IPGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmgxNzFkOTM0ZmQyZjdiYzhlTlRjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8W2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0eXBlczo6VG9rZW5dPjo6aDU3OTZjODdmZWE5M2EyNjFPbWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnVuZXhwZWN0ZWRfc3RhcnRfdGFnX2luX2ZvcmVpZ25fY29udGVudDo6aDNhYjdhZWNiZGFmZTE3ZjRQYzxhbGxvYzo6dmVjOjpWZWM8VD4gYXMgYWxsb2M6OnZlYzo6c3BlY19mcm9tX2l0ZXI6OlNwZWNGcm9tSXRlcjxULEk+Pjo6ZnJvbV9pdGVyOjpoODlhNGRmMTNlNGMzZGM4NlFvPGNvcmU6OnJjZG9tOjpSY0RvbSBhcyBtYXJrdXA1ZXZlcjo6aW50ZXJmYWNlOjp0cmVlX2J1aWxkZXI6OlRyZWVTaW5rPjo6YWRkX2F0dHJzX2lmX21pc3Npbmc6OmhiOWQ2MDQ4MTI2NDljN2QxUkFkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpkaXNwb3NlX2NodW5rOjpoOTFhZmE5ODI4ZDU0NWNkZFNBcGFya2luZ19sb3RfY29yZTo6cGFya2luZ19sb3Q6OlRocmVhZERhdGE6Om5ldzo6aDYwYTU3YjE2ZjM4NDEyZGNURjxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aGQzMjBlMzkyZmMyZWRkNjhVRjxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDYzNWFlNWY1NzgzMzdjYWVWUmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dHlwZXM6OlRva2VuPjo6aDgzYjg3MDNlYjI1YmVjOTNXTmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxtYXJrdXA1ZXZlcjo6aW50ZXJmYWNlOjpBdHRyaWJ1dGU+OjpoZDg1OWQ3NzE5YWI1NWUwMlhUaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5fc2NvcGVfbmFtZWQ6OmgyZTMxNWY4OTllYzhmYjI2WTRodG1sNWV2ZXI6OnRva2VuaXplcjo6b3B0aW9uX3B1c2g6OmgwNWNlYjI2ZDNhNTZkOTA0WjtoYXNoYnJvd246Om1hcDo6SGFzaE1hcDxLLFYsUyxBPjo6aW5zZXJ0OjpoMTI1NjNlNjg4MWE4ZWQxM1tuPGFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6Om1hcDo6SXRlcjxLLFY+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6bmV4dDo6aGQxYzYxZDYyMjc0MThmMTlcTDxzdGQ6OmlvOjpzdGRpbzo6U3Rkb3V0TG9jayBhcyBzdGQ6OmlvOjpXcml0ZT46OndyaXRlX2FsbDo6aDQ4YzdmMjcxM2Q2YTUxNjhdYTxjb3JlOjpyY2RvbTo6UmNEb20gYXMgbWFya3VwNWV2ZXI6OmludGVyZmFjZTo6dHJlZV9idWlsZGVyOjpUcmVlU2luaz46OmFwcGVuZDo6aDgwNDNkMjYyYjNjNTE0ZjNeMGNvcmU6Omhhc2g6Okhhc2hlcjo6d3JpdGVfdTMyOjpoYjk0MjVhMDRmOWJlOTA5ZV9faHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6YWRqdXN0X2ZvcmVpZ25fYXR0cmlidXRlczo6aGE1ZWI1ZTNiMDg3NDg4NWVgP2NvcmU6OnNsaWNlOjpzb3J0OjppbnNlcnRpb25fc29ydF9zaGlmdF9sZWZ0OjpoMTg1YWVkYmY2YTQ4ODM3Y2E5c3RyaW5nX2NhY2hlOjpkeW5hbWljX3NldDo6U2V0OjppbnNlcnQ6OmhiM2M0OTA0MDE2MjE4YjI4YjNhbGxvYzo6Zm10Ojpmb3JtYXQ6OmZvcm1hdF9pbm5lcjo6aGVhZWMzOGJjZDcyZmMzM2FjbDxjb3JlOjpyY2RvbTo6UmNEb20gYXMgbWFya3VwNWV2ZXI6OmludGVyZmFjZTo6dHJlZV9idWlsZGVyOjpUcmVlU2luaz46OnJlcGFyZW50X2NoaWxkcmVuOjpoZjk3NTk2YTQ2MDA4ZDhhOWRVY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGh0bWw1ZXZlcjo6dG9rZW5pemVyOjppbnRlcmZhY2U6OkRvY3R5cGU+OjpoYTk2ZjFmZDE1MzgzZWFkZGVCc3RkOjppbzo6c3RkaW86OnByaW50X3RvX2J1ZmZlcl9pZl9jYXB0dXJlX3VzZWQ6OmgxMTM1NDQ3ZjViN2Y2OTExZlw8c3RkOjpjb2xsZWN0aW9uczo6aGFzaDo6bWFwOjpEZWZhdWx0SGFzaGVyIGFzIGNvcmU6Omhhc2g6Okhhc2hlcj46OndyaXRlOjpoYTA0NzdhYTZmZDUyYTg5YWdUaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5fc2NvcGVfbmFtZWQ6OmgzNTFhYjY1OTVlNTU2MWRlaFRodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppbl9zY29wZV9uYW1lZDo6aDgzMjgyZTdmYmZlMmIxOWZpSWh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OnBvcF9leGNlcHRfZnJvbTo6aGJkZjE1MmJiMWQ0ZWQwNDNqQHBhcmtpbmdfbG90X2NvcmU6OnBhcmtpbmdfbG90OjpIYXNoVGFibGU6Om5ldzo6aDYzY2I3MTgzNzBhZWIwYWZrNGNvcmU6Omhhc2g6OkJ1aWxkSGFzaGVyOjpoYXNoX29uZTo6aDY4ZTAyN2I0MDZmMTViYmZsOGhhc2hicm93bjo6cmF3OjpSYXdUYWJsZTxULEE+OjppbnNlcnQ6OmhkMGJkNjY5YjYwYjgxODZhbTZoYXNoYnJvd246OnJhdzo6UmF3VGFibGU8VCxBPjo6ZmluZDo6aGRhNGQ0ZTY3MGMxYzVlYjBuaDxhbGxvYzo6c3RyaW5nOjpTdHJpbmcgYXMgY29yZTo6aXRlcjo6dHJhaXRzOjpjb2xsZWN0OjpGcm9tSXRlcmF0b3I8Y2hhcj4+Ojpmcm9tX2l0ZXI6OmgwODUyMmYwZmYxMWI5MWVlb2g8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6Y29sbGVjdDo6RnJvbUl0ZXJhdG9yPGNoYXI+Pjo6ZnJvbV9pdGVyOjpoNWEzOTBlOTZiYmZlMWJjNXBhaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Z2VuZXJhdGVfaW1wbGllZF9lbmRfZXhjZXB0OjpoMjY0NTU1YWY0MjVjMDk1ZnFJc3RyaW5nX2NhY2hlOjphdG9tOjpBdG9tPFN0YXRpYz46OmVxX2lnbm9yZV9hc2NpaV9jYXNlOjpoYzNhNzdkZTIzZDc4ODI5M3JDdGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDxGLEE+Ojp1bnNhZmVfcG9wX2Zyb250OjpoNjQ0NzY2MTU3NjU2MzRjY3NDdGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDxGLEE+Ojp1bnNhZmVfcG9wX2Zyb250OjpoOWNlOWNiZDFjNzZmZWY1ZXQ3Y29yZTo6cGFuaWNraW5nOjphc3NlcnRfZmFpbGVkX2lubmVyOjpoMmFhNWU4ZTdmZTIwMWM2ZXVQaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6dW5leHBlY3RlZDo6aGY1OGZjMDJmMzI1ZmRjNDJ2UGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnVuZXhwZWN0ZWQ6OmhiYjA0MjAzY2Y2OWRjYzk1d1VodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpleHBlY3RfdG9fY2xvc2U6OmgxYjkzMGM4MmQyNWIxOWYweDBkbG1hbGxvYzo6RGxtYWxsb2M8QT46Om1hbGxvYzo6aDc4ZDRiNGQ4YzEzYWJiNDJ5T2h0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmdldF9wcmVwcm9jZXNzZWRfY2hhcjo6aGUzNDlmN2M4ZmU1ZWQyOTJ6STwmc3RkOjppbzo6c3RkaW86OlN0ZG91dCBhcyBzdGQ6OmlvOjpXcml0ZT46OndyaXRlX2ZtdDo6aDZmZjY5ODMyNDkxOTQ1ZDB7WGNvcmU6Om51bTo6Zmx0MmRlYzo6c3RyYXRlZ3k6OmdyaXN1Ojpmb3JtYXRfZXhhY3Rfb3B0Ojpwb3NzaWJseV9yb3VuZDo6aGUxNWFlYjMyNTdhMjNjMDV8MjxjaGFyIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgyNjVmYzI1OWJjZmQ2ZWJmfVNodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6OmZpbmlzaF9udW1lcmljOjpoZTEwYjU2NjczYTc2MjU3Zn5TPGNvcmU6OmZtdDo6YnVpbGRlcnM6OlBhZEFkYXB0ZXIgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDM0M2ExNzNhODBhZmExMjl/RTxzdGQ6OmlvOjplcnJvcjo6RXJyb3IgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoNDJjODEzMDdjODEzYTYxY4ABSmFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6Om1hcDo6QlRyZWVNYXA8SyxWLEE+OjppbnNlcnQ6OmhjM2ZkNWI5MjljYTZmNzBkgQE4Y29yZTo6bnVtOjpmbHQyZGVjOjpkaWdpdHNfdG9fZGVjX3N0cjo6aGU0MmM3Y2EyYjhjMzE0NziCAVJjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8KG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OlF1YWxOYW1lLCgpKT46Omg4YzcyNDQzZjVhODhkNDMzgwFNY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OlF1YWxOYW1lPjo6aGEwMzI3YTEzNzY3NTUwNziEAU1jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8bWFya3VwNWV2ZXI6OmludGVyZmFjZTo6UXVhbE5hbWU+OjpoMTc3ZDM4MzUyNTgxMWJhZIUBI2NvcmU6OnBhcnNlX2ZyYWc6OmhkOGFhMWVhZGIxNzBlNjg0hgFWaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjp1bmNvbnN1bWVfbnVtZXJpYzo6aDA2YjZkM2I3YmQzYWI2MTWHAVFjb3JlOjpzbGljZTo6Y21wOjo8aW1wbCBjb3JlOjpjbXA6OlBhcnRpYWxFcTxbQl0+IGZvciBbQV0+OjplcTo6aGY5ZWY1ODc5ZGIzZjA2NGOIATJjb3JlOjp1bmljb2RlOjpwcmludGFibGU6OmNoZWNrOjpoZmJmY2VkMjY4MmM0YjlhNIkBZ3N0ZDo6aW86OmVycm9yOjo8aW1wbCBjb3JlOjpmbXQ6OkRlYnVnIGZvciBzdGQ6OmlvOjplcnJvcjo6cmVwcl91bnBhY2tlZDo6UmVwcj46OmZtdDo6aDY4YjU3ODJiMGVlMTdkNWGKATA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGU1MjcyNDdlZjk0OGRkMDmLATA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGU5MjlhYjM0OWQxNjE0ZTWMAUdjb3JlOjp1bmljb2RlOjp1bmljb2RlX2RhdGE6OmdyYXBoZW1lX2V4dGVuZDo6bG9va3VwOjpoNTUyNTgxZmE5ZDI1ZDIyOI0BPWh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46Om5ldzo6aDY4MDczNGY3OWZlYzc1ZWWOATpjb3JlOjpmbXQ6OmJ1aWxkZXJzOjpEZWJ1Z1N0cnVjdDo6ZmllbGQ6OmgyMzM1NDI0MTM4YzUwNDVkjwE9aHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6ZWF0OjpoNGEzMjFlYTgxMzRlMWVhNJABVGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmNoZWNrX2JvZHlfZW5kOjpoYWFmNmM5NjU3NDcxYjU5OJEBL2NvcmU6OmZtdDo6V3JpdGU6OndyaXRlX2NoYXI6OmhhNTExODMzYTJkYTNlMmU3kgFnaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y2xlYXJfYWN0aXZlX2Zvcm1hdHRpbmdfdG9fbWFya2VyOjpoYzk5NGNhMWU4ZmUxYzM0M5MBaGNvcmU6Om9wczo6ZnVuY3Rpb246OmltcGxzOjo8aW1wbCBjb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk11dDxBPiBmb3IgJm11dCBGPjo6Y2FsbF9tdXQ6OmhhNjU4ZjAwYWM3ODYyYzg5lAE7PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfY2hhcjo6aDQ3MTQ2OTM5M2QxMWIwNTeVATs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoZGVlYzA2YTA2MWNhZDU3NpYBNGh0bWw1ZXZlcjo6ZHJpdmVyOjpwYXJzZV9kb2N1bWVudDo6aGIzZTZkODY0MTk1ODZiY2KXAR5jb3JlOjpwYXJzZTo6aDkyMGE2MDY3M2E3ODlhYzSYAUo8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoZDY3YzMyNWM1ZTQyYmYyZZkBLmFsbG9jOjpzdHJpbmc6OlN0cmluZzo6cHVzaDo6aDgyMzliNzU5YzE2NzdmMGWaAVVodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojpwb3BfdW50aWxfbmFtZWQ6OmhlZWU3Zjg2MmVmNjE1MzE5mwExY29tcGlsZXJfYnVpbHRpbnM6Om1lbTo6bWVtY3B5OjpoY2JiOTljZTc5NTdmOGYyOZwBM3N0ZDo6c3lzOjp3YXNtOjpvbmNlOjpPbmNlOjpjYWxsOjpoMzM5YTUwOGY5YjkxN2QwZZ0BL2NvcmU6OmZtdDo6bnVtOjppbXA6OmZtdF91NjQ6Omg0ZWZkZmUyZTI5MTBjOGJhngEKcGFyc2VfZnJhZ58BPmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjphbnlfbm90X3doaXRlc3BhY2U6OmgxZTk2ZjQxNmE3NjAwN2RjoAFGY29yZTo6Zm10OjpudW06OjxpbXBsIGNvcmU6OmZtdDo6RGVidWcgZm9yIHU4Pjo6Zm10OjpoNDBhYTg5NGJjMjM2YjQxZKEBR2NvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6OkRlYnVnIGZvciB1NjQ+OjpmbXQ6OmhjYTg3YmRhZmRmYzRmMDc3ogE2Y29yZTo6c2xpY2U6Om1lbWNocjo6bWVtY2hyX2FsaWduZWQ6Omg5NmFkNzZjZmUxYjI4ZDBmowFHY29yZTo6Zm10OjpudW06OjxpbXBsIGNvcmU6OmZtdDo6RGVidWcgZm9yIHUzMj46OmZtdDo6aDAwNGViZjA2YmMwODhjMDekAUVtYXJrdXA1ZXZlcjo6dXRpbDo6YnVmZmVyX3F1ZXVlOjpCdWZmZXJRdWV1ZTo6bmV4dDo6aGIxYWZjZmEyYTQxMjRkOTmlAUNodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+OjplbWl0X2NoYXI6Omg1ODJhNzNiZGNjNDMwMjZmpgE0Y29yZTo6cmNkb206OmdldF9wYXJlbnRfYW5kX2luZGV4OjpoMmY0MTU5MjQ4MWExMWNlNqcBRmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OnVubGlua19sYXJnZV9jaHVuazo6aGE5ZjI5N2ExMzNhZTBhMTmoASlzdGQ6OmlvOjpzdGRpbzo6X3ByaW50OjpoZTZlZGE1ZjEwZGQwMDlkNakBPWh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OnJ1bjo6aDA3ZWU2MDJhOTY1ODNkM2aqAVI8bWFya3VwNWV2ZXI6OmludGVyZmFjZTo6RXhwYW5kZWROYW1lIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg2MjRjYjA0OTFhZDkwZWE3qwE5Y29yZTo6Zm10OjpidWlsZGVyczo6RGVidWdUdXBsZTo6ZmllbGQ6OmgxNDFhODkyNjJjMTVlZjJlrAE7PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfY2hhcjo6aGY3MWIyMDI3NjViM2M5MjStAUZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjppbnNlcnRfbGFyZ2VfY2h1bms6Omg0ZDAzNGUxNGIyYTQ4MDJmrgEvY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfY2hhcjo6aDcwMDY1NTE1MTdjNTAwYTmvAS9jb3JlOjpmbXQ6OldyaXRlOjp3cml0ZV9jaGFyOjpoYThlZTY4YTM1OTkyMTUxNbABRW1hcmt1cDVldmVyOjp1dGlsOjpidWZmZXJfcXVldWU6OkJ1ZmZlclF1ZXVlOjpwZWVrOjpoMjBmMjViNjYwOWI0MDcwNLEBQmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0YWdfc2V0czo6YnV0dG9uX3Njb3BlOjpoMDI5MGY1NDMyMjU4MTgyNrIBS21hcmt1cDVldmVyOjp1dGlsOjpidWZmZXJfcXVldWU6OkJ1ZmZlclF1ZXVlOjpwdXNoX2Zyb250OjpoYmYzNDNjZWNlMGRlNDBlYbMBS2RsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OnJlbGVhc2VfdW51c2VkX3NlZ21lbnRzOjpoMTFkZjgyNDExNWM4ZmEwMLQBOWNvcmU6OmZtdDo6YnVpbGRlcnM6OkRlYnVnSW5uZXI6OmVudHJ5OjpoYTY5N2MxMzdlMzA5ZmM3YrUBNDxjaGFyIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGM5NTZiZTc1OGI5Y2FkZDm2AUw8c2VyZGVfanNvbjo6ZXJyb3I6OkVycm9yQ29kZSBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6Omg5MWY5MDZjMDQ2NTI0OWM5twFKbWFya3VwNWV2ZXI6OnV0aWw6OmJ1ZmZlcl9xdWV1ZTo6QnVmZmVyUXVldWU6OnB1c2hfYmFjazo6aGNkNTliMmNiNmI5MDRiOWK4AUVodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6Omxpc3RfaXRlbV9zY29wZTo6aGI3ODYwZDBmZDEwMmE0N2G5AWZodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojp0b2tlbml6ZXJfc3RhdGVfZm9yX2NvbnRleHRfZWxlbTo6aDU5ZTU3Njk0NzU5MDEwYze6ATJjb3JlOjpyY2RvbTo6cmVtb3ZlX2Zyb21fcGFyZW50OjpoMGQwMDI4ZGMxMmI1ZWNjZbsBNGh0bWw1ZXZlcjo6ZHJpdmVyOjpwYXJzZV9mcmFnbWVudDo6aDkwZjBhNDcyMTc1NWQ4ODS8AUpodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OnRob3JvdWdoX2ltcGxpZWRfZW5kOjpoMGM3Y2IwNzgxMDFmN2U5Yb0BU2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmVudGVyX2ZvcmVpZ246Omg2ZjcwZjFiYjQ2ZGMyNjY4vgFEaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6Y3JlYXRlX3RhZzo6aGM3OGNjNzRhMmVhY2Q0YzG/AT9jb3JlOjpzbGljZTo6c29ydDo6aW5zZXJ0aW9uX3NvcnRfc2hpZnRfbGVmdDo6aGJiYzkzMTk1Y2Y0NWUwNjbAAUVwYXJraW5nX2xvdF9jb3JlOjp3b3JkX2xvY2s6OldvcmRMb2NrOjp1bmxvY2tfc2xvdzo6aDk5ZmE5ODQ5OGYzYWVlODjBATs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoMTI2YjNlNDk3OTkxYjFhMsIBXmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmFkanVzdF9tYXRobWxfYXR0cmlidXRlczo6aGJiZDJlMzhhZTVhMjliMDjDAUpodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+Ojpjb25zdW1lX2NoYXJfcmVmOjpoZmYwODI0YTQ5OTAzM2I5Y8QBSmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmNyZWF0ZV9hdHRyaWJ1dGU6Omg5NTMwMzAxMDc5MTE2NjlhxQFFaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6ZGlzY2FyZF90YWc6Omg2MzRkZDBjZWExMjgwZTU1xgEvY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfY2hhcjo6aDQwY2U3YjFjYmRhYTlkZGXHAVg8YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg1ZDUwMzhiMGY3MjRmOWVhyAFhaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y2hlY2tfYm9keV9lbmQ6OmJvZHlfZW5kX29rOjpoMDMyNTY1NGMwY2U5YzdmYskBOWNvcmU6OnVuaWNvZGU6OnByaW50YWJsZTo6aXNfcHJpbnRhYmxlOjpoNTMwZTk2YzI4Y2E2Yjg2McoBMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYmI4OTcyMWJkNGM0OTMxNMsBTmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmVtaXRfY3VycmVudF9kb2N0eXBlOjpoNmI4ODAzNTZjMWU0MDhiOMwBRjxzZXJkZV9qc29uOjplcnJvcjo6RXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDY3MjFkYTE4NTg1YmQ4ZmXNAVRodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppbl9zY29wZV9uYW1lZDo6aDAwZDk3Y2E3YWNhNjlkNmTOAVRodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppbl9zY29wZV9uYW1lZDo6aDFlNmViNDc2Yjk0Nzc4MTLPAU5odG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppbl9zY29wZTo6aDQ2ZmE1YTNhYTQyZGE0ODnQAQVwYXJzZdEBJmNvcmU6OmRvbV90b19zdHJpbmc6Omg5YzlmNTA0NjUzYWZjMjcx0gFIaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6YmFkX2NoYXJfZXJyb3I6OmhjNjgxYjRiODRhNjQwMmRj0wFPPG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OlF1YWxOYW1lIGFzIGNvcmU6Omhhc2g6Okhhc2g+OjpoYXNoOjpoNmY0MDU1M2I2OWE5ZGEyNdQBM2luc3RhbnQ6Ondhc206OmR1cmF0aW9uX2Zyb21fZjY0OjpoMDk5OGQzMmRlYmVmZjA5ZdUBN2NvcmU6OmNoYXI6Om1ldGhvZHM6OmVuY29kZV91dGY4X3Jhdzo6aDI4NWYxMmFmNDBlMDRjY2LWAVBodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6OmVuZF9vZl9maWxlOjpoODQwMjQwODI2Mzg4NmZjZdcBTmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoOGQzNWIzMjdmYTk1YTg3YtgBTmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoOTBiMWEyN2RhNzkwMDQ0MNkBTmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoOWIwMmIzMTQzZjFlYTliM9oBTmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoZWQzNTg5NmE4YTQ5ZWRkY9sBTmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmluX3Njb3BlOjpoNWRhNDg0MDQyMWU0MzViY9wBTmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmluX3Njb3BlOjpoNjdkNzhmMzA3YzcwYWUxNt0BaDxjb3JlOjppdGVyOjphZGFwdGVyczo6bWFwOjpNYXA8SSxGPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46OmZvbGQ6OmgyMzY0NGM3M2M0MTYxMGFl3gFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoMDdlN2MxZjhlMGIwMTczNN8BQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDVjMDA1Y2Y1MjQ4ZjYxNTjgAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6Omg4YjM5ZDI3NDRhZGUwN2E44QFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoYWNlZWMwZWU3OWYxNWRjN+IBQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aGRkY2QxNGJkNjcxNGY3ZDHjAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6OmhhMWYxNjkxOTJkNGJmZDc25AFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoOTc4ZjE5NmI5NmRkYjljMeUBfHN0cmluZ19jYWNoZTo6dHJpdmlhbF9pbXBsczo6PGltcGwgc2VyZGU6OnNlcjo6U2VyaWFsaXplIGZvciBzdHJpbmdfY2FjaGU6OmF0b206OkF0b208U3RhdGljPj46OnNlcmlhbGl6ZTo6aDFlOThhZWExYTBjNTZjODLmAVFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8aHRtbDVldmVyOjp0b2tlbml6ZXI6OmludGVyZmFjZTo6VGFnPjo6aDQ0ZGJkYmZjZmI2NWVmZjTnAVRodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+Ojpwcm9jZXNzX3Rva2VuX2FuZF9jb250aW51ZTo6aGY1M2NlYmIwMWI1MWI3MGPoAUpodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+OjpjbGVhcl9kb2N0eXBlX2lkOjpoOTVkY2U5YmRiMmQzYzEyOOkBJmNvcmU6OnJjZG9tOjphcHBlbmQ6OmhkYjdmZWExNmMwOTgwZDBm6gFOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6OmhkYWEwMDY3MDJhYmQ5YWNh6wFOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6Omg5Yzc0NDMyNGE4Mzk2ZmI07AFOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6OmgyYzMwYTlmZTg5ZTE2NWRl7QFOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6OmhhM2Y5ZDNkZmIxMDU5NGEy7gFDY29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3N0cnVjdF9maWVsZDRfZmluaXNoOjpoZTQ5ODAyZTNjMGQ5NGEyNu8BQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDFiOTcwODY3OTJiZGEzMjbwAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6OmgwMWVjYWEyNGE1Nzc5Zjhj8QFPaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpnZXRfcmVzdWx0OjpoMzIwYzkzN2YzYjFhOTkyMvIBQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDkwZGU4ZGU2YTk0NWYyMmPzAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6Omg5NTUxYWNkMDdjZmRmZGEx9AFCY29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3R1cGxlX2ZpZWxkMl9maW5pc2g6OmhmOThkZGUxMTU2ZTlhZTRm9QF8Y29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0eXBlczo6UHJvY2Vzc1Jlc3VsdDxhbGxvYzo6cmM6OlJjPGNvcmU6OnJjZG9tOjpOb2RlPj4+OjpoYmQ3Y2JjODZmNzkzZDQwNvYBUGh0bWw1ZXZlcjo6dG9rZW5pemVyOjppbnRlcmZhY2U6OlRhZzo6ZXF1aXZfbW9kdWxvX2F0dHJfb3JkZXI6OmhiN2ZhNDg5NmMzZWVhN2Q19wEzc3RkOjpzeXM6Ondhc206Om9uY2U6Ok9uY2U6OmNhbGw6OmhjZmJkMGEyNDdkYzg4NjZi+AFoPHN0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjpQYW5pY1BheWxvYWQgYXMgY29yZTo6cGFuaWM6OkJveE1lVXA+Ojp0YWtlX2JveDo6aDRjNTM2MTcwYzdkNTZlNGL5ATdzdGQ6OnBhbmlja2luZzo6cnVzdF9wYW5pY193aXRoX2hvb2s6Omg4NWI3ZjY2MjhjMjkxZTEy+gFJPGNvcmU6OnN0cjo6ZXJyb3I6OlV0ZjhFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoODQxMjgxOWE0MzdlOGVkY/sBRDxhbGxvYzo6cmM6OlJjPFQ+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg5MGY3MGRmOGI5ZWRmMTE1/AFOaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5fc2NvcGU6OmhiY2E2ZmFjM2ViMzE0YTk3/QFCY29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3R1cGxlX2ZpZWxkMV9maW5pc2g6Omg1ZjRjYWEwN2Y0NjY4NmY2/gEuYWxsb2M6OnJhd192ZWM6OmZpbmlzaF9ncm93OjpoZjYxMGJkZjcyNDU2YmNkMf8BQ2NvcmU6OmZtdDo6Rm9ybWF0dGVyOjpkZWJ1Z19zdHJ1Y3RfZmllbGQzX2ZpbmlzaDo6aDUxNzViZDY0MGNjMGJjNzeAAmVodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpjbG9zZV9wX2VsZW1lbnRfaW5fYnV0dG9uX3Njb3BlOjpoNWM5Mjc4NThlYzcxZWVmNIECV2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBvcF91bnRpbF9jdXJyZW50OjpoMDc2N2FlMzMwYTZjYmIyMYICV2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBvcF91bnRpbF9jdXJyZW50OjpoODA4YjVkOWY4OGNkZTRkZoMCV2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBvcF91bnRpbF9jdXJyZW50OjpoZjZmZTc2OGE3OTRkYzFlMoQCVWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46Omh0bWxfZWxlbV9uYW1lZDo6aDQ4NGVjMDFmNzQ5MzcwNGKFAlxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjphcHBlbmRfY29tbWVudF90b19odG1sOjpoZTVlZDhkMjUzMGMxNDY2MoYCMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYThmMzAwMzdhN2UyY2JhNIcCMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZTJlYTdjMzk1NjhkZjllZYgCMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbXNldDo6aGVkZjJkZGRjMTlmYTI5NDOJAk48c3RyaW5nX2NhY2hlOjphdG9tOjpBdG9tPFN0YXRpYz4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDYzNjNmN2YzYTAyYjFlMzGKAk48c3RyaW5nX2NhY2hlOjphdG9tOjpBdG9tPFN0YXRpYz4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDQ4MTNjNjgyODEwM2IyMTGLAilsb2c6Ol9fcHJpdmF0ZV9hcGlfbG9nOjpoZjNkY2NmMDBlNDY3MDk4MowCTjxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208U3RhdGljPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNGViMTY0Y2MwZjlhODEzNY0CXDxjb3JlOjpjaGFyOjpFc2NhcGVEZWJ1ZyBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46Om5leHQ6OmgwYzczODZmZjU2NDQyNDM3jgJDY29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3N0cnVjdF9maWVsZDJfZmluaXNoOjpoZjg0NDAxZjk5NzdiYmY5NY8CUWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmNyZWF0ZV9yb290OjpoMDMyNjVjNzBhM2VjNWFhY5ACRzxjb3JlOjp0aW1lOjpEdXJhdGlvbiBhcyBjb3JlOjpvcHM6OmFyaXRoOjpBZGQ+OjphZGQ6OmhmYzU4MzcyN2FiZmUyZDQ4kQJPaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5zZXJ0X2F0OjpoZTUwN2RiMzM4OGYzNzExNJICVWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmNsb3NlX3BfZWxlbWVudDo6aGJlOWJkOGZkZGVhYmI4ZjiTAi5hbGxvYzo6cmF3X3ZlYzo6ZmluaXNoX2dyb3c6OmhkYjk0MzQwOGJjOTkzMDY2lAIuYWxsb2M6OnJhd192ZWM6OmZpbmlzaF9ncm93OjpoNGUwNzkyZTg0YTc3YjA3MZUCLmFsbG9jOjpyYXdfdmVjOjpmaW5pc2hfZ3Jvdzo6aGRiNDQ0MGZiZjYxOGI5MziWAi5hbGxvYzo6cmF3X3ZlYzo6ZmluaXNoX2dyb3c6OmhmZDAxZjYzZGQ2YzNjMzA5lwIuYWxsb2M6OnJhd192ZWM6OmZpbmlzaF9ncm93OjpoYzMzYmM0ZjEzM2QxNmI5NpgCLmFsbG9jOjpyYXdfdmVjOjpmaW5pc2hfZ3Jvdzo6aGIxZGM4ZWViNjRhY2ZlOGWZAlM8aHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OnR5cGVzOjpUb2tlbiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNzdmOGQxNTIxODg4YTA1Y5oCWmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmdlbmVyYXRlX2ltcGxpZWRfZW5kOjpoOTA1ZDQzMDA2NThiZWY5YZsCWmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmdlbmVyYXRlX2ltcGxpZWRfZW5kOjpoYzU5OTY0N2YzOTk0OTYyNJwCRjxjb3JlOjpvcHRpb246Ok9wdGlvbjxUPiBhcyBjb3JlOjpoYXNoOjpIYXNoPjo6aGFzaDo6aGJkYjc1ODhkOTczOTM0YmKdAl5odG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpjbG9zZV9wX2VsZW1lbnQ6OmltcGxpZWQ6OmhiNDljNjE2MzQ4ZDE3MGI3ngJPaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6cG9wX3VudGlsOjpoODhmMWU1NTc3ZGE5NzVmMp8CVGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmFwcGVuZF9jb21tZW50OjpoN2Q2MWMyMjE1MTZkOWJiM6ACRWFsbG9jOjpjb2xsZWN0aW9uczo6dmVjX2RlcXVlOjpWZWNEZXF1ZTxULEE+Ojpncm93OjpoZDBkNmQ1NjQ0NTMwMjA4OaECRWFsbG9jOjpjb2xsZWN0aW9uczo6dmVjX2RlcXVlOjpWZWNEZXF1ZTxULEE+Ojpncm93OjpoODRmZTk0NzU0MzgyZjE0NqICQ3BhcmtpbmdfbG90X2NvcmU6OndvcmRfbG9jazo6V29yZExvY2s6OmxvY2tfc2xvdzo6aGRkM2ZjYjYxNjYyMGJhNTmjAi9hbGxvYzo6dmVjOjpWZWM8VCxBPjo6aW5zZXJ0OjpoNzJmMjA2MjJlNzVlMjdmN6QCV2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnJlbW92ZV9mcm9tX3N0YWNrOjpoMTYxZGE2N2MxMTcyMzY2OaUCcGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpvcHRpb246Ok9wdGlvbjx0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPHRlbmRyaWw6OmZtdDo6VVRGOD4+Pjo6aGRkYTFhZjkwZDYxMmQzNDKmAltodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjphcHBlbmRfY29tbWVudF90b19kb2M6Omg3MjJmNDljMGJlNTZiMzQ2pwI6Y29yZTo6Zm10OjpidWlsZGVyczo6RGVidWdUdXBsZTo6ZmluaXNoOjpoYTQxZDNiNjFiODlmNTQxN6gCSWNvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6OlVwcGVySGV4IGZvciBpOD46OmZtdDo6aGFlZDliMTQ3MjA0YmYwNjGpAkljb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpMb3dlckhleCBmb3IgaTg+OjpmbXQ6OmhhYjljMWY5YzNmYWZlZGViqgIyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDI4Yzg4NTJiM2Q1N2M1YTOrAlpjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDx0ZW5kcmlsOjpmbXQ6OlVURjg+Pjo6aDhhYjZhOTY0YzhjYzM4ZTOsAlpjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDx0ZW5kcmlsOjpmbXQ6OlVURjg+Pjo6aDhhYjZhOTY0YzhjYzM4ZTOtAlpjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDx0ZW5kcmlsOjpmbXQ6OlVURjg+Pjo6aDhhYjZhOTY0YzhjYzM4ZTOuAjI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoMGE3ZmQ2ZmYyMWE5NTYwM68CQ3N0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjp7e2Nsb3N1cmV9fTo6aDFlMTdiYWQwNGE1NzEzYTSwAkpjb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpMb3dlckhleCBmb3IgaTMyPjo6Zm10OjpoMDUyYjBjNGFiZDAwYTg0OLECSmNvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6OlVwcGVySGV4IGZvciBpMzI+OjpmbXQ6Omg3MGUwZTgyMjU0ZGZjMDdjsgJIaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6Y2xlYXJfdGVtcF9idWY6OmhlODRkZTEzZGE3ZGNhMDVmswJcaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5zZXJ0X2VsZW1lbnQ6Omxpc3RlZDo6aDE2ZjJiNWEzZWVlMWQ3Njm0AklodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OmN1cnNvcnlfaW1wbGllZF9lbmQ6OmgxOGY3YmFkZjZlYmEzOWI0tQI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoNDY4ZWI5MGMyODc4ZmE5MbYCMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmgyZmM1MGNjYzY0YTBlMjA1twIyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGE5OWE4MDk3YTk2YTVkZjC4AjI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoNDUyM2VlMzgxZmNkZjU3ZrkCOHRlbmRyaWw6OnRlbmRyaWw6OlRlbmRyaWw8RixBPjo6Y2xlYXI6OmhmN2FhZmUyOTQ2NTcxMTE3ugJZPHN0ZDo6aW86OldyaXRlOjp3cml0ZV9mbXQ6OkFkYXB0ZXI8VD4gYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGM0NDJhYTlkMTQ1NTI3MmO7AkVjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c2VyZGVfanNvbjo6ZXJyb3I6OkVycm9yPjo6aDQxNzUzYWU5MTE2NThlOTm8Alpjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDx0ZW5kcmlsOjpmbXQ6OlVURjg+Pjo6aDhhYjZhOTY0YzhjYzM4ZTO9AkhodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6Omh0bWxfZGVmYXVsdF9zY29wZTo6aDk1MmJjNWNkMWY1MjIwMje+Anxjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6b3B0aW9uOjpPcHRpb248c3RyaW5nX2NhY2hlOjphdG9tOjpBdG9tPG1hcmt1cDVldmVyOjpMb2NhbE5hbWVTdGF0aWNTZXQ+Pj46OmhlYzUyN2VmM2IwMjAyMDgyvwJ5Y29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPHN0cmluZ19jYWNoZTo6YXRvbTo6QXRvbTxtYXJrdXA1ZXZlcjo6UHJlZml4U3RhdGljU2V0Pj4+OjpoZjc5MGI0NjZhYjk4MGJiNMACLmNvcmU6OnJlc3VsdDo6dW53cmFwX2ZhaWxlZDo6aGUwZGRjMjY5MDgzMDk4YWbBAi9hbGxvYzo6dmVjOjpWZWM8VCxBPjo6cmVtb3ZlOjpoNDBmMWQ2MWM3ODk3MWMyOcICUzxodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OlN0YXRlIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhmODJmYjRhMDJhYTRkM2I5wwJnaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5zZXJ0X2VsZW1lbnQ6OmZvcm1fYXNzb2NpYXRhYmxlOjpoZDcwNTE4NmE3M2ExZWQ1N8QCZmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208bWFya3VwNWV2ZXI6OkxvY2FsTmFtZVN0YXRpY1NldD4+OjpoNzI5ZWRhOTU1MTc1NGMzNMUCZmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208bWFya3VwNWV2ZXI6OkxvY2FsTmFtZVN0YXRpY1NldD4+OjpoYjlhZTE5ZTNmM2IxNDFhOcYCZmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208bWFya3VwNWV2ZXI6Ok5hbWVzcGFjZVN0YXRpY1NldD4+OjpoNTIxN2JlZWYxMjcxZTI5MMcCrQE8aHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPiBhcyBodG1sNWV2ZXI6OnRva2VuaXplcjo6aW50ZXJmYWNlOjpUb2tlblNpbms+OjphZGp1c3RlZF9jdXJyZW50X25vZGVfcHJlc2VudF9idXRfbm90X2luX2h0bWxfbmFtZXNwYWNlOjpoZDA0MWIwZjQ1MDVjNjZkMsgCMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNjQ2OGFlNzlmMzViY2Y1MckCPmFsbG9jOjp2ZWM6OlZlYzxULEE+OjppbnNlcnQ6OmFzc2VydF9mYWlsZWQ6Omg2NjJjMzk0MmQ5MTkzODE0ygI+YWxsb2M6OnZlYzo6VmVjPFQsQT46OnJlbW92ZTo6YXNzZXJ0X2ZhaWxlZDo6aDk4NGRmM2I3ZjJmZTQwM2HLAjZjb3JlOjpwYW5pY2tpbmc6OnBhbmljX2JvdW5kc19jaGVjazo6aDBjZmNlNDU5MjYwYTBhODLMAkRjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsX3J0OjpoMGMxNDMxNDAyMjRmNTFlOc0CQmNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfZW5kX2luZGV4X2xlbl9mYWlsX3J0OjpoNDFiNWU0OTBlODRhMzBkNM4CQGNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfaW5kZXhfb3JkZXJfZmFpbF9ydDo6aDU4NzdlZjJhMWYyMzVhZmTPAjA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJhOTgwM2I5ZTM2ZjM4YTbQAjlzdHJpbmdfY2FjaGU6OmR5bmFtaWNfc2V0OjpTZXQ6OnJlbW92ZTo6aGNiNjFlYzUwMmJjMDEzZjHRAi1hbGxvYzo6dmVjOjpWZWM8VCxBPjo6cHVzaDo6aDk4ZmQ5NjcyMjZmMWQ3NzfSAjtjb3JlOjpmbXQ6OmJ1aWxkZXJzOjpEZWJ1Z1N0cnVjdDo6ZmluaXNoOjpoNDdmMzA0NGI2ZDcxNTRmNdMCVGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBhcnNlX3Jhd19kYXRhOjpoZDdkZmJmNmFkMThkZTZkN9QCSjxjb3JlOjpvcHM6OnJhbmdlOjpSYW5nZTxJZHg+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhhOGE3ZjVjZTM5MzI5NGQ41QJYaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5faHRtbF9lbGVtX25hbWVkOjpoYjEzZGE3MDM4NDgwNGJiZdYCMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmgyNjQ3YTk3YzMzOWQ4MWRl1wIvYWxsb2M6OnZlYzo6VmVjPFQsQT46Omluc2VydDo6aGEzOTdkZTg3N2RjNmIzMWLYAjxkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+Ojppbml0X3RvcDo6aDAwZDZlZWFlNmE5NDY2MzHZAjdzdGQ6OmFsbG9jOjpkZWZhdWx0X2FsbG9jX2Vycm9yX2hvb2s6Omg4NzIwMWY1ZmU1YWI3NDU42gJbaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Zm9zdGVyX3BhcmVudF9pbl9ib2R5OjpoY2RkMTBmMzE1MmNkY2JiYtsCTXN0ZDo6aW86OmJ1ZmZlcmVkOjpidWZ3cml0ZXI6OkJ1ZldyaXRlcjxXPjo6d3JpdGVfYWxsX2NvbGQ6Omg4MzhjZDhiYmI3YWRjOTY33AJjPHN0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjpQYW5pY1BheWxvYWQgYXMgY29yZTo6cGFuaWM6OkJveE1lVXA+OjpnZXQ6OmhmNzRmY2UwYzg4MzAwNDgx3QI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfZm10OjpoZTBhMWMzZTk2ZTMxNjMzZd4COjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aDMxYWI3NTcyZmVjY2IzODPfAjo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9mbXQ6OmgzODhjYmE0NTMyYzEyM2Vj4AI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfZm10OjpoNDFkOTdmZWVhZjRjOTk4OOECOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aGRhOWI2ZGJiYzc4OTFjZDDiAjo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9mbXQ6OmhkOWVjNjQ3MWJhMzdmNjZi4wI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfZm10OjpoMzY5MDg2NmYzYWFjNTUyMeQCMWNvcmU6OnBhbmlja2luZzo6YXNzZXJ0X2ZhaWxlZDo6aGZjMzNjMWJjNzkyMzYwNTblAjFjb3JlOjpwYW5pY2tpbmc6OmFzc2VydF9mYWlsZWQ6OmgzM2QzZjU1ZWE0ODAxNDZl5gIxY29yZTo6cGFuaWNraW5nOjphc3NlcnRfZmFpbGVkOjpoZDk5NDBmZTkwZGI4ZjkyN+cCSmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnB1c2g6OmhlZTM5YjdjYmQyMjI0MTg06AIyY29yZTo6Zm10OjpGb3JtYXR0ZXI6OndyaXRlX2ZtdDo6aGJkZTU1ZTY0Y2MyNzBkNGXpAi5jb3JlOjpmbXQ6OldyaXRlOjp3cml0ZV9mbXQ6OmgwOTk0ODczMWQ3NmNhYjE16gIuY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfZm10OjpoMDZiN2NmMDkyM2VlZmMzY+sCLmNvcmU6OmZtdDo6V3JpdGU6OndyaXRlX2ZtdDo6aDdjYzM3MzQxMGRiMTUxZjLsAi5jb3JlOjpmbXQ6OldyaXRlOjp3cml0ZV9mbXQ6OmhjZTk2NDlhNWE4NDIxYzY57QJCPGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgwN2YxZDJhMzAzNGY2OWI47gIuY29yZTo6b3B0aW9uOjpleHBlY3RfZmFpbGVkOjpoYzM2YTY5MzY2Nzc3Y2UwYu8CLmNvcmU6OmZtdDo6V3JpdGU6OndyaXRlX2ZtdDo6aGU3ZjBhOTlmN2NmNzQ4NzfwAmY8Y29yZTo6cmNkb206OlJjRG9tIGFzIG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OnRyZWVfYnVpbGRlcjo6VHJlZVNpbms+OjpwYXJzZV9lcnJvcjo6aDEyM2UxZmMyNTQ2Nzc1NWbxAkFodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OmhlYWRpbmdfdGFnOjpoMTdjZTBjN2UzYjljOWNlNvICMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYTRhY2JiOTgyNjdmODBkMPMCWDxtYXJrdXA1ZXZlcjo6dXRpbDo6YnVmZmVyX3F1ZXVlOjpTZXRSZXN1bHQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGY1ZGI5NWYyYzkxZjNmOTH0Ai1sb2c6Ol9fcHJpdmF0ZV9hcGlfZW5hYmxlZDo6aGI3NDNkOWNmYTA3YzZmN2T1Aj5hbGxvYzo6Y29sbGVjdGlvbnM6OmJ0cmVlOjpub2RlOjpzcGxpdHBvaW50OjpoYjhmYzFkNjgxNzMxNWY0MfYCXzxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208U3RhdGljPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpkcm9wX3Nsb3c6Omg1MGY3OTNhYzFiZjgyYWEy9wJWPGh0bWw1ZXZlcjo6dG9rZW5pemVyOjppbnRlcmZhY2U6OkRvY3R5cGUgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJjYWM0YTE2Mjc4YmUxYjX4AlI8aHRtbDVldmVyOjp0b2tlbml6ZXI6OmludGVyZmFjZTo6VGFnIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg1Mzg0YWU5MTU4OTBmZmVk+QJVaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y3VycmVudF9ub2RlX2luOjpoMzIwNzM5NTBjMjQ3OWFkOfoCL2FsbG9jOjp2ZWM6OlZlYzxULEE+OjpyZW1vdmU6OmgxNzliNTkxODJmYTUyNWMy+wJBaGFzaGJyb3duOjpyYXc6OkZhbGxpYmlsaXR5OjpjYXBhY2l0eV9vdmVyZmxvdzo6aGM2MWQ4YWRlYTlkYTQ5NWb8AlNodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6Om1hdGhtbF90ZXh0X2ludGVncmF0aW9uX3BvaW50OjpoNWI1NDBjOGYzMDNhZTk0NP0CSGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0YWdfc2V0czo6dGFibGVfYm9keV9jb250ZXh0OjpoMDE1YjlmYWYyMjQwNjE5Y/4CaWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnByb2Nlc3NfY2hhcnNfaW5fdGFibGU6OnRhYmxlX291dGVyOjpoNjg5ZDEwNzI0N2JlMWIzMv8CYzxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OlBhbmljUGF5bG9hZDxBPiBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoNGI2M2Y1Yzk2MzYzYTliZoADUWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmFwcGVuZF90ZXh0OjpoY2M1YTk3MmRlMDJiYzRmZoEDYzxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OlBhbmljUGF5bG9hZDxBPiBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoMDg0ODMyYTY5OGI4NmE2YYIDEXJ1c3RfYmVnaW5fdW53aW5kgwMtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6Omg1OTcwNTMwODg2NzUzOWYxhANePGNvcmU6OnNsaWNlOjppdGVyOjpJdGVyPFQ+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6YW55OjpoM2FjYTE1M2QzNzg3OWY3MYUDU2h0bWw1ZXZlcjo6dG9rZW5pemVyOjpjaGFyX3JlZjo6Q2hhclJlZlRva2VuaXplcjo6dW5jb25zdW1lX25hbWU6OmgyNDQ1MWMwN2QxYjE2N2Y4hgNCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHN0ZDo6aW86OmVycm9yOjpFcnJvcj46OmhkOTgyNjJhM2MxY2FhYzQyhwNkY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHN0ZDo6aW86OldyaXRlOjp3cml0ZV9mbXQ6OkFkYXB0ZXI8YWxsb2M6OnZlYzo6VmVjPHU4Pj4+OjpoYjk1Mzg2ZjVmNTVjYzUwM4gDMWFsbG9jOjp2ZWM6OlZlYzxULEE+Ojp0cnVuY2F0ZTo6aDIxNzM3Yjg4YTdiZGZhNWKJA0JwYXJraW5nX2xvdF9jb3JlOjpwYXJraW5nX2xvdDo6Y3JlYXRlX2hhc2h0YWJsZTo6aGMxYWM5ZDIzODI1NzlhMjSKA2Rjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RkOjppbzo6V3JpdGU6OndyaXRlX2ZtdDo6QWRhcHRlcjxhbGxvYzo6dmVjOjpWZWM8dTg+Pj46OmhjZWE5OWJkNzc3NTE4OGU4iwNOPG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OlF1YWxOYW1lIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhlNzdlMmJmZWFhYzNhMDE1jANdPHN0cmluZ19jYWNoZTo6ZHluYW1pY19zZXQ6OkRZTkFNSUNfU0VUIGFzIGNvcmU6Om9wczo6ZGVyZWY6OkRlcmVmPjo6ZGVyZWY6Omg3MWExYTE1Yjg0ODExNDYwjQMpY29yZTo6cGFuaWNraW5nOjpwYW5pYzo6aDJmMDQxYmY2YWE5OTBkZmSOAzFjb21waWxlcl9idWlsdGluczo6bWVtOjptZW1jbXA6OmhiZTkzYzEzNWU3NTVjOWRijwNFPGNvcmU6Om9wdGlvbjo6T3B0aW9uPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhkOTNhN2JlYjI1ZDE3ZDRjkANFPGNvcmU6Om9wdGlvbjo6T3B0aW9uPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhmNDVmNTM3NGYyYjkyOWE4kQNFPGNvcmU6Om9wdGlvbjo6T3B0aW9uPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg3ZDNkYjY3YTE3OGRiYzA3kgMxYWxsb2M6OnN5bmM6OkFyYzxUPjo6ZHJvcF9zbG93OjpoNzYxODcyMzYwZTY0NmEzNZMDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDYwYTdkOGE3YzFmNzIyMTiUA1JodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojphc3NlcnRfbmFtZWQ6OmgzY2I5OGExZmQ1ZWU3NjczlQM6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoY2M5MmNiNWYxNDZjZGYwOZYDWTxzdGQ6OmlvOjpXcml0ZTo6d3JpdGVfZm10OjpBZGFwdGVyPFQ+IGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9zdHI6Omg5OTkxOGQ3ZjliNzg1MjNllwM6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoZmIzNTM4N2E2OTBlZTBiY5gDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGUzYTMwOGFlMzc5MTM0NTaZA1k8c3RkOjppbzo6V3JpdGU6OndyaXRlX2ZtdDo6QWRhcHRlcjxUPiBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoOTVkOGI2MDVlN2QzYTI0YZoDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGY1NTEzNTNiY2E1N2M2ZmabAz1jb3JlOjpudW06OjxpbXBsIHU4Pjo6ZXFfaWdub3JlX2FzY2lpX2Nhc2U6OmhjOWM0NjFhNDRlOGM2NjNinANJPGFsbG9jOjpzdHJpbmc6OlN0cmluZyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoZTg3MzY5YWU5Yjg4N2I0OZ0DTzxtYXJrdXA1ZXZlcjo6aW50ZXJmYWNlOjpBdHRyaWJ1dGUgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDkzMzFkY2MwYTRmYTk1ZmSeAypzdGQ6OnRpbWU6Okluc3RhbnQ6Om5vdzo6aDIzMTFjOThjYjYwOTQ1ZDifAy5zdGQ6OnRpbWU6Okluc3RhbnQ6OmVsYXBzZWQ6OmhiMDdmZWFkMmRiMTNmZDg1oAM0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5X292ZXJmbG93OjpoM2JiNDUzN2I1ZjlmODQwNKEDSjxhbGxvYzo6c3RyaW5nOjpGcm9tVXRmOEVycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhhOTE2NDRhYTAzNDQ1YzcxogMtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6OmhjNjcyNGRjYjU3ZjdjOGE0owNZaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6c3RlcDo6ZXh0cmFfc3BlY2lhbDo6aGU4YTM5ZTI5NzU4OThiNTekA2s8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlN0clBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoMTAwMjY2MDA2MjM3ZmM0ZKUDSWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBvcDo6aDY2N2M3OWU4MDU0Y2U3YTimA0g8ZGxtYWxsb2M6OnN5czo6U3lzdGVtIGFzIGRsbWFsbG9jOjpBbGxvY2F0b3I+OjphbGxvYzo6aGViOGEwYjE2ZjhmNWJjYzCnA0Njb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjp3cml0ZV9wcmVmaXg6OmhiNjIzNjljMDJmMWEyOTZhqANLY29yZTo6Zm10OjpmbG9hdDo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciBmNjQ+OjpmbXQ6OmhiMjY0MTExY2JmYjFjOTk2qQMtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6Omg3NDJhMTc3ZmM1ZWM5MDg3qgNQaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OnRhZ19zZXRzOjpzdmdfaHRtbF9pbnRlZ3JhdGlvbl9wb2ludDo6aDJkNDFiMWZjMTA5YTA4ZWarA0FodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OnRhYmxlX3Njb3BlOjpoNWNhODY1N2JjZDNjZTNkYawDR2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0YWdfc2V0czo6dGFibGVfcm93X2NvbnRleHQ6Omg5NWVmNWRhZTFkNjBkOGYyrQNXaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6c3RlcDo6dGFibGVfb3V0ZXI6OmgyZjNiNjdlMWVkYTZkN2VhrgNNY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHN0cmluZ19jYWNoZTo6ZHluYW1pY19zZXQ6OkVudHJ5Pjo6aGNlYzllN2ZjODY0MmFlNzivA01jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RyaW5nX2NhY2hlOjpkeW5hbWljX3NldDo6RW50cnk+OjpoY2VjOWU3ZmM4NjQyYWU3OLADQmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmdldF9jaGFyOjpoMzY5ZjcxODE5OWIyYmQzZrEDQHN0ZDo6c3luYzo6b25jZV9sb2NrOjpPbmNlTG9jazxUPjo6aW5pdGlhbGl6ZTo6aGZlMGIyMGZmMmM1MDY3MDGyAy1jb3JlOjpwYW5pY2tpbmc6OnBhbmljX2ZtdDo6aGY1YzRjZDkyOWQ0YWFhOWWzAxFfX3diaW5kZ2VuX21hbGxvY7QDL3NlcmRlX2pzb246OmVycm9yOjpFcnJvcjo6aW86OmhmZTA4YWRlNjBlNmM1Y2RhtQNYaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y3VycmVudF9ub2RlX25hbWVkOjpoMGI3ZDgzZWY2Nzk2ZTc2ZbYDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoM2YzZGM0NmU2ZTgxZWYzNbcDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOTdkYjRjMjNlMzg2OWQ3MLgDEl9fcmRsX2FsbG9jX3plcm9lZLkDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYzNjOTJkNTUzZjQ2NWMyZboDSGh0bWw1ZXZlcjo6dG9rZW5pemVyOjpjaGFyX3JlZjo6Q2hhclJlZlRva2VuaXplcjo6bmV3OjpoYTA0YTExZjIwMThkNmI1OLsDRnBhcmtpbmdfbG90X2NvcmU6OnBhcmtpbmdfbG90OjpGYWlyVGltZW91dDo6Z2VuX3UzMjo6aDk0ZDcyMmQyMDNmMmMxZja8A0ZodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+OjpkaXNjYXJkX2NoYXI6Omg1ODkzYzU4ZWNkY2RkYzNivQNZaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpmaW5pc2hfbnVtZXJpYzo6Y29udjo6aGFhNDc4ZWExYTYzZTg1YzW+A3s8bWFya3VwNWV2ZXI6OmludGVyZmFjZTo6RXhwYW5kZWROYW1lIGFzIGNvcmU6OmNtcDo6UGFydGlhbEVxPG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OkV4cGFuZGVkTmFtZT4+OjplcTo6aGUyOTQ4MmY4NGJjYjcxMWa/Azljb3JlOjpmbXQ6OmJ1aWxkZXJzOjpEZWJ1Z0xpc3Q6OmZpbmlzaDo6aGYxM2M5MTcyYjMxNTNlNGTAAzRjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6ZGVidWdfdHVwbGU6OmgxNDQ5ZDJjOGRkOWNlZTUxwQM7c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljOjp7e2Nsb3N1cmV9fTo6aDcwMTg0NDE2MzA1YjdjZGXCA0JodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OnNlbGVjdF9zY29wZTo6aGFlZmZlYTA4OGU5ZTJlZGPDAztodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OnRkX3RoOjpoZWM3NjIxMGUwYzUzNDk0MsQDVmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnN0ZXA6OmNsb3NlX2RlZm46Omg3MTA5OTk1NmUxOGZiMzIzxQM7c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljOjp7e2Nsb3N1cmV9fTo6aDliNjE2ZDM1ODgyOTQ2MznGA0djb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpEZWJ1ZyBmb3IgaTMyPjo6Zm10OjpoMmQ0ZTRmYmNiYmE4MzQ1MccDN2RsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnNldF9pbnVzZTo6aDcyZWVhYzRlYjEwYzc0YTfIA2g8Y29yZTo6Y2hhcjo6RXNjYXBlRGVmYXVsdCBhcyBjb3JlOjppdGVyOjp0cmFpdHM6OmV4YWN0X3NpemU6OkV4YWN0U2l6ZUl0ZXJhdG9yPjo6bGVuOjpoZGNhMTBiMjY1MWUxNzYwMckDLGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpuZXc6OmhjZWEwZjM4OTQ5MTJhMGJkygM1Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3N0cnVjdDo6aDA2ZWQxZTIyMWQwZDE2YjfLAzNjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6ZGVidWdfbGlzdDo6aGM3MTQwNjA3MWQ2N2IyNDbMAy5zdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OmgwZDllYjIxZmU5NzBmMDAxzQNaaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5zZXJ0X2FwcHJvcHJpYXRlbHk6OmhhODM1NTAwNjVmY2ZlYzUyzgM7aHRtbDVldmVyOjp1dGlsOjpzdHI6Omxvd2VyX2FzY2lpX2xldHRlcjo6aGJjMzVlNzNlNjZiZmQzM2PPAy5zdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6Omg3OWMyOGUzYjkxYzEzNzNk0ANYY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPGFsbG9jOjpzdHJpbmc6OlN0cmluZz4+OjpoMjIwYWNmNmFiNjcyMGNmNNEDNWRsbWFsbG9jOjpkbG1hbGxvYzo6U2VnbWVudDo6aG9sZHM6OmgwNmFlODFiYWZmNzU0YjM20gMSX193YmluZGdlbl9yZWFsbG9j0wNCZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6c2V0X2ZyZWVfd2l0aF9waW51c2U6OmgyYzdkOWY1OTJjOWMxNjM21ANOY29yZTo6Zm10OjpudW06OmltcDo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciBpMzI+OjpmbXQ6OmhjNGY2MTQ3MjA1NTg4Nzcy1QMwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgzYzUwZDJkYzBhNzc5NDMy1gNbPGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0eXBlczo6SW5zZXJ0aW9uTW9kZSBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoN2M5YmI1MWZiZTJjZTQwY9cDWTxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dHlwZXM6OlNwbGl0U3RhdHVzIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhiZGM0YTkxYjYyYzdiODAw2ANHPHN0ZDo6aW86OmVycm9yOjpFcnJvcktpbmQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDliNDQ3ZTY2ZWIzYTgzMjTZA0JkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpzZXRfaW51c2VfYW5kX3BpbnVzZTo6aDdmYWMyMzI2ZjQ3MDAwNzXaAzloYXNoYnJvd246OnJhdzo6RmFsbGliaWxpdHk6OmFsbG9jX2Vycjo6aDQxMmI4MGFjOTMzMTZhMWLbA0ljb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnN0cmluZzo6RnJvbVV0ZjhFcnJvcj46Omg1ZGYwZWY2YjFmZjZlNzU13ANCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjpzdHJpbmc6OlN0cmluZz46OmgyMmUzNDEyODZmNzBlYzJj3QM3aHRtbDVldmVyOjp1dGlsOjpzdHI6OmlzX2FzY2lpX2FsbnVtOjpoOWIwNjE5NmI5NDkzNTIzMt4DMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNmQ0NDEzOWUzNTAxZTJkY98DQmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6c3RyaW5nOjpTdHJpbmc+OjpoZWUyYmU4NmM3Mzc0YWY2YuADvwFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8PGFsbG9jOjpib3hlZDo6Qm94PGR5biBjb3JlOjplcnJvcjo6RXJyb3IrY29yZTo6bWFya2VyOjpTeW5jK2NvcmU6Om1hcmtlcjo6U2VuZD4gYXMgY29yZTo6Y29udmVydDo6RnJvbTxhbGxvYzo6c3RyaW5nOjpTdHJpbmc+Pjo6ZnJvbTo6U3RyaW5nRXJyb3I+OjpoY2NjOWQzMzc1Mjc2Zjk2NuEDNDxib29sIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGRhMzk1NzMyODhkZjljNjbiA148c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljOjpQYW5pY1BheWxvYWQ8QT4gYXMgY29yZTo6cGFuaWM6OkJveE1lVXA+OjpnZXQ6Omg0NWE2ZWZjYmMyYjlmZjM14wNNaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpuYW1lX2J1Zjo6aDRkNmY4MDI4YzdkYzI4MTTkA1FodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6Om5hbWVfYnVmX211dDo6aDdkOWUxMTU2NWI2YTIwZmLlA1s8aHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplck9wdHMgYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6OmgzNWViOWYzNTI0NmY5Nzhk5gNAaHRtbDVldmVyOjp0b2tlbml6ZXI6OmludGVyZmFjZTo6RG9jdHlwZTo6bmV3OjpoYjhkMDQ0NGNlMDFjOTJlOOcDVjxodG1sNWV2ZXI6OnRva2VuaXplcjo6aW50ZXJmYWNlOjpUYWdLaW5kIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhiMTVjZDEyMmQ5NjViZWM26ANePHN0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pYzo6UGFuaWNQYXlsb2FkPEE+IGFzIGNvcmU6OnBhbmljOjpCb3hNZVVwPjo6Z2V0OjpoZDc0ZDIxYzc5YThmYjdmM+kDTzx0ZW5kcmlsOjp0ZW5kcmlsOjpTdWJ0ZW5kcmlsRXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDk4NzkxNDYwNjJiNGNkOGTqAzA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGVhOTU5MWMyZDI1N2FiOGXrA0BkbG1hbGxvYzo6ZGxtYWxsb2M6OlRyZWVDaHVuazo6bGVmdG1vc3RfY2hpbGQ6OmgzNzIwMzJlYjkxMzQ1NWQ57ANPaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpmaW5pc2hfb25lOjpoYTZhZmI2ZjNhMWM2Y2RmMu0DJ3N0ZDo6YWxsb2M6OnJ1c3Rfb29tOjpoZWM0YzhkNTdkMTA4M2FiM+4DP2RsbWFsbG9jOjpkbG1hbGxvYzo6bGVmdHNoaWZ0X2Zvcl90cmVlX2luZGV4OjpoMzVhZjdmODkyNDI2OWY1Nu8DT2RsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnNldF9zaXplX2FuZF9waW51c2Vfb2ZfZnJlZV9jaHVuazo6aGZjYWIzMzIxODBmZTgxMWLwA1BodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6OmZpbmlzaF9ub25lOjpoN2ViODMxMjlhZWUyYTAwNvEDPGh0bWw1ZXZlcjo6dXRpbDo6c3RyOjppc19hc2NpaV93aGl0ZXNwYWNlOjpoNjlmZGUyNzlkZWVjNTViZfIDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoODQwMDY3YTRmODkyNDllYfMDVmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnN0ZXA6OmNsb3NlX2xpc3Q6Omg2ZWY1NTE0ZWUyYTE2NzYx9AMvZGxtYWxsb2M6OmRsbWFsbG9jOjphbGlnbl91cDo6aDc3ZWRkOWE5NWRjZDczMmL1Aw5fX3J1c3RfcmVhbGxvY/YDD19fd2JpbmRnZW5fZnJlZfcDMGRsbWFsbG9jOjpkbG1hbGxvYzo6bGVmdF9iaXRzOjpoNjk0NWM5ODgwZGJjY2I1YfgDRTxjb3JlOjpjZWxsOjpCb3Jyb3dFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZmRhY2JjMDE0YzExYWI0ZPkDSDxjb3JlOjpjZWxsOjpCb3Jyb3dNdXRFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYzFhZjk2YjE2NzVlNTBhZfoDMmNvcmU6OmZtdDo6Rm9ybWF0dGVyOjp3cml0ZV9zdHI6Omg2MDE4YTljYWNiY2U2ODYw+wM+PGNvcmU6OmZtdDo6RXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDM4YzQ2MmMwNTYxODQxMzD8AzA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDA0Yjc1NDRiOTYwM2M0Yjj9Ay5jb3JlOjpzdHI6OnNsaWNlX2Vycm9yX2ZhaWw6Omg3NTZlZTcwYWQxMjdkZWVl/gMMX19ydXN0X2FsbG9j/wMTX19ydXN0X2FsbG9jX3plcm9lZIAERTxhbGxvYzo6c3RyaW5nOjpTdHJpbmcgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoYjJjODFjNzc3MmExMDNkZIEEMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6Omg0MTcxOTkxMjQ2YTIxODZhggRDPGFsbG9jOjpzdHJpbmc6OlN0cmluZyBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYmJmM2U5ZTk0NzlhMjY5YoMEMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmhhZTI0OGI1YjkyM2I0ZTQ5hARgPGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlck9wdHMgYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6Omg0MGUyYzk0MWNkOTQ4YmIzhQQyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDFjNWEyNWE2NmFhOGVmYzeGBF08cGFya2luZ19sb3RfY29yZTo6cGFya2luZ19sb3Q6OlRocmVhZERhdGEgYXMgY29yZTo6b3BzOjpkcm9wOjpEcm9wPjo6ZHJvcDo6aDkwMjZjMDllZWFjMjZhM2OHBDA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGEwZTA4MTY4ZjdlZGFiYjmIBDI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoNDA3MTk2MmEyNzE0YWQ0ZokEQzxhbGxvYzo6c3RyaW5nOjpTdHJpbmcgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJiZjNlOWU5NDc5YTI2OWKKBEU8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGIyYzgxYzc3NzJhMTAzZGSLBGY8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlN0clBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OmdldDo6aDhlYWEwZDY3ZDczYmRkMjOMBD5zdGQ6OnN5czo6d2FzbTo6Y29tbW9uOjpoYXNobWFwX3JhbmRvbV9rZXlzOjpoZDcyNTczZWY4MGNkMmE4No0ENGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OmNpbnVzZTo6aGM1OTQzODZiNmJhN2JjNjOOBDpkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpjbGVhcl9waW51c2U6OmgzNWU2ZDdjOWVmODM1OTdmjwQzZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6aW51c2U6OmgwYzNkOTc0OWNjZDliNDkxkAQyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDgzZDY0ZGFhMDFhNWExMDWRBEQ8Y29yZTo6Zm10OjpBcmd1bWVudHMgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoNmYyMzQ2MzU1NjhjZTUxOJIEOGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpkZWJ1Z19sb3dlcl9oZXg6OmhhMzExNjE1NmQ2YTkyNmQ1kwQ4Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3VwcGVyX2hleDo6aGU0YjliN2JiMzU0YjI1NmKUBA5fX3J1c3RfZGVhbGxvY5UES2NvcmU6OmNtcDo6aW1wbHM6OjxpbXBsIGNvcmU6OmNtcDo6UGFydGlhbEVxIGZvciB1OD46OmVxOjpoMmMyZDUxODkwNzNkMWE4NpYEhwE8cGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6aW1wOjpUaHJlYWRQYXJrZXIgYXMgcGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6VGhyZWFkUGFya2VyVD46OnByZXBhcmVfcGFyazo6aGNiZjQyODZkNTMzNmI0ODeXBIQBPHBhcmtpbmdfbG90X2NvcmU6OnRocmVhZF9wYXJrZXI6OmltcDo6VGhyZWFkUGFya2VyIGFzIHBhcmtpbmdfbG90X2NvcmU6OnRocmVhZF9wYXJrZXI6OlRocmVhZFBhcmtlclQ+Ojp0aW1lZF9vdXQ6Omg2MjhhZjRkMWYzMDc4ZDZjmAR/PHBhcmtpbmdfbG90X2NvcmU6OnRocmVhZF9wYXJrZXI6OmltcDo6VGhyZWFkUGFya2VyIGFzIHBhcmtpbmdfbG90X2NvcmU6OnRocmVhZF9wYXJrZXI6OlRocmVhZFBhcmtlclQ+OjpwYXJrOjpoMDA3MDYzNmI4YTMyYzBkZJkEhQE8cGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6aW1wOjpUaHJlYWRQYXJrZXIgYXMgcGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6VGhyZWFkUGFya2VyVD46OnBhcmtfdW50aWw6Omg3YTBlMTk1YWRjNjMzNjg0mgSGATxwYXJraW5nX2xvdF9jb3JlOjp0aHJlYWRfcGFya2VyOjppbXA6OlRocmVhZFBhcmtlciBhcyBwYXJraW5nX2xvdF9jb3JlOjp0aHJlYWRfcGFya2VyOjpUaHJlYWRQYXJrZXJUPjo6dW5wYXJrX2xvY2s6OmhmNTcxMzU3ODI0YWU0N2IzmwQKcnVzdF9wYW5pY5wEWTxzdGQ6OnN5czo6d2FzbTo6b25jZTo6Q29tcGxldGlvbkd1YXJkIGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmhlZTI0MWRhZDNjYTc5MTAwnQQwZGxtYWxsb2M6OmRsbWFsbG9jOjpsZWFzdF9iaXQ6OmgzMzA4YWEzYTM5ZmI0ZTExngQ1ZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6bW1hcHBlZDo6aDAyMDRkNmEwMWFmNGJhYjKfBFBkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpzZXRfc2l6ZV9hbmRfcGludXNlX29mX2ludXNlX2NodW5rOjpoZTc5MzYzZmFiMjQ0NTI2MKAEM2RsbWFsbG9jOjpkbG1hbGxvYzo6U2VnbWVudDo6dG9wOjpoMGQ5NmZiNTJiNWUyMjM4Y6EEOzwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6Omg3NmMzNTY2OTAwYjk5NzdlogQ5Y29yZTo6b3BzOjpmdW5jdGlvbjo6Rm5PbmNlOjpjYWxsX29uY2U6OmgzZGM4NjFmZTgyNDNjYTQ2owRBY29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9zdGFydF9pbmRleF9sZW5fZmFpbDo6aDY1ZjRjNjNjZjljM2ZjYTCkBD9jb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX2VuZF9pbmRleF9sZW5fZmFpbDo6aDU5MmM5ZmQ0Mzg0NDRjYWKlBD1jb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX2luZGV4X29yZGVyX2ZhaWw6Omg2YjAwNTIwYTY0NzU2NDExpgROY29yZTo6Zm10OjpudW06OmltcDo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciB1MzI+OjpmbXQ6Omg5MjQyM2M0MzZmYjhlYjZjpwRNY29yZTo6Zm10OjpudW06OmltcDo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciB1OD46OmZtdDo6aDk3Mzk4NTk1YTYxMjVkMTKoBDdjb3JlOjpmbXQ6OmJ1aWxkZXJzOjpEZWJ1Z1NldDo6ZW50cnk6OmhkNDNhNTBmNGJjZDljYjQ3qQQ6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoNzQ5YzdiNzUwMzdmNTE0N6oETmNvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTY0Pjo6Zm10OjpoNTFjMWNkYmYyMDQ3YzYwM6sEH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXKsBBpfX3J1c3RfYWxsb2NfZXJyb3JfaGFuZGxlcq0EMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYzBlMDA5NzVkNjNmZGEzNK4EMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYjExOWNlY2FmZjRlNGRiNa8EMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNGJkMDUzNmJhZGUxYjYxYbAEMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZjViM2VjMjcyNzEyZjcxYbEEMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOWI5OGRjOWFmMGFlZWJmZLIEMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMjMzYjNhMzU1ZTRhZjdlObMEQDx0ZW5kcmlsOjpmbXQ6OlVURjggYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJjMTI1MDVjNWVkZTMxMGS0BDA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGZmYjkyZGNjOTkyMjNhMzC1BDs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoMDczNzBhZGVmMjk5YWQ0NLYEOzwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6OmhlYmY0OTk1NjBmYWUwNTFjtwQyZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6c2l6ZTo6aGMxYzZlZTE4NjJlZDNmNjO4BDRkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpwaW51c2U6OmgxNjA3Mzc1NDQ4MGE0N2JjuQQ5ZGxtYWxsb2M6OmRsbWFsbG9jOjpTZWdtZW50Ojppc19leHRlcm46Omg1Yjg4OGZjMTY5NGFhZGExugQ5ZGxtYWxsb2M6OmRsbWFsbG9jOjpTZWdtZW50OjpzeXNfZmxhZ3M6Omg0MmM0MjViNDM5NzkzMGVluwQwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg0ZDNmMWFiZmI3ZDJlMGE5vAQzYWxsb2M6OmFsbG9jOjpoYW5kbGVfYWxsb2NfZXJyb3I6Omg0ZjQ0MGZlMzI2YTQ0NTBkvQQ9YWxsb2M6OmFsbG9jOjpoYW5kbGVfYWxsb2NfZXJyb3I6OnJ0X2Vycm9yOjpoMTRhMTZkZDgzZTY1ZDE5Yr4EMzxzdHIgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoN2RjYjZlZGEwZjllMTVlMr8EMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoM2UzZDdmYzVjNTcwMGJiMMAEMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZjU1ZDM4YTdlODY3ZTI0YcEEB21lbW1vdmXCBAZtZW1jbXDDBAZtZW1zZXTEBAZtZW1jcHnFBElzdGQ6OnN5c19jb21tb246OmJhY2t0cmFjZTo6X19ydXN0X2VuZF9zaG9ydF9iYWNrdHJhY2U6Omg5MjRlZGE4MDE0NGI5NTAxxgQyPGJvb2wgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGFiOWYxNjA5OWM2NWE4MTHHBElzdGQ6OnN5c19jb21tb246OmJhY2t0cmFjZTo6X19ydXN0X2VuZF9zaG9ydF9iYWNrdHJhY2U6Omg4YzE0YWY3MTg2YjgwMmRiyARBc3RkOjpwYW5pY2tpbmc6OnBhbmljX2NvdW50Ojppc196ZXJvX3Nsb3dfcGF0aDo6aGEyNTc0MDYxNDc1MWFiZWTJBEM8c3RkOjppbzo6ZXJyb3I6OkVycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhmNmU3MDgxZjBiNzUzMzQ3ygRJc3RkOjpzeXNfY29tbW9uOjpiYWNrdHJhY2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoNjNhZGFlNWMzMTQ1OGM0YssEC19fcmRsX2FsbG9jzAQ5ZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6cGx1c19vZmZzZXQ6Omg4Yzg4MTA2NzE4YjdkYTZlzQQ6ZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6bWludXNfb2Zmc2V0OjpoYjZkOTBhNmU4MWIwNDNiYs4ENGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnRvX21lbTo6aGYyOGUyMzZhNThlNGU3OWXPBDZkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpmcm9tX21lbTo6aDA2MmMwNGIyOGFlOGQxYjLQBDV3YXNtX2JpbmRnZW46Ol9fcnQ6Om1hbGxvY19mYWlsdXJlOjpoMDhjMjRkZTZhMmM3M2RlM9EEDV9fcmRsX2RlYWxsb2PSBDZkbG1hbGxvYzo6ZGxtYWxsb2M6OlRyZWVDaHVuazo6bmV4dDo6aDE4NzNiOWNkN2QzMWE5MDLTBDZkbG1hbGxvYzo6ZGxtYWxsb2M6OlRyZWVDaHVuazo6cHJldjo6aGU5YmE2OTgyNjBkOTVmYjPUBD5jb3JlOjpwYW5pYzo6cGFuaWNfaW5mbzo6UGFuaWNJbmZvOjptZXNzYWdlOjpoY2Q3MWU2ZWIzMmQwNTYzMNUEP2NvcmU6OnBhbmljOjpwYW5pY19pbmZvOjpQYW5pY0luZm86OmxvY2F0aW9uOjpoOThmZjM2NmFlODRjMTA2YdYEQWNvcmU6OnBhbmljOjpwYW5pY19pbmZvOjpQYW5pY0luZm86OmNhbl91bndpbmQ6OmgzZmMzNDZiMTA4MmNkZGJm1wQxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoMTljYWZhOGIyNzIwNDk4MtgEODxsb2c6Ok5vcExvZ2dlciBhcyBsb2c6OkxvZz46OmVuYWJsZWQ6OmhlODJhMjcxYzk2MTYxMjIx2QRlPG1hcmt1cDVldmVyOjpMb2NhbE5hbWVTdGF0aWNTZXQgYXMgc3RyaW5nX2NhY2hlOjpzdGF0aWNfc2V0czo6U3RhdGljQXRvbVNldD46OmdldDo6aDQ5ZWMxZmU2ZDk2N2I1YTLaBGI8bWFya3VwNWV2ZXI6OlByZWZpeFN0YXRpY1NldCBhcyBzdHJpbmdfY2FjaGU6OnN0YXRpY19zZXRzOjpTdGF0aWNBdG9tU2V0Pjo6Z2V0OjpoMjgwMDg0NjAwNTQzNWQ1YtsEZTxtYXJrdXA1ZXZlcjo6TmFtZXNwYWNlU3RhdGljU2V0IGFzIHN0cmluZ19jYWNoZTo6c3RhdGljX3NldHM6OlN0YXRpY0F0b21TZXQ+OjpnZXQ6OmhhNGUyOWVkYzNkNDRlNjFm3ARFcGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6aW1wOjp0aHJlYWRfeWllbGQ6Omg5Y2Y4YzY2Y2EwNzU5N2Zk3QQxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoYWMyYjVhNzY1M2E1Y2I2ZN4EMWluc3RhbnQ6Ondhc206OlN5c3RlbVRpbWU6Om5vdzo6aGQwMzZhNTM3OWRmNDNhYWXfBDE8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVfaWQ6OmgyNGM4YzRiYzg2NzAzZDAz4AQxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoMzVjMGI2MGI2YTVmZTA2YuEEMTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aGQzYThjYTg0MmM3NzhmODTiBCZzdGQ6OnByb2Nlc3M6OmFib3J0OjpoYzNhMjVkZTQ1NDcyMDc0YuMEEl9fcnVzdF9zdGFydF9wYW5pY+QEPGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OmZlbmNlcG9zdF9oZWFkOjpoZmQyMDRlODYyOTE0NTVmOeUEOGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6Om1lbV9vZmZzZXQ6Omg4MGYyOThkMmVkN2Q2ZmZj5gQ3ZGxtYWxsb2M6OmRsbWFsbG9jOjpUcmVlQ2h1bms6OmNodW5rOjpoNjcyMGJmMTBmZWI0NTVlZOcESDxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OnJlbWFwOjpoNzU1MWQ2ZDFmM2Y1OTYwNegETDxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OmZyZWVfcGFydDo6aGM3YTFmOWU1MTg3YWM3YmLpBEc8ZGxtYWxsb2M6OnN5czo6U3lzdGVtIGFzIGRsbWFsbG9jOjpBbGxvY2F0b3I+OjpmcmVlOjpoZDBkMGY2Y2Y2ZmY3MGQyOOoEUzxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OmNhbl9yZWxlYXNlX3BhcnQ6Omg5MzlhYTNiYWIyNGJiYWIw6wRSPGRsbWFsbG9jOjpzeXM6OlN5c3RlbSBhcyBkbG1hbGxvYzo6QWxsb2NhdG9yPjo6YWxsb2NhdGVzX3plcm9zOjpoNjFlMDg1NWU3MDIwN2U2YuwETDxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OnBhZ2Vfc2l6ZTo6aDcwNTc5YzY5YTk2NWZmMzftBDE8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVfaWQ6Omg2MTEyOWZiNjVjNGQzNjll7gRMY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHN0ZDo6dGhyZWFkOjpsb2NhbDo6QWNjZXNzRXJyb3I+OjpoOTBhMzkxOTNlNTIzNjZkNe8ERGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpjZWxsOjpCb3Jyb3dFcnJvcj46OmhjZDE0ZDU0ZTBlZjJkZDRk8ARzY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPDxjb3JlOjpjZWxsOjpSZWZDZWxsPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OkJvcnJvd2VkUGxhY2Vob2xkZXI+OjpoODU2ODUzMTk5NmEyYjY5YvEET2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmbWFya3VwNWV2ZXI6OmludGVyZmFjZTo6QXR0cmlidXRlPjo6aDQ0ZmY1MDAzMDZmZDJhMGbyBE5jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6U3VidGVuZHJpbEVycm9yPjo6aGZlNTFhM2Y2ZjY5ZjVkZTbzBE5jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8JmFsbG9jOjpyYzo6UmM8Y29yZTo6cmNkb206Ok5vZGU+Pjo6aGY4YmQzYmU1ZjExNDE5MmP0BERjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6Y2VsbDo6Qm9ycm93RXJyb3I+OjpoY2QxNGQ1NGUwZWYyZGQ0ZPUEPWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpmbXQ6OkVycm9yPjo6aDc1ZmIxZDZjNmE4YjgyNzT2BEdjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Jm11dCBhbGxvYzo6c3RyaW5nOjpTdHJpbmc+OjpoYzY3ZGJiNzg3NjUxYTQzY/cEMWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmdTMyPjo6aGI1OTQ3ZDUwYTQ2NjQ3ODn4BE9jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Jm1hcmt1cDVldmVyOjppbnRlcmZhY2U6OkF0dHJpYnV0ZT46Omg0MDhkYzNhM2VlNzRmOGM3+QRbY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZ0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPHRlbmRyaWw6OmZtdDo6VVRGOD4+OjpoYzNjY2M1ODcxN2M4ZGY2Y/oEMWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxib29sPjo6aDBjN2MwZjE2M2ExNjdkM2P7BFNjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Jmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpzdGF0ZXM6OlJhd0tpbmQ+OjpoMDhjN2U4MmUzYjUzY2ZhOfwEUmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmaHRtbDVldmVyOjp0b2tlbml6ZXI6OmludGVyZmFjZTo6VGFnPjo6aDA0MDVmMTA1ZDc3YWJiMTf9BDdjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8bG9nOjpMZXZlbD46Omg2MjY5ZDhjYWUyNGQxOWY1/gQ0PGxvZzo6Tm9wTG9nZ2VyIGFzIGxvZzo6TG9nPjo6bG9nOjpoYTZiMGJlNmZlZWM1MjAyZf8ENjxsb2c6Ok5vcExvZ2dlciBhcyBsb2c6OkxvZz46OmZsdXNoOjpoM2MwMjQ1ODUwZjYwODljN4AFhAFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8JmFsbG9jOjpjb2xsZWN0aW9uczo6dmVjX2RlcXVlOjpWZWNEZXF1ZTx0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPHRlbmRyaWw6OmZtdDo6VVRGOD4+Pjo6aDU0ODVlMWIxNzFjNjFjOTGBBWRjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8JnN0cmluZ19jYWNoZTo6YXRvbTo6QXRvbTxtYXJrdXA1ZXZlcjo6UHJlZml4U3RhdGljU2V0Pj46OmgxOWNjMDBlYmRmM2VjMzNlggVbY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZ0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPHRlbmRyaWw6OmZtdDo6VVRGOD4+OjpoNjI4ODg5YzY0MGVjZTVkNIMFXGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OlBhbmljUGF5bG9hZDwmc3RyPj46OmhkYWJkNjcxMmI1MTJkZGEwhAUxY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZzdHI+OjpoYjFmOTFjZWZlYTlkYzE0MYUFfjxwYXJraW5nX2xvdF9jb3JlOjp0aHJlYWRfcGFya2VyOjppbXA6OlRocmVhZFBhcmtlciBhcyBwYXJraW5nX2xvdF9jb3JlOjp0aHJlYWRfcGFya2VyOjpUaHJlYWRQYXJrZXJUPjo6bmV3OjpoODcxNmVjZjQ5NDA0OWQxNYYFaWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmbXV0IHN0ZDo6aW86OldyaXRlOjp3cml0ZV9mbXQ6OkFkYXB0ZXI8YWxsb2M6OnZlYzo6VmVjPHU4Pj4+OjpoMDU0ZmU1ZmRmNGZjMDliZYcFLHN0ZDo6ZnM6Ok9wZW5PcHRpb25zOjpuZXc6Omg0NTM3YzY0OGFlYzI1ZTRhiAUyY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHVzaXplPjo6aDg2ZmRmYzMwOWFkNzEyODaJBW9jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8JmNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjpjb3BpZWQ6OkNvcGllZDxjb3JlOjpzbGljZTo6aXRlcjo6SXRlcjx1OD4+Pjo6aDAxOTk1ZmNmMzc5NjFmZDUA+4CAgAAJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjcwLjAgKDkwYzU0MTgwNiAyMDIzLTA1LTMxKQZ3YWxydXMGMC4xOS4wDHdhc20tYmluZGdlbhIwLjIuNzggKDdmODIwZGI0YikArICAgAAPdGFyZ2V0X2ZlYXR1cmVzAisPbXV0YWJsZS1nbG9iYWxzKwhzaWduLWV4dA=="
    ),
    (c2) => c2.charCodeAt(0)
  );
  const { instance, module: module2 } = await load(input, imports);
  wasm = instance.exports;
  init.__wbindgen_wasm_module = module2;
  return wasm;
}
var deno_wasm_default = init;

// https://deno.land/x/deno_dom@v0.1.43/src/parser.ts
init_define_BUILD_INFO();
var parse2 = (_html) => {
  console.error("Error: deno-dom: No parser registered");
  Deno.exit(1);
};
var parseFrag = (_html, _contextLocalName) => {
  console.error("Error: deno-dom: No parser registered");
  Deno.exit(1);
};
var originalParse = parse2;
function register(func, fragFunc) {
  if (parse2 !== originalParse) {
    return;
  }
  parse2 = func;
  parseFrag = fragFunc;
}

// https://deno.land/x/deno_dom@v0.1.43/src/api.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/deserialize.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/constructor-lock.ts
init_define_BUILD_INFO();
var CTOR_KEY = Symbol();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/node.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/node-list.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/html-collection.ts
init_define_BUILD_INFO();
var HTMLCollectionMutatorSym = Symbol();
var HTMLCollectionClass = (() => {
  class HTMLCollection2 extends Array {
    // @ts-ignore
    forEach(cb, thisArg = void 0) {
      super.forEach(cb, thisArg);
    }
    item(index) {
      return this[index] ?? null;
    }
    [HTMLCollectionMutatorSym]() {
      return {
        push: Array.prototype.push.bind(this),
        splice: Array.prototype.splice.bind(this),
        indexOf: Array.prototype.indexOf.bind(this)
      };
    }
    toString() {
      return "[object HTMLCollection]";
    }
  }
  return HTMLCollection2;
})();
for (const staticMethod of [
  "from",
  "isArray",
  "of"
]) {
  HTMLCollectionClass[staticMethod] = void 0;
}
for (const instanceMethod of [
  "concat",
  "copyWithin",
  "every",
  "fill",
  "filter",
  "find",
  "findIndex",
  "flat",
  "flatMap",
  "includes",
  "indexOf",
  "join",
  "lastIndexOf",
  "map",
  "pop",
  "push",
  "reduce",
  "reduceRight",
  "reverse",
  "shift",
  "slice",
  "some",
  "sort",
  "splice",
  "toLocaleString",
  "unshift",
  // Unlike NodeList, HTMLCollection also doesn't implement these
  "entries",
  "forEach",
  "keys",
  "values"
]) {
  HTMLCollectionClass.prototype[instanceMethod] = void 0;
}
var HTMLCollection = HTMLCollectionClass;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/node-list.ts
var nodeListMutatorSym = Symbol();
var nodeListCachedMutator = Symbol();
var { push, splice, slice, indexOf, filter } = Array.prototype;
var NodeListMutatorImpl = class {
  constructor(arrayInstance) {
    this.arrayInstance = arrayInstance;
  }
  // There should only ever be one elementView per element. Element views
  // are basically just the source of HTMLCollections/.children properties
  // on elements that are always in sync with their .childNodes counterpart.
  elementViews = [];
  push(...items) {
    for (const view of this.elementViews) {
      for (const item of items) {
        if (item.nodeType === Node.ELEMENT_NODE) {
          push.call(view, item);
        }
      }
    }
    return push.call(this.arrayInstance, ...items);
  }
  splice(index, deleteCount = 0, ...items) {
    for (const view of this.elementViews) {
      const toDelete = filter.call(
        slice.call(this.arrayInstance, index, index + deleteCount),
        (item) => item.nodeType === Node.ELEMENT_NODE
      );
      const toInsert = items.filter(
        (item) => item.nodeType === Node.ELEMENT_NODE
      );
      let elementViewSpliceIndex = -1;
      for (let idx = index; idx < this.arrayInstance.length; idx++) {
        const item = this.arrayInstance[idx];
        if (item.nodeType === Node.ELEMENT_NODE) {
          elementViewSpliceIndex = indexOf.call(view, item);
          break;
        }
      }
      if (elementViewSpliceIndex === -1) {
        elementViewSpliceIndex = view.length;
      }
      if (toDelete.length) {
        splice.call(view, elementViewSpliceIndex, toDelete.length);
      }
      splice.call(view, elementViewSpliceIndex, 0, ...toInsert);
    }
    return splice.call(this.arrayInstance, index, deleteCount, ...items);
  }
  indexOf(item, fromIndex = 0) {
    return indexOf.call(this.arrayInstance, item, fromIndex);
  }
  indexOfElementsView(item, fromIndex = 0) {
    return indexOf.call(this.elementsView(), item, fromIndex);
  }
  // Return the elements-only view for this NodeList. Creates one if
  // it doesn't already exist.
  elementsView() {
    let view = this.elementViews[0];
    if (!view) {
      view = new HTMLCollection();
      this.elementViews.push(view);
      push.call(
        view,
        ...filter.call(
          this.arrayInstance,
          (item) => item.nodeType === Node.ELEMENT_NODE
        )
      );
    }
    return view;
  }
};
var NodeListClass = (() => {
  class NodeList2 extends Array {
    // @ts-ignore
    forEach(cb, thisArg = void 0) {
      super.forEach(cb, thisArg);
    }
    item(index) {
      return this[index] ?? null;
    }
    [nodeListMutatorSym]() {
      const cachedMutator = this[nodeListCachedMutator];
      if (cachedMutator) {
        return cachedMutator;
      } else {
        const cachedMutator2 = new NodeListMutatorImpl(this);
        this[nodeListCachedMutator] = cachedMutator2;
        return cachedMutator2;
      }
    }
    toString() {
      return "[object NodeList]";
    }
  }
  return NodeList2;
})();
for (const staticMethod of [
  "from",
  "isArray",
  "of"
]) {
  NodeListClass[staticMethod] = void 0;
}
for (const instanceMethod of [
  "concat",
  "copyWithin",
  "every",
  "fill",
  "filter",
  "find",
  "findIndex",
  "flat",
  "flatMap",
  "includes",
  "indexOf",
  "join",
  "lastIndexOf",
  "map",
  "pop",
  "push",
  "reduce",
  "reduceRight",
  "reverse",
  "shift",
  "slice",
  "some",
  "sort",
  "splice",
  "toLocaleString",
  "unshift"
]) {
  NodeListClass.prototype[instanceMethod] = void 0;
}
var NodeList = NodeListClass;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/utils.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/utils-types.ts
init_define_BUILD_INFO();
var utils_types_default = {
  Element: null,
  Document: null,
  DocumentFragment: null
};

// https://deno.land/x/deno_dom@v0.1.43/src/dom/utils.ts
var upperCaseCharRe = /[A-Z]/;
var lowerCaseCharRe = /[a-z]/;
function getDatasetHtmlAttrName(name) {
  let attributeName = "data-";
  for (const char of name) {
    if (upperCaseCharRe.test(char)) {
      attributeName += "-" + char.toLowerCase();
    } else {
      attributeName += char;
    }
  }
  return attributeName;
}
function getDatasetJavascriptName(name) {
  let javascriptName = "";
  let prevChar = "";
  for (const char of name.slice("data-".length)) {
    if (prevChar === "-" && lowerCaseCharRe.test(char)) {
      javascriptName += char.toUpperCase();
      prevChar = "";
    } else {
      javascriptName += prevChar;
      prevChar = char;
    }
  }
  return javascriptName + prevChar;
}
function getElementsByClassName(element, className, search) {
  for (const child of element.childNodes) {
    if (child.nodeType === 1 /* ELEMENT_NODE */) {
      const classList = className.trim().split(/\s+/);
      let matchesCount = 0;
      for (const singleClassName of classList) {
        if (child.classList.contains(singleClassName)) {
          matchesCount++;
        }
      }
      if (matchesCount === classList.length) {
        search.push(child);
      }
      getElementsByClassName(child, className, search);
    }
  }
  return search;
}
function getOuterHTMLOpeningTag(parentElement) {
  return "<" + parentElement.localName + getElementAttributesString(parentElement) + ">";
}
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function getOuterOrInnerHtml(parentElement, asOuterHtml) {
  let outerHTMLOpeningTag = "";
  let outerHTMLClosingTag = "";
  let innerHTML = "";
  if (asOuterHtml) {
    outerHTMLOpeningTag = getOuterHTMLOpeningTag(parentElement);
    outerHTMLClosingTag = `</${parentElement.localName}>`;
    if (voidElements.has(parentElement.localName)) {
      return outerHTMLOpeningTag;
    }
  }
  const initialChildNodes = parentElement.localName === "template" ? parentElement.content.childNodes : parentElement.childNodes;
  const childNodeDepth = [initialChildNodes];
  const indexDepth = [0];
  const closingTagDepth = [outerHTMLClosingTag];
  let depth = 0;
  depthLoop:
    while (depth > -1) {
      const child = childNodeDepth[depth][indexDepth[depth]];
      if (child) {
        switch (child.nodeType) {
          case 1 /* ELEMENT_NODE */: {
            innerHTML += getOuterHTMLOpeningTag(child);
            const childLocalName = child.localName;
            if (!voidElements.has(childLocalName)) {
              if (childLocalName === "template") {
                childNodeDepth.push(
                  child.content.childNodes
                );
              } else {
                childNodeDepth.push(child.childNodes);
              }
              indexDepth.push(0);
              closingTagDepth.push(`</${childLocalName}>`);
              depth++;
              continue depthLoop;
            }
            break;
          }
          case 8 /* COMMENT_NODE */:
            innerHTML += `<!--${child.data}-->`;
            break;
          case 3 /* TEXT_NODE */:
            switch (child.parentNode.localName) {
              case "style":
              case "script":
              case "xmp":
              case "iframe":
              case "noembed":
              case "noframes":
              case "plaintext":
                innerHTML += child.data;
                break;
              default:
                innerHTML += child.data.replace(/&/g, "&amp;").replace(/\xA0/g, "&nbsp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                break;
            }
            break;
        }
      } else {
        depth--;
        indexDepth.pop();
        childNodeDepth.pop();
        innerHTML += closingTagDepth.pop();
      }
      indexDepth[depth]++;
    }
  return outerHTMLOpeningTag + innerHTML;
}
function getElementAttributesString(element) {
  let out = "";
  for (const attribute of element.getAttributeNames()) {
    out += ` ${attribute.toLowerCase()}`;
    out += `="${element.getAttribute(attribute).replace(/&/g, "&amp;").replace(/\xA0/g, "&nbsp;").replace(/"/g, "&quot;")}"`;
  }
  return out;
}
function insertBeforeAfter(node, nodes, before) {
  const parentNode = node.parentNode;
  const mutator = parentNode._getChildNodesMutator();
  let viablePrevNextSibling = null;
  {
    const difference = before ? -1 : 1;
    for (let i3 = mutator.indexOf(node) + difference; 0 <= i3 && i3 < parentNode.childNodes.length; i3 += difference) {
      if (!nodes.includes(parentNode.childNodes[i3])) {
        viablePrevNextSibling = parentNode.childNodes[i3];
        break;
      }
    }
  }
  nodes = nodesAndTextNodes(nodes, parentNode);
  let index;
  if (viablePrevNextSibling) {
    index = mutator.indexOf(viablePrevNextSibling) + (before ? 1 : 0);
  } else {
    index = before ? 0 : parentNode.childNodes.length;
  }
  mutator.splice(index, 0, ...nodes);
}
function isDocumentFragment(node) {
  let obj = node;
  if (!(obj && typeof obj === "object")) {
    return false;
  }
  while (true) {
    switch (obj.constructor) {
      case utils_types_default.DocumentFragment:
        return true;
      case Node:
      case utils_types_default.Element:
        return false;
      case Object:
      case null:
      case void 0:
        return false;
      default:
        obj = Reflect.getPrototypeOf(obj);
    }
  }
}
function moveDocumentFragmentChildren(fragment, newParent) {
  const childCount = fragment.childNodes.length;
  for (const child of fragment.childNodes) {
    child._setParent(newParent);
  }
  const mutator = fragment._getChildNodesMutator();
  mutator.splice(0, childCount);
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/node.ts
var nodesAndTextNodes = (nodes, parentNode) => {
  return nodes.flatMap((n2) => {
    if (isDocumentFragment(n2)) {
      const children = Array.from(n2.childNodes);
      moveDocumentFragmentChildren(n2, parentNode);
      return children;
    } else {
      const node = n2 instanceof Node ? n2 : new Text2("" + n2);
      if (n2 === node && parentNode) {
        parentNode._assertNotAncestor(node);
      }
      node._remove(true);
      node._setParent(parentNode, true);
      return [node];
    }
  });
};
var Node = class _Node extends EventTarget {
  constructor(nodeName, nodeType, parentNode, key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor.");
    }
    super();
    this.nodeName = nodeName;
    this.nodeType = nodeType;
    this.#nodeValue = null;
    this.childNodes = new NodeList();
    this.#childNodesMutator = this.childNodes[nodeListMutatorSym]();
    this.parentElement = parentNode;
    if (parentNode) {
      parentNode.appendChild(this);
    }
  }
  #nodeValue = null;
  childNodes;
  parentNode = null;
  parentElement;
  #childNodesMutator;
  #ownerDocument = null;
  _ancestors = /* @__PURE__ */ new Set();
  // Instance constants defined after Node
  // class body below to avoid clutter
  static ELEMENT_NODE = 1 /* ELEMENT_NODE */;
  static ATTRIBUTE_NODE = 2 /* ATTRIBUTE_NODE */;
  static TEXT_NODE = 3 /* TEXT_NODE */;
  static CDATA_SECTION_NODE = 4 /* CDATA_SECTION_NODE */;
  static ENTITY_REFERENCE_NODE = 5 /* ENTITY_REFERENCE_NODE */;
  static ENTITY_NODE = 6 /* ENTITY_NODE */;
  static PROCESSING_INSTRUCTION_NODE = 7 /* PROCESSING_INSTRUCTION_NODE */;
  static COMMENT_NODE = 8 /* COMMENT_NODE */;
  static DOCUMENT_NODE = 9 /* DOCUMENT_NODE */;
  static DOCUMENT_TYPE_NODE = 10 /* DOCUMENT_TYPE_NODE */;
  static DOCUMENT_FRAGMENT_NODE = 11 /* DOCUMENT_FRAGMENT_NODE */;
  static NOTATION_NODE = 12 /* NOTATION_NODE */;
  _getChildNodesMutator() {
    return this.#childNodesMutator;
  }
  /**
   * Update ancestor chain & owner document for this child
   * and all its children.
   */
  _setParent(newParent, force = false) {
    const sameParent = this.parentNode === newParent;
    const shouldUpdateParentAndAncestors = !sameParent || force;
    if (shouldUpdateParentAndAncestors) {
      this.parentNode = newParent;
      if (newParent) {
        if (!sameParent) {
          if (newParent.nodeType === 1 /* ELEMENT_NODE */) {
            this.parentElement = newParent;
          } else {
            this.parentElement = null;
          }
          this._setOwnerDocument(newParent.#ownerDocument);
        }
        this._ancestors = new Set(newParent._ancestors);
        this._ancestors.add(newParent);
      } else {
        this.parentElement = null;
        this._ancestors.clear();
      }
      for (const child of this.childNodes) {
        child._setParent(this, shouldUpdateParentAndAncestors);
      }
    }
  }
  _assertNotAncestor(child) {
    if (child.contains(this)) {
      throw new DOMException("The new child is an ancestor of the parent");
    }
  }
  _setOwnerDocument(document2) {
    if (this.#ownerDocument !== document2) {
      this.#ownerDocument = document2;
      for (const child of this.childNodes) {
        child._setOwnerDocument(document2);
      }
    }
  }
  contains(child) {
    return child._ancestors.has(this) || child === this;
  }
  get ownerDocument() {
    return this.#ownerDocument;
  }
  get nodeValue() {
    return this.#nodeValue;
  }
  set nodeValue(value) {
  }
  get textContent() {
    let out = "";
    for (const child of this.childNodes) {
      switch (child.nodeType) {
        case 3 /* TEXT_NODE */:
          out += child.nodeValue;
          break;
        case 1 /* ELEMENT_NODE */:
          out += child.textContent;
          break;
      }
    }
    return out;
  }
  set textContent(content) {
    for (const child of this.childNodes) {
      child._setParent(null);
    }
    this._getChildNodesMutator().splice(0, this.childNodes.length);
    this.appendChild(new Text2(content));
  }
  get firstChild() {
    return this.childNodes[0] || null;
  }
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  hasChildNodes() {
    return Boolean(this.childNodes.length);
  }
  cloneNode(deep = false) {
    const copy = this._shallowClone();
    copy._setOwnerDocument(this.ownerDocument);
    if (deep) {
      for (const child of this.childNodes) {
        copy.appendChild(child.cloneNode(true));
      }
    }
    return copy;
  }
  _shallowClone() {
    throw new Error("Illegal invocation");
  }
  _remove(skipSetParent = false) {
    const parent = this.parentNode;
    if (parent) {
      const nodeList = parent._getChildNodesMutator();
      const idx = nodeList.indexOf(this);
      nodeList.splice(idx, 1);
      if (!skipSetParent) {
        this._setParent(null);
      }
    }
  }
  appendChild(child) {
    if (isDocumentFragment(child)) {
      const mutator = this._getChildNodesMutator();
      mutator.push(...child.childNodes);
      moveDocumentFragmentChildren(child, this);
      return child;
    } else {
      return child._appendTo(this);
    }
  }
  _appendTo(parentNode) {
    parentNode._assertNotAncestor(this);
    const oldParentNode = this.parentNode;
    if (oldParentNode === parentNode) {
      if (parentNode._getChildNodesMutator().indexOf(this) !== -1) {
        return this;
      }
    } else if (oldParentNode) {
      this._remove();
    }
    this._setParent(parentNode, true);
    parentNode._getChildNodesMutator().push(this);
    return this;
  }
  removeChild(child) {
    if (child && typeof child === "object") {
      if (child.parentNode === this) {
        child._remove();
        return child;
      } else {
        throw new DOMException(
          "Node.removeChild: The node to be removed is not a child of this node"
        );
      }
    } else {
      throw new TypeError("Node.removeChild: Argument 1 is not an object.");
    }
  }
  replaceChild(newChild, oldChild) {
    if (oldChild.parentNode !== this) {
      throw new Error("Old child's parent is not the current node.");
    }
    oldChild._replaceWith(newChild);
    return oldChild;
  }
  insertBefore(newNode, refNode) {
    this._assertNotAncestor(newNode);
    const mutator = this._getChildNodesMutator();
    if (refNode === null) {
      this.appendChild(newNode);
      return newNode;
    }
    const index = mutator.indexOf(refNode);
    if (index === -1) {
      throw new Error(
        "DOMException: Child to insert before is not a child of this node"
      );
    }
    if (isDocumentFragment(newNode)) {
      mutator.splice(index, 0, ...newNode.childNodes);
      moveDocumentFragmentChildren(newNode, this);
    } else {
      const oldParentNode = newNode.parentNode;
      const oldMutator = oldParentNode?._getChildNodesMutator();
      if (oldMutator) {
        oldMutator.splice(oldMutator.indexOf(newNode), 1);
      }
      newNode._setParent(this, oldParentNode !== this);
      mutator.splice(index, 0, newNode);
    }
    return newNode;
  }
  _replaceWith(...nodes) {
    if (this.parentNode) {
      const parentNode = this.parentNode;
      const mutator = parentNode._getChildNodesMutator();
      let viableNextSibling = null;
      {
        const thisIndex = mutator.indexOf(this);
        for (let i3 = thisIndex + 1; i3 < parentNode.childNodes.length; i3++) {
          if (!nodes.includes(parentNode.childNodes[i3])) {
            viableNextSibling = parentNode.childNodes[i3];
            break;
          }
        }
      }
      nodes = nodesAndTextNodes(nodes, parentNode);
      let index = viableNextSibling ? mutator.indexOf(viableNextSibling) : parentNode.childNodes.length;
      let deleteNumber;
      if (parentNode.childNodes[index - 1] === this) {
        index--;
        deleteNumber = 1;
      } else {
        deleteNumber = 0;
      }
      mutator.splice(index, deleteNumber, ...nodes);
      this._setParent(null);
    }
  }
  get nextSibling() {
    const parent = this.parentNode;
    if (!parent) {
      return null;
    }
    const index = parent._getChildNodesMutator().indexOf(this);
    const next = parent.childNodes[index + 1] || null;
    return next;
  }
  get previousSibling() {
    const parent = this.parentNode;
    if (!parent) {
      return null;
    }
    const index = parent._getChildNodesMutator().indexOf(this);
    const prev = parent.childNodes[index - 1] || null;
    return prev;
  }
  // Node.compareDocumentPosition()'s bitmask values
  static DOCUMENT_POSITION_DISCONNECTED = 1;
  static DOCUMENT_POSITION_PRECEDING = 2;
  static DOCUMENT_POSITION_FOLLOWING = 4;
  static DOCUMENT_POSITION_CONTAINS = 8;
  static DOCUMENT_POSITION_CONTAINED_BY = 16;
  static DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
  /**
   * FIXME: Does not implement attribute node checks
   * ref: https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
   * MDN: https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
   */
  compareDocumentPosition(other) {
    if (other === this) {
      return 0;
    }
    if (!(other instanceof _Node)) {
      throw new TypeError(
        "Node.compareDocumentPosition: Argument 1 does not implement interface Node."
      );
    }
    let node1Root = other;
    let node2Root = this;
    const node1Hierarchy = [node1Root];
    const node2Hierarchy = [node2Root];
    while (node1Root.parentNode ?? node2Root.parentNode) {
      node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
      node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
    }
    if (node1Root !== node2Root) {
      return _Node.DOCUMENT_POSITION_DISCONNECTED | _Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | _Node.DOCUMENT_POSITION_PRECEDING;
    }
    const longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
    const shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
    if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
      return longerHierarchy === node1Hierarchy ? _Node.DOCUMENT_POSITION_CONTAINED_BY | _Node.DOCUMENT_POSITION_FOLLOWING : _Node.DOCUMENT_POSITION_CONTAINS | _Node.DOCUMENT_POSITION_PRECEDING;
    }
    const longerStart = longerHierarchy.length - shorterHierarchy.length;
    for (let i3 = shorterHierarchy.length - 1; i3 >= 0; i3--) {
      const shorterHierarchyNode = shorterHierarchy[i3];
      const longerHierarchyNode = longerHierarchy[longerStart + i3];
      if (longerHierarchyNode !== shorterHierarchyNode) {
        const siblings = shorterHierarchyNode.parentNode._getChildNodesMutator();
        if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
          if (shorterHierarchy === node1Hierarchy) {
            return _Node.DOCUMENT_POSITION_PRECEDING;
          } else {
            return _Node.DOCUMENT_POSITION_FOLLOWING;
          }
        } else {
          if (longerHierarchy === node1Hierarchy) {
            return _Node.DOCUMENT_POSITION_PRECEDING;
          } else {
            return _Node.DOCUMENT_POSITION_FOLLOWING;
          }
        }
      }
    }
    return _Node.DOCUMENT_POSITION_FOLLOWING;
  }
  getRootNode(opts = {}) {
    if (this.parentNode) {
      return this.parentNode.getRootNode(opts);
    }
    if (opts.composed && this.host) {
      return this.host.getRootNode(opts);
    }
    return this;
  }
};
Node.prototype.ELEMENT_NODE = 1 /* ELEMENT_NODE */;
Node.prototype.ATTRIBUTE_NODE = 2 /* ATTRIBUTE_NODE */;
Node.prototype.TEXT_NODE = 3 /* TEXT_NODE */;
Node.prototype.CDATA_SECTION_NODE = 4 /* CDATA_SECTION_NODE */;
Node.prototype.ENTITY_REFERENCE_NODE = 5 /* ENTITY_REFERENCE_NODE */;
Node.prototype.ENTITY_NODE = 6 /* ENTITY_NODE */;
Node.prototype.PROCESSING_INSTRUCTION_NODE = 7 /* PROCESSING_INSTRUCTION_NODE */;
Node.prototype.COMMENT_NODE = 8 /* COMMENT_NODE */;
Node.prototype.DOCUMENT_NODE = 9 /* DOCUMENT_NODE */;
Node.prototype.DOCUMENT_TYPE_NODE = 10 /* DOCUMENT_TYPE_NODE */;
Node.prototype.DOCUMENT_FRAGMENT_NODE = 11 /* DOCUMENT_FRAGMENT_NODE */;
Node.prototype.NOTATION_NODE = 12 /* NOTATION_NODE */;
var CharacterData = class extends Node {
  #nodeValue = "";
  constructor(data, nodeName, nodeType, parentNode, key) {
    super(
      nodeName,
      nodeType,
      parentNode,
      key
    );
    this.#nodeValue = data;
  }
  get nodeValue() {
    return this.#nodeValue;
  }
  set nodeValue(value) {
    this.#nodeValue = String(value ?? "");
  }
  get data() {
    return this.#nodeValue;
  }
  set data(value) {
    this.nodeValue = value;
  }
  get textContent() {
    return this.#nodeValue;
  }
  set textContent(value) {
    this.nodeValue = value;
  }
  get length() {
    return this.data.length;
  }
  before(...nodes) {
    if (this.parentNode) {
      insertBeforeAfter(this, nodes, true);
    }
  }
  after(...nodes) {
    if (this.parentNode) {
      insertBeforeAfter(this, nodes, false);
    }
  }
  remove() {
    this._remove();
  }
  replaceWith(...nodes) {
    this._replaceWith(...nodes);
  }
  // TODO: Implement NonDocumentTypeChildNode.nextElementSibling, etc
  // ref: https://developer.mozilla.org/en-US/docs/Web/API/CharacterData
};
var Text2 = class _Text extends CharacterData {
  constructor(text = "") {
    super(
      String(text),
      "#text",
      3 /* TEXT_NODE */,
      null,
      CTOR_KEY
    );
  }
  _shallowClone() {
    return new _Text(this.textContent);
  }
  get textContent() {
    return this.nodeValue;
  }
};
var Comment2 = class _Comment extends CharacterData {
  constructor(text = "") {
    super(
      String(text),
      "#comment",
      8 /* COMMENT_NODE */,
      null,
      CTOR_KEY
    );
  }
  _shallowClone() {
    return new _Comment(this.textContent);
  }
  get textContent() {
    return this.nodeValue;
  }
};

// https://deno.land/x/deno_dom@v0.1.43/src/dom/document.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/element.ts
init_define_BUILD_INFO();
var DOMTokenList = class _DOMTokenList {
  #_value = "";
  get #value() {
    return this.#_value;
  }
  set #value(value) {
    this.#_value = value;
    this.#onChange(value);
  }
  #set = /* @__PURE__ */ new Set();
  #onChange;
  constructor(onChange, key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor");
    }
    this.#onChange = onChange;
  }
  static #invalidToken(token) {
    return token === "" || /[\t\n\f\r ]/.test(token);
  }
  #setIndices() {
    const classes = Array.from(this.#set);
    for (let i3 = 0; i3 < classes.length; i3++) {
      this[i3] = classes[i3];
    }
  }
  set value(input) {
    this.#value = input;
    this.#set = new Set(
      input.trim().split(/[\t\n\f\r\s]+/g).filter(Boolean)
    );
    this.#setIndices();
  }
  get value() {
    return this.#_value;
  }
  get length() {
    return this.#set.size;
  }
  *entries() {
    const array = Array.from(this.#set);
    for (let i3 = 0; i3 < array.length; i3++) {
      yield [i3, array[i3]];
    }
  }
  *values() {
    yield* this.#set.values();
  }
  *keys() {
    for (let i3 = 0; i3 < this.#set.size; i3++) {
      yield i3;
    }
  }
  *[Symbol.iterator]() {
    yield* this.#set.values();
  }
  item(index) {
    index = Number(index);
    if (Number.isNaN(index) || index === Infinity)
      index = 0;
    return this[Math.trunc(index) % 2 ** 32] ?? null;
  }
  contains(element) {
    return this.#set.has(element);
  }
  add(...elements) {
    for (const element of elements) {
      if (_DOMTokenList.#invalidToken(element)) {
        throw new DOMException(
          "Failed to execute 'add' on 'DOMTokenList': The token provided must not be empty."
        );
      }
      const { size } = this.#set;
      this.#set.add(element);
      if (size < this.#set.size) {
        this[size] = element;
      }
    }
    this.#updateClassString();
  }
  remove(...elements) {
    const { size } = this.#set;
    for (const element of elements) {
      if (_DOMTokenList.#invalidToken(element)) {
        throw new DOMException(
          "Failed to execute 'remove' on 'DOMTokenList': The token provided must not be empty."
        );
      }
      this.#set.delete(element);
    }
    if (size !== this.#set.size) {
      for (let i3 = this.#set.size; i3 < size; i3++) {
        delete this[i3];
      }
      this.#setIndices();
    }
    this.#updateClassString();
  }
  replace(oldToken, newToken) {
    if ([oldToken, newToken].some((v2) => _DOMTokenList.#invalidToken(v2))) {
      throw new DOMException(
        "Failed to execute 'replace' on 'DOMTokenList': The token provided must not be empty."
      );
    }
    if (!this.#set.has(oldToken)) {
      return false;
    }
    if (this.#set.has(newToken)) {
      this.remove(oldToken);
    } else {
      this.#set.delete(oldToken);
      this.#set.add(newToken);
      this.#setIndices();
      this.#updateClassString();
    }
    return true;
  }
  supports() {
    throw new Error("Not implemented");
  }
  toggle(element, force) {
    if (force !== void 0) {
      const operation = force ? "add" : "remove";
      this[operation](element);
      return false;
    } else {
      const contains = this.contains(element);
      const operation = contains ? "remove" : "add";
      this[operation](element);
      return !contains;
    }
  }
  forEach(callback) {
    for (const [i3, value] of this.entries()) {
      callback(value, i3, this);
    }
  }
  #updateClassString() {
    this.#value = Array.from(this.#set).join(" ");
  }
};
var setNamedNodeMapOwnerElementSym = Symbol();
var setAttrValueSym = Symbol();
var Attr = class _Attr extends Node {
  #namedNodeMap = null;
  #name = "";
  #value = "";
  #ownerElement = null;
  constructor(map2, name, value, key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor");
    }
    super(name, 2 /* ATTRIBUTE_NODE */, null, CTOR_KEY);
    this.#name = name;
    this.#value = value;
    this.#namedNodeMap = map2;
  }
  [setNamedNodeMapOwnerElementSym](ownerElement) {
    this.#ownerElement = ownerElement;
    this.#namedNodeMap = ownerElement?.attributes ?? null;
    if (ownerElement) {
      this._setOwnerDocument(ownerElement.ownerDocument);
    }
  }
  [setAttrValueSym](value) {
    this.#value = value;
  }
  _shallowClone() {
    const newAttr = new _Attr(null, this.#name, this.#value, CTOR_KEY);
    newAttr._setOwnerDocument(this.ownerDocument);
    return newAttr;
  }
  cloneNode() {
    return super.cloneNode();
  }
  appendChild() {
    throw new DOMException("Cannot add children to an Attribute");
  }
  replaceChild() {
    throw new DOMException("Cannot add children to an Attribute");
  }
  insertBefore() {
    throw new DOMException("Cannot add children to an Attribute");
  }
  removeChild() {
    throw new DOMException(
      "The node to be removed is not a child of this node"
    );
  }
  get name() {
    return this.#name;
  }
  get localName() {
    return this.#name;
  }
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = String(value);
    if (this.#namedNodeMap) {
      this.#namedNodeMap[setNamedNodeMapValueSym](
        this.#name,
        this.#value,
        true
      );
    }
  }
  get ownerElement() {
    return this.#ownerElement ?? null;
  }
  get specified() {
    return true;
  }
  // TODO
  get prefix() {
    return null;
  }
};
var setNamedNodeMapValueSym = Symbol();
var getNamedNodeMapValueSym = Symbol();
var getNamedNodeMapAttrNamesSym = Symbol();
var getNamedNodeMapAttrNodeSym = Symbol();
var removeNamedNodeMapAttrSym = Symbol();
var NamedNodeMap = class _NamedNodeMap {
  static #indexedAttrAccess = function(map2, index) {
    if (index + 1 > this.length) {
      return void 0;
    }
    const attribute = Object.keys(map2).filter((attribute2) => map2[attribute2] !== void 0)[index]?.slice(1);
    return this[getNamedNodeMapAttrNodeSym](attribute);
  };
  #onAttrNodeChange;
  constructor(ownerElement, onAttrNodeChange, key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor.");
    }
    this.#ownerElement = ownerElement;
    this.#onAttrNodeChange = onAttrNodeChange;
  }
  #attrNodeCache = {};
  #map = {};
  #length = 0;
  #capacity = 0;
  #ownerElement = null;
  [getNamedNodeMapAttrNodeSym](attribute) {
    const safeAttrName = "a" + attribute;
    let attrNode = this.#attrNodeCache[safeAttrName];
    if (!attrNode) {
      attrNode = this.#attrNodeCache[safeAttrName] = new Attr(
        this,
        attribute,
        this.#map[safeAttrName],
        CTOR_KEY
      );
      attrNode[setNamedNodeMapOwnerElementSym](this.#ownerElement);
    }
    return attrNode;
  }
  [getNamedNodeMapAttrNamesSym]() {
    const names = [];
    for (const [name, value] of Object.entries(this.#map)) {
      if (value !== void 0) {
        names.push(name.slice(1));
      }
    }
    return names;
  }
  [getNamedNodeMapValueSym](attribute) {
    const safeAttrName = "a" + attribute;
    return this.#map[safeAttrName];
  }
  [setNamedNodeMapValueSym](attribute, value, bubble = false) {
    const safeAttrName = "a" + attribute;
    if (this.#map[safeAttrName] === void 0) {
      this.#length++;
      if (this.#length > this.#capacity) {
        this.#capacity = this.#length;
        const index = this.#capacity - 1;
        Object.defineProperty(this, String(this.#capacity - 1), {
          get: _NamedNodeMap.#indexedAttrAccess.bind(this, this.#map, index)
        });
      }
    } else if (this.#attrNodeCache[safeAttrName]) {
      this.#attrNodeCache[safeAttrName][setAttrValueSym](value);
    }
    this.#map[safeAttrName] = value;
    if (bubble) {
      this.#onAttrNodeChange(attribute, value);
    }
  }
  /**
   * Called when an attribute is removed from
   * an element
   */
  [removeNamedNodeMapAttrSym](attribute) {
    const safeAttrName = "a" + attribute;
    if (this.#map[safeAttrName] !== void 0) {
      this.#length--;
      this.#map[safeAttrName] = void 0;
      this.#onAttrNodeChange(attribute, null);
      const attrNode = this.#attrNodeCache[safeAttrName];
      if (attrNode) {
        attrNode[setNamedNodeMapOwnerElementSym](null);
        this.#attrNodeCache[safeAttrName] = void 0;
      }
    }
  }
  *[Symbol.iterator]() {
    for (let i3 = 0; i3 < this.length; i3++) {
      yield this[i3];
    }
  }
  get length() {
    return this.#length;
  }
  // FIXME: This method should accept anything and basically
  // coerce any non numbers (and Infinity/-Infinity) into 0
  item(index) {
    if (index >= this.#length) {
      return null;
    }
    return this[index];
  }
  getNamedItem(attribute) {
    const safeAttrName = "a" + attribute;
    if (this.#map[safeAttrName] !== void 0) {
      return this[getNamedNodeMapAttrNodeSym](attribute);
    }
    return null;
  }
  setNamedItem(attrNode) {
    if (attrNode.ownerElement) {
      throw new DOMException("Attribute already in use");
    }
    const safeAttrName = "a" + attrNode.name;
    const previousAttr = this.#attrNodeCache[safeAttrName];
    if (previousAttr) {
      previousAttr[setNamedNodeMapOwnerElementSym](null);
      this.#map[safeAttrName] = void 0;
    }
    attrNode[setNamedNodeMapOwnerElementSym](this.#ownerElement);
    this.#attrNodeCache[safeAttrName] = attrNode;
    this[setNamedNodeMapValueSym](attrNode.name, attrNode.value, true);
  }
  removeNamedItem(attribute) {
    const safeAttrName = "a" + attribute;
    if (this.#map[safeAttrName] !== void 0) {
      const attrNode = this[getNamedNodeMapAttrNodeSym](attribute);
      this[removeNamedNodeMapAttrSym](attribute);
      return attrNode;
    }
    throw new DOMException("Node was not found");
  }
};
var XML_NAMESTART_CHAR_RE_SRC = ":A-Za-z_" + String.raw`\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}` + String.raw`\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}` + String.raw`\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}`;
var XML_NAME_CHAR_RE_SRC = XML_NAMESTART_CHAR_RE_SRC + String.raw`\u{B7}\u{0300}-\u{036F}\u{203F}-\u{2040}0-9.-`;
var xmlNamestartCharRe = new RegExp(`[${XML_NAMESTART_CHAR_RE_SRC}]`, "u");
var xmlNameCharRe = new RegExp(`[${XML_NAME_CHAR_RE_SRC}]`, "u");
var Element2 = class _Element extends Node {
  constructor(tagName, parentNode, attributes, key) {
    super(
      tagName,
      1 /* ELEMENT_NODE */,
      parentNode,
      key
    );
    this.tagName = tagName;
    for (const attr of attributes) {
      this.setAttribute(attr[0], attr[1]);
      switch (attr[0]) {
        case "class":
          this.#classList.value = attr[1];
          break;
        case "id":
          this.#currentId = attr[1];
          break;
      }
    }
    this.tagName = this.nodeName = tagName.toUpperCase();
    this.localName = tagName.toLowerCase();
  }
  localName;
  attributes = new NamedNodeMap(this, (attribute, value) => {
    if (value === null) {
      value = "";
    }
    switch (attribute) {
      case "class":
        this.#classList.value = value;
        break;
      case "id":
        this.#currentId = value;
        break;
    }
  }, CTOR_KEY);
  #datasetProxy = null;
  #currentId = "";
  #classList = new DOMTokenList(
    (className) => {
      if (this.hasAttribute("class") || className !== "") {
        this.attributes[setNamedNodeMapValueSym]("class", className);
      }
    },
    CTOR_KEY
  );
  _shallowClone() {
    const attributes = [];
    for (const attribute of this.getAttributeNames()) {
      attributes.push([attribute, this.getAttribute(attribute)]);
    }
    return new _Element(this.nodeName, null, attributes, CTOR_KEY);
  }
  get childElementCount() {
    return this._getChildNodesMutator().elementsView().length;
  }
  get className() {
    return this.getAttribute("class") ?? "";
  }
  set className(className) {
    this.setAttribute("class", className);
    this.#classList.value = className;
  }
  get classList() {
    return this.#classList;
  }
  get outerHTML() {
    return getOuterOrInnerHtml(this, true);
  }
  set outerHTML(html) {
    if (this.parentNode) {
      const { parentElement, parentNode } = this;
      let contextLocalName = parentElement?.localName;
      switch (parentNode.nodeType) {
        case 9 /* DOCUMENT_NODE */: {
          throw new DOMException(
            "Modifications are not allowed for this document"
          );
        }
        case 11 /* DOCUMENT_FRAGMENT_NODE */: {
          contextLocalName = "body";
        }
        default: {
          const { childNodes: newChildNodes } = fragmentNodesFromString(html, contextLocalName).childNodes[0];
          const mutator = parentNode._getChildNodesMutator();
          const insertionIndex = mutator.indexOf(this);
          for (let i3 = newChildNodes.length - 1; i3 >= 0; i3--) {
            const child = newChildNodes[i3];
            mutator.splice(insertionIndex, 0, child);
            child._setParent(parentNode);
            child._setOwnerDocument(parentNode.ownerDocument);
          }
          this.remove();
        }
      }
    }
  }
  get innerHTML() {
    return getOuterOrInnerHtml(this, false);
  }
  set innerHTML(html) {
    for (const child of this.childNodes) {
      child._setParent(null);
    }
    const mutator = this._getChildNodesMutator();
    mutator.splice(0, this.childNodes.length);
    if (html.length) {
      const parsed = fragmentNodesFromString(html, this.localName);
      for (const child of parsed.childNodes[0].childNodes) {
        mutator.push(child);
      }
      for (const child of this.childNodes) {
        child._setParent(this);
        child._setOwnerDocument(this.ownerDocument);
      }
    }
  }
  get innerText() {
    return this.textContent;
  }
  set innerText(text) {
    this.textContent = text;
  }
  get children() {
    return this._getChildNodesMutator().elementsView();
  }
  get id() {
    return this.#currentId || "";
  }
  set id(id) {
    this.setAttribute("id", this.#currentId = id);
  }
  get dataset() {
    if (this.#datasetProxy) {
      return this.#datasetProxy;
    }
    this.#datasetProxy = new Proxy({}, {
      get: (_target, property, _receiver) => {
        if (typeof property === "string") {
          const attributeName = getDatasetHtmlAttrName(property);
          return this.getAttribute(attributeName) ?? void 0;
        }
        return void 0;
      },
      set: (_target, property, value, _receiver) => {
        if (typeof property === "string") {
          let attributeName = "data-";
          let prevChar = "";
          for (const char of property) {
            if (prevChar === "-" && lowerCaseCharRe.test(char)) {
              throw new DOMException(
                "An invalid or illegal string was specified"
              );
            }
            if (!xmlNameCharRe.test(char)) {
              throw new DOMException("String contains an invalid character");
            }
            if (upperCaseCharRe.test(char)) {
              attributeName += "-";
            }
            attributeName += char.toLowerCase();
            prevChar = char;
          }
          this.setAttribute(attributeName, String(value));
        }
        return true;
      },
      deleteProperty: (_target, property) => {
        if (typeof property === "string") {
          const attributeName = getDatasetHtmlAttrName(property);
          this.removeAttribute(attributeName);
        }
        return true;
      },
      ownKeys: (_target) => {
        return this.getAttributeNames().flatMap((attributeName) => {
          if (attributeName.startsWith?.("data-")) {
            return [getDatasetJavascriptName(attributeName)];
          } else {
            return [];
          }
        });
      },
      getOwnPropertyDescriptor: (_target, property) => {
        if (typeof property === "string") {
          const attributeName = getDatasetHtmlAttrName(property);
          if (this.hasAttribute(attributeName)) {
            return {
              writable: true,
              enumerable: true,
              configurable: true
            };
          }
        }
        return void 0;
      },
      has: (_target, property) => {
        if (typeof property === "string") {
          const attributeName = getDatasetHtmlAttrName(property);
          return this.hasAttribute(attributeName);
        }
        return false;
      }
    });
    return this.#datasetProxy;
  }
  getAttributeNames() {
    return this.attributes[getNamedNodeMapAttrNamesSym]();
  }
  getAttribute(name) {
    return this.attributes[getNamedNodeMapValueSym](name.toLowerCase()) ?? null;
  }
  setAttribute(rawName, value) {
    const name = String(rawName?.toLowerCase());
    const strValue = String(value);
    this.attributes[setNamedNodeMapValueSym](name, strValue);
    if (name === "id") {
      this.#currentId = strValue;
    } else if (name === "class") {
      this.#classList.value = strValue;
    }
  }
  removeAttribute(rawName) {
    const name = String(rawName?.toLowerCase());
    this.attributes[removeNamedNodeMapAttrSym](name);
    if (name === "class") {
      this.#classList.value = "";
    }
  }
  hasAttribute(name) {
    return this.attributes[getNamedNodeMapValueSym](
      String(name?.toLowerCase())
    ) !== void 0;
  }
  hasAttributeNS(_namespace, name) {
    return this.attributes[getNamedNodeMapValueSym](
      String(name?.toLowerCase())
    ) !== void 0;
  }
  replaceWith(...nodes) {
    this._replaceWith(...nodes);
  }
  remove() {
    this._remove();
  }
  append(...nodes) {
    const mutator = this._getChildNodesMutator();
    mutator.push(...nodesAndTextNodes(nodes, this));
  }
  prepend(...nodes) {
    const mutator = this._getChildNodesMutator();
    mutator.splice(0, 0, ...nodesAndTextNodes(nodes, this));
  }
  before(...nodes) {
    if (this.parentNode) {
      insertBeforeAfter(this, nodes, true);
    }
  }
  after(...nodes) {
    if (this.parentNode) {
      insertBeforeAfter(this, nodes, false);
    }
  }
  get firstElementChild() {
    const elements = this._getChildNodesMutator().elementsView();
    return elements[0] ?? null;
  }
  get lastElementChild() {
    const elements = this._getChildNodesMutator().elementsView();
    return elements[elements.length - 1] ?? null;
  }
  get nextElementSibling() {
    const parent = this.parentNode;
    if (!parent) {
      return null;
    }
    const mutator = parent._getChildNodesMutator();
    const index = mutator.indexOfElementsView(this);
    const elements = mutator.elementsView();
    return elements[index + 1] ?? null;
  }
  get previousElementSibling() {
    const parent = this.parentNode;
    if (!parent) {
      return null;
    }
    const mutator = parent._getChildNodesMutator();
    const index = mutator.indexOfElementsView(this);
    const elements = mutator.elementsView();
    return elements[index - 1] ?? null;
  }
  querySelector(selectors) {
    if (!this.ownerDocument) {
      throw new Error("Element must have an owner document");
    }
    return this.ownerDocument._nwapi.first(selectors, this);
  }
  querySelectorAll(selectors) {
    if (!this.ownerDocument) {
      throw new Error("Element must have an owner document");
    }
    const nodeList = new NodeList();
    const mutator = nodeList[nodeListMutatorSym]();
    for (const match of this.ownerDocument._nwapi.select(selectors, this)) {
      mutator.push(match);
    }
    return nodeList;
  }
  matches(selectorString) {
    return this.ownerDocument._nwapi.match(selectorString, this);
  }
  closest(selectorString) {
    const { match } = this.ownerDocument._nwapi;
    let el = this;
    do {
      if (match(selectorString, el)) {
        return el;
      }
      el = el.parentElement;
    } while (el !== null);
    return null;
  }
  // TODO: DRY!!!
  getElementById(id) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.id === id) {
          return child;
        }
        const search = child.getElementById(id);
        if (search) {
          return search;
        }
      }
    }
    return null;
  }
  getElementsByTagName(tagName) {
    const fixCaseTagName = tagName.toUpperCase();
    if (fixCaseTagName === "*") {
      return this._getElementsByTagNameWildcard([]);
    } else {
      return this._getElementsByTagName(tagName.toUpperCase(), []);
    }
  }
  _getElementsByTagNameWildcard(search) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        search.push(child);
        child._getElementsByTagNameWildcard(search);
      }
    }
    return search;
  }
  _getElementsByTagName(tagName, search) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.tagName === tagName) {
          search.push(child);
        }
        child._getElementsByTagName(tagName, search);
      }
    }
    return search;
  }
  getElementsByClassName(className) {
    return getElementsByClassName(this, className, []);
  }
  getElementsByTagNameNS(_namespace, localName) {
    return this.getElementsByTagName(localName);
  }
};
utils_types_default.Element = Element2;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/document-fragment.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/custom-api.ts
init_define_BUILD_INFO();
var customByTagNameSym = Symbol();
var customByClassNameSym = Symbol();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/document-fragment.ts
var DocumentFragment2 = class _DocumentFragment extends Node {
  constructor() {
    super(
      "#document-fragment",
      11 /* DOCUMENT_FRAGMENT_NODE */,
      null,
      CTOR_KEY
    );
  }
  get childElementCount() {
    return this._getChildNodesMutator().elementsView().length;
  }
  get children() {
    return this._getChildNodesMutator().elementsView();
  }
  get firstElementChild() {
    const elements = this._getChildNodesMutator().elementsView();
    return elements[0] ?? null;
  }
  get lastElementChild() {
    const elements = this._getChildNodesMutator().elementsView();
    return elements[elements.length - 1] ?? null;
  }
  _shallowClone() {
    return new _DocumentFragment();
  }
  append(...nodes) {
    const mutator = this._getChildNodesMutator();
    mutator.push(...nodesAndTextNodes(nodes, this));
  }
  prepend(...nodes) {
    const mutator = this._getChildNodesMutator();
    mutator.splice(0, 0, ...nodesAndTextNodes(nodes, this));
  }
  replaceChildren(...nodes) {
    const mutator = this._getChildNodesMutator();
    for (const child of this.childNodes) {
      child._setParent(null);
    }
    mutator.splice(0, this.childNodes.length);
    mutator.splice(0, 0, ...nodesAndTextNodes(nodes, this));
  }
  // TODO: DRY!!!
  getElementById(id) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.id === id) {
          return child;
        }
        const search = child.getElementById(id);
        if (search) {
          return search;
        }
      }
    }
    return null;
  }
  querySelector(selectors) {
    if (!this.ownerDocument) {
      throw new Error("DocumentFragment must have an owner document");
    }
    return this.ownerDocument._nwapi.first(selectors, this);
  }
  querySelectorAll(selectors) {
    if (!this.ownerDocument) {
      throw new Error("DocumentFragment must have an owner document");
    }
    const nodeList = new NodeList();
    const mutator = nodeList[nodeListMutatorSym]();
    mutator.push(
      ...this.ownerDocument._nwapi.select(selectors, this)
    );
    return nodeList;
  }
};
utils_types_default.DocumentFragment = DocumentFragment2;
function documentFragmentGetElementsByTagName(tagName) {
  const search = [];
  if (tagName === "*") {
    return documentFragmentGetElementsByTagNameWildcard(this, search);
  }
  for (const child of this.childNodes) {
    if (child.nodeType === 1 /* ELEMENT_NODE */) {
      if (child.tagName === tagName) {
        search.push(child);
      }
      child._getElementsByTagName(tagName, search);
    }
  }
  return search;
}
function documentFragmentGetElementsByClassName(className) {
  return getElementsByClassName(this, className, []);
}
function documentFragmentGetElementsByTagNameWildcard(fragment, search) {
  for (const child of fragment.childNodes) {
    if (child.nodeType === 1 /* ELEMENT_NODE */) {
      search.push(child);
      child._getElementsByTagNameWildcard(search);
    }
  }
  return search;
}
DocumentFragment2.prototype[customByTagNameSym] = documentFragmentGetElementsByTagName;
DocumentFragment2.prototype[customByClassNameSym] = documentFragmentGetElementsByClassName;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/elements/html-template-element.ts
init_define_BUILD_INFO();
var HTMLTemplateElement = class _HTMLTemplateElement extends Element2 {
  /**
   * This blocks access to the .#contents property when the
   * super() constructor is running which invokes (our
   * overridden) _setParent() method. Without it, we get
   * the following error thrown:
   *
   *   TypeError: Cannot read private member #content from
   *   an object whose class did not declare it
   *
   * FIXME: Maybe find a cleaner way to do this
   */
  __contentIsSet = false;
  #content = null;
  constructor(parentNode, attributes, key, content) {
    super(
      "TEMPLATE",
      parentNode,
      attributes,
      key
    );
    this.#content = content;
    this.__contentIsSet = true;
  }
  get content() {
    return this.#content;
  }
  _setOwnerDocument(document2) {
    super._setOwnerDocument(document2);
    if (this.__contentIsSet) {
      this.content._setOwnerDocument(document2);
    }
  }
  _shallowClone() {
    const frag = new DocumentFragment2();
    const attributes = this.getAttributeNames().map((name) => [name, this.getAttribute(name)]);
    return new _HTMLTemplateElement(null, attributes, CTOR_KEY, frag);
  }
  cloneNode(deep = false) {
    const newNode = super.cloneNode(deep);
    if (deep) {
      const destContent = newNode.content;
      for (const child of this.content.childNodes) {
        destContent.appendChild(child.cloneNode(deep));
      }
    }
    return newNode;
  }
  get innerHTML() {
    return getOuterOrInnerHtml(this, false);
  }
  // Replace children in the `.content`
  set innerHTML(html) {
    const content = this.content;
    for (const child of content.childNodes) {
      child._setParent(null);
    }
    const mutator = content._getChildNodesMutator();
    mutator.splice(0, content.childNodes.length);
    if (html.length) {
      const parsed = fragmentNodesFromString(html, this.localName);
      mutator.push(...parsed.childNodes[0].childNodes);
      for (const child of content.childNodes) {
        child._setParent(content);
        child._setOwnerDocument(content.ownerDocument);
      }
    }
  }
  get outerHTML() {
    return `<template${getElementAttributesString(this)}>${this.innerHTML}</template>`;
  }
};

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/selectors.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/nwsapi-types.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/nwsapi.js
init_define_BUILD_INFO();
var nwsapi_default = (document2) => {
  const NW = Factory({ document: document2, DOMException }, "null");
  NW.configure({
    IDS_DUPES: false,
    LOGERRORS: false
  });
  return NW;
};
function Factory(global, Export) {
  var version = "nwsapi-2.2.0", doc = global.document, root = doc.documentElement, slice2 = Array.prototype.slice, WSP = "[\\x20\\t\\r\\n\\f]", CFG = {
    // extensions
    operators: "[~*^$|]=|=",
    combinators: "[\\x20\\t>+~](?=[^>+~])"
  }, NOT = {
    // not enclosed in double/single/parens/square
    double_enc: '(?=(?:[^"]*["][^"]*["])*[^"]*$)',
    single_enc: "(?=(?:[^']*['][^']*['])*[^']*$)",
    parens_enc: "(?![^\\x28]*\\x29)",
    square_enc: "(?![^\\x5b]*\\x5d)"
  }, REX = {
    // regular expressions
    HasEscapes: RegExp("\\\\"),
    HexNumbers: RegExp("^[0-9a-fA-F]"),
    EscOrQuote: RegExp("^\\\\|[\\x22\\x27]"),
    RegExpChar: RegExp("(?:(?!\\\\)[\\\\^$.*+?()[\\]{}|\\/])", "g"),
    TrimSpaces: RegExp("[\\r\\n\\f]|^" + WSP + "+|" + WSP + "+$", "g"),
    CommaGroup: RegExp("(\\s*,\\s*)" + NOT.square_enc + NOT.parens_enc, "g"),
    SplitGroup: RegExp("((?:\\x28[^\\x29]*\\x29|\\[[^\\]]*\\]|\\\\.|[^,])+)", "g"),
    FixEscapes: RegExp("\\\\([0-9a-fA-F]{1,6}" + WSP + "?|.)|([\\x22\\x27])", "g"),
    CombineWSP: RegExp("[\\n\\r\\f\\x20]+" + NOT.single_enc + NOT.double_enc, "g"),
    TabCharWSP: RegExp("(\\x20?\\t+\\x20?)" + NOT.single_enc + NOT.double_enc, "g"),
    PseudosWSP: RegExp("\\s+([-+])\\s+" + NOT.square_enc, "g")
  }, STD = {
    combinator: RegExp("\\s?([>+~])\\s?", "g"),
    apimethods: RegExp("^(?:[a-z]+|\\*)\\|", "i"),
    namespaces: RegExp("(\\*|[a-z]+)\\|[-a-z]+", "i")
  }, GROUPS = {
    // pseudo-classes requiring parameters
    linguistic: "(dir|lang)\\x28\\s?([-\\w]{2,})\\s?(?:\\x29|$)",
    logicalsel: "(is|where|matches|not)\\x28\\s?([^()]*|[^\\x28]*\\x28[^\\x29]*\\x29)\\s?(?:\\x29|$)",
    treestruct: "(nth(?:-last)?(?:-child|-of-type))(?:\\x28\\s?(even|odd|(?:[-+]?\\d*)(?:n\\s?[-+]?\\s?\\d*)?)\\s?(?:\\x29|$))",
    // pseudo-classes not requiring parameters
    locationpc: "(any-link|link|visited|target)\\b",
    useraction: "(hover|active|focus|focus-within)\\b",
    structural: "(root|empty|(?:(?:first|last|only)(?:-child|-of-type)))\\b",
    inputstate: "(enabled|disabled|read-only|read-write|placeholder-shown|default)\\b",
    inputvalue: "(checked|indeterminate|required|optional|valid|invalid|in-range|out-of-range)\\b",
    // pseudo-elements starting with single colon (:)
    pseudo_sng: "(after|before|first-letter|first-line)\\b",
    // pseudo-elements starting with double colon (::)
    pseudo_dbl: ":(after|before|first-letter|first-line|selection|placeholder|-webkit-[-a-zA-Z0-9]{2,})\\b"
  }, Patterns = {
    // pseudo-classes
    treestruct: RegExp("^:(?:" + GROUPS.treestruct + ")(.*)", "i"),
    structural: RegExp("^:(?:" + GROUPS.structural + ")(.*)", "i"),
    linguistic: RegExp("^:(?:" + GROUPS.linguistic + ")(.*)", "i"),
    useraction: RegExp("^:(?:" + GROUPS.useraction + ")(.*)", "i"),
    inputstate: RegExp("^:(?:" + GROUPS.inputstate + ")(.*)", "i"),
    inputvalue: RegExp("^:(?:" + GROUPS.inputvalue + ")(.*)", "i"),
    locationpc: RegExp("^:(?:" + GROUPS.locationpc + ")(.*)", "i"),
    logicalsel: RegExp("^:(?:" + GROUPS.logicalsel + ")(.*)", "i"),
    pseudo_dbl: RegExp("^:(?:" + GROUPS.pseudo_dbl + ")(.*)", "i"),
    pseudo_sng: RegExp("^:(?:" + GROUPS.pseudo_sng + ")(.*)", "i"),
    // combinator symbols
    children: RegExp("^" + WSP + "?\\>" + WSP + "?(.*)"),
    adjacent: RegExp("^" + WSP + "?\\+" + WSP + "?(.*)"),
    relative: RegExp("^" + WSP + "?\\~" + WSP + "?(.*)"),
    ancestor: RegExp("^" + WSP + "+(.*)"),
    // universal & namespace
    universal: RegExp("^\\*(.*)"),
    namespace: RegExp("^(\\w+|\\*)?\\|(.*)")
  }, RTL = RegExp("^[\\u0591-\\u08ff\\ufb1d-\\ufdfd\\ufe70-\\ufefc ]+$"), qsNotArgs = "Not enough arguments", qsInvalid = " is not a valid selector", reNthElem = RegExp("(:nth(?:-last)?-child)", "i"), reNthType = RegExp("(:nth(?:-last)?-of-type)", "i"), reOptimizer, reValidator, Config = {
    IDS_DUPES: true,
    MIXEDCASE: true,
    LOGERRORS: true,
    VERBOSITY: true
  }, NAMESPACE, QUIRKS_MODE, HTML_DOCUMENT, ATTR_STD_OPS = {
    "=": 1,
    "^=": 1,
    "$=": 1,
    "|=": 1,
    "*=": 1,
    "~=": 1
  }, HTML_TABLE = {
    "accept": 1,
    "accept-charset": 1,
    "align": 1,
    "alink": 1,
    "axis": 1,
    "bgcolor": 1,
    "charset": 1,
    "checked": 1,
    "clear": 1,
    "codetype": 1,
    "color": 1,
    "compact": 1,
    "declare": 1,
    "defer": 1,
    "dir": 1,
    "direction": 1,
    "disabled": 1,
    "enctype": 1,
    "face": 1,
    "frame": 1,
    "hreflang": 1,
    "http-equiv": 1,
    "lang": 1,
    "language": 1,
    "link": 1,
    "media": 1,
    "method": 1,
    "multiple": 1,
    "nohref": 1,
    "noresize": 1,
    "noshade": 1,
    "nowrap": 1,
    "readonly": 1,
    "rel": 1,
    "rev": 1,
    "rules": 1,
    "scope": 1,
    "scrolling": 1,
    "selected": 1,
    "shape": 1,
    "target": 1,
    "text": 1,
    "type": 1,
    "valign": 1,
    "valuetype": 1,
    "vlink": 1
  }, Combinators = {}, Selectors = {}, Operators = {
    "=": {
      p1: "^",
      p2: "$",
      p3: "true"
    },
    "^=": {
      p1: "^",
      p2: "",
      p3: "true"
    },
    "$=": {
      p1: "",
      p2: "$",
      p3: "true"
    },
    "*=": {
      p1: "",
      p2: "",
      p3: "true"
    },
    "|=": {
      p1: "^",
      p2: "(-|$)",
      p3: "true"
    },
    "~=": {
      p1: "(^|\\s)",
      p2: "(\\s|$)",
      p3: "true"
    }
  }, concatCall = function(nodes, callback) {
    var i3 = 0, l3 = nodes.length, list = Array(l3);
    while (l3 > i3) {
      if (false === callback(list[i3] = nodes[i3]))
        break;
      ++i3;
    }
    return list;
  }, concatList = function(list, nodes) {
    var i3 = -1, l3 = nodes.length;
    while (l3--) {
      list[list.length] = nodes[++i3];
    }
    return list;
  }, documentOrder = function(a2, b2) {
    if (!hasDupes && a2 === b2) {
      hasDupes = true;
      return 0;
    }
    return a2.compareDocumentPosition(b2) & 4 ? -1 : 1;
  }, hasDupes = false, unique = function(nodes) {
    var i3 = 0, j2 = -1, l3 = nodes.length + 1, list = [];
    while (--l3) {
      if (nodes[i3++] === nodes[i3])
        continue;
      list[++j2] = nodes[i3 - 1];
    }
    hasDupes = false;
    return list;
  }, hasMixedCaseTagNames = function(context) {
    var ns2, api = "getElementsByTagNameNS";
    context = context.ownerDocument || context;
    ns2 = context.documentElement.namespaceURI || "http://www.w3.org/1999/xhtml";
    return context[api]("*", "*").length - context[api](ns2, "*").length > 0;
  }, switchContext = function(context, force) {
    var oldDoc = doc;
    doc = context.ownerDocument || context;
    if (force || oldDoc !== doc) {
      root = doc.documentElement;
      HTML_DOCUMENT = isHTML(doc);
      QUIRKS_MODE = HTML_DOCUMENT && doc.compatMode.indexOf("CSS") < 0;
      NAMESPACE = root && root.namespaceURI;
      Snapshot.doc = doc;
      Snapshot.root = root;
    }
    return Snapshot.from = context;
  }, codePointToUTF16 = function(codePoint) {
    if (codePoint < 1 || codePoint > 1114111 || codePoint > 55295 && codePoint < 57344) {
      return "\\ufffd";
    }
    if (codePoint < 65536) {
      var lowHex = "000" + codePoint.toString(16);
      return "\\u" + lowHex.substr(lowHex.length - 4);
    }
    return "\\u" + ((codePoint - 65536 >> 10) + 55296).toString(16) + "\\u" + ((codePoint - 65536) % 1024 + 56320).toString(16);
  }, stringFromCodePoint = function(codePoint) {
    if (codePoint < 1 || codePoint > 1114111 || codePoint > 55295 && codePoint < 57344) {
      return "\uFFFD";
    }
    if (codePoint < 65536) {
      return String.fromCharCode(codePoint);
    }
    return String.fromCodePoint ? String.fromCodePoint(codePoint) : String.fromCharCode(
      (codePoint - 65536 >> 10) + 55296,
      (codePoint - 65536) % 1024 + 56320
    );
  }, convertEscapes = function(str) {
    return REX.HasEscapes.test(str) ? str.replace(
      REX.FixEscapes,
      function(substring, p1, p2) {
        return p2 ? "\\" + p2 : (
          // javascript strings are UTF-16 encoded
          REX.HexNumbers.test(p1) ? codePointToUTF16(parseInt(p1, 16)) : (
            // \' \"
            REX.EscOrQuote.test(p1) ? substring : (
              // \g \h \. \# etc
              p1
            )
          )
        );
      }
    ) : str;
  }, unescapeIdentifier = function(str) {
    return REX.HasEscapes.test(str) ? str.replace(
      REX.FixEscapes,
      function(substring, p1, p2) {
        return p2 ? p2 : (
          // javascript strings are UTF-16 encoded
          REX.HexNumbers.test(p1) ? stringFromCodePoint(parseInt(p1, 16)) : (
            // \' \"
            REX.EscOrQuote.test(p1) ? substring : (
              // \g \h \. \# etc
              p1
            )
          )
        );
      }
    ) : str;
  }, method = {
    "#": "getElementById",
    "*": "getElementsByTagNameNS",
    ".": "getElementsByClassName"
  }, compat = {
    "#": function(c2, n2) {
      REX.HasEscapes.test(n2) && (n2 = unescapeIdentifier(n2));
      return function(e2, f2) {
        return byId(n2, c2);
      };
    },
    "*": function(c2, n2) {
      REX.HasEscapes.test(n2) && (n2 = unescapeIdentifier(n2));
      return function(e2, f2) {
        return byTag(n2, c2);
      };
    },
    ".": function(c2, n2) {
      REX.HasEscapes.test(n2) && (n2 = unescapeIdentifier(n2));
      return function(e2, f2) {
        return byClass(n2, c2);
      };
    }
  }, byIdRaw = function(id, context) {
    var node = context, nodes = [], next = node.firstElementChild;
    while (node = next) {
      node.id == id && (nodes[nodes.length] = node);
      if (next = node.firstElementChild || node.nextElementSibling)
        continue;
      while (!next && (node = node.parentElement) && node !== context) {
        next = node.nextElementSibling;
      }
    }
    return nodes;
  }, byId = function(id, context) {
    var e2, nodes, api = method["#"];
    if (Config.IDS_DUPES === false) {
      if (api in context) {
        return (e2 = context[api](id)) ? [e2] : none;
      }
    } else {
      if ("all" in context) {
        if (e2 = context.all[id]) {
          if (e2.nodeType == 1)
            return e2.getAttribute("id") != id ? [] : [e2];
          else if (id == "length")
            return (e2 = context[api](id)) ? [e2] : none;
          for (i = 0, l = e2.length, nodes = []; l > i; ++i) {
            if (e2[i].id == id)
              nodes[nodes.length] = e2[i];
          }
          return nodes && nodes.length ? nodes : [nodes];
        } else
          return none;
      }
    }
    return byIdRaw(id, context);
  }, byTag = function(tag, context) {
    var e2, nodes, api = method["*"];
    if (api in context) {
      return slice2.call(context[api]("*", tag));
    } else {
      tag = tag.toLowerCase();
      if (e2 = context.firstElementChild) {
        if (!(e2.nextElementSibling || tag == "*" || e2.localName == tag)) {
          return slice2.call(e2[api]("*", tag));
        } else {
          nodes = [];
          do {
            if (tag == "*" || e2.localName == tag)
              nodes[nodes.length] = e2;
            concatList(nodes, e2[api]("*", tag));
          } while (e2 = e2.nextElementSibling);
        }
      } else
        nodes = none;
    }
    return nodes;
  }, byClass = function(cls, context) {
    var e2, nodes, api = method["."], reCls;
    if (api in context) {
      return slice2.call(context[api](cls));
    } else {
      if (e2 = context.firstElementChild) {
        reCls = RegExp("(^|\\s)" + cls + "(\\s|$)", QUIRKS_MODE ? "i" : "");
        if (!(e2.nextElementSibling || reCls.test(e2.className))) {
          return slice2.call(e2[api](cls));
        } else {
          nodes = [];
          do {
            if (reCls.test(e2.className))
              nodes[nodes.length] = e2;
            concatList(nodes, e2[api](cls));
          } while (e2 = e2.nextElementSibling);
        }
      } else
        nodes = none;
    }
    return nodes;
  }, hasAttributeNS = function(e2, name) {
    var i3, l3, attr = e2.getAttributeNames();
    name = RegExp(":?" + name + "$", HTML_DOCUMENT ? "i" : "");
    for (i3 = 0, l3 = attr.length; l3 > i3; ++i3) {
      if (name.test(attr[i3]))
        return true;
    }
    return false;
  }, nthElement = function() {
    var idx = 0, len = 0, set2 = 0, parent = void 0, parents = Array(), nodes = Array();
    return function(element, dir) {
      if (dir == 2) {
        idx = 0;
        len = 0;
        set2 = 0;
        nodes.length = 0;
        parents.length = 0;
        parent = void 0;
        return -1;
      }
      var e2, i3, j2, k2, l3;
      if (parent === element.parentElement) {
        i3 = set2;
        j2 = idx;
        l3 = len;
      } else {
        l3 = parents.length;
        parent = element.parentElement;
        for (i3 = -1, j2 = 0, k2 = l3 - 1; l3 > j2; ++j2, --k2) {
          if (parents[j2] === parent) {
            i3 = j2;
            break;
          }
          if (parents[k2] === parent) {
            i3 = k2;
            break;
          }
        }
        if (i3 < 0) {
          parents[i3 = l3] = parent;
          l3 = 0;
          nodes[i3] = Array();
          e2 = parent && parent.firstElementChild || element;
          while (e2) {
            nodes[i3][l3] = e2;
            if (e2 === element)
              j2 = l3;
            e2 = e2.nextElementSibling;
            ++l3;
          }
          set2 = i3;
          idx = 0;
          len = l3;
          if (l3 < 2)
            return l3;
        } else {
          l3 = nodes[i3].length;
          set2 = i3;
        }
      }
      if (element !== nodes[i3][j2] && element !== nodes[i3][j2 = 0]) {
        for (j2 = 0, e2 = nodes[i3], k2 = l3 - 1; l3 > j2; ++j2, --k2) {
          if (e2[j2] === element) {
            break;
          }
          if (e2[k2] === element) {
            j2 = k2;
            break;
          }
        }
      }
      idx = j2 + 1;
      len = l3;
      return dir ? l3 - j2 : idx;
    };
  }(), nthOfType = function() {
    var idx = 0, len = 0, set2 = 0, parent = void 0, parents = Array(), nodes = Array();
    return function(element, dir) {
      if (dir == 2) {
        idx = 0;
        len = 0;
        set2 = 0;
        nodes.length = 0;
        parents.length = 0;
        parent = void 0;
        return -1;
      }
      var e2, i3, j2, k2, l3, name = element.localName;
      if (nodes[set2] && nodes[set2][name] && parent === element.parentElement) {
        i3 = set2;
        j2 = idx;
        l3 = len;
      } else {
        l3 = parents.length;
        parent = element.parentElement;
        for (i3 = -1, j2 = 0, k2 = l3 - 1; l3 > j2; ++j2, --k2) {
          if (parents[j2] === parent) {
            i3 = j2;
            break;
          }
          if (parents[k2] === parent) {
            i3 = k2;
            break;
          }
        }
        if (i3 < 0 || !nodes[i3][name]) {
          parents[i3 = l3] = parent;
          nodes[i3] || (nodes[i3] = Object());
          l3 = 0;
          nodes[i3][name] = Array();
          e2 = parent && parent.firstElementChild || element;
          while (e2) {
            if (e2 === element)
              j2 = l3;
            if (e2.localName == name) {
              nodes[i3][name][l3] = e2;
              ++l3;
            }
            e2 = e2.nextElementSibling;
          }
          set2 = i3;
          idx = j2;
          len = l3;
          if (l3 < 2)
            return l3;
        } else {
          l3 = nodes[i3][name].length;
          set2 = i3;
        }
      }
      if (element !== nodes[i3][name][j2] && element !== nodes[i3][name][j2 = 0]) {
        for (j2 = 0, e2 = nodes[i3][name], k2 = l3 - 1; l3 > j2; ++j2, --k2) {
          if (e2[j2] === element) {
            break;
          }
          if (e2[k2] === element) {
            j2 = k2;
            break;
          }
        }
      }
      idx = j2 + 1;
      len = l3;
      return dir ? l3 - j2 : idx;
    };
  }(), isHTML = function(node) {
    var doc2 = node.ownerDocument || node;
    return doc2.nodeType == 9 && // contentType not in IE <= 11
    "contentType" in doc2 ? doc2.contentType.indexOf("/html") > 0 : doc2.createElement("DiV").localName == "div";
  }, configure = function(option, clear) {
    if (typeof option == "string") {
      return !!Config[option];
    }
    if (typeof option != "object") {
      return Config;
    }
    for (var i3 in option) {
      Config[i3] = !!option[i3];
    }
    if (clear) {
      matchResolvers = {};
      selectResolvers = {};
    }
    setIdentifierSyntax();
    return true;
  }, emit = function(message, proto) {
    var err;
    if (Config.VERBOSITY) {
      if (proto) {
        err = new proto(message);
      } else {
        err = new global.DOMException(message, "SyntaxError");
      }
      throw err;
    }
    if (Config.LOGERRORS && console && console.log) {
      console.log(message);
    }
  }, initialize = function(doc2) {
    setIdentifierSyntax();
    lastContext = switchContext(doc2, true);
  }, setIdentifierSyntax = function() {
    var identifier = (
      // doesn't start with a digit
      "(?=[^0-9])(?:-{2}|[a-zA-Z0-9-_]|[^\\x00-\\x9f]|\\\\[^\\r\\n\\f0-9a-fA-F]|\\\\[0-9a-fA-F]{1,6}(?:\\r\\n|\\s)?|\\\\.)+"
    ), pseudonames = "[-\\w]+", pseudoparms = "(?:[-+]?\\d*)(?:n\\s?[-+]?\\s?\\d*)", doublequote = '"[^"\\\\]*(?:\\\\.[^"\\\\]*)*(?:"|$)', singlequote = "'[^'\\\\]*(?:\\\\.[^'\\\\]*)*(?:'|$)", attrparser = identifier + "|" + doublequote + "|" + singlequote, attrvalues = "([\\x22\\x27]?)((?!\\3)*|(?:\\\\?.)*?)(?:\\3|$)", attributes = "\\[(?:\\*\\|)?" + WSP + "?(" + identifier + "(?::" + identifier + ")?)" + WSP + "?(?:(" + CFG.operators + ")" + WSP + "?(?:" + attrparser + "))?" + // attribute case sensitivity
    WSP + "?(i)?" + WSP + "?(?:\\]|$)", attrmatcher = attributes.replace(attrparser, attrvalues), pseudoclass = "(?:\\x28" + WSP + "*(?:" + pseudoparms + "?)?|(?:\\*|\\|)|(?:(?::" + pseudonames + "(?:\\x28" + pseudoparms + "?(?:\\x29|$))?|)|(?:[.#]?" + identifier + ")|(?:" + attributes + "))+|(?:" + WSP + "?," + WSP + "?)|(?:" + WSP + "?)|(?:\\x29|$))*", standardValidator = "(?=" + WSP + "?[^>+~(){}<>])(?:(?:\\*|\\|)|(?:[.#]?" + identifier + ")+|(?:" + attributes + ")+|(?:::?" + pseudonames + pseudoclass + ")|(?:" + WSP + "?" + CFG.combinators + WSP + "?)|(?:" + WSP + "?," + WSP + "?)|(?:" + WSP + "?))+";
    reOptimizer = RegExp(
      "(?:([.:#*]?)(" + identifier + ")(?::[-\\w]+|\\[[^\\]]+(?:\\]|$)|\\x28[^\\x29]+(?:\\x29|$))*)$"
    );
    reValidator = RegExp(standardValidator, "g");
    Patterns.id = RegExp("^#(" + identifier + ")(.*)");
    Patterns.tagName = RegExp("^(" + identifier + ")(.*)");
    Patterns.className = RegExp("^\\.(" + identifier + ")(.*)");
    Patterns.attribute = RegExp("^(?:" + attrmatcher + ")(.*)");
  }, F_INIT = '"use strict";return function Resolver(c,f,x,r)', S_HEAD = "var e,n,o,j=r.length-1,k=-1", M_HEAD = "var e,n,o", S_LOOP = "main:while((e=c[++k]))", N_LOOP = "main:while((e=c.item(++k)))", M_LOOP = "e=c;", S_BODY = "r[++j]=c[k];", N_BODY = "r[++j]=c.item(k);", M_BODY = "", S_TAIL = "continue main;", M_TAIL = "r=true;", S_TEST = "if(f(c[k])){break main;}", N_TEST = "if(f(c.item(k))){break main;}", M_TEST = "f(c);", S_VARS = [], M_VARS = [], compile = function(selector, mode, callback) {
    var factory, token, head = "", loop = "", macro = "", source = "", vars = "";
    switch (mode) {
      case true:
        if (selectLambdas[selector]) {
          return selectLambdas[selector];
        }
        macro = S_BODY + (callback ? S_TEST : "") + S_TAIL;
        head = S_HEAD;
        loop = S_LOOP;
        break;
      case false:
        if (matchLambdas[selector]) {
          return matchLambdas[selector];
        }
        macro = M_BODY + (callback ? M_TEST : "") + M_TAIL;
        head = M_HEAD;
        loop = M_LOOP;
        break;
      case null:
        if (selectLambdas[selector]) {
          return selectLambdas[selector];
        }
        macro = N_BODY + (callback ? N_TEST : "") + S_TAIL;
        head = S_HEAD;
        loop = N_LOOP;
        break;
      default:
        break;
    }
    source = compileSelector(selector, macro, mode, callback, false);
    loop += mode || mode === null ? "{" + source + "}" : source;
    if (mode || mode === null && selector.includes(":nth")) {
      loop += reNthElem.test(selector) ? "s.nthElement(null, 2);" : "";
      loop += reNthType.test(selector) ? "s.nthOfType(null, 2);" : "";
    }
    if (S_VARS[0] || M_VARS[0]) {
      vars = "," + (S_VARS.join(",") || M_VARS.join(","));
      S_VARS.length = 0;
      M_VARS.length = 0;
    }
    factory = Function("s", F_INIT + "{" + head + vars + ";" + loop + "return r;}")(Snapshot);
    return mode || mode === null ? selectLambdas[selector] = factory : matchLambdas[selector] = factory;
  }, compileSelector = function(expression, source, mode, callback, not) {
    var a2, b2, n2, f2, i3, l3, name, NS, N2 = not ? "!" : "", D2 = not ? "" : "!", compat2, expr, match2, result2, status, symbol, test, type, selector = expression, selector_string, vars;
    selector_string = mode ? lastSelected : lastMatched;
    selector = selector.replace(STD.combinator, "$1");
    while (selector) {
      symbol = STD.apimethods.test(selector) ? "|" : selector[0];
      switch (symbol) {
        case "*":
          match2 = selector.match(Patterns.universal);
          if (N2 == "!") {
            source = "if(" + N2 + "true){" + source + "}";
          }
          break;
        case "#":
          match2 = selector.match(Patterns.id);
          source = "if(" + N2 + "(/^" + match2[1] + '$/.test(e.getAttribute("id")))){' + source + "}";
          break;
        case ".":
          match2 = selector.match(Patterns.className);
          compat2 = (QUIRKS_MODE ? "i" : "") + '.test(e.getAttribute("class"))';
          source = "if(" + N2 + "(/(^|\\s)" + match2[1] + "(\\s|$)/" + compat2 + ")){" + source + "}";
          break;
        case (/[_a-z]/i.test(symbol) ? symbol : void 0):
          match2 = selector.match(Patterns.tagName);
          source = "if(" + N2 + "(e.localName" + (Config.MIXEDCASE || hasMixedCaseTagNames(doc) ? '=="' + match2[1].toLowerCase() + '"' : '=="' + match2[1].toUpperCase() + '"') + ")){" + source + "}";
          break;
        case "|":
          match2 = selector.match(Patterns.namespace);
          if (match2[1] == "*") {
            source = "if(" + N2 + "true){" + source + "}";
          } else if (!match2[1]) {
            source = "if(" + N2 + "(!e.namespaceURI)){" + source + "}";
          } else if (typeof match2[1] == "string" && root.prefix == match2[1]) {
            source = "if(" + N2 + '(e.namespaceURI=="' + NAMESPACE + '")){' + source + "}";
          } else {
            emit("'" + selector_string + "'" + qsInvalid);
          }
          break;
        case "[":
          match2 = selector.match(Patterns.attribute);
          NS = match2[0].match(STD.namespaces);
          name = match2[1];
          expr = name.split(":");
          expr = expr.length == 2 ? expr[1] : expr[0];
          if (match2[2] && !(test = Operators[match2[2]])) {
            emit("'" + selector_string + "'" + qsInvalid);
            return "";
          }
          if (match2[4] === "") {
            test = match2[2] == "~=" ? { p1: "^\\s", p2: "+$", p3: "true" } : match2[2] in ATTR_STD_OPS && match2[2] != "~=" ? { p1: "^", p2: "$", p3: "true" } : test;
          } else if (match2[2] == "~=" && match2[4].includes(" ")) {
            source = "if(" + N2 + "false){" + source + "}";
            break;
          } else if (match2[4]) {
            match2[4] = convertEscapes(match2[4]).replace(REX.RegExpChar, "\\$&");
          }
          type = match2[5] == "i" || HTML_DOCUMENT && HTML_TABLE[expr.toLowerCase()] ? "i" : "";
          source = "if(" + N2 + "(" + (!match2[2] ? NS ? 's.hasAttributeNS(e,"' + name + '")' : 'e.hasAttribute&&e.hasAttribute("' + name + '")' : !match2[4] && ATTR_STD_OPS[match2[2]] && match2[2] != "~=" ? 'e.getAttribute&&e.getAttribute("' + name + '")==""' : "(/" + test.p1 + match2[4] + test.p2 + "/" + type + ').test(e.getAttribute&&e.getAttribute("' + name + '"))==' + test.p3) + ")){" + source + "}";
          break;
        case "~":
          match2 = selector.match(Patterns.relative);
          source = "n=e;while((e=e.previousElementSibling)){" + source + "}e=n;";
          break;
        case "+":
          match2 = selector.match(Patterns.adjacent);
          source = "n=e;if((e=e.previousElementSibling)){" + source + "}e=n;";
          break;
        case "	":
        case " ":
          match2 = selector.match(Patterns.ancestor);
          source = "n=e;while((e=e.parentElement)){" + source + "}e=n;";
          break;
        case ">":
          match2 = selector.match(Patterns.children);
          source = "n=e;if((e=e.parentElement)){" + source + "}e=n;";
          break;
        case (symbol in Combinators ? symbol : void 0):
          match2[match2.length - 1] = "*";
          source = Combinators[symbol](match2) + source;
          break;
        case ":":
          if (match2 = selector.match(Patterns.structural)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "root":
                source = "if(" + N2 + "(e===s.root)){" + source + (mode ? "break main;" : "") + "}";
                break;
              case "empty":
                source = "n=e.firstChild;while(n&&!(/1|3/).test(n.nodeType)){n=n.nextSibling}if(" + D2 + "n){" + source + "}";
                break;
              case "only-child":
                source = "if(" + N2 + "(!e.nextElementSibling&&!e.previousElementSibling)){" + source + "}";
                break;
              case "last-child":
                source = "if(" + N2 + "(!e.nextElementSibling)){" + source + "}";
                break;
              case "first-child":
                source = "if(" + N2 + "(!e.previousElementSibling)){" + source + "}";
                break;
              case "only-of-type":
                source = "o=e.localName;n=e;while((n=n.nextElementSibling)&&n.localName!=o);if(!n){n=e;while((n=n.previousElementSibling)&&n.localName!=o);}if(" + D2 + "n){" + source + "}";
                break;
              case "last-of-type":
                source = "n=e;o=e.localName;while((n=n.nextElementSibling)&&n.localName!=o);if(" + D2 + "n){" + source + "}";
                break;
              case "first-of-type":
                source = "n=e;o=e.localName;while((n=n.previousElementSibling)&&n.localName!=o);if(" + D2 + "n){" + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.treestruct)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "nth-child":
              case "nth-of-type":
              case "nth-last-child":
              case "nth-last-of-type":
                expr = /-of-type/i.test(match2[1]);
                if (match2[1] && match2[2]) {
                  type = /last/i.test(match2[1]);
                  if (match2[2] == "n") {
                    source = "if(" + N2 + "true){" + source + "}";
                    break;
                  } else if (match2[2] == "1") {
                    test = type ? "next" : "previous";
                    source = expr ? "n=e;o=e.localName;while((n=n." + test + "ElementSibling)&&n.localName!=o);if(" + D2 + "n){" + source + "}" : "if(" + N2 + "!e." + test + "ElementSibling){" + source + "}";
                    break;
                  } else if (match2[2] == "even" || match2[2] == "2n0" || match2[2] == "2n+0" || match2[2] == "2n") {
                    test = "n%2==0";
                  } else if (match2[2] == "odd" || match2[2] == "2n1" || match2[2] == "2n+1") {
                    test = "n%2==1";
                  } else {
                    f2 = /n/i.test(match2[2]);
                    n2 = match2[2].split("n");
                    a2 = parseInt(n2[0], 10) || 0;
                    b2 = parseInt(n2[1], 10) || 0;
                    if (n2[0] == "-") {
                      a2 = -1;
                    }
                    if (n2[0] == "+") {
                      a2 = 1;
                    }
                    test = (b2 ? "(n" + (b2 > 0 ? "-" : "+") + Math.abs(b2) + ")" : "n") + "%" + a2 + "==0";
                    test = a2 >= 1 ? f2 ? "n>" + (b2 - 1) + (Math.abs(a2) != 1 ? "&&" + test : "") : "n==" + a2 : a2 <= -1 ? f2 ? "n<" + (b2 + 1) + (Math.abs(a2) != 1 ? "&&" + test : "") : "n==" + a2 : a2 === 0 ? n2[0] ? "n==" + b2 : "n>" + (b2 - 1) : "false";
                  }
                  expr = expr ? "OfType" : "Element";
                  type = type ? "true" : "false";
                  source = "n=s.nth" + expr + "(e," + type + ");if(" + N2 + "(" + test + ")){" + source + "}";
                } else {
                  emit("'" + selector_string + "'" + qsInvalid);
                }
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.logicalsel)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "is":
              case "where":
              case "matches":
                expr = match2[2].replace(REX.CommaGroup, ",").replace(REX.TrimSpaces, "");
                source = 'if(s.match("' + expr.replace(/\x22/g, '\\"') + '",e)){' + source + "}";
                break;
              case "not":
                expr = match2[2].replace(REX.CommaGroup, ",").replace(REX.TrimSpaces, "");
                source = 'if(!s.match("' + expr.replace(/\x22/g, '\\"') + '",e)){' + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.linguistic)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "dir":
                source = "var p;if(" + N2 + "((/" + match2[2] + '/i.test(e.dir))||(p=s.ancestor("[dir]", e))&&(/' + match2[2] + '/i.test(p.dir))||(e.dir==""||e.dir=="auto")&&(' + (match2[2] == "ltr" ? "!" : "") + RTL + ".test(e.textContent)))){" + source + "};";
                break;
              case "lang":
                expr = "(?:^|-)" + match2[2] + "(?:-|$)";
                source = "var p;if(" + N2 + '((e.isConnected&&(e.lang==""&&(p=s.ancestor("[lang]",e)))&&(p.lang=="' + match2[2] + '")||/' + expr + "/i.test(e.lang)))){" + source + "};";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.locationpc)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "any-link":
                source = "if(" + N2 + '(/^a|area$/i.test(e.localName)&&e.hasAttribute("href")||e.visited)){' + source + "}";
                break;
              case "link":
                source = "if(" + N2 + '(/^a|area$/i.test(e.localName)&&e.hasAttribute("href"))){' + source + "}";
                break;
              case "visited":
                source = "if(" + N2 + '(/^a|area$/i.test(e.localName)&&e.hasAttribute("href")&&e.visited)){' + source + "}";
                break;
              case "target":
                source = "if(" + N2 + "((s.doc.compareDocumentPosition(e)&16)&&s.doc.location.hash&&e.id==s.doc.location.hash.slice(1))){" + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.useraction)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "hover":
                source = "hasFocus" in doc && doc.hasFocus() ? "if(" + N2 + "(e===s.doc.hoverElement)){" + source + "}" : "if(" + D2 + "true){" + source + "}";
                break;
              case "active":
                source = "hasFocus" in doc && doc.hasFocus() ? "if(" + N2 + "(e===s.doc.activeElement)){" + source + "}" : "if(" + D2 + "true){" + source + "}";
                break;
              case "focus":
                source = "hasFocus" in doc ? "if(" + N2 + '(e===s.doc.activeElement&&s.doc.hasFocus()&&(e.type||e.href||typeof e.tabIndex=="number"))){' + source + "}" : "if(" + N2 + "(e===s.doc.activeElement&&(e.type||e.href))){" + source + "}";
                break;
              case "focus-within":
                source = "hasFocus" in doc ? "n=s.doc.activeElement;while(e){if(e===n||e.parentNode===n)break;}if(" + N2 + '(e===n&&s.doc.hasFocus()&&(e.type||e.href||typeof e.tabIndex=="number"))){' + source + "}" : source;
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.inputstate)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "enabled":
                source = "if(" + N2 + '(("form" in e||/^optgroup$/i.test(e.localName))&&"disabled" in e &&e.disabled===false)){' + source + "}";
                break;
              case "disabled":
                source = "if(" + N2 + '(("form" in e||/^optgroup$/i.test(e.localName))&&"disabled" in e&&(e.disabled===true||(n=s.ancestor("fieldset",e))&&(n=s.first("legend",n))&&!n.contains(e)))){' + source + "}";
                break;
              case "read-only":
                source = "if(" + N2 + '((/^textarea$/i.test(e.localName)&&(e.readOnly||e.disabled))||("|password|text|".includes("|"+e.type+"|")&&e.readOnly))){' + source + "}";
                break;
              case "read-write":
                source = "if(" + N2 + '(((/^textarea$/i.test(e.localName)&&!e.readOnly&&!e.disabled)||("|password|text|".includes("|"+e.type+"|")&&!e.readOnly&&!e.disabled))||(e.hasAttribute("contenteditable")||(s.doc.designMode=="on")))){' + source + "}";
                break;
              case "placeholder-shown":
                source = "if(" + N2 + '((/^input|textarea$/i.test(e.localName))&&e.hasAttribute("placeholder")&&("|textarea|password|number|search|email|text|tel|url|".includes("|"+e.type+"|"))&&(!s.match(":focus",e)))){' + source + "}";
                break;
              case "default":
                source = "if(" + N2 + '("form" in e && e.form)){var x=0;n=[];if(e.type=="image")n=e.form.getElementsByTagName("input");if(e.type=="submit")n=e.form.elements;while(n[x]&&e!==n[x]){if(n[x].type=="image")break;if(n[x].type=="submit")break;x++;}}if(' + N2 + '(e.form&&(e===n[x]&&"|image|submit|".includes("|"+e.type+"|"))||((/^option$/i.test(e.localName))&&e.defaultSelected)||(("|radio|checkbox|".includes("|"+e.type+"|"))&&e.defaultChecked))){' + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.inputvalue)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "checked":
                source = "if(" + N2 + '(/^input$/i.test(e.localName)&&("|radio|checkbox|".includes("|"+e.type+"|")&&e.checked)||(/^option$/i.test(e.localName)&&(e.selected||e.checked)))){' + source + "}";
                break;
              case "indeterminate":
                source = "if(" + N2 + '(/^progress$/i.test(e.localName)&&!e.hasAttribute("value"))||(/^input$/i.test(e.localName)&&("checkbox"==e.type&&e.indeterminate)||("radio"==e.type&&e.name&&!s.first("input[name="+e.name+"]:checked",e.form)))){' + source + "}";
                break;
              case "required":
                source = "if(" + N2 + "(/^input|select|textarea$/i.test(e.localName)&&e.required)){" + source + "}";
                break;
              case "optional":
                source = "if(" + N2 + "(/^input|select|textarea$/i.test(e.localName)&&!e.required)){" + source + "}";
                break;
              case "invalid":
                source = "if(" + N2 + '(((/^form$/i.test(e.localName)&&!e.noValidate)||(e.willValidate&&!e.formNoValidate))&&!e.checkValidity())||(/^fieldset$/i.test(e.localName)&&s.first(":invalid",e))){' + source + "}";
                break;
              case "valid":
                source = "if(" + N2 + '(((/^form$/i.test(e.localName)&&!e.noValidate)||(e.willValidate&&!e.formNoValidate))&&e.checkValidity())||(/^fieldset$/i.test(e.localName)&&s.first(":valid",e))){' + source + "}";
                break;
              case "in-range":
                source = "if(" + N2 + '(/^input$/i.test(e.localName))&&(e.willValidate&&!e.formNoValidate)&&(!e.validity.rangeUnderflow&&!e.validity.rangeOverflow)&&("|date|datetime-local|month|number|range|time|week|".includes("|"+e.type+"|"))&&("range"==e.type||e.getAttribute("min")||e.getAttribute("max"))){' + source + "}";
                break;
              case "out-of-range":
                source = "if(" + N2 + '(/^input$/i.test(e.localName))&&(e.willValidate&&!e.formNoValidate)&&(e.validity.rangeUnderflow||e.validity.rangeOverflow)&&("|date|datetime-local|month|number|range|time|week|".includes("|"+e.type+"|"))&&("range"==e.type||e.getAttribute("min")||e.getAttribute("max"))){' + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.pseudo_sng)) {
            source = 'if(e.element&&e.type.toLowerCase()==":' + match2[0].toLowerCase() + '"){e=e.element;' + source + "}";
          } else if (match2 = selector.match(Patterns.pseudo_dbl)) {
            source = 'if(e.element&&e.type.toLowerCase()=="' + match2[0].toLowerCase() + '"){e=e.element;' + source + "}";
          } else {
            expr = false;
            status = false;
            for (expr in Selectors) {
              if (match2 = selector.match(Selectors[expr].Expression)) {
                result2 = Selectors[expr].Callback(match2, source, mode, callback);
                if ("match" in result2) {
                  match2 = result2.match;
                }
                vars = result2.modvar;
                if (mode) {
                  vars && S_VARS.indexOf(vars) < 0 && (S_VARS[S_VARS.length] = vars);
                } else {
                  vars && M_VARS.indexOf(vars) < 0 && (M_VARS[M_VARS.length] = vars);
                }
                source = result2.source;
                status = result2.status;
                if (status) {
                  break;
                }
              }
            }
            if (!status) {
              emit("unknown pseudo-class selector '" + selector + "'");
              return "";
            }
            if (!expr) {
              emit("unknown token in selector '" + selector + "'");
              return "";
            }
          }
          break;
        default:
          emit("'" + selector_string + "'" + qsInvalid);
          break;
      }
      if (!match2) {
        emit("'" + selector_string + "'" + qsInvalid);
        return "";
      }
      selector = match2.pop();
    }
    return source;
  }, makeref = function(selectors, element) {
    return selectors.replace(
      /:scope/ig,
      element.localName + (element.id ? "#" + element.id : "") + (element.className ? "." + element.classList[0] : "")
    );
  }, ancestor = function _closest2(selectors, element, callback) {
    if (/:scope/i.test(selectors)) {
      selectors = makeref(selectors, element);
    }
    while (element) {
      if (match(selectors, element, callback))
        break;
      element = element.parentElement;
    }
    return element;
  }, match_assert = function(f2, element, callback) {
    for (var i3 = 0, l3 = f2.length, r2 = false; l3 > i3; ++i3)
      f2[i3](element, callback, null, false) && (r2 = true);
    return r2;
  }, match_collect = function(selectors, callback) {
    for (var i3 = 0, l3 = selectors.length, f2 = []; l3 > i3; ++i3)
      f2[i3] = compile(selectors[i3], false, callback);
    return { factory: f2 };
  }, match = function _matches2(selectors, element, callback) {
    var expressions, parsed;
    if (element && matchResolvers[selectors]) {
      return match_assert(matchResolvers[selectors].factory, element, callback);
    }
    lastMatched = selectors;
    if (arguments.length === 0) {
      emit(qsNotArgs, TypeError);
      return Config.VERBOSITY ? void 0 : false;
    } else if (arguments[0] === "") {
      emit("''" + qsInvalid);
      return Config.VERBOSITY ? void 0 : false;
    }
    if (typeof selectors != "string") {
      selectors = "" + selectors;
    }
    if (/:scope/i.test(selectors)) {
      selectors = makeref(selectors, element);
    }
    parsed = selectors.replace(/\x00|\\$/g, "\uFFFD").replace(REX.CombineWSP, " ").replace(REX.PseudosWSP, "$1").replace(REX.TabCharWSP, "	").replace(REX.CommaGroup, ",").replace(REX.TrimSpaces, "");
    if ((expressions = parsed.match(reValidator)) && expressions.join("") == parsed) {
      expressions = parsed.match(REX.SplitGroup);
      if (parsed[parsed.length - 1] == ",") {
        emit(qsInvalid);
        return Config.VERBOSITY ? void 0 : false;
      }
    } else {
      emit("'" + selectors + "'" + qsInvalid);
      return Config.VERBOSITY ? void 0 : false;
    }
    matchResolvers[selectors] = match_collect(expressions, callback);
    return match_assert(matchResolvers[selectors].factory, element, callback);
  }, first = function _querySelector2(selectors, context, callback) {
    if (arguments.length === 0) {
      emit(qsNotArgs, TypeError);
    }
    return select(
      selectors,
      context,
      typeof callback == "function" ? function firstMatch(element) {
        callback(element);
        return false;
      } : function firstMatch() {
        return false;
      }
    )[0] || null;
  }, select = function _querySelectorAll2(selectors, context, callback) {
    var expressions, nodes, parsed, resolver;
    context || (context = doc);
    if (selectors) {
      if (resolver = selectResolvers[selectors]) {
        if (resolver.context === context && resolver.callback === callback) {
          var f2 = resolver.factory, h2 = resolver.htmlset, n2 = resolver.nodeset, nodes = [];
          if (n2.length > 1) {
            for (var i3 = 0, l3 = n2.length, list; l3 > i3; ++i3) {
              list = compat[n2[i3][0]](context, n2[i3].slice(1))();
              if (f2[i3] !== null) {
                f2[i3](list, callback, context, nodes);
              } else {
                nodes = nodes.concat(list);
              }
            }
            if (l3 > 1 && nodes.length > 1) {
              nodes.sort(documentOrder);
              hasDupes && (nodes = unique(nodes));
            }
          } else {
            if (f2[0]) {
              nodes = f2[0](h2[0](), callback, context, nodes);
            } else {
              nodes = h2[0]();
            }
          }
          return typeof callback == "function" ? concatCall(nodes, callback) : nodes;
        }
      }
    }
    lastSelected = selectors;
    if (arguments.length === 0) {
      emit(qsNotArgs, TypeError);
      return Config.VERBOSITY ? void 0 : none;
    } else if (arguments[0] === "") {
      emit("''" + qsInvalid);
      return Config.VERBOSITY ? void 0 : none;
    } else if (lastContext !== context) {
      lastContext = switchContext(context);
    }
    if (typeof selectors != "string") {
      selectors = "" + selectors;
    }
    if (/:scope/i.test(selectors)) {
      selectors = makeref(selectors, context);
    }
    parsed = selectors.replace(/\x00|\\$/g, "\uFFFD").replace(REX.CombineWSP, " ").replace(REX.PseudosWSP, "$1").replace(REX.TabCharWSP, "	").replace(REX.CommaGroup, ",").replace(REX.TrimSpaces, "");
    if ((expressions = parsed.match(reValidator)) && expressions.join("") == parsed) {
      expressions = parsed.match(REX.SplitGroup);
      if (parsed[parsed.length - 1] == ",") {
        emit(qsInvalid);
        return Config.VERBOSITY ? void 0 : false;
      }
    } else {
      emit("'" + selectors + "'" + qsInvalid);
      return Config.VERBOSITY ? void 0 : false;
    }
    selectResolvers[selectors] = collect(expressions, context, callback);
    nodes = selectResolvers[selectors].results;
    return typeof callback == "function" ? concatCall(nodes, callback) : nodes;
  }, optimize = function(selector, token) {
    var index = token.index, length = token[1].length + token[2].length;
    return selector.slice(0, index) + (" >+~".indexOf(selector.charAt(index - 1)) > -1 ? ":[".indexOf(selector.charAt(index + length + 1)) > -1 ? "*" : "" : "") + selector.slice(index + length - (token[1] == "*" ? 1 : 0));
  }, collect = function(selectors, context, callback) {
    var i3, l3, seen = {}, token = ["", "*", "*"], optimized = selectors, factory = [], htmlset = [], nodeset = [], results = [], type;
    for (i3 = 0, l3 = selectors.length; l3 > i3; ++i3) {
      if (!seen[selectors[i3]] && (seen[selectors[i3]] = true)) {
        type = selectors[i3].match(reOptimizer);
        if (type && type[1] != ":" && (token = type)) {
          token[1] || (token[1] = "*");
          optimized[i3] = optimize(optimized[i3], token);
        } else {
          token = ["", "*", "*"];
        }
      }
      nodeset[i3] = token[1] + token[2];
      htmlset[i3] = compat[token[1]](context, token[2]);
      factory[i3] = compile(optimized[i3], true, null);
      factory[i3] ? factory[i3](htmlset[i3](), callback, context, results) : result.concat(htmlset[i3]());
    }
    if (l3 > 1) {
      results.sort(documentOrder);
      hasDupes && (results = unique(results));
    }
    return {
      callback,
      context,
      factory,
      htmlset,
      nodeset,
      results
    };
  }, _closest, _matches, _querySelector, _querySelectorAll, install = function(all) {
    _closest = Element.prototype.closest;
    _matches = Element.prototype.matches;
    _querySelector = Document.prototype.querySelector;
    _querySelectorAll = Document.prototype.querySelectorAll;
    Element.prototype.closest = function closest() {
      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;
      if (!("nodeType" in this)) {
        emit("'closest' called on an object that does not implement interface " + ctor + ".", TypeError);
      }
      return arguments.length < 1 ? ancestor.apply(this, []) : arguments.length < 2 ? ancestor.apply(this, [arguments[0], this]) : ancestor.apply(this, [arguments[0], this, typeof arguments[1] == "function" ? arguments[1] : void 0]);
    };
    Element.prototype.matches = function matches() {
      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;
      if (!("nodeType" in this)) {
        emit("'matches' called on an object that does not implement interface " + ctor + ".", TypeError);
      }
      return arguments.length < 1 ? match.apply(this, []) : arguments.length < 2 ? match.apply(this, [arguments[0], this]) : match.apply(this, [arguments[0], this, typeof arguments[1] == "function" ? arguments[1] : void 0]);
    };
    Element.prototype.querySelector = Document.prototype.querySelector = DocumentFragment.prototype.querySelector = function querySelector() {
      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;
      if (!("nodeType" in this)) {
        emit("'querySelector' called on an object that does not implement interface " + ctor + ".", TypeError);
      }
      return arguments.length < 1 ? first.apply(this, []) : arguments.length < 2 ? first.apply(this, [arguments[0], this]) : first.apply(this, [arguments[0], this, typeof arguments[1] == "function" ? arguments[1] : void 0]);
    };
    Element.prototype.querySelectorAll = Document.prototype.querySelectorAll = DocumentFragment.prototype.querySelectorAll = function querySelectorAll() {
      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;
      if (!("nodeType" in this)) {
        emit("'querySelectorAll' called on an object that does not implement interface " + ctor + ".", TypeError);
      }
      return arguments.length < 1 ? select.apply(this, []) : arguments.length < 2 ? select.apply(this, [arguments[0], this]) : select.apply(this, [arguments[0], this, typeof arguments[1] == "function" ? arguments[1] : void 0]);
    };
    if (all) {
      document.addEventListener("load", function(e2) {
        var c2, d2, r2, s2, t2 = e2.target;
        if (/iframe/i.test(t2.localName)) {
          c2 = "(" + Export + ")(this, " + Factory + ");";
          d2 = t2.contentDocument;
          s2 = d2.createElement("script");
          s2.textContent = c2 + "NW.Dom.install()";
          r2 = d2.documentElement;
          r2.removeChild(r2.insertBefore(s2, r2.firstChild));
        }
      }, true);
    }
  }, uninstall = function() {
    Element.prototype.closest = _closest;
    Element.prototype.matches = _matches;
    Element.prototype.querySelector = Document.prototype.querySelector = DocumentFragment.prototype.querySelector = _querySelector;
    Element.prototype.querySelectorAll = Document.prototype.querySelectorAll = DocumentFragment.prototype.querySelectorAll = _querySelectorAll;
  }, none = Array(), lastContext, lastMatched, lastSelected, matchLambdas = {}, selectLambdas = {}, matchResolvers = {}, selectResolvers = {}, Snapshot = {
    doc,
    from: doc,
    root,
    byTag,
    first,
    match,
    ancestor,
    nthOfType,
    nthElement,
    hasAttributeNS
  }, Dom = {
    // exported cache objects
    lastMatched,
    lastSelected,
    matchLambdas,
    selectLambdas,
    matchResolvers,
    selectResolvers,
    // exported compiler macros
    CFG,
    M_BODY,
    S_BODY,
    M_TEST,
    S_TEST,
    // exported engine methods
    byId,
    byTag,
    byClass,
    match,
    first,
    select,
    closest: ancestor,
    compile,
    configure,
    emit,
    Config,
    Snapshot,
    Version: version,
    install,
    uninstall,
    Operators,
    Selectors,
    // register a new selector combinator symbol and its related function resolver
    registerCombinator: function(combinator, resolver) {
      var i3 = 0, l3 = combinator.length, symbol;
      for (; l3 > i3; ++i3) {
        if (combinator[i3] != "=") {
          symbol = combinator[i3];
          break;
        }
      }
      if (CFG.combinators.indexOf(symbol) < 0) {
        CFG.combinators = CFG.combinators.replace("](", symbol + "](");
        CFG.combinators = CFG.combinators.replace("])", symbol + "])");
        Combinators[combinator] = resolver;
        setIdentifierSyntax();
      } else {
        console.warn("Warning: the '" + combinator + "' combinator is already registered.");
      }
    },
    // register a new attribute operator symbol and its related function resolver
    registerOperator: function(operator, resolver) {
      var i3 = 0, l3 = operator.length, symbol;
      for (; l3 > i3; ++i3) {
        if (operator[i3] != "=") {
          symbol = operator[i3];
          break;
        }
      }
      if (CFG.operators.indexOf(symbol) < 0 && !Operators[operator]) {
        CFG.operators = CFG.operators.replace("]=", symbol + "]=");
        Operators[operator] = resolver;
        setIdentifierSyntax();
      } else {
        console.warn("Warning: the '" + operator + "' operator is already registered.");
      }
    },
    // register a new selector symbol and its related function resolver
    registerSelector: function(name, rexp, func) {
      Selectors[name] || (Selectors[name] = {
        Expression: rexp,
        Callback: func
      });
    }
  };
  initialize(doc);
  return Dom;
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/nwsapi-types.ts
var DOM = nwsapi_default;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/sizzle-types.ts
init_define_BUILD_INFO();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/sizzle.js
init_define_BUILD_INFO();
var sizzle_default = (document2) => {
  const sizzleWindow = {
    document: document2
  };
  SetupSizzle(sizzleWindow);
  const { Sizzle } = sizzleWindow;
  return {
    first(selectors, context) {
      return Sizzle(selectors, context)[0] ?? null;
    },
    select(selectors, context) {
      return Sizzle(selectors, context);
    },
    match(selectors, context) {
      return Sizzle.matchesSelector(context, selectors);
    }
  };
};
function SetupSizzle(window2) {
  var i3, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document2, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * /* @__PURE__ */ new Date(), preferredDoc = window2.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a2, b2) {
    if (a2 === b2) {
      hasDuplicate = true;
    }
    return 0;
  }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, pushNative = arr.push, push2 = arr.push, slice2 = arr.slice, indexOf2 = function(list, elem) {
    var i4 = 0, len = list.length;
    for (; i4 < len; i4++) {
      if (list[i4] === elem) {
        return i4;
      }
    }
    return -1;
  }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
  "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
  // or strings [capture 3 or capture 4]"
  `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp(
    "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
    "g"
  ), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp(
    "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"
  ), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
    ID: new RegExp("^#(" + identifier + ")"),
    CLASS: new RegExp("^\\.(" + identifier + ")"),
    TAG: new RegExp("^(" + identifier + "|[*])"),
    ATTR: new RegExp("^" + attributes),
    PSEUDO: new RegExp("^" + pseudos),
    CHILD: new RegExp(
      "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
      "i"
    ),
    bool: new RegExp("^(?:" + booleans + ")$", "i"),
    // For use in libraries implementing .is()
    // We use this for POS matching in `select`
    needsContext: new RegExp(
      "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",
      "i"
    )
  }, rhtml = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp(
    "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])",
    "g"
  ), funescape = function(escape, nonHex) {
    var high = "0x" + escape.slice(1) - 65536;
    return nonHex ? (
      // Strip the backslash prefix from a non-hex escape sequence
      nonHex
    ) : (
      // Replace a hexadecimal escape sequence with the encoded Unicode code point
      // Support: IE <=11+
      // For values outside the Basic Multilingual Plane (BMP), manually construct a
      // surrogate pair
      high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
    );
  }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
    if (asCodePoint) {
      if (ch === "\0") {
        return "\uFFFD";
      }
      return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
    }
    return "\\" + ch;
  }, unloadHandler = function() {
    setDocument();
  }, inDisabledFieldset = addCombinator(
    function(elem) {
      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    },
    { dir: "parentNode", next: "legend" }
  );
  try {
    push2.apply(
      arr = slice2.call(preferredDoc.childNodes),
      preferredDoc.childNodes
    );
    arr[preferredDoc.childNodes.length].nodeType;
  } catch (e2) {
    push2 = {
      apply: arr.length ? (
        // Leverage slice if possible
        function(target, els) {
          pushNative.apply(target, slice2.call(els));
        }
      ) : (
        // Support: IE<9
        // Otherwise append directly
        function(target, els) {
          var j2 = target.length, i4 = 0;
          while (target[j2++] = els[i4++]) {
          }
          target.length = j2 - 1;
        }
      )
    };
  }
  function Sizzle(selector, context, results, seed) {
    var m2, i4, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
    results = results || [];
    if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
      return results;
    }
    if (!seed) {
      setDocument(context);
      context = context || document2;
      if (documentIsHTML) {
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          if (m2 = match[1]) {
            if (nodeType === 9) {
              if (elem = context.getElementById(m2)) {
                if (elem.id === m2) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (newContext && (elem = newContext.getElementById(m2)) && contains(context, elem) && elem.id === m2) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push2.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m2 = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push2.apply(results, context.getElementsByClassName(m2));
            return results;
          }
        }
        if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && // Support: IE 8 only
        // Exclude object elements
        (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
          newSelector = selector;
          newContext = context;
          if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            if (newContext !== context || !support.scope) {
              if (nid = context.getAttribute("id")) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", nid = expando);
              }
            }
            groups = tokenize(selector);
            i4 = groups.length;
            while (i4--) {
              groups[i4] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i4]);
            }
            newSelector = groups.join(",");
          }
          try {
            push2.apply(results, newContext.querySelectorAll(newSelector));
            return results;
          } catch (qsaError) {
            nonnativeSelectorCache(selector, true);
          } finally {
            if (nid === expando) {
              context.removeAttribute("id");
            }
          }
        }
      }
    }
    return select(selector.replace(rtrim, "$1"), context, results, seed);
  }
  function createCache() {
    var keys = [];
    function cache(key, value) {
      if (keys.push(key + " ") > Expr.cacheLength) {
        delete cache[keys.shift()];
      }
      return cache[key + " "] = value;
    }
    return cache;
  }
  function markFunction(fn2) {
    fn2[expando] = true;
    return fn2;
  }
  function assert(fn2) {
    return true;
    var el = document2.createElement("fieldset");
    try {
      return !!fn2(el);
    } catch (e2) {
      return false;
    } finally {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
      el = null;
    }
  }
  function addHandle(attrs, handler) {
    var arr2 = attrs.split("|"), i4 = arr2.length;
    while (i4--) {
      Expr.attrHandle[arr2[i4]] = handler;
    }
  }
  function siblingCheck(a2, b2) {
    var cur = b2 && a2, diff = cur && a2.nodeType === 1 && b2.nodeType === 1 && a2.sourceIndex - b2.sourceIndex;
    if (diff) {
      return diff;
    }
    if (cur) {
      while (cur = cur.nextSibling) {
        if (cur === b2) {
          return -1;
        }
      }
    }
    return a2 ? 1 : -1;
  }
  function createInputPseudo(type) {
    return function(elem) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === type;
    };
  }
  function createButtonPseudo(type) {
    return function(elem) {
      var name = elem.nodeName.toLowerCase();
      return (name === "input" || name === "button") && elem.type === type;
    };
  }
  function createDisabledPseudo(disabled) {
    return function(elem) {
      if ("form" in elem) {
        if (elem.parentNode && elem.disabled === false) {
          if ("label" in elem) {
            if ("label" in elem.parentNode) {
              return elem.parentNode.disabled === disabled;
            } else {
              return elem.disabled === disabled;
            }
          }
          return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
          /* jshint -W018 */
          elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
        }
        return elem.disabled === disabled;
      } else if ("label" in elem) {
        return elem.disabled === disabled;
      }
      return false;
    };
  }
  function createPositionalPseudo(fn2) {
    return markFunction(function(argument) {
      argument = +argument;
      return markFunction(function(seed, matches2) {
        var j2, matchIndexes = fn2([], seed.length, argument), i4 = matchIndexes.length;
        while (i4--) {
          if (seed[j2 = matchIndexes[i4]]) {
            seed[j2] = !(matches2[j2] = seed[j2]);
          }
        }
      });
    });
  }
  function testContext(context) {
    return context && typeof context.getElementsByTagName !== "undefined" && context;
  }
  support = Sizzle.support = {};
  isXML = Sizzle.isXML = function(elem) {
    var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
    return !rhtml.test(namespace || docElem2 && docElem2.nodeName || "HTML");
  };
  setDocument = Sizzle.setDocument = function(node) {
    var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
    if (doc == document2 || doc.nodeType !== 9 || !doc.documentElement) {
      return document2;
    }
    document2 = doc;
    docElem = document2.documentElement;
    documentIsHTML = !isXML(document2);
    if (preferredDoc != document2 && (subWindow = document2.defaultView) && subWindow.top !== subWindow) {
      if (subWindow.addEventListener) {
        subWindow.addEventListener("unload", unloadHandler, false);
      } else if (subWindow.attachEvent) {
        subWindow.attachEvent("onunload", unloadHandler);
      }
    }
    support.scope = assert(function(el) {
      docElem.appendChild(el).appendChild(document2.createElement("div"));
      return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
    });
    support.attributes = assert(function(el) {
      el.className = "i";
      return !el.getAttribute("className");
    });
    support.getElementsByTagName = assert(function(el) {
      el.appendChild(document2.createComment(""));
      return !el.getElementsByTagName("*").length;
    });
    support.getElementsByClassName = rnative.test(
      document2.getElementsByClassName
    );
    support.getById = assert(function(el) {
      docElem.appendChild(el).id = expando;
      return !document2.getElementsByName || !document2.getElementsByName(expando).length;
    });
    if (support.getById) {
      Expr.filter["ID"] = function(id) {
        var attrId = id.replace(runescape, funescape);
        return function(elem) {
          return elem.getAttribute("id") === attrId;
        };
      };
      Expr.find["ID"] = function(id, context) {
        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
          var elem = context.getElementById(id);
          return elem ? [elem] : [];
        }
      };
    } else {
      Expr.filter["ID"] = function(id) {
        var attrId = id.replace(runescape, funescape);
        return function(elem) {
          var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
          return node2 && node2.value === attrId;
        };
      };
      Expr.find["ID"] = function(id, context) {
        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
          var node2, i4, elems, elem = context.getElementById(id);
          if (elem) {
            node2 = elem.getAttributeNode("id");
            if (node2 && node2.value === id) {
              return [elem];
            }
            elems = context.getElementsByName(id);
            i4 = 0;
            while (elem = elems[i4++]) {
              node2 = elem.getAttributeNode("id");
              if (node2 && node2.value === id) {
                return [elem];
              }
            }
          }
          return [];
        }
      };
    }
    Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
      if (typeof context.getElementsByTagName !== "undefined") {
        return context.getElementsByTagName(tag);
      } else if (context[customByTagNameSym]) {
        return context[customByTagNameSym](tag);
      } else if (support.qsa) {
        return context.querySelectorAll(tag);
      }
    } : function(tag, context) {
      var elem, tmp = [], i4 = 0, results = context.getElementsByTagName(tag);
      if (tag === "*") {
        while (elem = results[i4++]) {
          if (elem.nodeType === 1) {
            tmp.push(elem);
          }
        }
        return tmp;
      }
      return results;
    };
    Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
      if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
        return context.getElementsByClassName(className);
      } else if (context[customByClassNameSym]) {
        return context[customByClassNameSym](className);
      }
    };
    rbuggyMatches = [];
    rbuggyQSA = [];
    if (support.qsa = rnative.test(document2.querySelectorAll)) {
      assert(function(el) {
        var input;
        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
        if (el.querySelectorAll("[msallowcapture^='']").length) {
          rbuggyQSA.push("[*^$]=" + whitespace + `*(?:''|"")`);
        }
        if (!el.querySelectorAll("[selected]").length) {
          rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
        }
        if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
          rbuggyQSA.push("~=");
        }
        input = document2.createElement("input");
        input.setAttribute("name", "");
        el.appendChild(input);
        if (!el.querySelectorAll("[name='']").length) {
          rbuggyQSA.push(
            "\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`
          );
        }
        if (!el.querySelectorAll(":checked").length) {
          rbuggyQSA.push(":checked");
        }
        if (!el.querySelectorAll("a#" + expando + "+*").length) {
          rbuggyQSA.push(".#.+[+~]");
        }
        el.querySelectorAll("\\\f");
        rbuggyQSA.push("[\\r\\n\\f]");
      });
      assert(function(el) {
        el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
        var input = document2.createElement("input");
        input.setAttribute("type", "hidden");
        el.appendChild(input).setAttribute("name", "D");
        if (el.querySelectorAll("[name=d]").length) {
          rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
        }
        if (el.querySelectorAll(":enabled").length !== 2) {
          rbuggyQSA.push(":enabled", ":disabled");
        }
        docElem.appendChild(el).disabled = true;
        if (el.querySelectorAll(":disabled").length !== 2) {
          rbuggyQSA.push(":enabled", ":disabled");
        }
        el.querySelectorAll("*,:x");
        rbuggyQSA.push(",.*:");
      });
    }
    if (support.matchesSelector = rnative.test(
      matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector
    )) {
      assert(function(el) {
        support.disconnectedMatch = matches.call(el, "*");
        matches.call(el, "[s!='']:x");
        rbuggyMatches.push("!=", pseudos);
      });
    }
    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
    hasCompare = rnative.test(docElem.compareDocumentPosition);
    contains = hasCompare || rnative.test(docElem.contains) ? function(a2, b2) {
      var adown = a2.nodeType === 9 ? a2.documentElement : a2, bup = b2 && b2.parentNode;
      return a2 === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
    } : function(a2, b2) {
      if (b2) {
        while (b2 = b2.parentNode) {
          if (b2 === a2) {
            return true;
          }
        }
      }
      return false;
    };
    sortOrder = hasCompare ? function(a2, b2) {
      if (a2 === b2) {
        hasDuplicate = true;
        return 0;
      }
      var compare = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
      if (compare) {
        return compare;
      }
      compare = (a2.ownerDocument || a2) == (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : (
        // Otherwise we know they are disconnected
        1
      );
      if (compare & 1 || !support.sortDetached && b2.compareDocumentPosition(a2) === compare) {
        if (a2 == document2 || a2.ownerDocument == preferredDoc && contains(preferredDoc, a2)) {
          return -1;
        }
        if (b2 == document2 || b2.ownerDocument == preferredDoc && contains(preferredDoc, b2)) {
          return 1;
        }
        return sortInput ? indexOf2(sortInput, a2) - indexOf2(sortInput, b2) : 0;
      }
      return compare & 4 ? -1 : 1;
    } : function(a2, b2) {
      if (a2 === b2) {
        hasDuplicate = true;
        return 0;
      }
      var cur, i4 = 0, aup = a2.parentNode, bup = b2.parentNode, ap = [a2], bp = [b2];
      if (!aup || !bup) {
        return a2 == document2 ? -1 : b2 == document2 ? 1 : (
          /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a2) - indexOf2(sortInput, b2) : 0
        );
      } else if (aup === bup) {
        return siblingCheck(a2, b2);
      }
      cur = a2;
      while (cur = cur.parentNode) {
        ap.unshift(cur);
      }
      cur = b2;
      while (cur = cur.parentNode) {
        bp.unshift(cur);
      }
      while (ap[i4] === bp[i4]) {
        i4++;
      }
      return i4 ? (
        // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i4], bp[i4])
      ) : (
        // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        /* eslint-disable eqeqeq */
        ap[i4] == preferredDoc ? -1 : bp[i4] == preferredDoc ? 1 : (
          /* eslint-enable eqeqeq */
          0
        )
      );
    };
    return document2;
  };
  Sizzle.matches = function(expr, elements) {
    return Sizzle(expr, null, null, elements);
  };
  Sizzle.matchesSelector = function(elem, expr) {
    setDocument(elem);
    if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
      try {
        var ret = matches.call(elem, expr);
        if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
        // fragment in IE 9
        elem.document && elem.document.nodeType !== 11) {
          return ret;
        }
      } catch (e2) {
        nonnativeSelectorCache(expr, true);
      }
    }
    return Sizzle(expr, document2, null, [elem]).length > 0;
  };
  Sizzle.contains = function(context, elem) {
    if ((context.ownerDocument || context) != document2) {
      setDocument(context);
    }
    return contains(context, elem);
  };
  Sizzle.attr = function(elem, name) {
    if ((elem.ownerDocument || elem) != document2) {
      setDocument(elem);
    }
    var fn2 = Expr.attrHandle[name.toLowerCase()], val = fn2 && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn2(elem, name, !documentIsHTML) : void 0;
    return val !== void 0 ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
  };
  Sizzle.escape = function(sel) {
    return (sel + "").replace(rcssescape, fcssescape);
  };
  Sizzle.error = function(msg) {
    throw new DOMException(`'${msg}' is not a valid selector`);
  };
  Sizzle.uniqueSort = function(results) {
    var elem, duplicates = [], j2 = 0, i4 = 0;
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice(0);
    results.sort(sortOrder);
    if (hasDuplicate) {
      while (elem = results[i4++]) {
        if (elem === results[i4]) {
          j2 = duplicates.push(i4);
        }
      }
      while (j2--) {
        results.splice(duplicates[j2], 1);
      }
    }
    sortInput = null;
    return results;
  };
  getText = Sizzle.getText = function(elem) {
    var node, ret = "", i4 = 0, nodeType = elem.nodeType;
    if (!nodeType) {
      while (node = elem[i4++]) {
        ret += getText(node);
      }
    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
      if (typeof elem.textContent === "string") {
        return elem.textContent;
      } else {
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          ret += getText(elem);
        }
      }
    } else if (nodeType === 3 || nodeType === 4) {
      return elem.nodeValue;
    }
    return ret;
  };
  Expr = Sizzle.selectors = {
    // Can be adjusted by the user
    cacheLength: 50,
    createPseudo: markFunction,
    match: matchExpr,
    attrHandle: {},
    find: {},
    relative: {
      ">": { dir: "parentNode", first: true },
      " ": { dir: "parentNode" },
      "+": { dir: "previousSibling", first: true },
      "~": { dir: "previousSibling" }
    },
    preFilter: {
      ATTR: function(match) {
        match[1] = match[1].replace(runescape, funescape);
        match[3] = (match[3] || match[4] || match[5] || "").replace(
          runescape,
          funescape
        );
        if (match[2] === "~=") {
          match[3] = " " + match[3] + " ";
        }
        return match.slice(0, 4);
      },
      CHILD: function(match) {
        match[1] = match[1].toLowerCase();
        if (match[1].slice(0, 3) === "nth") {
          if (!match[3]) {
            Sizzle.error(match[0]);
          }
          match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
          match[5] = +(match[7] + match[8] || match[3] === "odd");
        } else if (match[3]) {
          Sizzle.error(match[0]);
        }
        return match;
      },
      PSEUDO: function(match) {
        var excess, unquoted = !match[6] && match[2];
        if (matchExpr["CHILD"].test(match[0])) {
          return null;
        }
        if (match[3]) {
          match[2] = match[4] || match[5] || "";
        } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
        (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
        (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
          match[0] = match[0].slice(0, excess);
          match[2] = unquoted.slice(0, excess);
        }
        return match.slice(0, 3);
      }
    },
    filter: {
      TAG: function(nodeNameSelector) {
        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
        return nodeNameSelector === "*" ? function() {
          return true;
        } : function(elem) {
          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
        };
      },
      CLASS: function(className) {
        var pattern = classCache[className + " "];
        return pattern || (pattern = new RegExp(
          "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"
        )) && classCache(className, function(elem) {
          return pattern.test(
            typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
          );
        });
      },
      ATTR: function(name, operator, check) {
        return function(elem) {
          var result2 = Sizzle.attr(elem, name);
          if (result2 == null) {
            return operator === "!=";
          }
          if (!operator) {
            return true;
          }
          result2 += "";
          return operator === "=" ? result2 === check : operator === "!=" ? result2 !== check : operator === "^=" ? check && result2.indexOf(check) === 0 : operator === "*=" ? check && result2.indexOf(check) > -1 : operator === "$=" ? check && result2.slice(-check.length) === check : operator === "~=" ? (" " + result2.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result2 === check || result2.slice(0, check.length + 1) === check + "-" : false;
        };
      },
      CHILD: function(type, what, _argument, first, last) {
        var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
        return first === 1 && last === 0 ? (
          // Shortcut for :nth-*(n)
          function(elem) {
            return !!elem.parentNode;
          }
        ) : function(elem, _context, xml) {
          var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
          if (parent) {
            if (simple) {
              while (dir) {
                node = elem;
                while (node = node[dir]) {
                  if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                    return false;
                  }
                }
                start = dir = type === "only" && !start && "nextSibling";
              }
              return true;
            }
            start = [forward ? parent.firstChild : parent.lastChild];
            if (forward && useCache) {
              node = parent;
              outerCache = node[expando] || (node[expando] = {});
              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
              cache = uniqueCache[type] || [];
              nodeIndex = cache[0] === dirruns && cache[1];
              diff = nodeIndex && cache[2];
              node = nodeIndex && parent.childNodes[nodeIndex];
              while (node = ++nodeIndex && node && node[dir] || // Fallback to seeking `elem` from the start
              (diff = nodeIndex = 0) || start.pop()) {
                if (node.nodeType === 1 && ++diff && node === elem) {
                  uniqueCache[type] = [dirruns, nodeIndex, diff];
                  break;
                }
              }
            } else {
              if (useCache) {
                node = elem;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex;
              }
              if (diff === false) {
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      uniqueCache[type] = [dirruns, diff];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
            }
            diff -= last;
            return diff === first || diff % first === 0 && diff / first >= 0;
          }
        };
      },
      PSEUDO: function(pseudo, argument) {
        var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
        if (fn2[expando]) {
          return fn2(argument);
        }
        if (fn2.length > 1) {
          args = [pseudo, pseudo, "", argument];
          return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
            var idx, matched = fn2(seed, argument), i4 = matched.length;
            while (i4--) {
              idx = indexOf2(seed, matched[i4]);
              seed[idx] = !(matches2[idx] = matched[i4]);
            }
          }) : function(elem) {
            return fn2(elem, 0, args);
          };
        }
        return fn2;
      }
    },
    pseudos: {
      // Potentially complex pseudos
      not: markFunction(function(selector) {
        var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
        return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
          var elem, unmatched = matcher(seed, null, xml, []), i4 = seed.length;
          while (i4--) {
            if (elem = unmatched[i4]) {
              seed[i4] = !(matches2[i4] = elem);
            }
          }
        }) : function(elem, _context, xml) {
          input[0] = elem;
          matcher(input, null, xml, results);
          input[0] = null;
          return !results.pop();
        };
      }),
      has: markFunction(function(selector) {
        return function(elem) {
          return Sizzle(selector, elem).length > 0;
        };
      }),
      contains: markFunction(function(text) {
        text = text.replace(runescape, funescape);
        return function(elem) {
          return (elem.textContent || getText(elem)).indexOf(text) > -1;
        };
      }),
      // "Whether an element is represented by a :lang() selector
      // is based solely on the element's language value
      // being equal to the identifier C,
      // or beginning with the identifier C immediately followed by "-".
      // The matching of C against the element's language value is performed case-insensitively.
      // The identifier C does not have to be a valid language name."
      // http://www.w3.org/TR/selectors/#lang-pseudo
      lang: markFunction(function(lang) {
        if (!ridentifier.test(lang || "")) {
          Sizzle.error("unsupported lang: " + lang);
        }
        lang = lang.replace(runescape, funescape).toLowerCase();
        return function(elem) {
          var elemLang;
          do {
            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
              elemLang = elemLang.toLowerCase();
              return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
            }
          } while ((elem = elem.parentNode) && elem.nodeType === 1);
          return false;
        };
      }),
      // Miscellaneous
      target: function(elem) {
        var hash = window2.location && window2.location.hash;
        return hash && hash.slice(1) === elem.id;
      },
      root: function(elem) {
        return elem === docElem;
      },
      focus: function(elem) {
        return elem === document2.activeElement && (!document2.hasFocus || document2.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
      },
      // Boolean properties
      enabled: createDisabledPseudo(false),
      disabled: createDisabledPseudo(true),
      checked: function(elem) {
        var nodeName = elem.nodeName.toLowerCase();
        return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
      },
      selected: function(elem) {
        if (elem.parentNode) {
          elem.parentNode.selectedIndex;
        }
        return elem.selected === true;
      },
      // Contents
      empty: function(elem) {
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          if (elem.nodeType < 6) {
            return false;
          }
        }
        return true;
      },
      parent: function(elem) {
        return !Expr.pseudos["empty"](elem);
      },
      // Element/input types
      header: function(elem) {
        return rheader.test(elem.nodeName);
      },
      input: function(elem) {
        return rinputs.test(elem.nodeName);
      },
      button: function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === "button" || name === "button";
      },
      text: function(elem) {
        var attr;
        return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE<8
        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
        ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
      },
      // Position-in-collection
      first: createPositionalPseudo(function() {
        return [0];
      }),
      last: createPositionalPseudo(function(_matchIndexes, length) {
        return [length - 1];
      }),
      eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
        return [argument < 0 ? argument + length : argument];
      }),
      even: createPositionalPseudo(function(matchIndexes, length) {
        var i4 = 0;
        for (; i4 < length; i4 += 2) {
          matchIndexes.push(i4);
        }
        return matchIndexes;
      }),
      odd: createPositionalPseudo(function(matchIndexes, length) {
        var i4 = 1;
        for (; i4 < length; i4 += 2) {
          matchIndexes.push(i4);
        }
        return matchIndexes;
      }),
      lt: createPositionalPseudo(function(matchIndexes, length, argument) {
        var i4 = argument < 0 ? argument + length : argument > length ? length : argument;
        for (; --i4 >= 0; ) {
          matchIndexes.push(i4);
        }
        return matchIndexes;
      }),
      gt: createPositionalPseudo(function(matchIndexes, length, argument) {
        var i4 = argument < 0 ? argument + length : argument;
        for (; ++i4 < length; ) {
          matchIndexes.push(i4);
        }
        return matchIndexes;
      })
    }
  };
  Expr.pseudos["nth"] = Expr.pseudos["eq"];
  for (i3 in {
    radio: true,
    checkbox: true,
    file: true,
    password: true,
    image: true
  }) {
    Expr.pseudos[i3] = createInputPseudo(i3);
  }
  for (i3 in { submit: true, reset: true }) {
    Expr.pseudos[i3] = createButtonPseudo(i3);
  }
  function setFilters() {
  }
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();
  tokenize = Sizzle.tokenize = function(selector, parseOnly) {
    var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
    if (cached) {
      return parseOnly ? 0 : cached.slice(0);
    }
    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;
    while (soFar) {
      if (!matched || (match = rcomma.exec(soFar))) {
        if (match) {
          soFar = soFar.slice(match[0].length) || soFar;
        }
        groups.push(tokens = []);
      }
      matched = false;
      if (match = rcombinators.exec(soFar)) {
        matched = match.shift();
        tokens.push({
          value: matched,
          // Cast descendant combinators to space
          type: match[0].replace(rtrim, " ")
        });
        soFar = soFar.slice(matched.length);
      }
      for (type in Expr.filter) {
        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type,
            matches: match
          });
          soFar = soFar.slice(matched.length);
        }
      }
      if (!matched) {
        break;
      }
    }
    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : (
      // Cache the tokens
      tokenCache(selector, groups).slice(0)
    );
  };
  function toSelector(tokens) {
    var i4 = 0, len = tokens.length, selector = "";
    for (; i4 < len; i4++) {
      selector += tokens[i4].value;
    }
    return selector;
  }
  function addCombinator(matcher, combinator, base) {
    var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
    return combinator.first ? (
      // Check against closest ancestor/preceding element
      function(elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
        return false;
      }
    ) : (
      // Check against all ancestor/preceding elements
      function(elem, context, xml) {
        var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return newCache[2] = oldCache[2];
              } else {
                uniqueCache[key] = newCache;
                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }
    );
  }
  function elementMatcher(matchers) {
    return matchers.length > 1 ? function(elem, context, xml) {
      var i4 = matchers.length;
      while (i4--) {
        if (!matchers[i4](elem, context, xml)) {
          return false;
        }
      }
      return true;
    } : matchers[0];
  }
  function multipleContexts(selector, contexts, results) {
    var i4 = 0, len = contexts.length;
    for (; i4 < len; i4++) {
      Sizzle(selector, contexts[i4], results);
    }
    return results;
  }
  function condense(unmatched, map2, filter2, context, xml) {
    var elem, newUnmatched = [], i4 = 0, len = unmatched.length, mapped = map2 != null;
    for (; i4 < len; i4++) {
      if (elem = unmatched[i4]) {
        if (!filter2 || filter2(elem, context, xml)) {
          newUnmatched.push(elem);
          if (mapped) {
            map2.push(i4);
          }
        }
      }
    }
    return newUnmatched;
  }
  function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
    if (postFilter && !postFilter[expando]) {
      postFilter = setMatcher(postFilter);
    }
    if (postFinder && !postFinder[expando]) {
      postFinder = setMatcher(postFinder, postSelector);
    }
    return markFunction(function(seed, results, context, xml) {
      var temp, i4, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
        selector || "*",
        context.nodeType ? [context] : context,
        []
      ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? (
        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? (
          // ...intermediate processing is necessary
          []
        ) : (
          // ...otherwise use results directly
          results
        )
      ) : matcherIn;
      if (matcher) {
        matcher(matcherIn, matcherOut, context, xml);
      }
      if (postFilter) {
        temp = condense(matcherOut, postMap);
        postFilter(temp, [], context, xml);
        i4 = temp.length;
        while (i4--) {
          if (elem = temp[i4]) {
            matcherOut[postMap[i4]] = !(matcherIn[postMap[i4]] = elem);
          }
        }
      }
      if (seed) {
        if (postFinder || preFilter) {
          if (postFinder) {
            temp = [];
            i4 = matcherOut.length;
            while (i4--) {
              if (elem = matcherOut[i4]) {
                temp.push(matcherIn[i4] = elem);
              }
            }
            postFinder(null, matcherOut = [], temp, xml);
          }
          i4 = matcherOut.length;
          while (i4--) {
            if ((elem = matcherOut[i4]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i4]) > -1) {
              seed[temp] = !(results[temp] = elem);
            }
          }
        }
      } else {
        matcherOut = condense(
          matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
        );
        if (postFinder) {
          postFinder(null, results, matcherOut, xml);
        } else {
          push2.apply(results, matcherOut);
        }
      }
    });
  }
  function matcherFromTokens(tokens) {
    var checkContext, matcher, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i4 = leadingRelative ? 1 : 0, matchContext = addCombinator(
      function(elem) {
        return elem === checkContext;
      },
      implicitRelative,
      true
    ), matchAnyContext = addCombinator(
      function(elem) {
        return indexOf2(checkContext, elem) > -1;
      },
      implicitRelative,
      true
    ), matchers = [
      function(elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
        checkContext = null;
        return ret;
      }
    ];
    for (; i4 < len; i4++) {
      if (matcher = Expr.relative[tokens[i4].type]) {
        matchers = [addCombinator(elementMatcher(matchers), matcher)];
      } else {
        matcher = Expr.filter[tokens[i4].type].apply(null, tokens[i4].matches);
        if (matcher[expando]) {
          j2 = ++i4;
          for (; j2 < len; j2++) {
            if (Expr.relative[tokens[j2].type]) {
              break;
            }
          }
          return setMatcher(
            i4 > 1 && elementMatcher(matchers),
            i4 > 1 && toSelector(
              // If the preceding token was a descendant combinator, insert an implicit any-element `*`
              tokens.slice(0, i4 - 1).concat({ value: tokens[i4 - 2].type === " " ? "*" : "" })
            ).replace(rtrim, "$1"),
            matcher,
            i4 < j2 && matcherFromTokens(tokens.slice(i4, j2)),
            j2 < len && matcherFromTokens(tokens = tokens.slice(j2)),
            j2 < len && toSelector(tokens)
          );
        }
        matchers.push(matcher);
      }
    }
    return elementMatcher(matchers);
  }
  function matcherFromGroupMatchers(elementMatchers, setMatchers) {
    var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
      var elem, j2, matcher, matchedCount = 0, i4 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
      if (outermost) {
        outermostContext = context == document2 || context || outermost;
      }
      for (; i4 !== len && (elem = elems[i4]) != null; i4++) {
        if (byElement && elem) {
          j2 = 0;
          if (!context && elem.ownerDocument != document2) {
            setDocument(elem);
            xml = !documentIsHTML;
          }
          while (matcher = elementMatchers[j2++]) {
            if (matcher(elem, context || document2, xml)) {
              results.push(elem);
              break;
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
          }
        }
        if (bySet) {
          if (elem = !matcher && elem) {
            matchedCount--;
          }
          if (seed) {
            unmatched.push(elem);
          }
        }
      }
      matchedCount += i4;
      if (bySet && i4 !== matchedCount) {
        j2 = 0;
        while (matcher = setMatchers[j2++]) {
          matcher(unmatched, setMatched, context, xml);
        }
        if (seed) {
          if (matchedCount > 0) {
            while (i4--) {
              if (!(unmatched[i4] || setMatched[i4])) {
                setMatched[i4] = pop.call(results);
              }
            }
          }
          setMatched = condense(setMatched);
        }
        push2.apply(results, setMatched);
        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
          Sizzle.uniqueSort(results);
        }
      }
      if (outermost) {
        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      }
      return unmatched;
    };
    return bySet ? markFunction(superMatcher) : superMatcher;
  }
  compile = Sizzle.compile = function(selector, match) {
    var i4, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
    if (!cached) {
      if (!match) {
        match = tokenize(selector);
      }
      i4 = match.length;
      while (i4--) {
        cached = matcherFromTokens(match[i4]);
        if (cached[expando]) {
          setMatchers.push(cached);
        } else {
          elementMatchers.push(cached);
        }
      }
      cached = compilerCache(
        selector,
        matcherFromGroupMatchers(elementMatchers, setMatchers)
      );
      cached.selector = selector;
    }
    return cached;
  };
  select = Sizzle.select = function(selector, context, results, seed) {
    var i4, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
    results = results || [];
    if (match.length === 1) {
      tokens = match[0] = match[0].slice(0);
      if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
        context = (Expr.find["ID"](
          token.matches[0].replace(runescape, funescape),
          context
        ) || [])[0];
        if (!context) {
          return results;
        } else if (compiled) {
          context = context.parentNode;
        }
        selector = selector.slice(tokens.shift().value.length);
      }
      i4 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
      while (i4--) {
        token = tokens[i4];
        if (Expr.relative[type = token.type]) {
          break;
        }
        if (find = Expr.find[type]) {
          if (seed = find(
            token.matches[0].replace(runescape, funescape),
            rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
          )) {
            tokens.splice(i4, 1);
            selector = seed.length && toSelector(tokens);
            if (!selector) {
              push2.apply(results, seed);
              return results;
            }
            break;
          }
        }
      }
    }
    (compiled || compile(selector, match))(
      seed,
      context,
      !documentIsHTML,
      results,
      !context || rsibling.test(selector) && testContext(context.parentNode) || context
    );
    return results;
  };
  support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
  support.detectDuplicates = !!hasDuplicate;
  setDocument();
  support.sortDetached = assert(function(el) {
    return el.compareDocumentPosition(document2.createElement("fieldset")) & 1;
  });
  if (!assert(function(el) {
    el.innerHTML = "<a href='#'></a>";
    return el.firstChild.getAttribute("href") === "#";
  })) {
    addHandle("type|href|height|width", function(elem, name, isXML2) {
      if (!isXML2) {
        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
      }
    });
  }
  if (!support.attributes || !assert(function(el) {
    el.innerHTML = "<input/>";
    el.firstChild.setAttribute("value", "");
    return el.firstChild.getAttribute("value") === "";
  })) {
    addHandle("value", function(elem, _name, isXML2) {
      if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
        return elem.defaultValue;
      }
    });
  }
  if (!assert(function(el) {
    return el.getAttribute("disabled") == null;
  })) {
    addHandle(booleans, function(elem, name, isXML2) {
      var val;
      if (!isXML2) {
        return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      }
    });
  }
  var _sizzle = window2.Sizzle;
  Sizzle.noConflict = function() {
    if (window2.Sizzle === Sizzle) {
      window2.Sizzle = _sizzle;
    }
    return Sizzle;
  };
  if (typeof define === "function" && define.amd) {
    define(function() {
      return Sizzle;
    });
  } else if (typeof module !== "undefined" && module.exports) {
    module.exports = Sizzle;
  } else {
    window2.Sizzle = Sizzle;
  }
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/sizzle-types.ts
var DOM2 = sizzle_default;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/selectors.ts
var codeGenerationAllowed = null;
function getSelectorEngine() {
  if (codeGenerationAllowed === null) {
    try {
      new Function("");
      codeGenerationAllowed = true;
    } catch (e2) {
      codeGenerationAllowed = false;
    }
  }
  if (codeGenerationAllowed) {
    return DOM;
  } else {
    return DOM2;
  }
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/document.ts
var DOMImplementation = class {
  constructor(key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor.");
    }
  }
  createDocument() {
    throw new Error("Unimplemented");
  }
  createHTMLDocument(titleStr) {
    titleStr += "";
    const doc = new HTMLDocument(CTOR_KEY);
    const docType = new DocumentType("html", "", "", CTOR_KEY);
    doc.appendChild(docType);
    const html = new Element2("html", doc, [], CTOR_KEY);
    html._setOwnerDocument(doc);
    const head = new Element2("head", html, [], CTOR_KEY);
    const body = new Element2("body", html, [], CTOR_KEY);
    const title = new Element2("title", head, [], CTOR_KEY);
    const titleText = new Text2(titleStr);
    title.appendChild(titleText);
    doc.head = head;
    doc.body = body;
    return doc;
  }
  createDocumentType(qualifiedName, publicId, systemId) {
    const doctype = new DocumentType(
      qualifiedName,
      publicId,
      systemId,
      CTOR_KEY
    );
    return doctype;
  }
};
var DocumentType = class _DocumentType extends Node {
  #qualifiedName = "";
  #publicId = "";
  #systemId = "";
  constructor(name, publicId, systemId, key) {
    super(
      "html",
      10 /* DOCUMENT_TYPE_NODE */,
      null,
      key
    );
    this.#qualifiedName = name;
    this.#publicId = publicId;
    this.#systemId = systemId;
  }
  get name() {
    return this.#qualifiedName;
  }
  get publicId() {
    return this.#publicId;
  }
  get systemId() {
    return this.#systemId;
  }
  _shallowClone() {
    return new _DocumentType(
      this.#qualifiedName,
      this.#publicId,
      this.#systemId,
      CTOR_KEY
    );
  }
};
var Document2 = class _Document extends Node {
  head = null;
  body = null;
  implementation;
  #lockState = false;
  #documentURI = "about:blank";
  // TODO
  #title = "";
  #nwapi = null;
  constructor() {
    super(
      "#document",
      9 /* DOCUMENT_NODE */,
      null,
      CTOR_KEY
    );
    this.implementation = new DOMImplementation(CTOR_KEY);
  }
  _shallowClone() {
    return new _Document();
  }
  // Expose the document's NWAPI for Element's access to
  // querySelector/querySelectorAll
  get _nwapi() {
    return this.#nwapi || (this.#nwapi = getSelectorEngine()(this));
  }
  get documentURI() {
    return this.#documentURI;
  }
  get title() {
    return this.querySelector("title")?.textContent || "";
  }
  get cookie() {
    return "";
  }
  set cookie(newCookie) {
  }
  get visibilityState() {
    return "visible";
  }
  get hidden() {
    return false;
  }
  get compatMode() {
    return "CSS1Compat";
  }
  get documentElement() {
    for (const node of this.childNodes) {
      if (node.nodeType === 1 /* ELEMENT_NODE */) {
        return node;
      }
    }
    return null;
  }
  get doctype() {
    for (const node of this.childNodes) {
      if (node.nodeType === 10 /* DOCUMENT_TYPE_NODE */) {
        return node;
      }
    }
    return null;
  }
  get childElementCount() {
    let count = 0;
    for (const { nodeType } of this.childNodes) {
      if (nodeType === 1 /* ELEMENT_NODE */) {
        count++;
      }
    }
    return count;
  }
  appendChild(child) {
    super.appendChild(child);
    child._setOwnerDocument(this);
    return child;
  }
  createElement(tagName, options) {
    tagName = tagName.toUpperCase();
    switch (tagName) {
      case "TEMPLATE": {
        const frag = new DocumentFragment2();
        const elm = new HTMLTemplateElement(
          null,
          [],
          CTOR_KEY,
          frag
        );
        elm._setOwnerDocument(this);
        return elm;
      }
      default: {
        const elm = new Element2(tagName, null, [], CTOR_KEY);
        elm._setOwnerDocument(this);
        return elm;
      }
    }
  }
  createElementNS(namespace, qualifiedName, options) {
    if (namespace === "http://www.w3.org/1999/xhtml") {
      return this.createElement(qualifiedName, options);
    } else {
      throw new Error(
        `createElementNS: "${namespace}" namespace unimplemented`
      );
    }
  }
  createTextNode(data) {
    return new Text2(data);
  }
  createComment(data) {
    return new Comment2(data);
  }
  createDocumentFragment() {
    const fragment = new DocumentFragment2();
    fragment._setOwnerDocument(this);
    return fragment;
  }
  importNode(node, deep = false) {
    const copy = node.cloneNode(deep);
    copy._setOwnerDocument(this);
    return copy;
  }
  adoptNode(node) {
    if (node instanceof _Document) {
      throw new DOMException(
        "Adopting a Document node is not supported.",
        "NotSupportedError"
      );
    }
    node._setParent(null);
    node._setOwnerDocument(this);
    return node;
  }
  querySelector(selectors) {
    return this._nwapi.first(selectors, this);
  }
  querySelectorAll(selectors) {
    const nodeList = new NodeList();
    const mutator = nodeList[nodeListMutatorSym]();
    for (const match of this._nwapi.select(selectors, this)) {
      mutator.push(match);
    }
    return nodeList;
  }
  // TODO: DRY!!!
  getElementById(id) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.id === id) {
          return child;
        }
        const search = child.getElementById(id);
        if (search) {
          return search;
        }
      }
    }
    return null;
  }
  getElementsByTagName(tagName) {
    if (tagName === "*") {
      return this.documentElement ? this._getElementsByTagNameWildcard(
        this.documentElement,
        []
      ) : [];
    } else {
      return this._getElementsByTagName(tagName.toUpperCase(), []);
    }
  }
  _getElementsByTagNameWildcard(node, search) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        search.push(child);
        child._getElementsByTagNameWildcard(search);
      }
    }
    return search;
  }
  _getElementsByTagName(tagName, search) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.tagName === tagName) {
          search.push(child);
        }
        child._getElementsByTagName(tagName, search);
      }
    }
    return search;
  }
  getElementsByTagNameNS(_namespace, localName) {
    return this.getElementsByTagName(localName);
  }
  getElementsByClassName(className) {
    return getElementsByClassName(this, className, []);
  }
  hasFocus() {
    return true;
  }
};
var HTMLDocument = class _HTMLDocument extends Document2 {
  constructor(key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor.");
    }
    super();
  }
  _shallowClone() {
    return new _HTMLDocument(CTOR_KEY);
  }
};
utils_types_default.Document = Document2;

// https://deno.land/x/deno_dom@v0.1.43/src/deserialize.ts
function nodesFromString(html) {
  const parsed = JSON.parse(parse2(html));
  const node = nodeFromArray(parsed, null);
  return node;
}
function fragmentNodesFromString(html, contextLocalName) {
  const parsed = JSON.parse(parseFrag(html, contextLocalName));
  const node = nodeFromArray(parsed, null);
  return node;
}
function nodeFromArray(data, parentNode) {
  if (data[1] === "template") {
    const content = nodeFromArray(data[3], null);
    const contentFrag = new DocumentFragment2();
    const fragMutator = contentFrag._getChildNodesMutator();
    for (const child of content.childNodes) {
      fragMutator.push(child);
      child._setParent(contentFrag);
    }
    return new HTMLTemplateElement(
      parentNode,
      data[2],
      CTOR_KEY,
      contentFrag
    );
  }
  const elm = new Element2(data[1], parentNode, data[2], CTOR_KEY);
  const childNodes = elm._getChildNodesMutator();
  let childNode;
  for (const child of data.slice(3)) {
    switch (child[0]) {
      case 3 /* TEXT_NODE */:
        childNode = new Text2(child[1]);
        childNode.parentNode = childNode.parentElement = elm;
        childNodes.push(childNode);
        break;
      case 8 /* COMMENT_NODE */:
        childNode = new Comment2(child[1]);
        childNode.parentNode = childNode.parentElement = elm;
        childNodes.push(childNode);
        break;
      case 9 /* DOCUMENT_NODE */:
      case 1 /* ELEMENT_NODE */:
        nodeFromArray(child, elm);
        break;
      case 10 /* DOCUMENT_TYPE_NODE */:
        childNode = new DocumentType(child[1], child[2], child[3], CTOR_KEY);
        childNode.parentNode = childNode.parentElement = elm;
        childNodes.push(childNode);
        break;
    }
  }
  return elm;
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/dom-parser.ts
init_define_BUILD_INFO();
var DOMParser2 = class {
  parseFromString(source, mimeType) {
    if (mimeType !== "text/html") {
      throw new Error(`DOMParser: "${mimeType}" unimplemented`);
    }
    const doc = new HTMLDocument(CTOR_KEY);
    const fakeDoc = nodesFromString(source);
    let htmlNode = null;
    let hasDoctype = false;
    for (const child of [...fakeDoc.childNodes]) {
      doc.appendChild(child);
      if (child instanceof DocumentType) {
        hasDoctype = true;
      } else if (child.nodeName === "HTML") {
        htmlNode = child;
      }
    }
    if (!hasDoctype) {
      const docType = new DocumentType("html", "", "", CTOR_KEY);
      if (doc.childNodes.length === 0) {
        doc.appendChild(docType);
      } else {
        doc.insertBefore(docType, doc.childNodes[0]);
      }
    }
    if (htmlNode) {
      for (const child of htmlNode.childNodes) {
        switch (child.tagName) {
          case "HEAD":
            doc.head = child;
            break;
          case "BODY":
            doc.body = child;
            break;
        }
      }
    }
    return doc;
  }
};

// https://deno.land/x/deno_dom@v0.1.43/src/api.ts
var oldHasInstance = Array[Symbol.hasInstance];
Object.defineProperty(Array, Symbol.hasInstance, {
  value(value) {
    switch (value?.constructor) {
      case HTMLCollection:
      case NodeList:
        return false;
      default:
        return oldHasInstance.call(this, value);
    }
  },
  configurable: true
});
var oldIsArray = Array.isArray;
Object.defineProperty(Array, "isArray", {
  value: (value) => {
    switch (value?.constructor) {
      case HTMLCollection:
      case NodeList:
        return false;
      default:
        return oldIsArray.call(Array, value);
    }
  },
  configurable: true
});

// https://deno.land/x/deno_dom@v0.1.43/deno-dom-wasm.ts
await deno_wasm_default();
register(
  parse,
  parse_frag
);

// ../../enhanced/terminology_service.ts
var OpenEHRTerminologyService = class _OpenEHRTerminologyService {
  static instance;
  terminologies = /* @__PURE__ */ new Map();
  externalTerminology;
  constructor() {
  }
  static getInstance() {
    if (!_OpenEHRTerminologyService.instance) {
      _OpenEHRTerminologyService.instance = new _OpenEHRTerminologyService();
    }
    return _OpenEHRTerminologyService.instance;
  }
  /**
   * Initialize the terminology service by loading XML files
   */
  async initialize() {
    const languages = ["en", "es", "pt"];
    for (const lang of languages) {
      try {
        const xml = await Deno.readTextFile(`terminology_data/openehr_terminology_${lang}.xml`);
        const terminology = this.parseTerminologyXml(xml);
        this.terminologies.set(lang, terminology);
      } catch (error) {
        console.warn(`Failed to load terminology for language ${lang}:`, error);
      }
    }
    try {
      const xml = await Deno.readTextFile("terminology_data/openehr_external_terminologies.xml");
      this.externalTerminology = this.parseTerminologyXml(xml);
    } catch (error) {
      console.warn("Failed to load external terminologies:", error);
    }
  }
  /**
   * Parse terminology XML file
   */
  parseTerminologyXml(xmlContent) {
    const parser = new DOMParser2();
    const doc = parser.parseFromString(xmlContent, "text/xml");
    if (!doc) {
      throw new Error("Failed to parse XML");
    }
    const root = doc.querySelector("terminology");
    if (!root) {
      throw new Error("No terminology element found in XML");
    }
    const terminology = {
      name: root.getAttribute("name") || "",
      language: root.getAttribute("language") || "",
      version: root.getAttribute("version") || "",
      date: root.getAttribute("date") || "",
      codeSets: /* @__PURE__ */ new Map(),
      groups: /* @__PURE__ */ new Map()
    };
    const codeSets = Array.from(doc.querySelectorAll("codeset"));
    for (const codeSetEl of codeSets) {
      const codeSet = {
        issuer: codeSetEl.getAttribute("issuer") || "",
        openehr_id: codeSetEl.getAttribute("openehr_id") || "",
        name: codeSetEl.getAttribute("name") || "",
        external_id: codeSetEl.getAttribute("external_id") || "",
        codes: []
      };
      const codes = Array.from(codeSetEl.querySelectorAll("code"));
      for (const codeEl of codes) {
        codeSet.codes.push({
          code: codeEl.getAttribute("value") || "",
          description: codeEl.getAttribute("description") || void 0
        });
      }
      terminology.codeSets.set(codeSet.openehr_id, codeSet);
    }
    const groups = Array.from(doc.querySelectorAll("group"));
    for (const groupEl of groups) {
      const group = {
        openehr_id: groupEl.getAttribute("openehr_id") || "",
        name: groupEl.getAttribute("name") || "",
        concepts: /* @__PURE__ */ new Map()
      };
      const concepts = Array.from(groupEl.querySelectorAll("concept"));
      for (const conceptEl of concepts) {
        const id = conceptEl.getAttribute("id") || "";
        const rubric = conceptEl.getAttribute("rubric") || "";
        group.concepts.set(id, rubric);
      }
      terminology.groups.set(group.openehr_id, group);
    }
    return terminology;
  }
  /**
   * Get terminology by name (currently only "openehr" is supported)
   */
  hasTerminology(name) {
    return name.toLowerCase() === "openehr";
  }
  /**
   * Get code set by openEHR internal ID
   */
  getCodeSet(id, language = "en") {
    const terminology = this.terminologies.get(language);
    if (terminology) {
      return terminology.codeSets.get(id);
    }
    if (this.externalTerminology) {
      return this.externalTerminology.codeSets.get(id);
    }
    return void 0;
  }
  /**
   * Check if a code set exists
   */
  hasCodeSet(id) {
    for (const terminology of this.terminologies.values()) {
      if (terminology.codeSets.has(id)) {
        return true;
      }
    }
    if (this.externalTerminology && this.externalTerminology.codeSets.has(id)) {
      return true;
    }
    return false;
  }
  /**
   * Get terminology group
   */
  getGroup(groupId, language = "en") {
    const terminology = this.terminologies.get(language);
    return terminology?.groups.get(groupId);
  }
  /**
   * Check if a terminology group exists
   */
  hasGroup(groupId) {
    for (const terminology of this.terminologies.values()) {
      if (terminology.groups.has(groupId)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get all code set identifiers
   */
  getCodeSetIdentifiers() {
    const identifiers = /* @__PURE__ */ new Set();
    for (const terminology of this.terminologies.values()) {
      for (const id of terminology.codeSets.keys()) {
        identifiers.add(id);
      }
    }
    if (this.externalTerminology) {
      for (const id of this.externalTerminology.codeSets.keys()) {
        identifiers.add(id);
      }
    }
    return Array.from(identifiers);
  }
  /**
   * Get all terminology group identifiers
   */
  getGroupIdentifiers() {
    const identifiers = /* @__PURE__ */ new Set();
    for (const terminology of this.terminologies.values()) {
      for (const id of terminology.groups.keys()) {
        identifiers.add(id);
      }
    }
    return Array.from(identifiers);
  }
  /**
   * Get all codes from a code set
   */
  getAllCodes(codeSetId, language = "en") {
    const codeSet = this.getCodeSet(codeSetId, language);
    return codeSet ? codeSet.codes.map((c2) => c2.code) : [];
  }
  /**
   * Get concept rubric from group
   */
  getConceptRubric(groupId, conceptId, language = "en") {
    const group = this.getGroup(groupId, language);
    return group?.concepts.get(conceptId);
  }
  /**
   * Get all codes for a specific terminology group
   */
  getCodesForGroup(groupId, language = "en") {
    const group = this.getGroup(groupId, language);
    if (!group) {
      return [];
    }
    return Array.from(group.concepts.keys());
  }
  /**
   * Get group ID by name in a specific language
   */
  getGroupIdByName(name, language = "en") {
    const terminology = this.terminologies.get(language);
    if (!terminology) {
      return void 0;
    }
    const normalizedName = name.toLowerCase();
    for (const [id, group] of terminology.groups) {
      if (group.name.toLowerCase() === normalizedName) {
        return id;
      }
    }
    return void 0;
  }
  /**
   * Get rubric (human-readable term) for a specific code
   * Searches across all groups to find the rubric
   */
  getRubricForCode(code, language = "en") {
    const terminology = this.terminologies.get(language);
    if (!terminology) {
      return void 0;
    }
    for (const group of terminology.groups.values()) {
      const rubric = group.concepts.get(code);
      if (rubric) {
        return rubric;
      }
    }
    for (const codeSet of terminology.codeSets.values()) {
      const codeEntry = codeSet.codes.find((c2) => c2.code === code);
      if (codeEntry?.description) {
        return codeEntry.description;
      }
    }
    return void 0;
  }
};

// ../../enhanced/init_helpers.ts
init_define_BUILD_INFO();
function initSingleValueWrapper(value, constructor) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (typeof value === "string") {
    const instance = new constructor();
    instance.value = value;
    return instance;
  } else if (value instanceof constructor) {
    return value;
  } else {
    return Object.assign(new constructor(), value);
  }
}
function initTerminologyId(value) {
  return initSingleValueWrapper(value, TERMINOLOGY_ID);
}
function initArchetypeId(value) {
  return initSingleValueWrapper(value, ARCHETYPE_ID);
}
function initObjectVersionId(value) {
  return initSingleValueWrapper(value, OBJECT_VERSION_ID);
}
function initTemplateId(value) {
  return initSingleValueWrapper(value, TEMPLATE_ID);
}
function initDvText(value) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (value instanceof DV_TEXT) {
    return value;
  } else {
    return new DV_TEXT(value);
  }
}
function initCodePhrase(value) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (typeof value === "string") {
    const parsed = parseTerseCodePhrase(value);
    if (parsed)
      return parsed;
    throw new Error(
      `Invalid CODE_PHRASE format: "${value}"
Expected terse format like "terminology::code"
Examples:
  - "ISO_639-1::en"
  - "openehr::433"
Or use object format: { code_string: "en", terminology_id: "ISO_639-1" }`
    );
  } else if (value instanceof CODE_PHRASE2) {
    return value;
  } else {
    const cp = new CODE_PHRASE2();
    if ("terminology_id" in value && value.terminology_id !== void 0) {
      cp.terminology_id = initTerminologyId(value.terminology_id);
    }
    if ("code_string" in value && value.code_string !== void 0) {
      cp.code_string = value.code_string;
    }
    return cp;
  }
}
function initDvCodedText(value) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (typeof value === "string") {
    const parsed = parseTerseDvCodedText(value);
    if (parsed)
      return parsed;
    throw new Error(
      `Invalid DV_CODED_TEXT format: "${value}"
Expected terse format like "terminology::code|value|"
Examples:
  - "openehr::433|event|"
  - "SNOMED-CT::73211009|diabetes mellitus|"
Or use object format: { value: "event", defining_code: {...} }`
    );
  } else if (value instanceof DV_CODED_TEXT) {
    return value;
  } else {
    const dct = new DV_CODED_TEXT();
    if ("value" in value && value.value !== void 0) {
      dct.value = value.value;
    }
    if ("defining_code" in value && value.defining_code !== void 0) {
      dct.defining_code = initCodePhrase(value.defining_code);
    }
    if ("hyperlink" in value)
      dct.hyperlink = value.hyperlink;
    if ("formatting" in value)
      dct.formatting = value.formatting;
    if ("mappings" in value)
      dct.mappings = value.mappings;
    if ("language" in value)
      dct.language = initCodePhrase(value.language);
    if ("encoding" in value)
      dct.encoding = initCodePhrase(value.encoding);
    return dct;
  }
}
function initPartyProxy(value) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (value instanceof PARTY_PROXY) {
    return value;
  }
  const party = new PARTY_IDENTIFIED();
  if ("name" in value && value.name !== void 0) {
    if (typeof value.name === "string") {
      party.name = value.name;
    } else if (typeof value.name.value === "string") {
      party.name = value.name.value;
    } else {
      party.name = value.name;
    }
  }
  if ("external_ref" in value)
    party.external_ref = value.external_ref;
  if ("identifiers" in value)
    party.identifiers = value.identifiers;
  return party;
}
function initArchetyped(value) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (value instanceof ARCHETYPED) {
    return value;
  }
  const archetyped = new ARCHETYPED();
  if ("archetype_id" in value && value.archetype_id !== void 0) {
    archetyped.archetype_id = initArchetypeId(value.archetype_id);
  }
  if ("rm_version" in value && value.rm_version !== void 0) {
    archetyped.rm_version = value.rm_version;
  }
  if ("template_id" in value && value.template_id !== void 0) {
    archetyped.template_id = initTemplateId(value.template_id);
  }
  return archetyped;
}
function initEventContext(value) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (value instanceof EVENT_CONTEXT) {
    return value;
  }
  const context = new EVENT_CONTEXT();
  Object.assign(context, value);
  return context;
}

// ../../enhanced/openehr_rm.ts
var PATHABLE = class _PATHABLE extends Any {
  /**
   * Internal storage for parent reference.
   * @protected
   */
  _parent;
  /**
   * Parent of this node in a compositional hierarchy.
   * Returns undefined if this is the root node.
   *
   * @returns Parent node or undefined
   */
  parent() {
    return this._parent;
  }
  /**
   * Sets the parent of this node.
   * @param parent - The parent node
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * The item at a path (relative to this item); only valid for unique paths, i.e. paths that resolve to a single item.
   * @param a_path - Path string in openEHR path format (e.g., "/content[at0001]/data")
   * @returns Result value at path, or undefined if not found
   */
  item_at_path(a_path) {
    const pathStr = typeof a_path === "string" ? a_path : a_path.value || "";
    const segments = this.parsePath(pathStr);
    if (segments.length === 0) {
      return this;
    }
    let current = this;
    for (const segment of segments) {
      if (!current)
        return void 0;
      current = this.navigateSegment(current, segment);
    }
    return current;
  }
  /**
   * Parses an openEHR path into segments.
   * @param path - The path string
   * @returns Array of path segments
   */
  parsePath(path) {
    if (!path || path === "/")
      return [];
    const segments = [];
    const pathStr = path.startsWith("/") ? path.substring(1) : path;
    const parts = pathStr.split("/").filter((p2) => p2.length > 0);
    for (const part of parts) {
      const match = part.match(/^([a-zA-Z_][a-zA-Z0-9_]*)(?:\[([^\]]+)\])?$/);
      if (match) {
        segments.push({
          attribute: match[1],
          nodeId: match[2]
        });
      }
    }
    return segments;
  }
  /**
   * Navigate to a child element based on a path segment.
   * @param current - Current object
   * @param segment - Path segment with attribute and optional nodeId
   * @returns The child element, or undefined if not found
   */
  navigateSegment(current, segment) {
    if (!current)
      return void 0;
    const attrValue = current[segment.attribute];
    if (attrValue === void 0)
      return void 0;
    if (!segment.nodeId) {
      return attrValue;
    }
    if (Array.isArray(attrValue)) {
      return attrValue.find((item) => {
        if (item && typeof item === "object" && "archetype_node_id" in item) {
          return item.archetype_node_id === segment.nodeId;
        }
        return false;
      });
    }
    if (attrValue && typeof attrValue === "object" && "archetype_node_id" in attrValue) {
      if (attrValue.archetype_node_id === segment.nodeId) {
        return attrValue;
      }
    }
    return void 0;
  }
  /**
   * List of items corresponding to a non-unique path.
   * @param a_path - Parameter
   * @returns List of items matching the path
   */
  items_at_path(a_path) {
    const pathStr = typeof a_path === "string" ? a_path : a_path.value || "";
    const results = [];
    const segments = this.parsePath(pathStr);
    if (segments.length === 0) {
      results.push(this);
      return results;
    }
    this.collectItemsAtPath(this, segments, 0, results);
    return results;
  }
  /**
   * Recursively collects items at a path.
   */
  collectItemsAtPath(current, segments, index, results) {
    if (!current || index >= segments.length) {
      if (current !== void 0) {
        results.push(current);
      }
      return;
    }
    const segment = segments[index];
    const attrValue = current[segment.attribute];
    if (attrValue === void 0)
      return;
    if (Array.isArray(attrValue)) {
      for (const item of attrValue) {
        if (!segment.nodeId || segment.nodeId === "*") {
          this.collectItemsAtPath(item, segments, index + 1, results);
        } else if (item && typeof item === "object" && "archetype_node_id" in item && item.archetype_node_id === segment.nodeId) {
          this.collectItemsAtPath(item, segments, index + 1, results);
        }
      }
    } else {
      if (!segment.nodeId || segment.nodeId === "*") {
        this.collectItemsAtPath(attrValue, segments, index + 1, results);
      } else if (attrValue && typeof attrValue === "object" && "archetype_node_id" in attrValue && attrValue.archetype_node_id === segment.nodeId) {
        this.collectItemsAtPath(attrValue, segments, index + 1, results);
      }
    }
  }
  /**
   * True if the path exists in the data with respect to the current item.
   * @param a_path - Parameter
   * @returns Boolean indicating if path exists
   */
  path_exists(a_path) {
    const item = this.item_at_path(a_path);
    return Boolean2.from(item !== void 0);
  }
  /**
   * True if the path corresponds to a single item in the data.
   * @param a_path - Parameter
   * @returns Boolean indicating if path is unique
   */
  path_unique(a_path) {
    const items = this.items_at_path(a_path);
    return Boolean2.from(items.length === 1);
  }
  /**
   * The path to an item relative to the root of this archetyped structure.
   * @param a_loc - The target item
   * @returns String path to the item
   */
  path_of_item(a_loc) {
    const segments = [];
    let current = a_loc;
    while (current && current !== this) {
      const segment = this.buildPathSegment(current);
      if (segment) {
        segments.unshift(segment);
      }
      current = current.parent();
    }
    if (current !== this) {
      return String2.from("");
    }
    return String2.from("/" + segments.join("/"));
  }
  /**
   * Build a path segment for a node based on its archetype_node_id.
   */
  buildPathSegment(node) {
    if ("archetype_node_id" in node && node.archetype_node_id) {
      const parent = node.parent();
      if (parent) {
        for (const [attr, value] of Object.entries(parent)) {
          if (value === node) {
            return `${attr}[${node.archetype_node_id}]`;
          }
          if (Array.isArray(value) && value.includes(node)) {
            return `${attr}[${node.archetype_node_id}]`;
          }
        }
      }
      return `[${node.archetype_node_id}]`;
    }
    return "";
  }
  /**
   * Default value equality comparison for PATHABLE subclasses.
   * Compares constructor names as a basic implementation.
   * Subclasses should override this for more specific comparisons.
   * @param other - The other object to compare with
   * @returns Boolean wrapper indicating equality
   */
  is_equal(other) {
    if (!(other instanceof _PATHABLE)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.constructor.name === other.constructor.name);
  }
};
var LINK = class {
  /**
   * Used to describe the relationship, usually in clinical terms, such as  in response to  (the relationship between test results and an order),  follow-up to  and so on. Such relationships can represent any clinically meaningful connection between pieces of information. Values for meaning include those described in Annex C, ENV 13606 pt 2 under the categories of  generic ,  documenting and reporting ,  organisational ,  clinical ,  circumstancial , and  view management .
   */
  meaning;
  /**
   * The type attribute is used to indicate a clinical or domain-level meaning for the kind of link, for example  problem  or  issue . If type values are designed appropriately, they can be used by the requestor of EHR extracts to categorise links which must be followed and which can be broken when the extract is created.
   */
  type;
  /**
   * The logical  to  object in the link relation, as per the linguistic sense of the meaning attribute.
   */
  target;
};
var LOCATABLE = class extends PATHABLE {
  /**
   * Runtime name of this fragment, used to build runtime paths. This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
   */
  name;
  /**
   * Internal storage for archetype_node_id
   * @protected
   */
  _archetype_node_id;
  /**
   * Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. Always in the form of an at-code, e.g.  \`at0005\`. This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
   *
   * At an archetype root point, the value of this attribute is always the stringified form of the \`_archetype_id_\` found in the \`_archetype_details_\` object.
   */
  get archetype_node_id() {
    return this._archetype_node_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for archetype_node_id.
   * Use this to access openehr_base.String methods.
   */
  get $archetype_node_id() {
    return this._archetype_node_id;
  }
  /**
   * Sets archetype_node_id from either a primitive value or openehr_base.String wrapper.
   */
  set archetype_node_id(val) {
    if (val === void 0 || val === null) {
      this._archetype_node_id = void 0;
    } else if (typeof val === "string") {
      this._archetype_node_id = String2.from(val);
    } else {
      this._archetype_node_id = val;
    }
  }
  /**
   * Optional globally unique object identifier for root points of archetyped structures.
   */
  uid;
  /**
   * Links to other archetyped structures (data whose root object inherits from \`ARCHETYPED\`, such as \`ENTRY\`, \`SECTION\` and so on). Links may be to structures in other compositions.
   */
  links;
  /**
   * Details of archetyping used on this node.
   */
  archetype_details;
  /**
   * Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
   */
  feeder_audit;
  /**
   * Clinical concept of the archetype as a whole (= derived from the archetype_node_id' of the root node)
   * @returns Result value
   */
  concept() {
    if (!this.name) {
      throw new Error("LOCATABLE name is required but not set");
    }
    return this.name;
  }
  /**
   * True if this node is the root of an archetyped structure.
   * @returns Result value
   */
  is_archetype_root() {
    return Boolean2.from(this.archetype_details !== void 0);
  }
};
var ARCHETYPED = class {
  /**
   * Globally unique archetype identifier.
   */
  archetype_id;
  /**
   * Globally unique template identifier, if a template was active at this point in the structure. Normally, a template would only be used at the top of a top-level structure, but the possibility exists for templates at lower levels.
   */
  template_id;
  /**
   * Internal storage for rm_version
   * @protected
   */
  _rm_version;
  /**
   * Version of the openEHR reference model used to create this object. Expressed in terms of the release version string, e.g.  1.0 ,  1.2.4 .
   */
  get rm_version() {
    return this._rm_version?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for rm_version.
   * Use this to access openehr_base.String methods.
   */
  get $rm_version() {
    return this._rm_version;
  }
  /**
   * Sets rm_version from either a primitive value or openehr_base.String wrapper.
   */
  set rm_version(val) {
    if (val === void 0 || val === null) {
      this._rm_version = void 0;
    } else if (typeof val === "string") {
      this._rm_version = String2.from(val);
    } else {
      this._rm_version = val;
    }
  }
};
var FEEDER_AUDIT = class {
  /**
   * Identifiers used for the item in the originating system, e.g. filler and placer ids.
   */
  originating_system_item_ids;
  /**
   * Identifiers used for the item in the feeder system, where the feeder system is distinct from the originating system.
   */
  feeder_system_item_ids;
  /**
   * Optional inline inclusion of or reference to original content corresponding to the openEHR content at this node. Typically a URI reference to a document or message in a persistent store associated with the EHR.
   */
  original_content;
  /**
   * Any audit information for the information item from the originating system.
   */
  originating_system_audit;
  /**
   * Any audit information for the information item from the feeder system, if different from the originating system.
   */
  feeder_system_audit;
};
var FEEDER_AUDIT_DETAILS = class {
  /**
   * Internal storage for system_id
   * @protected
   */
  _system_id;
  /**
   * Identifier of the system which handled the information item. This is the IT system owned by the organisation legally responsible for handling the data, and at which the data were previously created or passed by an earlier system.
   */
  get system_id() {
    return this._system_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for system_id.
   * Use this to access openehr_base.String methods.
   */
  get $system_id() {
    return this._system_id;
  }
  /**
   * Sets system_id from either a primitive value or openehr_base.String wrapper.
   */
  set system_id(val) {
    if (val === void 0 || val === null) {
      this._system_id = void 0;
    } else if (typeof val === "string") {
      this._system_id = String2.from(val);
    } else {
      this._system_id = val;
    }
  }
  /**
   * Identifier of the particular site/facility within an organisation which handled the item. For computability, this identifier needs to be e.g. a PKI identifier which can be included in the identifier list of the \`PARTY_IDENTIFIED\` object.
   */
  location;
  /**
   * Identifiers for subject of the received information item.
   */
  subject;
  /**
   * Optional provider(s) who created, committed, forwarded or otherwise handled the item.
   */
  provider;
  /**
   * Time of handling the item. For an originating system, this will be time of creation, for an intermediate feeder system, this will be a time of accession or other time of handling, where available.
   */
  time;
  /**
   * Internal storage for version_id
   * @protected
   */
  _version_id;
  /**
   * Any identifier used in the system such as  "interim" ,  "final" , or numeric versions if available.
   */
  get version_id() {
    return this._version_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for version_id.
   * Use this to access openehr_base.String methods.
   */
  get $version_id() {
    return this._version_id;
  }
  /**
   * Sets version_id from either a primitive value or openehr_base.String wrapper.
   */
  set version_id(val) {
    if (val === void 0 || val === null) {
      this._version_id = void 0;
    } else if (typeof val === "string") {
      this._version_id = String2.from(val);
    } else {
      this._version_id = val;
    }
  }
  /**
   * Optional attribute to carry any custom meta-data. May be archetyped.
   */
  other_details;
};
var VERSIONED_OBJECT = class {
  /**
   * Unique identifier of this version container in the form of a UID with no extension. This id will be the same in all instances of the same container in a distributed environment, meaning that it can be understood as the uid of the  virtual version tree.
   */
  uid;
  /**
   * Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
   */
  owner_id;
  /**
   * Time of initial creation of this versioned object.
   */
  time_created;
  /**
   * Internal storage for versions.
   * @protected
   */
  _versions = [];
  /**
   * Return the total number of versions in this object.
   * @returns Number of versions
   */
  version_count() {
    return Integer.from(this._versions.length);
  }
  /**
   * Return a list of ids of all versions in this object.
   * @returns Array of version IDs
   */
  all_version_ids() {
    return this._versions.map((v2) => {
      if (v2 instanceof ORIGINAL_VERSION) {
        return v2.uid;
      } else if (v2 instanceof IMPORTED_VERSION) {
        try {
          return v2.uid();
        } catch {
          return void 0;
        }
      }
      return void 0;
    }).filter((id) => id !== void 0);
  }
  /**
   * Return a list of all versions in this object.
   * @returns Array of all versions
   */
  all_versions() {
    return [...this._versions];
  }
  /**
   * True if a version for time  \`_a_time_\` exists.
   * @param a_time - The time to search for
   * @returns Boolean indicating if version exists at that time
   */
  has_version_at_time(a_time) {
    const targetTime = a_time.value || "";
    for (const version of this._versions) {
      if (version.commit_audit?.time_committed?.value === targetTime) {
        return Boolean2.from(true);
      }
    }
    return Boolean2.from(false);
  }
  /**
   * True if a version with \`_a_version_uid_\` exists.
   * @param a_version_uid - The version ID to search for
   * @returns Boolean indicating if version with that ID exists
   */
  has_version_id(a_version_uid) {
    const targetId = a_version_uid.value || "";
    for (const version of this._versions) {
      let versionId;
      if (version instanceof ORIGINAL_VERSION) {
        versionId = version.uid?.value;
      } else if (version instanceof IMPORTED_VERSION) {
        try {
          versionId = version.uid().value;
        } catch {
          continue;
        }
      }
      if (versionId === targetId) {
        return Boolean2.from(true);
      }
    }
    return Boolean2.from(false);
  }
  /**
   * Return the version with \`_uid_\` =  \`_a_version_uid_\`.
   *
   * @param a_version_uid - The version ID to find
   * @returns The matching version
   */
  version_with_id(a_version_uid) {
    const targetId = a_version_uid.value || "";
    for (const version of this._versions) {
      let versionId;
      if (version instanceof ORIGINAL_VERSION) {
        versionId = version.uid?.value;
      } else if (version instanceof IMPORTED_VERSION) {
        try {
          versionId = version.uid().value;
        } catch {
          continue;
        }
      }
      if (versionId === targetId) {
        return version;
      }
    }
    return void 0;
  }
  /**
   * True if version with \`_a_version_uid_\` is an \`ORIGINAL_VERSION\`.
   * @param a_version_uid - The version ID to check
   * @returns Boolean indicating if the version is an ORIGINAL_VERSION
   */
  is_original_version(a_version_uid) {
    const version = this.version_with_id(a_version_uid);
    return Boolean2.from(version instanceof ORIGINAL_VERSION);
  }
  /**
   * Return the version for time  \`_a_time_\`.
   * @param a_time - The time to search for
   * @returns The version at that time
   */
  version_at_time(a_time) {
    const targetTime = a_time.value || "";
    for (const version of this._versions) {
      if (version.commit_audit?.time_committed?.value === targetTime) {
        return version;
      }
    }
    return void 0;
  }
  /**
   * History of all audits and attestations in this versioned repository.
   * @returns Revision history
   */
  revision_history() {
    const history = new REVISION_HISTORY();
    history.items = this._versions.map((version) => {
      const item = new REVISION_HISTORY_ITEM();
      if (version instanceof ORIGINAL_VERSION) {
        item.version_id = version.uid;
        if (version.commit_audit) {
          item.audits = [version.commit_audit];
        }
      } else if (version instanceof IMPORTED_VERSION) {
        try {
          item.version_id = version.uid();
          if (version.commit_audit) {
            item.audits = [version.commit_audit];
          }
        } catch {
        }
      }
      return item;
    });
    return history;
  }
  /**
   * Return the most recently added version (i.e. on trunk or any branch).
   * @returns The latest version
   */
  latest_version() {
    if (this._versions.length === 0)
      return void 0;
    return this._versions[this._versions.length - 1];
  }
  /**
   * Return the most recently added trunk version.
   * @returns The latest trunk (non-branch) version
   */
  latest_trunk_version() {
    for (let i3 = this._versions.length - 1; i3 >= 0; i3--) {
      const version = this._versions[i3];
      if (version instanceof ORIGINAL_VERSION && version.uid) {
        const versionTreeId = version.uid.version_tree_id?.();
        if (versionTreeId && !versionTreeId.is_branch?.().value) {
          return version;
        }
      }
    }
    return this.latest_version();
  }
  /**
   * Return the lifecycle state from the latest trunk version. Useful for determining if the version container is logically deleted.
   * @returns The lifecycle state
   */
  trunk_lifecycle_state() {
    const trunkVersion = this.latest_trunk_version();
    if (trunkVersion instanceof ORIGINAL_VERSION) {
      return trunkVersion.lifecycle_state;
    }
    return void 0;
  }
  /**
   * Add a new original version.
   * @param a_contribution - Reference to the contribution
   * @param a_new_version_uid - UID for the new version
   * @param a_preceding_version_id - UID of the preceding version
   * @param an_audit - Audit details
   * @param a_lifecycle_state - Lifecycle state
   * @param a_data - The data content
   * @param signing_key - Key for signing (not used in this implementation)
   */
  commit_original_version(a_contribution, a_new_version_uid, a_preceding_version_id, an_audit, a_lifecycle_state, a_data, _signing_key) {
    const version = new ORIGINAL_VERSION();
    version.uid = a_new_version_uid;
    version.preceding_version_uid = a_preceding_version_id;
    version.lifecycle_state = a_lifecycle_state;
    version.data = a_data;
    version.contribution = a_contribution;
    version.commit_audit = an_audit;
    this._versions.push(version);
  }
  /**
   * Add a new original merged version. This commit function adds a parameter containing the ids of other versions merged into the current one.
   * @param a_contribution - Reference to the contribution
   * @param a_new_version_uid - UID for the new version
   * @param a_preceding_version_id - UID of the preceding version
   * @param an_audit - Audit details
   * @param a_lifecycle_state - Lifecycle state
   * @param a_data - The data content
   * @param an_other_input_uids - UIDs of other merged versions
   * @param signing_key - Key for signing (not used in this implementation)
   */
  commit_original_merged_version(a_contribution, a_new_version_uid, a_preceding_version_id, an_audit, a_lifecycle_state, a_data, an_other_input_uids, _signing_key) {
    const version = new ORIGINAL_VERSION();
    version.uid = a_new_version_uid;
    version.preceding_version_uid = a_preceding_version_id;
    version.lifecycle_state = a_lifecycle_state;
    version.data = a_data;
    version.contribution = a_contribution;
    version.commit_audit = an_audit;
    version.other_input_version_uids = an_other_input_uids;
    this._versions.push(version);
  }
  /**
   * Add a new imported version. Details of version id etc come from the \`ORIGINAL_VERSION\` being committed.
   * @param a_contribution - Reference to the contribution
   * @param an_audit - Audit details
   * @param a_version - The original version being imported
   */
  commit_imported_version(a_contribution, an_audit, a_version) {
    const imported = new IMPORTED_VERSION();
    imported.item = a_version;
    imported.contribution = a_contribution;
    imported.commit_audit = an_audit;
    this._versions.push(imported);
  }
  /**
   * Add a new attestation to a specified original version. Attestations can only be added to Original versions.
   * @param an_attestation - The attestation to add
   * @param a_ver_id - The version ID to add attestation to
   * @param signing_key - Key for signing (not used in this implementation)
   */
  commit_attestation(an_attestation, a_ver_id, _signing_key) {
    const version = this.version_with_id(a_ver_id);
    if (version instanceof ORIGINAL_VERSION) {
      if (!version.attestations) {
        version.attestations = [];
      }
      version.attestations.push(an_attestation);
    } else {
      throw new Error("Attestations can only be added to ORIGINAL_VERSION instances");
    }
  }
};
var CONTRIBUTION = class {
  /**
   * Unique identifier for this Contribution.
   */
  uid;
  /**
   * Set of references to Versions causing changes to this EHR. Each contribution contains a list of versions, which may include paths pointing to any number of versionable items, i.e. items of types such as \`COMPOSITION\` and \`FOLDER\`.
   */
  versions;
  /**
   * Audit trail corresponding to the committal of this Contribution.
   */
  audit;
};
var VERSION = class {
  /**
   * Contribution in which this version was added.
   */
  contribution;
  /**
   * Internal storage for signature
   * @protected
   */
  _signature;
  /**
   * OpenPGP digital signature or digest of content committed in this Version.
   */
  get signature() {
    return this._signature?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for signature.
   * Use this to access openehr_base.String methods.
   */
  get $signature() {
    return this._signature;
  }
  /**
   * Sets signature from either a primitive value or openehr_base.String wrapper.
   */
  set signature(val) {
    if (val === void 0 || val === null) {
      this._signature = void 0;
    } else if (typeof val === "string") {
      this._signature = String2.from(val);
    } else {
      this._signature = val;
    }
  }
  /**
   * Audit trail corresponding to the committal of this version to the \`VERSIONED_OBJECT\`.
   */
  commit_audit;
  /**
   * A canonical serial form of this Version, suitable for generating reliable hashes and signatures.
   * Returns a JSON string representation.
   * @returns Canonical string form
   */
  canonical_form() {
    const canonicalObj = {
      uid: this.uid()?.value,
      preceding_version_uid: this.preceding_version_uid?.()?.value,
      lifecycle_state: this.lifecycle_state?.()?.defining_code?.code_string,
      contribution: this.contribution?.id?.value,
      commit_audit: {
        time_committed: this.commit_audit?.time_committed?.value,
        committer: this.commit_audit?.committer,
        change_type: this.commit_audit?.change_type?.defining_code?.code_string,
        description: this.commit_audit?.description?.value
      }
    };
    return String2.from(JSON.stringify(canonicalObj));
  }
  /**
   * Copy of the owning \`VERSIONED_OBJECT._uid_\` value; extracted from the local \`_uid_\` property's \`_object_id_\`.
   * @returns HIER_OBJECT_ID representing the owner
   */
  owner_id() {
    const versionUid = this.uid();
    if (!versionUid) {
      throw new Error("VERSION uid is not set");
    }
    const objectId = versionUid.object_id?.();
    if (!objectId) {
      throw new Error("VERSION uid.object_id is not set");
    }
    const ownerId = new HIER_OBJECT_ID();
    ownerId.value = objectId.value;
    return ownerId;
  }
  /**
   * True if this Version represents a branch. Derived from \`_uid_\` attribute.
   * @returns Boolean indicating if this is a branch version
   */
  is_branch() {
    const versionUid = this.uid();
    if (!versionUid) {
      return Boolean2.from(false);
    }
    const versionTreeId = versionUid.version_tree_id?.();
    if (versionTreeId && typeof versionTreeId.is_branch === "function") {
      return versionTreeId.is_branch();
    }
    return Boolean2.from(false);
  }
};
var IMPORTED_VERSION = class extends VERSION {
  /**
   * The \`ORIGINAL_VERSION\` object that was imported.
   */
  item;
  /**
   * Computed version of inheritance precursor, derived as \`_item.uid_\`.
   * @returns Result value
   */
  uid() {
    if (!this.item) {
      throw new Error("IMPORTED_VERSION item is not set");
    }
    if (!this.item.uid) {
      throw new Error("IMPORTED_VERSION item.uid is not set");
    }
    return this.item.uid;
  }
  /**
   * Computed version of inheritance precursor, derived as \`_item.preceding_version_uid_\`.
   * @returns The preceding version UID from the imported original version
   */
  preceding_version_uid() {
    if (!this.item) {
      return void 0;
    }
    return this.item.preceding_version_uid;
  }
  /**
   * Lifecycle state of the content item in wrapped \`ORIGINAL_VERSION\`, derived as \`_item.lifecycle_state_\`; coded by openEHR vocabulary \`version lifecycle state\`.
   * @returns The lifecycle state from the imported original version
   */
  lifecycle_state() {
    if (!this.item) {
      return void 0;
    }
    return this.item.lifecycle_state;
  }
  /**
   * Original content of this Version.
   * @returns The data from the imported original version
   */
  data() {
    if (!this.item) {
      return void 0;
    }
    return this.item.data;
  }
};
var ORIGINAL_VERSION = class extends VERSION {
  /**
   * Stored version of inheritance precursor.
   */
  uid;
  /**
   * Stored version of inheritance precursor.
   */
  preceding_version_uid;
  /**
   * Identifiers of other versions whose content was merged into this version, if any.
   */
  other_input_version_uids;
  /**
   * Lifecycle state of the content item in this version; coded by openEHR vocabulary \`version lifecycle state\`.
   */
  lifecycle_state;
  /**
   * Set of attestations relating to this version.
   */
  attestations;
  /**
   * Data content of this Version.
   */
  data;
  /**
   * True if this Version was created from more than just the preceding (checked out) version.
   * @returns Boolean indicating if this version is merged
   */
  is_merged() {
    return Boolean2.from(
      this.other_input_version_uids !== void 0 && this.other_input_version_uids.length > 0
    );
  }
};
var REVISION_HISTORY_ITEM = class {
  /**
   * Version identifier for this revision.
   */
  version_id;
  /**
   * The audits for this revision; there will always be at least one commit audit (which may itself be an \`ATTESTATION\`), there may also be further attestations.
   */
  audits;
};
var AUDIT_DETAILS = class {
  /**
   * Internal storage for system_id
   * @protected
   */
  _system_id;
  /**
   * Identifier of the logical EHR system where the change was committed. This is almost always owned by the organisation legally responsible for the EHR, and is distinct from any application, or any hosting infrastructure.
   */
  get system_id() {
    return this._system_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for system_id.
   * Use this to access openehr_base.String methods.
   */
  get $system_id() {
    return this._system_id;
  }
  /**
   * Sets system_id from either a primitive value or openehr_base.String wrapper.
   */
  set system_id(val) {
    if (val === void 0 || val === null) {
      this._system_id = void 0;
    } else if (typeof val === "string") {
      this._system_id = String2.from(val);
    } else {
      this._system_id = val;
    }
  }
  /**
   * Time of committal of the item.
   */
  time_committed;
  /**
   * Type of change. Coded using the openEHR Terminology  audit change type  group.
   */
  change_type;
  /**
   * Reason for committal. This may be used to qualify the value in the \`_change_type_\` field. For example, if the change affects only the EHR directory, this field might be used to indicate 'Folder "episode 2018-02-16" added' or similar.
   */
  description;
  /**
   * Identity and optional reference into identity management service, of user who committed the item.
   */
  committer;
};
var ATTESTATION = class extends AUDIT_DETAILS {
  /**
   * Optional visual representation of content attested e.g. screen image.
   */
  attested_view;
  /**
   * Internal storage for proof
   * @protected
   */
  _proof;
  /**
   * Proof of attestation.
   */
  get proof() {
    return this._proof?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for proof.
   * Use this to access openehr_base.String methods.
   */
  get $proof() {
    return this._proof;
  }
  /**
   * Sets proof from either a primitive value or openehr_base.String wrapper.
   */
  set proof(val) {
    if (val === void 0 || val === null) {
      this._proof = void 0;
    } else if (typeof val === "string") {
      this._proof = String2.from(val);
    } else {
      this._proof = val;
    }
  }
  /**
   * Items attested, expressed as fully qualified runtime paths to the items in question. Although not recommended, these may include fine-grained items which have been attested in some other system. Otherwise it is assumed to be for the entire VERSION with which it is associated.
   */
  items;
  /**
   * Reason of this attestation. Optionally coded by the openEHR Terminology group  attestation reason ; includes values like  authorisation ,  witness  etc.
   */
  reason;
  /**
   * Internal storage for is_pending
   * @protected
   */
  _is_pending;
  /**
   * True if this attestation is outstanding; False means it has been completed.
   */
  get is_pending() {
    return this._is_pending?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for is_pending.
   * Use this to access openehr_base.Boolean methods.
   */
  get $is_pending() {
    return this._is_pending;
  }
  /**
   * Sets is_pending from either a primitive value or openehr_base.Boolean wrapper.
   */
  set is_pending(val) {
    if (val === void 0 || val === null) {
      this._is_pending = void 0;
    } else if (typeof val === "boolean") {
      this._is_pending = Boolean2.from(val);
    } else {
      this._is_pending = val;
    }
  }
};
var PARTICIPATION = class {
  /**
   * The function of the Party in this participation (note that a given party might participate in more than one way in a particular activity). This attribute should be coded, but cannot be limited to the HL7v3:ParticipationFunction vocabulary, since it is too limited and hospital-oriented.
   */
  function;
  /**
   * Optional field for recording the 'mode' of the performer / activity interaction, e.g. present, by telephone, by email etc.
   */
  mode;
  /**
   * The id and possibly demographic system link of the party participating in the activity.
   */
  performer;
  /**
   * The time interval during which the participation took place, if it is used in an observational context (i.e. recording facts about the past); or the intended time interval of the participation when used in future contexts, such as EHR Instructions.
   */
  time;
};
var PARTY_PROXY = class {
  /**
   * Optional reference to more detailed demographic or identification information for this party, in an external system.
   */
  external_ref;
};
var PARTY_IDENTIFIED = class extends PARTY_PROXY {
  /**
   * Internal storage for name
   * @protected
   */
  _name;
  /**
   * Optional human-readable name (in String form).
   */
  get name() {
    return this._name?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for name.
   * Use this to access openehr_base.String methods.
   */
  get $name() {
    return this._name;
  }
  /**
   * Sets name from either a primitive value or openehr_base.String wrapper.
   */
  set name(val) {
    if (val === void 0 || val === null) {
      this._name = void 0;
    } else if (typeof val === "string") {
      this._name = String2.from(val);
    } else {
      this._name = val;
    }
  }
  /**
   * One or more formal identifiers (possibly computable).
   */
  identifiers;
};
var PARTY_SELF = class extends PARTY_PROXY {
};
var PARTY_RELATED = class extends PARTY_IDENTIFIED {
  /**
   * Relationship of subject of this ENTRY to the subject of the record. May be coded. If it is the patient, coded as  self.
   */
  relationship;
};
var REVISION_HISTORY = class {
  /**
   * The items in this history in most-recent-last order.
   */
  items;
  /**
   * The version id of the most recent item, as a String.
   * @returns Result value
   */
  most_recent_version() {
    if (!this.items || this.items.length === 0) {
      return String2.from("");
    }
    const lastItem = this.items[this.items.length - 1];
    return String2.from(lastItem.version_id?.value || "");
  }
  /**
   * The commit date/time of the most recent item, as a String.
   * @returns Result value
   */
  most_recent_version_time_committed() {
    if (!this.items || this.items.length === 0) {
      return String2.from("");
    }
    const lastItem = this.items[this.items.length - 1];
    if (!lastItem.audits || lastItem.audits.length === 0) {
      return String2.from("");
    }
    return String2.from(lastItem.audits[0].time_committed?.value || "");
  }
};
var VERSIONED_FOLDER = class extends VERSIONED_OBJECT {
};
var FOLDER = class extends LOCATABLE {
  /**
   * The list of references to other (usually) versioned objects logically in this folder.
   */
  items;
  /**
   * Sub-folders of this \`FOLDER\`.
   */
  folders;
  /**
   * Archetypable meta-data for \`FOLDER\`.
   */
  details;
};
var AUTHORED_RESOURCE2 = class {
  /**
   * Language in which this resource was initially authored. Although there is no language primacy of resources overall, the language of original authoring is required to ensure natural language translations can preserve quality. Language is relevant in both the description and ontology sections.
   */
  original_language;
  /**
   * Internal storage for is_controlled
   * @protected
   */
  _is_controlled;
  /**
   * True if this resource is under any kind of change control (even file copying), in which case revision history is created.
   */
  get is_controlled() {
    return this._is_controlled?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for is_controlled.
   * Use this to access openehr_base.Boolean methods.
   */
  get $is_controlled() {
    return this._is_controlled;
  }
  /**
   * Sets is_controlled from either a primitive value or openehr_base.Boolean wrapper.
   */
  set is_controlled(val) {
    if (val === void 0 || val === null) {
      this._is_controlled = void 0;
    } else if (typeof val === "boolean") {
      this._is_controlled = Boolean2.from(val);
    } else {
      this._is_controlled = val;
    }
  }
  /**
   * List of details for each natural-language translation made of this resource, keyed by language. For each translation listed here, there must be corresponding sections in all language-dependent parts of the resource. The \`_original_language_\` does not appear in this list.
   */
  translations;
  /**
   * Description and lifecycle information of the resource.
   */
  description;
  /**
   * The revision history of the resource. Only required if \`_is_controlled_ = True\` (avoids large revision histories for informal or private editing situations).
   */
  revision_history;
  /**
   * Most recent revision in \`_revision_history_\` if \`_is_controlled_\` else  (uncontrolled) .
   * @returns Result value
   */
  current_revision() {
    if (!this.is_controlled || !this.revision_history) {
      return String2.from("(uncontrolled)");
    }
    return this.revision_history.most_recent_version();
  }
  /**
   * Total list of languages available in this resource, derived from \`_original_language_\` and \`_translations_\`.
   *
   * @returns Result value
   */
  languages_available() {
    const languages = [];
    if (this.original_language?.code_string) {
      languages.push(String2.from(this.original_language.code_string));
    }
    if (this.translations && Array.isArray(this.translations)) {
      for (const translation of this.translations) {
        if (translation.language?.code_string) {
          languages.push(String2.from(translation.language.code_string));
        }
      }
    }
    return languages;
  }
};
var RESOURCE_DESCRIPTION2 = class {
  /**
   * Original author of this resource, with all relevant details, including organisation.
   */
  original_author;
  /**
   * Other contributors to the resource, probably listed in  \`'name <email>'\`  form.
   */
  other_contributors;
  /**
   * Internal storage for lifecycle_state
   * @protected
   */
  _lifecycle_state;
  /**
   * Lifecycle state of the resource, typically including states such as: \`initial | submitted | experimental | awaiting_approval | approved | superseded | obsolete\`.
   */
  get lifecycle_state() {
    return this._lifecycle_state?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for lifecycle_state.
   * Use this to access openehr_base.String methods.
   */
  get $lifecycle_state() {
    return this._lifecycle_state;
  }
  /**
   * Sets lifecycle_state from either a primitive value or openehr_base.String wrapper.
   */
  set lifecycle_state(val) {
    if (val === void 0 || val === null) {
      this._lifecycle_state = void 0;
    } else if (typeof val === "string") {
      this._lifecycle_state = String2.from(val);
    } else {
      this._lifecycle_state = val;
    }
  }
  /**
   * Internal storage for resource_package_uri
   * @protected
   */
  _resource_package_uri;
  /**
   * URI of package to which this resource belongs.
   */
  get resource_package_uri() {
    return this._resource_package_uri?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for resource_package_uri.
   * Use this to access openehr_base.String methods.
   */
  get $resource_package_uri() {
    return this._resource_package_uri;
  }
  /**
   * Sets resource_package_uri from either a primitive value or openehr_base.String wrapper.
   */
  set resource_package_uri(val) {
    if (val === void 0 || val === null) {
      this._resource_package_uri = void 0;
    } else if (typeof val === "string") {
      this._resource_package_uri = String2.from(val);
    } else {
      this._resource_package_uri = val;
    }
  }
  /**
   * Additional non language-senstive resource meta-data, as a list of name/value pairs.
   */
  other_details;
  /**
   * Reference to owning resource.
   */
  parent_resource;
  /**
   * Details of all parts of resource description that are natural language-dependent, keyed by language code.
   */
  details;
};
var TRANSLATION_DETAILS2 = class {
  /**
   * Language of the translation.
   */
  language;
  /**
   * Translator name and other demographic details.
   */
  author;
  /**
   * Internal storage for accreditaton
   * @protected
   */
  _accreditaton;
  /**
   * Accreditation of translator, usually a national translator's registration or association membership id.
   */
  get accreditaton() {
    return this._accreditaton?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for accreditaton.
   * Use this to access openehr_base.String methods.
   */
  get $accreditaton() {
    return this._accreditaton;
  }
  /**
   * Sets accreditaton from either a primitive value or openehr_base.String wrapper.
   */
  set accreditaton(val) {
    if (val === void 0 || val === null) {
      this._accreditaton = void 0;
    } else if (typeof val === "string") {
      this._accreditaton = String2.from(val);
    } else {
      this._accreditaton = val;
    }
  }
  /**
   * Any other meta-data.
   */
  other_details;
};
var RESOURCE_DESCRIPTION_ITEM2 = class {
  /**
   * The localised language in which the items in this description item are written. Coded from openEHR code set \`languages\`.
   */
  language;
  /**
   * Internal storage for purpose
   * @protected
   */
  _purpose;
  /**
   * Purpose of the resource.
   */
  get purpose() {
    return this._purpose?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for purpose.
   * Use this to access openehr_base.String methods.
   */
  get $purpose() {
    return this._purpose;
  }
  /**
   * Sets purpose from either a primitive value or openehr_base.String wrapper.
   */
  set purpose(val) {
    if (val === void 0 || val === null) {
      this._purpose = void 0;
    } else if (typeof val === "string") {
      this._purpose = String2.from(val);
    } else {
      this._purpose = val;
    }
  }
  /**
   * Keywords which characterise this resource, used e.g. for indexing and searching.
   */
  keywords;
  /**
   * Internal storage for use
   * @protected
   */
  _use;
  /**
   * Description of the uses of the resource, i.e. contexts in which it could be used.
   */
  get use() {
    return this._use?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for use.
   * Use this to access openehr_base.String methods.
   */
  get $use() {
    return this._use;
  }
  /**
   * Sets use from either a primitive value or openehr_base.String wrapper.
   */
  set use(val) {
    if (val === void 0 || val === null) {
      this._use = void 0;
    } else if (typeof val === "string") {
      this._use = String2.from(val);
    } else {
      this._use = val;
    }
  }
  /**
   * Internal storage for misuse
   * @protected
   */
  _misuse;
  /**
   * Description of any misuses of the resource, i.e. contexts in which it should not be used.
   */
  get misuse() {
    return this._misuse?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for misuse.
   * Use this to access openehr_base.String methods.
   */
  get $misuse() {
    return this._misuse;
  }
  /**
   * Sets misuse from either a primitive value or openehr_base.String wrapper.
   */
  set misuse(val) {
    if (val === void 0 || val === null) {
      this._misuse = void 0;
    } else if (typeof val === "string") {
      this._misuse = String2.from(val);
    } else {
      this._misuse = val;
    }
  }
  /**
   * Internal storage for copyright
   * @protected
   */
  _copyright;
  /**
   * Optional copyright statement for the resource as a knowledge resource.
   */
  get copyright() {
    return this._copyright?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for copyright.
   * Use this to access openehr_base.String methods.
   */
  get $copyright() {
    return this._copyright;
  }
  /**
   * Sets copyright from either a primitive value or openehr_base.String wrapper.
   */
  set copyright(val) {
    if (val === void 0 || val === null) {
      this._copyright = void 0;
    } else if (typeof val === "string") {
      this._copyright = String2.from(val);
    } else {
      this._copyright = val;
    }
  }
  /**
   * URIs of original clinical document(s) or description of which resource is a formalisation, in the language of this description item; keyed by meaning.
   */
  original_resource_uri;
  /**
   * Additional language-senstive resource metadata, as a list of name/value pairs.
   */
  other_details;
};
var ITEM_TAG = class {
  /**
   * Internal storage for key
   * @protected
   */
  _key;
  /**
   * The tag key. May not be empty or contain leading or trailing whitespace.
   */
  get key() {
    return this._key?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for key.
   * Use this to access openehr_base.String methods.
   */
  get $key() {
    return this._key;
  }
  /**
   * Sets key from either a primitive value or openehr_base.String wrapper.
   */
  set key(val) {
    if (val === void 0 || val === null) {
      this._key = void 0;
    } else if (typeof val === "string") {
      this._key = String2.from(val);
    } else {
      this._key = val;
    }
  }
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * The value. If set, may not be empty.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for value.
   * Use this to access openehr_base.String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * Identifier of target, which may be a \`VERSIONED_OBJECT<T>\` or a \`VERSION<T>\`.
   */
  target;
  /**
   * Internal storage for target_path
   * @protected
   */
  _target_path;
  /**
   * Optional archetype (i.e. AQL) or RM path within \`_target_\`, used to tag a fine-grained element.
   */
  get target_path() {
    return this._target_path?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for target_path.
   * Use this to access openehr_base.String methods.
   */
  get $target_path() {
    return this._target_path;
  }
  /**
   * Sets target_path from either a primitive value or openehr_base.String wrapper.
   */
  set target_path(val) {
    if (val === void 0 || val === null) {
      this._target_path = void 0;
    } else if (typeof val === "string") {
      this._target_path = String2.from(val);
    } else {
      this._target_path = val;
    }
  }
  /**
   * Identifier of owner object, such as EHR.
   */
  owner_id;
};
var DATA_STRUCTURE = class extends LOCATABLE {
  /**
   * Hierarchical equivalent of the physical representation of each subtype, compatible with CEN EN 13606 structures.
   * @returns Result value
   */
  as_hierarchy() {
    throw new Error("Method as_hierarchy must be implemented by concrete subclass.");
  }
};
var ITEM_STRUCTURE = class extends DATA_STRUCTURE {
};
var ITEM_TREE = class extends ITEM_STRUCTURE {
  /**
   * The items comprising the \`ITEM_TREE\`. Can include 0 or more \`CLUSTERs\` and/or 0 or more individual \`ELEMENTs\`.
   */
  items;
  /**
   * True if path  a_path' is a valid leaf path.
   *
   * @param a_path - Parameter
   * @returns Result value
   */
  has_element_path(a_path) {
    const element = this.element_at_path(a_path);
    return Boolean2.from(element !== void 0);
  }
  /**
   * Return the leaf element at the path  a_path'.
   * @param a_path - Parameter
   * @returns Result value
   */
  element_at_path(a_path) {
    const item = this.item_at_path(a_path);
    if (item instanceof ELEMENT) {
      return item;
    }
    return void 0;
  }
  /**
   * Generate a CEN EN13606-compatible hierarchy, which is the same as the tree's physical representation.
   * @returns Result value
   */
  as_hierarchy() {
    const result2 = new CLUSTER();
    result2.archetype_node_id = this.archetype_node_id;
    result2.name = this.name;
    result2.items = this.items || [];
    return result2;
  }
};
var ITEM_SINGLE = class extends ITEM_STRUCTURE {
  item;
  /**
   * Generate a CEN EN13606-compatible hierarchy consisting of a single \`ELEMENT\`.
   * @returns Result value
   */
  as_hierarchy() {
    throw new Error("ITEM_SINGLE.as_hierarchy requires item access - not yet fully implemented");
  }
};
var ITEM_TABLE = class extends ITEM_STRUCTURE {
  /**
   * Physical representation of the table as a list of \`CLUSTERs\`, each containing the data of one row of the table.
   */
  rows;
  /**
   * Number of rows in the table.
   * @returns Result value
   */
  row_count() {
    return Integer.from(this.rows?.length || 0);
  }
  /**
   * Return number of columns in the table.
   * @returns Result value
   */
  column_count() {
    if (!this.rows || this.rows.length === 0)
      return Integer.from(0);
    const items = this.rows[0].items;
    return Integer.from(items?.length || 0);
  }
  /**
   * Return set of row names.
   * @returns Result value
   */
  row_names() {
    if (!this.rows)
      return [];
    return this.rows.map((row) => row.name).filter((name) => name !== void 0);
  }
  /**
   * Return set of column names.
   * @returns Result value
   */
  column_names() {
    if (!this.rows || this.rows.length === 0)
      return [];
    const items = this.rows[0].items;
    if (!items)
      return [];
    return items.map((item) => item.name).filter((name) => name !== void 0);
  }
  /**
   * Return i-th row.
   * @param i - Parameter
   * @returns Result value
   */
  ith_row(i3) {
    const index = typeof i3 === "number" ? i3 : i3.value || 0;
    if (!this.rows)
      return void 0;
    return this.rows[index - 1];
  }
  /**
   * Return \`True\` if there is a column with name = \`_a_key_\`.
   * @param a_key - Parameter
   * @returns Result value
   */
  has_row_with_name(a_key) {
    const key = typeof a_key === "string" ? a_key : a_key.value || "";
    if (!this.rows)
      return Boolean2.from(false);
    return Boolean2.from(this.rows.some((row) => row.name?.value === key));
  }
  /**
   * Return \`True\` if there is a column with name = \`_a_key_\`.
   * @param a_key - Parameter
   * @returns Result value
   */
  has_column_with_name(a_key) {
    const key = typeof a_key === "string" ? a_key : a_key.value || "";
    const colNames = this.column_names();
    return Boolean2.from(colNames.some((name) => name.value === key));
  }
  /**
   * Return row with name = \`_a_key_\`.
   * @param a_key - Parameter
   * @returns Result value
   */
  named_row(a_key) {
    const key = typeof a_key === "string" ? a_key : a_key.value || "";
    if (!this.rows)
      return void 0;
    return this.rows.find((row) => row.name?.value === key);
  }
  /**
   * Return \`True\` if there is a row with key \`_keys_\`.
   * @param keys - Parameter
   * @returns Result value
   */
  has_row_with_key(keys) {
    return Boolean2.from(this.row_with_key(keys) !== void 0);
  }
  /**
   * Return rows with particular keys.
   * @param keys - Parameter
   * @returns Result value
   */
  row_with_key(keys) {
    if (!this.rows || !keys || keys.length === 0)
      return void 0;
    return this.rows.find((row) => {
      const items = row.items;
      if (!items)
        return false;
      return keys.every((key, idx) => {
        const item = items[idx];
        return item?.value && item.value.value === key;
      });
    });
  }
  /**
   * Return cell at a particular location.
   * @param i - Parameter
   * @param j - Parameter
   * @returns Result value
   */
  element_at_cell_ij(i3, j2) {
    const rowIdx = typeof i3 === "number" ? i3 : i3.value || 0;
    const colIdx = typeof j2 === "number" ? j2 : j2.value || 0;
    const row = this.ith_row(rowIdx);
    if (!row)
      return void 0;
    const items = row.items;
    if (!items)
      return void 0;
    return items[colIdx - 1];
  }
  /**
   * Generate a CEN EN13606-compatible hierarchy consisting of a single \`CLUSTER\` containing the \`CLUSTERs\` representing the columns of this table.
   * @returns Result value
   */
  as_hierarchy() {
    const result2 = new CLUSTER();
    result2.archetype_node_id = this.archetype_node_id;
    result2.name = this.name;
    result2.items = this.rows || [];
    return result2;
  }
};
var ITEM_LIST = class extends ITEM_STRUCTURE {
  /**
   * Physical representation of the list.
   */
  items;
  /**
   * Count of all items.
   * @returns Result value
   */
  item_count() {
    return Integer.from(this.items?.length || 0);
  }
  /**
   * Retrieve the names of all items.
   * @returns Result value
   */
  names() {
    if (!this.items)
      return [];
    return this.items.map((item) => item.name).filter((name) => name !== void 0);
  }
  /**
   * Retrieve the item with name a_name.
   * @param a_name - Parameter
   * @returns Result value
   */
  named_item(a_name) {
    const name = typeof a_name === "string" ? a_name : a_name.value || "";
    if (!this.items)
      return void 0;
    return this.items.find((item) => item.name?.value === name);
  }
  /**
   * Retrieve the i-th item with name.
   * @param i - Parameter
   * @returns Result value
   */
  ith_item(i3) {
    const index = typeof i3 === "number" ? i3 : i3.value || 0;
    if (!this.items)
      return void 0;
    return this.items[index - 1];
  }
  /**
   * Generate a CEN EN13606-compatible hierarchy consisting of a single \`CLUSTER\` containing the \`ELEMENTs\` of this list.
   * @returns Result value
   */
  as_hierarchy() {
    const result2 = new CLUSTER();
    result2.archetype_node_id = this.archetype_node_id;
    result2.name = this.name;
    result2.items = this.items || [];
    return result2;
  }
};
var EVENT = class extends LOCATABLE {
  /**
   * Time of this event. If the width is non-zero, it is the time point of the trailing edge of the event.
   */
  time;
  /**
   * Optional state data for this event.
   */
  state;
  /**
   * The data of this event.
   */
  data;
  /**
   * Offset of this event from origin, computed as time.diff(parent.origin).
   * @returns Result value
   */
  offset() {
    const result2 = new DV_DURATION();
    const parent = this.parent();
    if (parent?.origin && this.time) {
      const eventTime = this.time.value || "";
      const originTime = parent.origin.value || "";
      result2.value = "PT0S";
    }
    return result2;
  }
};
var POINT_EVENT = class extends EVENT {
};
var INTERVAL_EVENT = class extends EVENT {
  /**
   * Duration of the time interval during which the values recorded under \`data\` are true and, if set, the values recorded under \`state\` are true. Void if an instantaneous event.
   */
  width;
  /**
   * Internal storage for sample_count
   * @protected
   */
  _sample_count;
  /**
   * Optional count of original samples to which this event corresponds.
   */
  get sample_count() {
    return this._sample_count?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for sample_count.
   * Use this to access openehr_base.Integer methods.
   */
  get $sample_count() {
    return this._sample_count;
  }
  /**
   * Sets sample_count from either a primitive value or openehr_base.Integer wrapper.
   */
  set sample_count(val) {
    if (val === void 0 || val === null) {
      this._sample_count = void 0;
    } else if (typeof val === "number") {
      this._sample_count = Integer.from(val);
    } else {
      this._sample_count = val;
    }
  }
  /**
   * Mathematical function of the data of this event, e.g.  maximum, mean etc. Coded using https://github.com/openEHR/terminology/blob/master/openEHR_RM/en/openehr_terminology.xml[openEHR vocabulary \`event math function\`]. Default value \`640|actual|\`, meaning 'actual value'.
   */
  math_function;
  /**
   * Start time of the interval of this event.
   * @returns Result value
   */
  interval_start_time() {
    const result2 = new DV_DATE_TIME();
    if (this.time && this.width) {
      result2.value = this.time.value;
    }
    return result2;
  }
};
var HISTORY = class extends DATA_STRUCTURE {
  /**
   * Time origin of this event history. The first event is not necessarily at the origin point.
   */
  origin;
  /**
   * Period between samples in this segment if periodic.
   */
  period;
  /**
   * Duration of the entire History; either corresponds to the duration of all the events, and/or the duration represented by the summary, if it exists.
   */
  duration;
  /**
   * Optional summary data that aggregates, organizes, reduces and transforms the event series. This may be a text or image that presents a graphical presentation, or some data that assists with the interpretation of the data.
   */
  summary;
  /**
   * The events in the series. This attribute is of a generic type whose parameter must be a descendant of \`ITEM_SUTRUCTURE\`.
   */
  events;
  /**
   * Indicates whether history is periodic.
   *
   * @returns Result value
   */
  is_periodic() {
    return Boolean2.from(this.period !== void 0);
  }
};
var ITEM = class extends LOCATABLE {
};
var CLUSTER = class extends ITEM {
  /**
   * Ordered list of items - \`CLUSTER\` or \`ELEMENT\` objects - under this \`CLUSTER\`.
   */
  items;
};
var ELEMENT = class extends ITEM {
  /**
   * Flavour of null value, e.g. \`253|unknown|\`, \`271|no information|\`, \`272|masked|\`, and \`273|not applicable|\`.
   */
  null_flavour;
  /**
   * Property representing leaf value object of \`ELEMENT\`. In real data, any concrete subtype of \`DATA_VALUE\` can be used.
   */
  value;
  /**
   * Optional specific reason for null value; if set, \`_null_flavour_\` must be set. Null reason may apply only to a minority of clinical data, commonly needed in reporting contexts.
   */
  null_reason;
  /**
   * True if value logically not known, e.g. if indeterminate, not asked etc.
   * @returns Result value
   */
  is_null() {
    return Boolean2.from(this.value === void 0 || this.null_flavour !== void 0);
  }
};
var DATA_VALUE = class extends OPENEHR_DEFINITIONS {
};
var DV_BOOLEAN = class extends DATA_VALUE {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * Boolean value of this item. Actual values may be language or implementation dependent.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for value.
   * Use this to access openehr_base.Boolean methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.Boolean wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "boolean") {
      this._value = Boolean2.from(val);
    } else {
      this._value = val;
    }
  }
};
var DV_STATE = class extends DATA_VALUE {
  /**
   * The state name. State names are determined by a state/event table defined in archetypes, and coded using openEHR Terminology or local archetype terms, as specified by the archetype.
   */
  value;
  /**
   * Internal storage for is_terminal
   * @protected
   */
  _is_terminal;
  /**
   * Indicates whether this state is a terminal state, such as  "aborted",  "completed" etc. from which no further transitions are possible.
   */
  get is_terminal() {
    return this._is_terminal?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for is_terminal.
   * Use this to access openehr_base.Boolean methods.
   */
  get $is_terminal() {
    return this._is_terminal;
  }
  /**
   * Sets is_terminal from either a primitive value or openehr_base.Boolean wrapper.
   */
  set is_terminal(val) {
    if (val === void 0 || val === null) {
      this._is_terminal = void 0;
    } else if (typeof val === "boolean") {
      this._is_terminal = Boolean2.from(val);
    } else {
      this._is_terminal = val;
    }
  }
};
var DV_IDENTIFIER = class extends DATA_VALUE {
  /**
   * Internal storage for issuer
   * @protected
   */
  _issuer;
  /**
   * Optional authority which issues the kind of id used in the id field of this object.
   */
  get issuer() {
    return this._issuer?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for issuer.
   * Use this to access openehr_base.String methods.
   */
  get $issuer() {
    return this._issuer;
  }
  /**
   * Sets issuer from either a primitive value or openehr_base.String wrapper.
   */
  set issuer(val) {
    if (val === void 0 || val === null) {
      this._issuer = void 0;
    } else if (typeof val === "string") {
      this._issuer = String2.from(val);
    } else {
      this._issuer = val;
    }
  }
  /**
   * Internal storage for assigner
   * @protected
   */
  _assigner;
  /**
   * Optional organisation that assigned the id to the item being identified.
   */
  get assigner() {
    return this._assigner?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for assigner.
   * Use this to access openehr_base.String methods.
   */
  get $assigner() {
    return this._assigner;
  }
  /**
   * Sets assigner from either a primitive value or openehr_base.String wrapper.
   */
  set assigner(val) {
    if (val === void 0 || val === null) {
      this._assigner = void 0;
    } else if (typeof val === "string") {
      this._assigner = String2.from(val);
    } else {
      this._assigner = val;
    }
  }
  /**
   * Internal storage for id
   * @protected
   */
  _id;
  /**
   * The identifier value. Often structured, according to the definition of the issuing authority's rules.
   */
  get id() {
    return this._id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for id.
   * Use this to access openehr_base.String methods.
   */
  get $id() {
    return this._id;
  }
  /**
   * Sets id from either a primitive value or openehr_base.String wrapper.
   */
  set id(val) {
    if (val === void 0 || val === null) {
      this._id = void 0;
    } else if (typeof val === "string") {
      this._id = String2.from(val);
    } else {
      this._id = val;
    }
  }
  /**
   * Internal storage for type
   * @protected
   */
  _type;
  /**
   * Optional identifier type, such as  prescription , or  Social Security Number . One day a controlled vocabulary might be possible for this.
   */
  get type() {
    return this._type?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for type.
   * Use this to access openehr_base.String methods.
   */
  get $type() {
    return this._type;
  }
  /**
   * Sets type from either a primitive value or openehr_base.String wrapper.
   */
  set type(val) {
    if (val === void 0 || val === null) {
      this._type = void 0;
    } else if (typeof val === "string") {
      this._type = String2.from(val);
    } else {
      this._type = val;
    }
  }
};
var DV_ENCAPSULATED = class extends DATA_VALUE {
  /**
   * Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set  character sets . Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. This attribute allows for variations from these assumptions.
   */
  charset;
  /**
   * Optional indicator of the localised language in which the data is written, if relevant. Coded from openEHR Code Set \`languages\`.
   */
  language;
};
var DV_MULTIMEDIA = class extends DV_ENCAPSULATED {
  /**
   * Internal storage for alternate_text
   * @protected
   */
  _alternate_text;
  /**
   * Text to display in lieu of multimedia display/replay.
   */
  get alternate_text() {
    return this._alternate_text?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for alternate_text.
   * Use this to access openehr_base.String methods.
   */
  get $alternate_text() {
    return this._alternate_text;
  }
  /**
   * Sets alternate_text from either a primitive value or openehr_base.String wrapper.
   */
  set alternate_text(val) {
    if (val === void 0 || val === null) {
      this._alternate_text = void 0;
    } else if (typeof val === "string") {
      this._alternate_text = String2.from(val);
    } else {
      this._alternate_text = val;
    }
  }
  /**
   * URI reference to electronic information stored outside the record as a file, database entry etc, if supplied as a reference.
   */
  uri;
  /**
   * The actual data found at \`_uri_\`, if supplied inline.
   */
  data;
  /**
   * Data media type coded from openEHR code set  media types  (interface for the IANA MIME types code set).
   */
  media_type;
  /**
   * Compression type, a coded value from the openEHR Integrity check code set. Void means no compression.
   */
  compression_algorithm;
  /**
   * Binary cryptographic integrity checksum.
   */
  integrity_check;
  /**
   * Type of integrity check, a coded value from the openEHR \`Integrity check\` code set.
   */
  integrity_check_algorithm;
  /**
   * The thumbnail for this item, if one exists; mainly for graphics formats.
   */
  thumbnail;
  /**
   * Internal storage for size
   * @protected
   */
  _size;
  /**
   * Original size in bytes of unencoded encapsulated data. I.e. encodings such as base64, hexadecimal etc do not change the value of this attribute.
   */
  get size() {
    return this._size?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for size.
   * Use this to access openehr_base.Integer methods.
   */
  get $size() {
    return this._size;
  }
  /**
   * Sets size from either a primitive value or openehr_base.Integer wrapper.
   */
  set size(val) {
    if (val === void 0 || val === null) {
      this._size = void 0;
    } else if (typeof val === "number") {
      this._size = Integer.from(val);
    } else {
      this._size = val;
    }
  }
  /**
   * Computed from the value of the \`_uri_\` attribute: True if  the data is stored externally to the record, as indicated by \`_uri_\`. A copy may also be stored internally, in which case \`_is_expanded_\` is also true.
   * @returns Result value
   */
  is_external() {
    return Boolean2.from(this.uri !== void 0);
  }
  /**
   * Computed from the value of the data attribute. True if  the  data is stored  in  expanded  form, ie within the EHR itself.
   * @returns Result value
   */
  is_inline() {
    return Boolean2.from(this.data !== void 0);
  }
  /**
   * Computed from the value of the \`_compression_algorithm_\` attribute: True if  the  data is stored in compressed form.
   * @returns Result value
   */
  is_compressed() {
    return Boolean2.from(this.compression_algorithm !== void 0);
  }
  /**
   * Computed from the value of the \`_integrity_check_algorithm_\` attribute: True if an integrity check has been computed.
   * @returns Result value
   */
  has_integrity_check() {
    return Boolean2.from(this.integrity_check_algorithm !== void 0);
  }
};
var DV_PARSABLE = class extends DV_ENCAPSULATED {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * The string, which may validly be empty in some syntaxes.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for value.
   * Use this to access openehr_base.String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * Internal storage for formalism
   * @protected
   */
  _formalism;
  /**
   * Name of the formalism, e.g.  GLIF 1.0 ,  Proforma  etc.
   */
  get formalism() {
    return this._formalism?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for formalism.
   * Use this to access openehr_base.String methods.
   */
  get $formalism() {
    return this._formalism;
  }
  /**
   * Sets formalism from either a primitive value or openehr_base.String wrapper.
   */
  set formalism(val) {
    if (val === void 0 || val === null) {
      this._formalism = void 0;
    } else if (typeof val === "string") {
      this._formalism = String2.from(val);
    } else {
      this._formalism = val;
    }
  }
  /**
   * Size in bytes of value.
   * @returns Result value
   */
  size() {
    const valueStr = this.value || "";
    const encoder = new TextEncoder();
    const bytes = encoder.encode(valueStr);
    return Integer.from(bytes.length);
  }
};
var DV_PARAGRAPH = class extends DATA_VALUE {
  /**
   * Items making up the paragraph, each of which is a text item (which may have its own formatting, and/or have hyperlinks).
   */
  items;
};
var DV_TEXT = class extends DATA_VALUE {
  /**
   * Constructor supports initialization from string or object.
   * 
   * @param init - String (sets value) or initialization object
   * 
   * @example
   * ```typescript
   * // Simple string
   * const text = new DV_TEXT("Hello world");
   * 
   * // Object format
   * const text2 = new DV_TEXT({ value: "Hello", language: "ISO_639-1::en" });
   * ```
   */
  constructor(init3) {
    super();
    if (typeof init3 === "string") {
      this.value = init3;
    } else if (init3) {
      if (init3.value !== void 0) {
        this.value = init3.value;
      }
      if (init3.hyperlink !== void 0) {
        this.hyperlink = init3.hyperlink;
      }
      if (init3.formatting !== void 0) {
        this.formatting = init3.formatting;
      }
      if (init3.mappings !== void 0) {
        this.mappings = init3.mappings;
      }
      if (init3.language !== void 0) {
        this.language = initCodePhrase(init3.language);
      }
      if (init3.encoding !== void 0) {
        this.encoding = initCodePhrase(init3.encoding);
      }
    }
  }
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * Displayable rendition of the item, regardless of its underlying structure. For \`DV_CODED_TEXT\`, this is the rubric of the complete term as provided by the terminology service.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for value.
   * Use this to access openehr_base.String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * DEPRECATED: this field is deprecated; use markdown link/text in the \`_value_\` attribute, and \`"markdown"\` as the value of the \`_formatting_\` field.
   *
   * Original usage, prior to RM Release 1.0.4: Optional link sitting behind a section of plain text or coded term item.
   */
  hyperlink;
  /**
   * Internal storage for formatting
   * @protected
   */
  _formatting;
  /**
   * If set, contains one of the following values:
   *
   * * \`"plain"\`: use for plain text, possibly containing newlines, but otherwise unformatted (same as Void);
   * * \`"plain_no_newlines"\`: use for text containing no newlines or other formatting;
   * * \`"markdown"\`: use for markdown formatted text, strongly recommended in the format of the CommonMark specification.
   *
   * DEPRECATED usage: contains a string of the form \`"name:value; name:value..."\` , e.g. \`"font-weight : bold; font-family : Arial; font-size : 12pt;"\`. Values taken from W3C CSS2 properties lists for background and font .
   */
  get formatting() {
    return this._formatting?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for formatting.
   * Use this to access openehr_base.String methods.
   */
  get $formatting() {
    return this._formatting;
  }
  /**
   * Sets formatting from either a primitive value or openehr_base.String wrapper.
   */
  set formatting(val) {
    if (val === void 0 || val === null) {
      this._formatting = void 0;
    } else if (typeof val === "string") {
      this._formatting = String2.from(val);
    } else {
      this._formatting = val;
    }
  }
  /**
   * Terms from other terminologies most closely matching this term, typically used where the originator (e.g. pathology lab) of information uses a local terminology but also supplies one or more equivalents from well known terminologies (e.g. LOINC).
   */
  mappings;
  /**
   * Optional indicator of the localised language in which the value is written. Coded from openEHR Code Set  languages . Only used when either the text object is in a different language from the enclosing \`ENTRY\`, or else the text object is being used outside of an \`ENTRY\` or other enclosing structure which indicates the language.
   */
  language;
  /**
   * Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set  character sets . Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. This attribute allows for variations from these assumptions.
   */
  encoding;
};
var DV_CODED_TEXT = class extends DV_TEXT {
  /**
   * Constructor supports initialization from terse format or object.
   * 
   * @param init - String (terse format "terminology::code|value|") or initialization object
   * 
   * @example
   * ```typescript
   * // Terse format
   * const dct = new DV_CODED_TEXT("openehr::433|event|");
   * 
   * // Object format
   * const dct2 = new DV_CODED_TEXT({
   *   value: "event",
   *   defining_code: { code_string: "433", terminology_id: "openehr" }
   * });
   * ```
   */
  constructor(init3) {
    if (typeof init3 === "string") {
      const parsed = parseTerseDvCodedText(init3);
      if (parsed) {
        super({ value: parsed.value });
        this.defining_code = parsed.defining_code;
      } else {
        super();
      }
    } else {
      super(init3);
      if (init3 && init3.defining_code !== void 0) {
        this.defining_code = initCodePhrase(init3.defining_code);
      }
    }
  }
  /**
   * The term of which the  \`_value_\` attribute is the textual rendition (i.e. rubric).
   */
  defining_code;
};
var TERM_MAPPING = class {
  /**
   * The relative match of the target term with respect to the mapped text item. Result meanings:
   *
   * * \`'>'\`: the mapping is to a broader term e.g. orginal text =  arbovirus infection , target =  viral infection
   * * \`'='\`: the mapping is to a (supposedly) equivalent to the original item
   * * \`'<'\`: the mapping is to a narrower term. e.g. original text =  diabetes , mapping =  diabetes mellitus .
   * * \`'?'\`: the kind of mapping is unknown.
   *
   * The first three values are taken from the ISO standards 2788 ( Guide to Establishment and development of monolingual thesauri) and 5964 (Guide to Establishment and development of multilingual thesauri).
   */
  match;
  /**
   * Purpose of the mapping e.g. 'automated data mining', 'billing', 'interoperability'.
   */
  purpose;
  /**
   * The target term of the mapping.
   */
  target;
  /**
   * The mapping is to a narrower term.
   * @returns Result value
   */
  narrower() {
    return Boolean2.from(this.match === "<");
  }
  /**
   * The mapping is to a broader term.
   * @returns Result value
   */
  broader() {
    return Boolean2.from(this.match === ">");
  }
  /**
   * The mapping is to an equivalent term.
   * @returns Result value
   */
  equivalent() {
    return Boolean2.from(this.match === "=");
  }
  /**
   * The kind of mapping is unknown.
   * @returns Result value
   */
  unknown() {
    return Boolean2.from(this.match === "?");
  }
  /**
   * True if match valid.
   * @param c - Parameter
   * @returns Result value
   */
  is_valid_match_code(c2) {
    const validCodes = ["=", "<", ">", "?"];
    return Boolean2.from(validCodes.includes(c2));
  }
};
var CODE_PHRASE2 = class {
  /**
   * Constructor supports initialization from terse format or object.
   * 
   * @param init - String (terse format "terminology::code") or initialization object
   * 
   * @example
   * ```typescript
   * // Terse format
   * const cp = new CODE_PHRASE("ISO_639-1::en");
   * 
   * // Object format
   * const cp2 = new CODE_PHRASE({
   *   code_string: "en",
   *   terminology_id: "ISO_639-1"
   * });
   * ```
   */
  constructor(init3) {
    if (typeof init3 === "string") {
      const parsed = initCodePhrase(init3);
      if (parsed) {
        this.terminology_id = parsed.terminology_id;
        this.code_string = parsed.code_string;
        if (parsed.preferred_term) {
          this.preferred_term = parsed.preferred_term;
        }
      }
    } else if (init3) {
      if (init3.terminology_id !== void 0) {
        if (typeof init3.terminology_id === "string") {
          const termId = new TERMINOLOGY_ID();
          termId.value = init3.terminology_id;
          this.terminology_id = termId;
        } else {
          this.terminology_id = init3.terminology_id;
        }
      }
      if (init3.code_string !== void 0) {
        this.code_string = init3.code_string;
      }
      if (init3.preferred_term !== void 0) {
        this.preferred_term = init3.preferred_term;
      }
    }
  }
  /**
   * Identifier of the distinct terminology from which the code_string (or its elements) was extracted.
   */
  terminology_id;
  /**
   * Internal storage for code_string
   * @protected
   */
  _code_string;
  /**
   * The key used by the terminology service to identify a concept or coordination of concepts. This string is most likely parsable inside the terminology service, but nothing can be assumed about its syntax outside that context.
   */
  get code_string() {
    return this._code_string?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for code_string.
   * Use this to access openehr_base.String methods.
   */
  get $code_string() {
    return this._code_string;
  }
  /**
   * Sets code_string from either a primitive value or openehr_base.String wrapper.
   */
  set code_string(val) {
    if (val === void 0 || val === null) {
      this._code_string = void 0;
    } else if (typeof val === "string") {
      this._code_string = String2.from(val);
    } else {
      this._code_string = val;
    }
  }
  /**
   * Internal storage for preferred_term
   * @protected
   */
  _preferred_term;
  /**
   * Optional attribute to carry preferred term corresponding to the code or expression in \`_code_string_\`. Typical use in integration situations which create mappings, and representing data for which both a (non-preferred) actual term and a preferred term are both required.
   */
  get preferred_term() {
    return this._preferred_term?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for preferred_term.
   * Use this to access openehr_base.String methods.
   */
  get $preferred_term() {
    return this._preferred_term;
  }
  /**
   * Sets preferred_term from either a primitive value or openehr_base.String wrapper.
   */
  set preferred_term(val) {
    if (val === void 0 || val === null) {
      this._preferred_term = void 0;
    } else if (typeof val === "string") {
      this._preferred_term = String2.from(val);
    } else {
      this._preferred_term = val;
    }
  }
};
var DV_ORDERED = class extends DATA_VALUE {
  /**
   * Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group  \`normal_status\`.
   */
  normal_status;
  /**
   * Optional normal range.
   */
  normal_range;
  /**
   * Optional tagged other reference ranges for this value in its particular measurement context.
   */
  other_reference_ranges;
  /**
   * True if this quantity has no reference ranges.
   * @returns Result value
   */
  is_simple() {
    return Boolean2.from(
      this.other_reference_ranges === void 0 || Array.isArray(this.other_reference_ranges) && this.other_reference_ranges.length === 0
    );
  }
  /**
   * Value is in the normal range, determined by comparison of the value to \`_normal_range_\` if present, or by the \`_normal_status_\` marker if present.
   *
   * @returns Result value
   */
  is_normal() {
    if (this.normal_status?.code_string === "N") {
      return Boolean2.from(true);
    }
    if (!this.normal_range) {
      return Boolean2.from(false);
    }
    return Boolean2.from(true);
  }
};
var DV_INTERVAL = class extends DATA_VALUE {
};
var REFERENCE_RANGE = class {
  /**
   * Term whose value indicates the meaning of this range, e.g.  normal,  critical,  therapeutic  etc.
   */
  meaning;
  /**
   * The data range for this meaning, e.g. critical  etc.
   */
  range;
  /**
   * Indicates if the value  \`_v_\` is inside the range.
   *
   * @param v - Parameter
   * @returns Result value
   */
  is_in_range(v2) {
    if (!this.range) {
      return Boolean2.from(false);
    }
    return Boolean2.from(true);
  }
};
var DV_QUANTIFIED = class extends DV_ORDERED {
  /**
   * Internal storage for magnitude_status
   * @protected
   */
  _magnitude_status;
  /**
   * Optional status of magnitude with values:
   *
   * * \`"="\`   :   magnitude is a point value
   * * \`"<"\`   :   value is < magnitude
   * * \`">"\`   :   value is > magnitude
   * * \`"<="\` : value is <= magnitude
   * * \`">="\` : value is >= magnitude
   * * \`"~"\`   :   value is approximately magnitude
   *
   * If not present, assumed meaning is  \`"="\` .
   */
  get magnitude_status() {
    return this._magnitude_status?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for magnitude_status.
   * Use this to access openehr_base.String methods.
   */
  get $magnitude_status() {
    return this._magnitude_status;
  }
  /**
   * Sets magnitude_status from either a primitive value or openehr_base.String wrapper.
   */
  set magnitude_status(val) {
    if (val === void 0 || val === null) {
      this._magnitude_status = void 0;
    } else if (typeof val === "string") {
      this._magnitude_status = String2.from(val);
    } else {
      this._magnitude_status = val;
    }
  }
  /**
   * Accuracy of measurement. Exact form of expression determined in descendants.
   */
  accuracy;
  /**
   * Test whether a string value is one of the valid values for the magnitude_status attribute.
   * @returns Result value
   */
  valid_magnitude_status() {
    const validStatuses = ["=", "<", ">", "<=", ">=", "~"];
    if (!this.magnitude_status) {
      return Boolean2.from(true);
    }
    return Boolean2.from(validStatuses.includes(this.magnitude_status));
  }
  /**
   * True if accuracy is not known, e.g. due to not being recorded or discernable.
   * @returns Result value
   */
  accuracy_unknown() {
    return Boolean2.from(this.accuracy === void 0 || this.accuracy === -1);
  }
  /**
   * True if this Quantified object is less than \`_other_\`, based on comparison of \`_magnitude_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    const thisMag = this.magnitude();
    const otherMag = other.magnitude();
    if (typeof thisMag === "number" && typeof otherMag === "number") {
      return Boolean2.from(thisMag < otherMag);
    }
    if (thisMag && typeof thisMag === "object" && "less_than" in thisMag) {
      return thisMag.less_than(otherMag);
    }
    return Boolean2.from(Number(thisMag) < Number(otherMag));
  }
};
var PROPORTION_KIND = class extends Integer {
};
var DV_AMOUNT = class extends DV_QUANTIFIED {
  /**
   * Internal storage for accuracy_is_percent
   * @protected
   */
  _accuracy_is_percent;
  /**
   * If \`True\`, indicates that when this object was created, \`_accuracy_\` was recorded as a percent value; if \`False\`, as an absolute quantity value.
   */
  get accuracy_is_percent() {
    return this._accuracy_is_percent?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for accuracy_is_percent.
   * Use this to access openehr_base.Boolean methods.
   */
  get $accuracy_is_percent() {
    return this._accuracy_is_percent;
  }
  /**
   * Sets accuracy_is_percent from either a primitive value or openehr_base.Boolean wrapper.
   */
  set accuracy_is_percent(val) {
    if (val === void 0 || val === null) {
      this._accuracy_is_percent = void 0;
    } else if (typeof val === "boolean") {
      this._accuracy_is_percent = Boolean2.from(val);
    } else {
      this._accuracy_is_percent = val;
    }
  }
  /**
   * Accuracy of measurement, expressed either as a half-range percent value (\`_accuracy_is_percent_\` = \`True\`) or a half-range quantity. A value of \`0\` means that accuracy is 100%, i.e. no error.
   *
   * A value of \`_unknown_accuracy_value_\` means that accuracy was not recorded.
   */
  accuracy = void 0;
  /**
   * Test whether a number is a valid percentage, i.e. between 0 and 100.
   * @param number - Parameter
   * @returns Result value
   */
  valid_percentage(number) {
    const value = typeof number === "number" ? number : Number(number);
    if (isNaN(value)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(value >= 0 && value <= 100);
  }
  /**
   * Sum of this amount and another. The value of accuracy in the result is either:
   *
   * * the sum of the accuracies of the operands, if both present, or;
   * * both operand accuracies are unknown_accuracy_value.
   *
   * If the accuracy value is a percentage in one operand and not in the other, the form in the result is that of the larger operand.
   * @param other - Parameter
   * @returns Result value
   */
  add(_other) {
    throw new Error("Method add must be implemented by concrete subclass.");
  }
  /**
   * Difference of this amount and another. The value of \`_accuracy_\` in the result is either:
   *
   * * the sum of the accuracies of the operands, if both present, or;
   * * unknown, if either or both operand accuracies are unknown.
   *
   * If the \`_accuracy_\` value is a percentage in one operand and not in the other, the form in the result is that of the larger operand.
   * @param other - Parameter
   * @returns Result value
   */
  subtract(_other) {
    throw new Error("Method subtract must be implemented by concrete subclass.");
  }
  /**
   * Product of this Amount and \`_factor_\`.
   * @param factor - Parameter
   * @returns Result value
   */
  multiply(_factor) {
    throw new Error("Method multiply must be implemented by concrete subclass.");
  }
  /**
   * Negated version of current object, such as used for representing a difference, e.g. a weight loss.
   * @returns Result value
   */
  negative() {
    throw new Error("Method negative must be implemented by concrete subclass.");
  }
  /**
   * True if this object is less than \`_other_\`. Based on comparison of \`_magnitude_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    const thisMag = this.magnitude();
    const otherMag = other.magnitude();
    const thisVal = typeof thisMag === "number" ? thisMag : Number(thisMag);
    const otherVal = typeof otherMag === "number" ? otherMag : Number(otherMag);
    return Boolean2.from(thisVal < otherVal);
  }
};
var DV_PROPORTION = class _DV_PROPORTION extends PROPORTION_KIND {
  /**
   * Numerator of ratio
   */
  numerator;
  /**
   * Denominator of ratio.
   */
  denominator;
  /**
   * Internal storage for type
   * @protected
   */
  _type;
  /**
   * Indicates semantic type of proportion, including percent, unitary etc.
   */
  get type() {
    return this._type?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for type.
   * Use this to access openehr_base.Integer methods.
   */
  get $type() {
    return this._type;
  }
  /**
   * Sets type from either a primitive value or openehr_base.Integer wrapper.
   */
  set type(val) {
    if (val === void 0 || val === null) {
      this._type = void 0;
    } else if (typeof val === "number") {
      this._type = Integer.from(val);
    } else {
      this._type = val;
    }
  }
  /**
   * Internal storage for precision
   * @protected
   */
  _precision;
  /**
   * Precision  to  which  the  \`_numerator_\` and \`_denominator_\` values of  the  proportion are expressed, in terms of number  of decimal places. The value 0 implies an integral quantity. The value -1 implies no limit, i.e. any number of decimal places.
   */
  get precision() {
    return this._precision?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for precision.
   * Use this to access openehr_base.Integer methods.
   */
  get $precision() {
    return this._precision;
  }
  /**
   * Sets precision from either a primitive value or openehr_base.Integer wrapper.
   */
  set precision(val) {
    if (val === void 0 || val === null) {
      this._precision = void 0;
    } else if (typeof val === "number") {
      this._precision = Integer.from(val);
    } else {
      this._precision = val;
    }
  }
  /**
   * Optional normal range.
   */
  normal_range = void 0;
  /**
   * Optional tagged other reference ranges for this value in its particular measurement context.
   */
  other_reference_ranges;
  /**
   * Effective magnitude represented by ratio.
   * @returns Result value
   */
  magnitude() {
    if (!this.denominator || this.denominator === 0) {
      throw new Error("Cannot compute magnitude with zero or undefined denominator");
    }
    return (this.numerator || 0) / this.denominator;
  }
  /**
   * True if the \`_numerator_\` and \`_denominator_\` values are integers, i.e. if \`_precision_\` is 0.
   * @returns Result value
   */
  is_integral() {
    return Boolean2.from(this.precision === 0);
  }
  /**
   * Sum of two strictly comparable proportions.
   * @param other - Parameter
   * @returns Result value
   */
  add(other) {
    if (this.type !== other.type) {
      throw new Error("Cannot add proportions with different types");
    }
    const result2 = new _DV_PROPORTION();
    const a2 = this.numerator || 0;
    const b2 = this.denominator || 1;
    const c2 = other.numerator || 0;
    const d2 = other.denominator || 1;
    result2.numerator = a2 * d2 + b2 * c2;
    result2.denominator = b2 * d2;
    result2.type = this.type;
    result2.precision = this.precision;
    return result2;
  }
  /**
   * Difference between two strictly comparable proportions.
   * @param other - Parameter
   * @returns Result value
   */
  subtract(other) {
    if (this.type !== other.type) {
      throw new Error("Cannot subtract proportions with different types");
    }
    const result2 = new _DV_PROPORTION();
    const a2 = this.numerator || 0;
    const b2 = this.denominator || 1;
    const c2 = other.numerator || 0;
    const d2 = other.denominator || 1;
    result2.numerator = a2 * d2 - b2 * c2;
    result2.denominator = b2 * d2;
    result2.type = this.type;
    result2.precision = this.precision;
    return result2;
  }
  /**
   * Return True if this \`DV_AMOUNT\` is considered equal to \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _DV_PROPORTION)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(
      this.type === other.type && this.numerator === other.numerator && this.denominator === other.denominator
    );
  }
  /**
   * Product of this Proportion and \`_factor_\`.
   * @param factor - Parameter
   * @returns Result value
   */
  multiply(factor) {
    const result2 = new _DV_PROPORTION();
    result2.numerator = (this.numerator || 0) * factor;
    result2.denominator = this.denominator;
    result2.type = this.type;
    result2.precision = this.precision;
    return result2;
  }
  /**
   * True if this Proportion is less than  \`_other_\`. Only valid if \`_is_strictly_comparable_to()_\` is True.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    return Boolean2.from(this.magnitude() < other.magnitude());
  }
  /**
   * Return True if the \`_type_\` of this proportion is the same as the \`_type_\` of \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  is_strictly_comparable_to(other) {
    if (!(other instanceof _DV_PROPORTION)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.type === other.type);
  }
};
var DV_QUANTITY = class _DV_QUANTITY extends DV_AMOUNT {
  /**
   * Numeric magnitude of the quantity.
   */
  magnitude;
  /**
   * Internal storage for precision
   * @protected
   */
  _precision;
  /**
   * Precision to which the value of the quantity is expressed, in terms of number of decimal places. The value 0 implies an integral quantity.
   * The value -1 implies no limit, i.e. any number of decimal places.
   */
  get precision() {
    return this._precision?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for precision.
   * Use this to access openehr_base.Integer methods.
   */
  get $precision() {
    return this._precision;
  }
  /**
   * Sets precision from either a primitive value or openehr_base.Integer wrapper.
   */
  set precision(val) {
    if (val === void 0 || val === null) {
      this._precision = void 0;
    } else if (typeof val === "number") {
      this._precision = Integer.from(val);
    } else {
      this._precision = val;
    }
  }
  /**
   * Internal storage for units
   * @protected
   */
  _units;
  /**
   * Quantity units, expressed as a code or syntax string from either UCUM (the default) or the units system specified in \`_units_system_\`, when set.
   *
   * In either case, the value is the code or syntax - normally formed of standard ASCII - which is in principal not the same as the display string, although in simple cases such as 'm' (for meters) it will be.
   *
   * If the \`_units_display_name_\` field is set, this may be used for display. If not, the implementations must effect the resolution of the \`_units_\` value to a display form locally, e.g. by lookup of reference tables, request to a terminology service etc.
   *
   * Example values from UCUM: "kg/m^2", mm[Hg]", "ms-1", "km/h".
   */
  get units() {
    return this._units?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for units.
   * Use this to access openehr_base.String methods.
   */
  get $units() {
    return this._units;
  }
  /**
   * Sets units from either a primitive value or openehr_base.String wrapper.
   */
  set units(val) {
    if (val === void 0 || val === null) {
      this._units = void 0;
    } else if (typeof val === "string") {
      this._units = String2.from(val);
    } else {
      this._units = val;
    }
  }
  /**
   * Optional normal range.
   */
  normal_range = void 0;
  /**
   * Optional tagged other reference ranges for this value in its particular measurement context.
   */
  other_reference_ranges;
  /**
   * Internal storage for units_system
   * @protected
   */
  _units_system;
  /**
   * Optional field used to specify a units system from which codes in \`_units_\` are defined. Value is a URI identifying a terminology containing units concepts from the  (https://www.hl7.org/fhir/terminologies-systems.html[HL7 FHIR terminologies list]).
   *
   * If not set, the UCUM standard (case-sensitive codes) is assumed as the units system.
   */
  get units_system() {
    return this._units_system?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for units_system.
   * Use this to access openehr_base.String methods.
   */
  get $units_system() {
    return this._units_system;
  }
  /**
   * Sets units_system from either a primitive value or openehr_base.String wrapper.
   */
  set units_system(val) {
    if (val === void 0 || val === null) {
      this._units_system = void 0;
    } else if (typeof val === "string") {
      this._units_system = String2.from(val);
    } else {
      this._units_system = val;
    }
  }
  /**
   * Internal storage for units_display_name
   * @protected
   */
  _units_display_name;
  /**
   * Optional field containing the displayable form of the \`_units_\` field, e.g. \`'C'\`.
   *
   * If not set, the application environment needs to determine the displayable form.
   *
   * NOTE: The display name may be language-dependent for various older and non-systematic units. For this reason, it is not recommended to add unit display names to archetypes, only to templates (for localisation purposes).
   */
  get units_display_name() {
    return this._units_display_name?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for units_display_name.
   * Use this to access openehr_base.String methods.
   */
  get $units_display_name() {
    return this._units_display_name;
  }
  /**
   * Sets units_display_name from either a primitive value or openehr_base.String wrapper.
   */
  set units_display_name(val) {
    if (val === void 0 || val === null) {
      this._units_display_name = void 0;
    } else if (typeof val === "string") {
      this._units_display_name = String2.from(val);
    } else {
      this._units_display_name = val;
    }
  }
  /**
   * Sum of this \`DV_QUANTITY\` and \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  add(other) {
    if (this.units !== other.units) {
      throw new Error("Cannot add quantities with different units");
    }
    const result2 = new _DV_QUANTITY();
    result2.magnitude = (this.magnitude || 0) + (other.magnitude || 0);
    result2.units = this.units;
    result2.units_system = this.units_system;
    result2.precision = this.precision;
    if (this.accuracy !== void 0 && other.accuracy !== void 0) {
      result2.accuracy = this.accuracy + other.accuracy;
    }
    return result2;
  }
  /**
   * Difference of this \`DV_QUANTITY\` and \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  subtract(other) {
    if (this.units !== other.units) {
      throw new Error("Cannot subtract quantities with different units");
    }
    const result2 = new _DV_QUANTITY();
    result2.magnitude = (this.magnitude || 0) - (other.magnitude || 0);
    result2.units = this.units;
    result2.units_system = this.units_system;
    result2.precision = this.precision;
    if (this.accuracy !== void 0 && other.accuracy !== void 0) {
      result2.accuracy = Math.sqrt(this.accuracy ** 2 + other.accuracy ** 2);
    }
    return result2;
  }
  /**
   * Product of this \`DV_QUANTITY\` and \`_factor_\`.
   * @param factor - Parameter
   * @returns Result value
   */
  multiply(factor) {
    const result2 = new _DV_QUANTITY();
    result2.magnitude = (this.magnitude || 0) * factor;
    result2.units = this.units;
    result2.units_system = this.units_system;
    result2.precision = this.precision;
    if (this.accuracy !== void 0) {
      result2.accuracy = this.accuracy * Math.abs(factor);
    }
    return result2;
  }
  /**
   * True if this Quantity object is less than \`_other_\`, based on comparison of \`_magnitude_\`. Only valid if \`_is_strictly_comparable_to()_\` is True.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (this.units !== other.units) {
      console.warn("Comparing quantities with different units");
    }
    return Boolean2.from((this.magnitude || 0) < (other.magnitude || 0));
  }
  /**
   * True if \`_precision_\` = 0, meaning that the \`_magnitude_\` is a whole number.
   * @returns Result value
   */
  is_integral() {
    return Boolean2.from(this.precision === 0);
  }
  /**
   * True if this quantity and \`_other_\` have the same \`_units_\` and also \`_units_system_\` if it exists.
   * @param other - Parameter
   * @returns Result value
   */
  is_strictly_comparable_to(other) {
    if (!(other instanceof _DV_QUANTITY)) {
      return Boolean2.from(false);
    }
    if (this.units !== other.units) {
      return Boolean2.from(false);
    }
    if (this.units_system !== void 0 || other.units_system !== void 0) {
      if (this.units_system !== other.units_system) {
        return Boolean2.from(false);
      }
    }
    return Boolean2.from(true);
  }
  /**
   * Value equality comparison.
   * @param other - The other object to compare with
   * @returns Boolean wrapper indicating equality
   */
  is_equal(other) {
    if (!(other instanceof _DV_QUANTITY)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(
      this.magnitude === other.magnitude && this.units === other.units
    );
  }
};
var DV_COUNT = class _DV_COUNT extends DV_AMOUNT {
  /**
   * Internal storage for magnitude
   * @protected
   */
  _magnitude;
  get magnitude() {
    return this._magnitude?.value;
  }
  /**
   * Gets the openehr_base.Integer64 wrapper object for magnitude.
   * Use this to access openehr_base.Integer64 methods.
   */
  get $magnitude() {
    return this._magnitude;
  }
  /**
   * Sets magnitude from either a primitive value or openehr_base.Integer64 wrapper.
   */
  set magnitude(val) {
    if (val === void 0 || val === null) {
      this._magnitude = void 0;
    } else if (typeof val === "number") {
      this._magnitude = Integer64.from(val);
    } else {
      this._magnitude = val;
    }
  }
  /**
   * Optional normal range.
   */
  normal_range = void 0;
  /**
   * Optional tagged other reference ranges for this value in its particular measurement context.
   */
  other_reference_ranges;
  /**
   * Sum of this \`DV_COUNT\` and \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  add(other) {
    const result2 = new _DV_COUNT();
    result2.magnitude = (this.magnitude || 0) + (other.magnitude || 0);
    if (this.accuracy !== void 0 && other.accuracy !== void 0) {
      result2.accuracy = this.accuracy + other.accuracy;
    }
    return result2;
  }
  /**
   * Difference of this \`DV_COUNT\` and \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  subtract(other) {
    const result2 = new _DV_COUNT();
    result2.magnitude = (this.magnitude || 0) - (other.magnitude || 0);
    if (this.accuracy !== void 0 && other.accuracy !== void 0) {
      result2.accuracy = Math.sqrt(this.accuracy ** 2 + other.accuracy ** 2);
    }
    return result2;
  }
  /**
   * Product of this \`DV_COUNT\` and \`_factor_\`.
   * @param factor - Parameter
   * @returns Result value
   */
  multiply(factor) {
    const result2 = new _DV_COUNT();
    result2.magnitude = Math.round((this.magnitude || 0) * factor);
    if (this.accuracy !== void 0) {
      result2.accuracy = this.accuracy * Math.abs(factor);
    }
    return result2;
  }
  /**
   * True if this Quantified object is less than \`_other_\`, based on comparison of \`_magnitude_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    return Boolean2.from((this.magnitude || 0) < (other.magnitude || 0));
  }
  /**
   * Return True.
   * @param other - Parameter
   * @returns Result value
   */
  is_strictly_comparable_to(other) {
    return Boolean2.from(other instanceof _DV_COUNT);
  }
  /**
   * Value equality comparison.
   * @param other - The other object to compare with
   * @returns Boolean wrapper indicating equality
   */
  is_equal(other) {
    if (!(other instanceof _DV_COUNT)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.magnitude === other.magnitude);
  }
};
var DV_ABSOLUTE_QUANTITY = class extends DV_QUANTIFIED {
  accuracy = void 0;
};
var DV_ORDINAL = class _DV_ORDINAL extends DV_ORDERED {
  /**
   * Coded textual representation of this value in the enumeration, which may be strings made from  +  symbols, or other enumerations of terms such as  \`mild\`, \`moderate\`, \`severe\`, or even the same number series as the values, e.g. 1, 2, 3.
   */
  symbol;
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * Value in ordered enumeration of values. Any integer value can be used.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for value.
   * Use this to access openehr_base.Integer methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.Integer wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "number") {
      this._value = Integer.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * True if this Ordinal value is less than \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    return Boolean2.from((this.value || 0) < (other.value || 0));
  }
  /**
   * Test if this Ordinal is strictly comparable to \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  is_strictly_comparable_to(other) {
    return Boolean2.from(other instanceof _DV_ORDINAL);
  }
};
var DV_SCALE = class _DV_SCALE extends DV_ORDERED {
  /**
   * Coded textual representation of this value in the scale range, which may be strings made from symbols or other enumerations of terms such as  \`no breathlessness\`, \`very very slight\`, \`slight breathlessness\`. Codes come from archetypes.
   *
   * In some cases, a scale may include values that have no code/symbol. In this case, the symbol will be a \`DV-CODED_TEXT\` including the \`_terminology_id_\` and a blank String value for \`_code_string_\`.
   */
  symbol;
  /**
   * Real number value of Scale item.
   */
  value;
  /**
   * Test if this Scale value is strictly comparable to \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  is_strictly_comparable_to(other) {
    return Boolean2.from(other instanceof _DV_SCALE);
  }
  /**
   * True if this Scale value is less than \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    return Boolean2.from((this.value || 0) < (other.value || 0));
  }
};
var DV_DURATION = class _DV_DURATION extends DV_AMOUNT {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * ISO8601 duration string, including described deviations to support negative values and weeks.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for value.
   * Use this to access openehr_base.String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * Sum of this Duration and \`_other_\`.
   * Uses the Iso8601_duration.add() method from BASE package.
   * @param other - Parameter
   * @returns Result value
   */
  add(other) {
    const dur1 = new Iso8601_duration();
    dur1.value = this.value || "";
    const dur2 = new Iso8601_duration();
    dur2.value = other.value || "";
    const resultDur = dur1.add(dur2);
    const result2 = new _DV_DURATION();
    result2.value = resultDur.value;
    return result2;
  }
  /**
   * Difference of this Duration and \`_other_\`.
   * Uses the Iso8601_duration.subtract() method from BASE package.
   * @param other - Parameter
   * @returns Result value
   */
  subtract(other) {
    const dur1 = new Iso8601_duration();
    dur1.value = this.value || "";
    const dur2 = new Iso8601_duration();
    dur2.value = other.value || "";
    const resultDur = dur1.subtract(dur2);
    const result2 = new _DV_DURATION();
    result2.value = resultDur.value;
    return result2;
  }
  /**
   * Product of this Duration and \`_factor_\`.
   * Uses the Iso8601_duration.multiply() method from BASE package.
   * @param factor - Parameter
   * @returns Result value
   */
  multiply(factor) {
    const dur = new Iso8601_duration();
    dur.value = this.value || "";
    const resultDur = dur.multiply(factor);
    const result2 = new _DV_DURATION();
    result2.value = resultDur.value;
    return result2;
  }
  /**
   * True if this duration object is less than \`_other_\`, based on comparison of \`_magnitude()_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    return Boolean2.from(this.magnitude() < other.magnitude());
  }
  /**
   * True, for any two Durations.
   * Per openEHR specification, any two DV_DURATION instances are strictly comparable
   * because they can both be converted to a common unit (seconds) for comparison.
   * @param other - Parameter
   * @returns Result value
   */
  is_strictly_comparable_to(other) {
    return Boolean2.from(other instanceof _DV_DURATION);
  }
  /**
   * Negated version of current duration.
   *
   * Assuming the current duration is positive, the negated version represents a time prior to some origin point, or a negative age (e.g. so-called 'adjusted age' of premature infant).
   * @returns Result value
   */
  negative() {
    const val = this.value || "";
    const result2 = new _DV_DURATION();
    if (val.startsWith("-P")) {
      result2.value = val.substring(1);
    } else if (val.startsWith("P")) {
      result2.value = "-" + val;
    } else if (val.startsWith("-")) {
      result2.value = val.substring(1);
    } else {
      result2.value = "-P" + val;
    }
    return result2;
  }
  /**
   * Numeric value of the duration as a number of seconds. Computed using the method \`_to_seconds()_\` inherited from \`Iso8601_duration\`.
   * @returns Result value
   */
  magnitude() {
    const dur = new Iso8601_duration();
    dur.value = this.value || "";
    return dur.to_seconds();
  }
  /**
   * Value equality comparison.
   * @param other - The other object to compare with
   * @returns Boolean wrapper indicating equality
   */
  is_equal(other) {
    if (!(other instanceof _DV_DURATION)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.value === other.value);
  }
};
var DV_TEMPORAL = class extends DV_ABSOLUTE_QUANTITY {
  /**
   * Time accuracy, expressed as a duration.
   */
  accuracy = void 0;
};
var DV_DATE = class _DV_DATE extends DV_TEMPORAL {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * ISO8601 date string.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for value.
   * Use this to access openehr_base.String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * Numeric value of the date as days since the calendar origin date \`0001-01-01\`.
   * @returns Result value
   */
  magnitude() {
    const val = this.value || "";
    if (!val) {
      return Integer.from(0);
    }
    try {
      const date = new Iso8601_date();
      date.value = val;
      const year = date.year().value;
      const month = date.month().value || 1;
      const day = date.day().value || 1;
      const a2 = Math.floor((14 - month) / 12);
      const y2 = year + 4800 - a2;
      const m2 = month + 12 * a2 - 3;
      const jdn = day + Math.floor((153 * m2 + 2) / 5) + 365 * y2 + Math.floor(y2 / 4) - Math.floor(y2 / 100) + Math.floor(y2 / 400) - 32045;
      const daysSinceOrigin = jdn - 1721426;
      return Integer.from(daysSinceOrigin);
    } catch {
      return Integer.from(0);
    }
  }
  /**
   * Return True if this \`DV_QUANTIFIED\` is considered equal to \`_other_\`.
   * @param other - Parameter
   * @returns Result value
   */
  is_equal(other) {
    if (!(other instanceof _DV_DATE)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.value === other.value);
  }
  /**
   * Addition of a Duration to this Date.
   * Uses the Iso8601_date.add() method from BASE package.
   * @param a_diff - Parameter
   * @returns Result value
   */
  add(a_diff) {
    const date = new Iso8601_date();
    date.value = this.value || "";
    const dur = new Iso8601_duration();
    dur.value = a_diff.value || "";
    const resultDate = date.add(dur);
    const result2 = new _DV_DATE();
    result2.value = resultDate.value;
    return result2;
  }
  /**
   * Subtract a Duration from this Date.
   * Uses the Iso8601_date.subtract() method from BASE package.
   * @param a_diff - Parameter
   * @returns Result value
   */
  subtract(a_diff) {
    const date = new Iso8601_date();
    date.value = this.value || "";
    const dur = new Iso8601_duration();
    dur.value = a_diff.value || "";
    const resultDate = date.subtract(dur);
    const result2 = new _DV_DATE();
    result2.value = resultDate.value;
    return result2;
  }
  /**
   * Difference between this Date and \`_other_\`.
   * Uses the Iso8601_date.diff() method from BASE package.
   * @param other - Parameter
   * @returns Result value
   */
  diff(other) {
    const date1 = new Iso8601_date();
    date1.value = this.value || "";
    const date2 = new Iso8601_date();
    date2.value = other.value || "";
    const resultDur = date1.diff(date2);
    const result2 = new DV_DURATION();
    result2.value = resultDur.value;
    return result2;
  }
  /**
   * True if this date object is less than \`_other_\`, based on comparison of \`_magnitude()_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (!this.value || !other.value) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.value < other.value);
  }
  /**
   * True, for any two Dates.
   * @param other - Parameter
   * @returns Result value
   */
  is_strictly_comparable_to(other) {
    return Boolean2.from(other instanceof _DV_DATE);
  }
  /**
   * Value equality comparison.
   * @param other - The other object to compare with
   * @returns Boolean wrapper indicating equality
   */
  is_equal(other) {
    if (!(other instanceof _DV_DATE)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.value === other.value);
  }
};
var DV_TIME = class _DV_TIME extends DV_TEMPORAL {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * ISO8601 time string
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for value.
   * Use this to access openehr_base.String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * Numeric value of the time as seconds since the start of day, i.e. \`00:00:00\`.
   * @returns Result value
   */
  magnitude() {
    const val = this.value || "";
    if (!val) {
      return 0;
    }
    try {
      const time = new Iso8601_time();
      time.value = val;
      const hours = time.hour().value;
      const minutes = time.minute().value;
      const seconds = time.second().value;
      const fractional = time.fractional_second().value;
      return hours * 3600 + minutes * 60 + seconds + fractional;
    } catch {
      return 0;
    }
  }
  /**
   * Addition of a Duration to this Time.
   * Uses the Iso8601_time.add() method from BASE package.
   * @param a_diff - Parameter
   * @returns Result value
   */
  add(a_diff) {
    const time = new Iso8601_time();
    time.value = this.value || "";
    const dur = new Iso8601_duration();
    dur.value = a_diff.value || "";
    const resultTime = time.add(dur);
    const result2 = new _DV_TIME();
    result2.value = resultTime.value;
    return result2;
  }
  /**
   * Subtract a Duration from this Time.
   * Uses the Iso8601_time.subtract() method from BASE package.
   * @param a_diff - Parameter
   * @returns Result value
   */
  subtract(a_diff) {
    const time = new Iso8601_time();
    time.value = this.value || "";
    const dur = new Iso8601_duration();
    dur.value = a_diff.value || "";
    const resultTime = time.subtract(dur);
    const result2 = new _DV_TIME();
    result2.value = resultTime.value;
    return result2;
  }
  /**
   * Difference between this Time and \`_other_\`.
   * Uses the Iso8601_time.diff() method from BASE package.
   * @param other - Parameter
   * @returns Result value
   */
  diff(other) {
    const time1 = new Iso8601_time();
    time1.value = this.value || "";
    const time2 = new Iso8601_time();
    time2.value = other.value || "";
    const resultDur = time1.diff(time2);
    const result2 = new DV_DURATION();
    result2.value = resultDur.value;
    return result2;
  }
  /**
   * True if this time object is less than \`_other_\`, based on comparison of \`_magnitude()_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (!this.value || !other.value) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.value < other.value);
  }
  /**
   * True, for any two Times.
   * @param other - Parameter
   * @returns Result value
   */
  is_strictly_comparable_to(other) {
    return Boolean2.from(other instanceof _DV_TIME);
  }
  /**
   * Value equality comparison.
   * @param other - The other object to compare with
   * @returns Boolean wrapper indicating equality
   */
  is_equal(other) {
    if (!(other instanceof _DV_TIME)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.value === other.value);
  }
};
var DV_DATE_TIME = class _DV_DATE_TIME extends DV_TEMPORAL {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * ISO8601 date/time string.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for value.
   * Use this to access openehr_base.String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * Numeric value of the date/time as seconds since the calendar origin date/time \`0001-01-01T00:00:00Z\`.
   *
   * @returns Result value
   */
  magnitude() {
    const val = this.value || "";
    if (!val) {
      return 0;
    }
    try {
      const dt2 = new Iso8601_date_time();
      dt2.value = val;
      const year = dt2.year().value;
      const month = dt2.month().value || 1;
      const day = dt2.day().value || 1;
      const hour = dt2.hour().value;
      const minute = dt2.minute().value;
      const second = dt2.second().value;
      const fractional = dt2.fractional_second().value;
      const a2 = Math.floor((14 - month) / 12);
      const y2 = year + 4800 - a2;
      const m2 = month + 12 * a2 - 3;
      const jdn = day + Math.floor((153 * m2 + 2) / 5) + 365 * y2 + Math.floor(y2 / 4) - Math.floor(y2 / 100) + Math.floor(y2 / 400) - 32045;
      const daysSinceOrigin = jdn - 1721426;
      const secondsInDay = hour * 3600 + minute * 60 + second + fractional;
      return daysSinceOrigin * 86400 + secondsInDay;
    } catch {
      return 0;
    }
  }
  /**
   * Addition of a Duration to this Date/time.
   * Uses the Iso8601_date_time.add() method from BASE package.
   * @param a_diff - Parameter
   * @returns Result value
   */
  add(a_diff) {
    const dt2 = new Iso8601_date_time();
    dt2.value = this.value || "";
    const dur = new Iso8601_duration();
    dur.value = a_diff.value || "";
    const resultDt = dt2.add(dur);
    const result2 = new _DV_DATE_TIME();
    result2.value = resultDt.value;
    return result2;
  }
  /**
   * Subtract a Duration from this Date/time.
   * Uses the Iso8601_date_time.subtract() method from BASE package.
   * @param a_diff - Parameter
   * @returns Result value
   */
  subtract(a_diff) {
    const dt2 = new Iso8601_date_time();
    dt2.value = this.value || "";
    const dur = new Iso8601_duration();
    dur.value = a_diff.value || "";
    const resultDt = dt2.subtract(dur);
    const result2 = new _DV_DATE_TIME();
    result2.value = resultDt.value;
    return result2;
  }
  /**
   * Difference between this Date/time and \`_other_\`.
   * Uses the Iso8601_date_time.diff() method from BASE package.
   * @param other - Parameter
   * @returns Result value
   */
  diff(other) {
    const dt1 = new Iso8601_date_time();
    dt1.value = this.value || "";
    const dt2 = new Iso8601_date_time();
    dt2.value = other.value || "";
    const resultDur = dt1.diff(dt2);
    const result2 = new DV_DURATION();
    result2.value = resultDur.value;
    return result2;
  }
  /**
   * True if this date-time object is less than \`_other_\`, based on comparison of \`_magnitude()_\`.
   * @param other - Parameter
   * @returns Result value
   */
  less_than(other) {
    if (!this.value || !other.value) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.value < other.value);
  }
  /**
   * True, for any two Date/times.
   * @param other - Parameter
   * @returns Result value
   */
  is_strictly_comparable_to(other) {
    return Boolean2.from(other instanceof _DV_DATE_TIME);
  }
  /**
   * Value equality comparison.
   * @param other - The other object to compare with
   * @returns Boolean wrapper indicating equality
   */
  is_equal(other) {
    if (!(other instanceof _DV_DATE_TIME)) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.value === other.value);
  }
};
var DV_TIME_SPECIFICATION = class extends DATA_VALUE {
  /**
   * The specification, in the HL7v3 syntax for \`PIVL\` or \`EIVL\` types.
   */
  value;
};
var DV_PERIODIC_TIME_SPECIFICATION = class _DV_PERIODIC_TIME_SPECIFICATION extends DV_TIME_SPECIFICATION {
  /**
   * HL7::TimingEvent codes for event-linked specifications (EIVL).
   * Ordered by length (longest first) for proper matching.
   */
  static EVENT_CODES = [
    "ACD",
    "ACM",
    "ACV",
    "AC",
    // Before meals
    "PCD",
    "PCM",
    "PCV",
    "PC",
    // After meals
    "WAKE",
    "HS",
    // Wake/sleep
    "CM",
    "CD",
    "CV",
    "C"
    // Meal times
  ];
  /**
   * Pre-compiled regex patterns for efficient parsing.
   * These are compiled once as static properties to avoid repeated compilation.
   */
  static PERIOD_REGEX = /\/\(([^)]+)\)/;
  static ALIGNMENT_REGEX = /@([A-Z]{2})/;
  static DURATION_REGEX = /^(\d+)([a-zA-Z]+)$/;
  /**
   * The period of the repetition, computationally derived from the syntax representation. Extracted from the  value' attribute.
   * @returns Result value
   */
  period() {
    const valueStr = this.value?.value ?? "";
    const periodMatch = valueStr.match(_DV_PERIODIC_TIME_SPECIFICATION.PERIOD_REGEX);
    if (periodMatch) {
      const periodStr = periodMatch[1];
      const isoDuration = this.convertToIsoDuration(periodStr);
      const result2 = new DV_DURATION();
      result2.value = isoDuration;
      return result2;
    }
    throw new Error("Cannot extract period from value: no period found in PIVL format");
  }
  /**
   * Convert shorthand duration notation to ISO 8601 format.
   * @param duration - Duration string (e.g., "7d", "1mo", "2h")
   * @returns ISO 8601 duration string (e.g., "P7D", "P1M", "PT2H")
   */
  convertToIsoDuration(duration) {
    if (duration.startsWith("P")) {
      return duration;
    }
    const match = duration.match(_DV_PERIODIC_TIME_SPECIFICATION.DURATION_REGEX);
    if (!match) {
      return `P${duration.toUpperCase()}`;
    }
    const num = match[1];
    const unit = match[2].toLowerCase();
    const unitMap = {
      "s": `PT${num}S`,
      // seconds
      "min": `PT${num}M`,
      // minutes
      "h": `PT${num}H`,
      // hours
      "d": `P${num}D`,
      // days
      "w": `P${num}W`,
      // weeks
      "wk": `P${num}W`,
      // weeks
      "mo": `P${num}M`,
      // months
      "m": `P${num}M`,
      // months (when not time)
      "y": `P${num}Y`,
      // years
      "a": `P${num}Y`
      // years (annum)
    };
    return unitMap[unit] || `P${duration.toUpperCase()}`;
  }
  /**
   * Valid calendar alignment codes from HL7::CalendarCycle domain.
   */
  static VALID_ALIGNMENTS = ["DW", "DM", "DY", "WY", "MY", "HD"];
  /**
   * Calendar alignment extracted from value.
   * Returns alignment code from HL7::CalendarCycle domain (DW, DM, DY, WY, MY, HD).
   * @returns Result value
   */
  calendar_alignment() {
    const valueStr = this.value?.value ?? "";
    const alignMatch = valueStr.match(_DV_PERIODIC_TIME_SPECIFICATION.ALIGNMENT_REGEX);
    if (alignMatch) {
      const alignment = alignMatch[1];
      if (_DV_PERIODIC_TIME_SPECIFICATION.VALID_ALIGNMENTS.includes(alignment)) {
        return String2.from(alignment);
      }
    }
    return String2.from("");
  }
  /**
   * Event alignment extracted from value.
   * Returns event code from HL7::TimingEvent domain for EIVL specifications.
   * @returns Result value
   */
  event_alignment() {
    const valueStr = this.value?.value ?? "";
    const formalism = this.value?.formalism ?? "";
    if (formalism !== "HL7:EIVL") {
      return String2.from("");
    }
    for (const code of _DV_PERIODIC_TIME_SPECIFICATION.EVENT_CODES) {
      if (valueStr.startsWith(code)) {
        return String2.from(code);
      }
    }
    return String2.from("");
  }
  /**
   * Indicates if the specification is aligned with institution schedules.
   * Returns true if "IST" suffix is present in the value.
   * @returns Result value
   */
  institution_specified() {
    const valueStr = this.value?.value ?? "";
    return Boolean2.from(valueStr.includes("IST"));
  }
};
var DV_GENERAL_TIME_SPECIFICATION = class _DV_GENERAL_TIME_SPECIFICATION extends DV_TIME_SPECIFICATION {
  /**
   * HL7::TimingEvent codes for event-linked specifications.
   * Ordered by length (longest first) for proper matching.
   */
  static EVENT_CODES = [
    "ACD",
    "ACM",
    "ACV",
    "AC",
    // Before meals
    "PCD",
    "PCM",
    "PCV",
    "PC",
    // After meals
    "WAKE",
    "HS",
    // Wake/sleep
    "CM",
    "CD",
    "CV",
    "C"
    // Meal times
  ];
  /**
   * Pre-compiled regex patterns for efficient parsing.
   */
  static ALIGNMENT_REGEX = /@([A-Z]{2})/;
  static VALID_ALIGNMENTS = ["DW", "DM", "DY", "WY", "MY", "HD"];
  /**
   * Pre-compiled regex patterns for event code matching in GTS expressions.
   * Each pattern matches the event code at start or after GTS operators.
   */
  static EVENT_REGEXES = _DV_GENERAL_TIME_SPECIFICATION.EVENT_CODES.map(
    (code) => new RegExp(`(^|[;\\\\(])${code}([^A-Z]|$)`)
  );
  /**
   * Calendar alignment extracted from value.
   * For GTS format, returns the alignment from the first PIVL component if present.
   * @returns Result value
   */
  calendar_alignment() {
    const valueStr = this.value?.value ?? "";
    const alignMatch = valueStr.match(_DV_GENERAL_TIME_SPECIFICATION.ALIGNMENT_REGEX);
    if (alignMatch) {
      const alignment = alignMatch[1];
      if (_DV_GENERAL_TIME_SPECIFICATION.VALID_ALIGNMENTS.includes(alignment)) {
        return String2.from(alignment);
      }
    }
    return String2.from("");
  }
  /**
   * Event alignment extracted from value.
   * For GTS format, returns the event from the first EIVL component if present.
   * @returns Result value
   */
  event_alignment() {
    const valueStr = this.value?.value ?? "";
    for (let i3 = 0; i3 < _DV_GENERAL_TIME_SPECIFICATION.EVENT_CODES.length; i3++) {
      if (_DV_GENERAL_TIME_SPECIFICATION.EVENT_REGEXES[i3].test(valueStr)) {
        return String2.from(_DV_GENERAL_TIME_SPECIFICATION.EVENT_CODES[i3]);
      }
    }
    return String2.from("");
  }
  /**
   * Returns true if any part of the specification is institution specified.
   * Checks for "IST" anywhere in the GTS expression.
   * @returns Result value
   */
  institution_specified() {
    const valueStr = this.value?.value ?? "";
    return Boolean2.from(valueStr.includes("IST"));
  }
};
var DV_URI = class extends DATA_VALUE {
  /**
   * Internal storage for value
   * @protected
   */
  _value;
  /**
   * Value of URI as a String. 'Plain-text' URIs are allowed, enabling better readability, but must be RFC-3986 encoded in use.
   */
  get value() {
    return this._value?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for value.
   * Use this to access openehr_base.String methods.
   */
  get $value() {
    return this._value;
  }
  /**
   * Sets value from either a primitive value or openehr_base.String wrapper.
   */
  set value(val) {
    if (val === void 0 || val === null) {
      this._value = void 0;
    } else if (typeof val === "string") {
      this._value = String2.from(val);
    } else {
      this._value = val;
    }
  }
  /**
   * A distributed information 'space' in which  information objects  exist. The scheme simultaneously specifies an information space and a mechanism for accessing objects in  that  space.  For  example  if  scheme  = "ftp", it identifies the information space in which  all  ftp-able objects  exist,  and also the application - ftp - which can be used to access them. Values may include: "ftp", "telnet", "mailto", etc. Refer to RFC-3986 for a full list.
   *
   * @returns Result value
   */
  scheme() {
    if (!this.value) {
      throw new Error("DV_URI value is required to extract scheme");
    }
    const colonIndex = this.value.indexOf(":");
    if (colonIndex === -1) {
      throw new Error("DV_URI value does not contain a valid scheme (no ':' separator found)");
    }
    return String2.from(this.value.substring(0, colonIndex));
  }
  /**
   * A string whose format is  a  function  of  the  scheme. Identifies   the   location  in  <scheme>-space  of  an information entity. Typical values include hierarchical directory  paths  for  any  machine.  For example, with scheme = "ftp", path might be \`"/pub/images/image_01"\`. The strings "." and ".." are reserved for use in the path. Paths may include internet/intranet location identifiers of the form: \`sub_domain...domain\`, e.g. \`"info.cern.ch"\`.
   * @returns Result value
   */
  path() {
    if (!this.value)
      return String2.from("");
    try {
      const url = new URL(this.value);
      return String2.from(url.pathname);
    } catch {
      const colonIdx = this.value.indexOf(":");
      if (colonIdx === -1)
        return String2.from("");
      let rest = this.value.substring(colonIdx + 1);
      if (rest.startsWith("//"))
        rest = rest.substring(2);
      const pathStart = rest.indexOf("/");
      if (pathStart === -1)
        return String2.from("");
      let path = rest.substring(pathStart);
      const queryIdx = path.indexOf("?");
      if (queryIdx !== -1)
        path = path.substring(0, queryIdx);
      const fragIdx = path.indexOf("#");
      if (fragIdx !== -1)
        path = path.substring(0, fragIdx);
      return String2.from(path);
    }
  }
  /**
   * A part of, a  fragment  or  a  sub-function  within  an object. Allows references to sub-parts of objects, such as a certain line and character  position  in  a  text object. The  syntax  and semantics are defined by the application responsible for the object.
   *
   * @returns Result value
   */
  fragment_id() {
    if (!this.value)
      return String2.from("");
    const fragIdx = this.value.indexOf("#");
    if (fragIdx === -1)
      return String2.from("");
    return String2.from(this.value.substring(fragIdx + 1));
  }
  /**
   * Query string to send to application implied  by  scheme and  path.  Enables  queries  to applications, including databases  to  be  included in  the  URI. Supports any query meaningful to the server, including SQL.
   *
   * @returns Result value
   */
  query() {
    if (!this.value)
      return String2.from("");
    const queryIdx = this.value.indexOf("?");
    if (queryIdx === -1)
      return String2.from("");
    let query = this.value.substring(queryIdx + 1);
    const fragIdx = query.indexOf("#");
    if (fragIdx !== -1)
      query = query.substring(0, fragIdx);
    return String2.from(query);
  }
};
var DV_EHR_URI = class extends DV_URI {
};
var OPENEHR_TERMINOLOGY_GROUP_IDENTIFIERS = class {
  /**
   * Validity function to test if an identifier is in the set defined by this class.
   * @param an_id - Parameter
   * @returns Result value
   */
  valid_terminology_group_id(an_id) {
    const service = OpenEHRTerminologyService.getInstance();
    const idStr = typeof an_id === "string" ? an_id : String(an_id);
    return Boolean2.from(service.hasGroup(idStr));
  }
};
var OPENEHR_CODE_SET_IDENTIFIERS = class {
  /**
   * Validity function to test if an identifier is in the set defined by this class.
   * @param an_id - Parameter
   * @returns Result value
   */
  valid_code_set_id(an_id) {
    const service = OpenEHRTerminologyService.getInstance();
    const idStr = typeof an_id === "string" ? an_id : an_id.value;
    return Boolean2.from(service.hasCodeSet(idStr));
  }
};
var TERMINOLOGY_SERVICE = class extends OPENEHR_TERMINOLOGY_GROUP_IDENTIFIERS {
  /**
   * Return an interface to the terminology named name. Allowable names include:-
   *
   * * openehr,
   * * centc251,
   * * any name from are taken from the US NLM UMLS meta-data list at http://www.nlm.nih.gov/research/umls/metaa1.html
   * @param name - Parameter
   * @returns Result value
   */
  terminology(name) {
    const nameStr = typeof name === "string" ? name : name.value;
    if (nameStr.toLowerCase() !== "openehr") {
      throw new Error(`Terminology "${nameStr}" is not supported. Only "openehr" is currently available.`);
    }
    return new TERMINOLOGY_ACCESS(nameStr);
  }
  /**
   * Return an interface to the code_set identified by the external identifier name (e.g.  ISO_639-1).
   * @param name - Parameter
   * @returns Result value
   */
  code_set(name) {
    const nameStr = typeof name === "string" ? name : name.value;
    const service = OpenEHRTerminologyService.getInstance();
    if (!service.hasCodeSet(nameStr)) {
      throw new Error(`Code set "${nameStr}" not found`);
    }
    return new CODE_SET_ACCESS(nameStr);
  }
  /**
   * Return an interface to the code_set identified internally in openEHR by id.
   *
   * @param id - Parameter
   * @returns Result value
   */
  code_set_for_id(id) {
    const idStr = typeof id === "string" ? id : id.value;
    const service = OpenEHRTerminologyService.getInstance();
    if (!service.hasCodeSet(idStr)) {
      throw new Error(`Code set with id "${idStr}" not found`);
    }
    return new CODE_SET_ACCESS(idStr);
  }
  /**
   * True if terminology named name known by this service. Allowable names include:-
   *
   * *  openehr
   * * centc251
   * * any name from are taken from the US NLM UMLS meta-data list at       http://www.nlm.nih.gov/research/umls/metaa1.html
   * @param name - Parameter
   * @returns Result value
   */
  has_terminology(name) {
    const service = OpenEHRTerminologyService.getInstance();
    const nameStr = typeof name === "string" ? name : name.value;
    return Boolean2.from(service.hasTerminology(nameStr));
  }
  /**
   * True if code_set linked to internal name (e.g. languages ) is available.
   * @param name - Parameter
   * @returns Result value
   */
  has_code_set(name) {
    const service = OpenEHRTerminologyService.getInstance();
    const nameStr = typeof name === "string" ? name : name.value;
    return Boolean2.from(service.hasCodeSet(nameStr));
  }
  /**
   * Set of all terminology identifiers known in the terminology service. Values from the US NLM UMLS meta-data list at:- http://www.nlm.nih.gov/research/umls/metaa1.html
   * @returns Result value
   */
  terminology_identifiers() {
    return String2.from("openehr");
  }
  /**
   * Set of all code set identifiers known in the terminology service.
   *
   * @returns Result value
   */
  openehr_code_sets() {
    const service = OpenEHRTerminologyService.getInstance();
    const identifiers = service.getCodeSetIdentifiers();
    return identifiers;
  }
  /**
   * Set of all code sets identifiers for which there is an internal openEHR name; returned as a Map of ids keyed by internal name.
   * @returns Result value
   */
  code_set_identifiers() {
    const service = OpenEHRTerminologyService.getInstance();
    const identifiers = service.getCodeSetIdentifiers();
    return String2.from(identifiers.join(", "));
  }
};
var MEASUREMENT_SERVICE = class _MEASUREMENT_SERVICE {
  /**
   * Common valid UCUM unit strings for clinical measurements.
   * This is a subset of the full UCUM specification covering common clinical use cases.
   *
   * NOTE: Both ASCII ('u') and Unicode ('') micro prefix variants are included
   * for compatibility. UCUM officially uses ASCII 'u' for micro, but many systems
   * use the Unicode '' character. Both are accepted as valid.
   */
  static VALID_UNITS = /* @__PURE__ */ new Set([
    // Mass (includes both ASCII 'ug' and Unicode 'g' for micro prefix)
    "kg",
    "g",
    "mg",
    "ug",
    "\u03BCg",
    "ng",
    "pg",
    "[lb_av]",
    "[oz_av]",
    // Length (includes both ASCII 'um' and Unicode 'm' for micro prefix)
    "m",
    "cm",
    "mm",
    "um",
    "\u03BCm",
    "nm",
    "km",
    "[in_i]",
    "[ft_i]",
    "[mi_i]",
    // Volume (includes both ASCII 'uL' and Unicode 'L' for micro prefix)
    "L",
    "l",
    "dL",
    "dl",
    "mL",
    "ml",
    "uL",
    "\u03BCL",
    "[gal_us]",
    "[pt_us]",
    "[cup_us]",
    "[tsp_us]",
    "[tbs_us]",
    // Time
    "s",
    "min",
    "h",
    "d",
    "wk",
    "mo",
    "a",
    // Temperature
    "Cel",
    "K",
    "[degF]",
    // Pressure
    "Pa",
    "kPa",
    "bar",
    "mm[Hg]",
    "[psi]",
    // Concentration (mass) - includes both ASCII and Unicode micro variants
    "mg/dL",
    "g/dL",
    "g/L",
    "mg/L",
    "ug/L",
    "\u03BCg/L",
    "ng/L",
    "mg/mL",
    "ug/mL",
    "\u03BCg/mL",
    // Concentration (substance) - includes both ASCII and Unicode micro variants
    "mol/L",
    "mmol/L",
    "umol/L",
    "\u03BCmol/L",
    "nmol/L",
    "mol/mL",
    "mmol/mL",
    "mEq/L",
    "uEq/L",
    // Rate/Flow
    "mL/min",
    "L/min",
    "L/h",
    "mL/h",
    "mL/min/1.73m2",
    // GFR
    "/min",
    "/s",
    "/h",
    // Velocity
    "m/s",
    "km/h",
    "[mi_i]/h",
    // Area
    "m2",
    "cm2",
    "mm2",
    // BMI
    "kg/m2",
    "kg/m^2",
    // Heart rate, respiratory rate
    "{beats}/min",
    "{breaths}/min",
    // Percentages and ratios
    "%",
    "1",
    "",
    // pH
    "[pH]",
    // Other clinical
    "[IU]",
    "[IU]/L",
    "[IU]/mL",
    "U",
    "U/L",
    "U/mL",
    "10*3/uL",
    "10*6/uL",
    "10*9/L",
    "10*12/L",
    "g/dL{RBC}",
    "pg{Hb}",
    "fL",
    "pg"
  ]);
  /**
   * UCUM-like patterns for validation when not in known units set.
   *
   * NOTE: The metric prefix character class includes both ASCII 'u' and Unicode ''
   * for micro prefix compatibility. UCUM officially uses ASCII 'u', but many systems
   * use Unicode ''. Both are matched for maximum compatibility.
   */
  static UCUM_PATTERNS = [
    // Basic unit with optional metric prefix (includes both 'u' and '' for micro)
    /^[yzafpnumcdhkMGTPEZY]?[a-zA-Z]+(\d+)?$/,
    // Compound unit with division
    /^[a-zA-Z]+(\d*)\/[a-zA-Z]+(\d*)$/,
    // Units with brackets (special units like mm[Hg])
    /^[a-zA-Z]*\[[^\]]+\]$/,
    // Units with annotations like kg{body}
    /^[a-zA-Z]+\{[^}]+\}$/,
    // Scientific notation units like 10*9/L
    /^10\*\d+\/[a-zA-Z]+$/,
    // Simple ratios with metric prefixes (includes both 'u' and '' for micro)
    /^[yzafpnumcdhkMGTPEZY]?[a-zA-Z]+\/[yzafpnumcdhkMGTPEZY]?[a-zA-Z]+$/
  ];
  /**
   * Dimension groups for unit equivalence checking.
   * Units in the same group measure the same physical property.
   */
  static DIMENSION_GROUPS = {
    "length": ["m", "cm", "mm", "um", "\u03BCm", "nm", "km", "[in_i]", "[ft_i]", "[mi_i]"],
    "mass": ["kg", "g", "mg", "ug", "\u03BCg", "ng", "pg", "[lb_av]", "[oz_av]"],
    "volume": ["L", "l", "dL", "dl", "mL", "ml", "uL", "\u03BCL", "[gal_us]", "[pt_us]", "[cup_us]"],
    "time": ["s", "min", "h", "d", "wk", "mo", "a"],
    "temperature": ["Cel", "K", "[degF]"],
    "pressure": ["Pa", "kPa", "bar", "mm[Hg]", "[psi]"],
    "concentration_mass": ["mg/dL", "g/dL", "g/L", "mg/L", "ug/L", "\u03BCg/L", "ng/L", "mg/mL", "ug/mL", "\u03BCg/mL"],
    "concentration_substance": ["mol/L", "mmol/L", "umol/L", "\u03BCmol/L", "nmol/L", "mol/mL", "mmol/mL", "mEq/L", "uEq/L"],
    "flow_rate": ["mL/min", "L/min", "L/h", "mL/h"],
    "velocity": ["m/s", "km/h", "[mi_i]/h"],
    "area": ["m2", "cm2", "mm2"],
    "bmi": ["kg/m2", "kg/m^2"],
    "frequency": ["/min", "/s", "/h", "{beats}/min", "{breaths}/min"]
  };
  /**
   * True if the units string 'units' is a valid string according to the HL7 UCUM specification.
   *
   * This method uses pattern-based validation for common UCUM units. For full UCUM
   * validation, use the UcumService from ucum_service.ts which integrates with
   * the @lhncbc/ucum-lhc library.
   *
   * @param units - The units string to validate
   * @returns Result value
   */
  is_valid_units_string(units) {
    const unitsStr = typeof units === "string" ? units : units?.value ?? "";
    if (unitsStr === "" || unitsStr === "1") {
      return Boolean2.from(true);
    }
    if (_MEASUREMENT_SERVICE.VALID_UNITS.has(unitsStr)) {
      return Boolean2.from(true);
    }
    for (const pattern of _MEASUREMENT_SERVICE.UCUM_PATTERNS) {
      if (pattern.test(unitsStr)) {
        return Boolean2.from(true);
      }
    }
    return Boolean2.from(false);
  }
  /**
   * True if two units strings correspond to the same measured property.
   * For example, "m" and "cm" are equivalent (both measure length),
   * but "kg" and "m" are not equivalent (different dimensions).
   *
   * This method uses dimension-based comparison. For more accurate equivalence
   * checking including complex units, use the UcumService from ucum_service.ts
   * which uses actual unit conversion to verify compatibility.
   *
   * @param units1 - First units string
   * @param units2 - Second units string
   * @returns Result value
   */
  units_equivalent(units1, units2) {
    const u1 = typeof units1 === "string" ? units1 : units1?.value ?? "";
    const u2 = typeof units2 === "string" ? units2 : units2?.value ?? "";
    if (u1 === u2) {
      return Boolean2.from(true);
    }
    const getDimension = (unit) => {
      for (const [dim, units] of Object.entries(_MEASUREMENT_SERVICE.DIMENSION_GROUPS)) {
        if (units.includes(unit))
          return dim;
      }
      return null;
    };
    const dim1 = getDimension(u1);
    const dim2 = getDimension(u2);
    if (dim1 && dim2 && dim1 === dim2) {
      return Boolean2.from(true);
    }
    return Boolean2.from(false);
  }
};
var EXTERNAL_ENVIRONMENT_ACCESS = class extends TERMINOLOGY_SERVICE {
};
var CODE_SET_ACCESS = class {
  codeSetId;
  language;
  constructor(codeSetId, language = "en") {
    this.codeSetId = codeSetId;
    this.language = language;
  }
  /**
   * External identifier of this code set.
   * @returns Result value
   */
  id() {
    return String2.from(this.codeSetId);
  }
  /**
   * Return all codes known in this code set.
   * @returns Result value
   */
  all_codes() {
    const service = OpenEHRTerminologyService.getInstance();
    const codes = service.getAllCodes(this.codeSetId, this.language);
    const result2 = new CODE_PHRASE2();
    if (codes.length > 0) {
      result2.code_string = codes[0];
    }
    return result2;
  }
  /**
   * True if code set knows about 'a_lang' .
   * @param a_lang - Parameter
   * @returns Result value
   */
  has_lang(a_lang) {
    const lang = typeof a_lang === "string" ? a_lang : a_lang.value;
    const supportedLangs = ["en", "es", "pt"];
    return Boolean2.from(supportedLangs.includes(lang));
  }
  /**
   * True if code set knows about  'a_code'.
   * @param a_code - Parameter
   * @returns Result value
   */
  has_code(a_code) {
    const service = OpenEHRTerminologyService.getInstance();
    const codes = service.getAllCodes(this.codeSetId, this.language);
    const codeStr = typeof a_code === "string" ? a_code : a_code.value;
    return Boolean2.from(codes.includes(codeStr));
  }
};
var TERMINOLOGY_ACCESS = class {
  terminologyId;
  language;
  constructor(terminologyId, language = "en") {
    this.terminologyId = terminologyId;
    this.language = language;
  }
  /**
   * Identification of this Terminology.
   * @returns Result value
   */
  id() {
    return String2.from(this.terminologyId);
  }
  /**
   * Return all codes known in this terminology.
   * @returns Result value
   */
  all_codes() {
    const service = OpenEHRTerminologyService.getInstance();
    const groups = service.getGroupIdentifiers();
    const result2 = new CODE_PHRASE2();
    if (groups.length > 0) {
      result2.code_string = groups[0];
    }
    return result2;
  }
  /**
   * Return all codes under grouper 'a_group_id' from this terminology.
   * 
   * NOTE: Per openEHR specification, this method should return a Set<CODE_PHRASE>.
   * Due to TypeScript API design limitations, only the first code is returned.
   * This is a known limitation that should be addressed in a future API revision.
   * For complete code retrieval, use the OpenEHRTerminologyService directly.
   * 
   * @param a_group_id - The group identifier (e.g., "audit_change_type", "attestation_reason")
   * @returns CODE_PHRASE containing the first code in the group
   */
  codes_for_group_id(a_group_id) {
    const groupId = typeof a_group_id === "string" ? a_group_id : a_group_id?.value ?? "";
    const service = OpenEHRTerminologyService.getInstance();
    const codes = service.getCodesForGroup(groupId, this.language);
    const result2 = new CODE_PHRASE2();
    result2.terminology_id = new TERMINOLOGY_ID();
    result2.terminology_id.value = this.terminologyId;
    if (codes.length > 0) {
      result2.code_string = codes[0];
    }
    return result2;
  }
  /**
   * Return all codes under grouper whose name in 'a_lang' is 'a_name' from this terminology.
   * 
   * NOTE: This method returns CODE_PHRASE per the openEHR specification, but conceptually
   * should return a collection of codes. Due to API limitations, only the first code is
   * returned. If the group is not found, an empty CODE_PHRASE is returned (no code_string).
   * Callers should check if code_string is set to determine if the group was found and has codes.
   * 
   * @param a_lang - Language code (e.g., "en", "es")
   * @param a_name - Group name in the specified language
   * @returns CODE_PHRASE with first code, or empty CODE_PHRASE if group not found
   */
  codes_for_group_name(a_lang, a_name) {
    const lang = typeof a_lang === "string" ? a_lang : a_lang?.value ?? "en";
    const name = typeof a_name === "string" ? a_name : a_name?.value ?? "";
    const service = OpenEHRTerminologyService.getInstance();
    const groupId = service.getGroupIdByName(name, lang);
    if (!groupId) {
      const result2 = new CODE_PHRASE2();
      result2.terminology_id = new TERMINOLOGY_ID();
      result2.terminology_id.value = this.terminologyId;
      return result2;
    }
    return this.codes_for_group_id(String2.from(groupId));
  }
  /**
   * True if 'a_code' is known in group 'group_id' in the openEHR terminology.
   * @param group_id - The group identifier
   * @param a_code - The code to check
   * @returns Result value
   */
  has_code_for_group_id(group_id, a_code) {
    const gid = typeof group_id === "string" ? group_id : group_id?.value ?? "";
    const codeStr = typeof a_code === "string" ? a_code : a_code?.value ?? "";
    const service = OpenEHRTerminologyService.getInstance();
    const codes = service.getCodesForGroup(gid, this.language);
    return Boolean2.from(codes.includes(codeStr));
  }
  /**
   * Return the rubric (human-readable term) for code 'a_code' in the configured language.
   * Falls back to English if the translation is not available.
   * @param a_code - The code to look up
   * @returns Result value
   */
  rubric_for_code(a_code) {
    const code = typeof a_code === "string" ? a_code : a_code?.value ?? "";
    const service = OpenEHRTerminologyService.getInstance();
    let rubric = service.getRubricForCode(code, this.language);
    if (!rubric && this.language !== "en") {
      rubric = service.getRubricForCode(code, "en");
    }
    return String2.from(rubric ?? code);
  }
};
var EHR = class {
  /**
   * The identifier of the logical EHR management system in which this EHR was created.
   */
  system_id;
  /**
   * The unique identifier of this EHR.
   *
   * NOTE: is is strongly recommended that a UUID always be used for this field.
   */
  ehr_id;
  /**
   * List of contributions causing changes to this EHR. Each contribution contains a list of versions, which may include references to any number of \`VERSION\` instances, i.e. items of type \`VERSIONED_COMPOSITION\` and \`VERSIONED_FOLDER\`.
   */
  contributions;
  /**
   * Reference to \`EHR_STATUS\` object for this EHR.
   */
  ehr_status;
  /**
   * Reference to \`EHR_ACCESS\` object for this EHR.
   */
  ehr_access;
  /**
   * Master list of all Versioned Composition references in this EHR.
   */
  compositions;
  /**
   * Optional directory structure for this EHR. If present, this is a reference to the first member of \`_folders_\`.
   */
  directory;
  /**
   * Time of creation of the EHR.
   */
  time_created;
  /**
   * Optional additional Folder structures for this EHR. If set, the \`_directory_\` attribute refers to the first member.
   */
  folders;
  /**
   * Optional list of tags associated with this EHR. Tag \`_target_\` values can only be within the same EHR.
   */
  tags;
};
var VERSIONED_EHR_ACCESS = class extends VERSIONED_OBJECT {
};
var VERSIONED_EHR_STATUS = class extends VERSIONED_OBJECT {
};
var VERSIONED_COMPOSITION = class extends VERSIONED_OBJECT {
  /**
   * Indicates whether this composition set is persistent; derived from first version.
   * @returns Result value
   */
  is_persistent() {
    throw new Error("VERSIONED_COMPOSITION.is_persistent requires version retrieval - not yet fully implemented");
  }
};
var EHR_ACCESS = class extends LOCATABLE {
  /**
   * Access control settings for the EHR. Instance is a subtype of the type \`ACCESS_CONTROL_SETTINGS\`, allowing for the use of different access control schemes.
   */
  settings;
  /**
   * The name of the access control scheme in use; corresponds to the concrete instance of the settings attribute.
   * @returns Result value
   */
  scheme() {
    if (!this.settings) {
      throw new Error("EHR_ACCESS settings is required to determine scheme");
    }
    return String2.from(this.settings.constructor.name);
  }
};
var EHR_STATUS = class extends LOCATABLE {
  /**
   * The subject of this EHR. The \`_external_ref_\` attribute can be used to contain a direct reference to the subject in a demographic or identity service. Alternatively, the association between patients and their records may be done elsewhere for security reasons.
   */
  subject;
  /**
   * Internal storage for is_queryable
   * @protected
   */
  _is_queryable;
  /**
   * True if this EHR should be included in population queries, i.e. if this EHR is considered active in the population.
   */
  get is_queryable() {
    return this._is_queryable?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for is_queryable.
   * Use this to access openehr_base.Boolean methods.
   */
  get $is_queryable() {
    return this._is_queryable;
  }
  /**
   * Sets is_queryable from either a primitive value or openehr_base.Boolean wrapper.
   */
  set is_queryable(val) {
    if (val === void 0 || val === null) {
      this._is_queryable = void 0;
    } else if (typeof val === "boolean") {
      this._is_queryable = Boolean2.from(val);
    } else {
      this._is_queryable = val;
    }
  }
  /**
   * Internal storage for is_modifiable
   * @protected
   */
  _is_modifiable;
  /**
   * True if the EHR, other than the \`EHR_STATUS\` object, is allowed to be written to. The \`EHR_STATUS\` object itself can always be written to.
   */
  get is_modifiable() {
    return this._is_modifiable?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for is_modifiable.
   * Use this to access openehr_base.Boolean methods.
   */
  get $is_modifiable() {
    return this._is_modifiable;
  }
  /**
   * Sets is_modifiable from either a primitive value or openehr_base.Boolean wrapper.
   */
  set is_modifiable(val) {
    if (val === void 0 || val === null) {
      this._is_modifiable = void 0;
    } else if (typeof val === "boolean") {
      this._is_modifiable = Boolean2.from(val);
    } else {
      this._is_modifiable = val;
    }
  }
  /**
   * Any other details of the EHR summary object, in the form of an archetyped \`ITEM_STRUCTURE\`.
   */
  other_details;
};
var ACCESS_CONTROL_SETTINGS = class {
};
var EXTRACT = class extends LOCATABLE {
  /**
   * The content extracted and serialised from the source repository for this Extract.
   */
  chapters;
  /**
   * The specification that this Extract actually conforms to; might not be identical with the specification of the corresponding request.
   */
  specification;
  /**
   * Reference to causing Request, if any.
   */
  request_id;
  /**
   * Creation time of this Extract
   */
  time_created;
  /**
   * Identifier of creating system.
   */
  system_id;
  /**
   * Internal storage for sequence_nr
   * @protected
   */
  _sequence_nr;
  /**
   * Number of this Extract response in sequence of responses to Extract request identified by \`_request_id_\`. If this is the sole response, or there was no request, value is 1.
   */
  get sequence_nr() {
    return this._sequence_nr?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for sequence_nr.
   * Use this to access openehr_base.Integer methods.
   */
  get $sequence_nr() {
    return this._sequence_nr;
  }
  /**
   * Sets sequence_nr from either a primitive value or openehr_base.Integer wrapper.
   */
  set sequence_nr(val) {
    if (val === void 0 || val === null) {
      this._sequence_nr = void 0;
    } else if (typeof val === "number") {
      this._sequence_nr = Integer.from(val);
    } else {
      this._sequence_nr = val;
    }
  }
  /**
   * Participations relevant to the creation of this Extract.
   */
  participations;
};
var EXTRACT_ACTION_REQUEST = class extends LOCATABLE {
  /**
   * Identifier of previous \`EXTRACT_REQUEST\`.
   */
  request_id;
  uid = void 0;
  /**
   * Requested action: \`cancel | resend | send new\`. Coded by openEHR Terminology group \`'extract action type'\`.
   */
  action;
};
var EXTRACT_CHAPTER = class extends LOCATABLE {
  /**
   * The information content of this chapter.
   */
  items;
};
var EXTRACT_ITEM = class extends LOCATABLE {
};
var EXTRACT_CONTENT_ITEM = class extends EXTRACT_ITEM {
  /**
   * Internal storage for is_primary
   * @protected
   */
  _is_primary;
  /**
   * True if the content item carried in this container was part of the primary set for the Extract, i.e. not added due to link-following.
   */
  get is_primary() {
    return this._is_primary?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for is_primary.
   * Use this to access openehr_base.Boolean methods.
   */
  get $is_primary() {
    return this._is_primary;
  }
  /**
   * Sets is_primary from either a primitive value or openehr_base.Boolean wrapper.
   */
  set is_primary(val) {
    if (val === void 0 || val === null) {
      this._is_primary = void 0;
    } else if (typeof val === "boolean") {
      this._is_primary = Boolean2.from(val);
    } else {
      this._is_primary = val;
    }
  }
  /**
   * Internal storage for is_changed
   * @protected
   */
  _is_changed;
  /**
   * True if the content item carried in this container is any kind of change since last send, in repeat sending situations.
   */
  get is_changed() {
    return this._is_changed?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for is_changed.
   * Use this to access openehr_base.Boolean methods.
   */
  get $is_changed() {
    return this._is_changed;
  }
  /**
   * Sets is_changed from either a primitive value or openehr_base.Boolean wrapper.
   */
  set is_changed(val) {
    if (val === void 0 || val === null) {
      this._is_changed = void 0;
    } else if (typeof val === "boolean") {
      this._is_changed = Boolean2.from(val);
    } else {
      this._is_changed = val;
    }
  }
  /**
   * Internal storage for is_masked
   * @protected
   */
  _is_masked;
  /**
   * True if the content of this item has not been included due to insufficient access rights of requestor.
   */
  get is_masked() {
    return this._is_masked?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for is_masked.
   * Use this to access openehr_base.Boolean methods.
   */
  get $is_masked() {
    return this._is_masked;
  }
  /**
   * Sets is_masked from either a primitive value or openehr_base.Boolean wrapper.
   */
  set is_masked(val) {
    if (val === void 0 || val === null) {
      this._is_masked = void 0;
    } else if (typeof val === "boolean") {
      this._is_masked = Boolean2.from(val);
    } else {
      this._is_masked = val;
    }
  }
  /**
   * Content object.
   */
  item;
};
var EXTRACT_ENTITY_CHAPTER = class extends EXTRACT_CHAPTER {
  /**
   * Internal storage for extract_id_key
   * @protected
   */
  _extract_id_key;
  /**
   * Reference to entity, usually a demographic entity such as a patient that the content of this chapter relates to.
   */
  get extract_id_key() {
    return this._extract_id_key?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for extract_id_key.
   * Use this to access openehr_base.String methods.
   */
  get $extract_id_key() {
    return this._extract_id_key;
  }
  /**
   * Sets extract_id_key from either a primitive value or openehr_base.String wrapper.
   */
  set extract_id_key(val) {
    if (val === void 0 || val === null) {
      this._extract_id_key = void 0;
    } else if (typeof val === "string") {
      this._extract_id_key = String2.from(val);
    } else {
      this._extract_id_key = val;
    }
  }
};
var EXTRACT_ENTITY_MANIFEST = class {
  /**
   * Internal storage for extract_id_key
   * @protected
   */
  _extract_id_key;
  /**
   * Identifier by which this entity is known in the Extract. May be one of the other identifiers, e.g. ehr_id or subject_id, or it may be something else, including a simple integer.
   */
  get extract_id_key() {
    return this._extract_id_key?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for extract_id_key.
   * Use this to access openehr_base.String methods.
   */
  get $extract_id_key() {
    return this._extract_id_key;
  }
  /**
   * Sets extract_id_key from either a primitive value or openehr_base.String wrapper.
   */
  set extract_id_key(val) {
    if (val === void 0 || val === null) {
      this._extract_id_key = void 0;
    } else if (typeof val === "string") {
      this._extract_id_key = String2.from(val);
    } else {
      this._extract_id_key = val;
    }
  }
  /**
   * Internal storage for ehr_id
   * @protected
   */
  _ehr_id;
  /**
   * EHR / EMR identifier for the entity at the target system.
   */
  get ehr_id() {
    return this._ehr_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for ehr_id.
   * Use this to access openehr_base.String methods.
   */
  get $ehr_id() {
    return this._ehr_id;
  }
  /**
   * Sets ehr_id from either a primitive value or openehr_base.String wrapper.
   */
  set ehr_id(val) {
    if (val === void 0 || val === null) {
      this._ehr_id = void 0;
    } else if (typeof val === "string") {
      this._ehr_id = String2.from(val);
    } else {
      this._ehr_id = val;
    }
  }
  /**
   * Internal storage for subject_id
   * @protected
   */
  _subject_id;
  /**
   * Subject (i.e. patient or similar) identifier for the entity at the target system.
   */
  get subject_id() {
    return this._subject_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for subject_id.
   * Use this to access openehr_base.String methods.
   */
  get $subject_id() {
    return this._subject_id;
  }
  /**
   * Sets subject_id from either a primitive value or openehr_base.String wrapper.
   */
  set subject_id(val) {
    if (val === void 0 || val === null) {
      this._subject_id = void 0;
    } else if (typeof val === "string") {
      this._subject_id = String2.from(val);
    } else {
      this._subject_id = val;
    }
  }
  /**
   * Other identifiers that may be used to find the entity at the target system, keyed by type. May include medicare numbers, drivers license number, tax number etc.
   */
  other_ids;
  /**
   * List of Uids of items to be included in the Extract, in cases where individual items are being requested by id. More typically, this attribute is not used, and the \`EXTRACT_SPEC._criteria query_\` defines the Extract contents. If set, for openEHR data, these are Uids identifying the version containers.
   */
  item_list;
};
var EXTRACT_ERROR = class {
  request_id;
  reason;
};
var EXTRACT_FOLDER = class extends EXTRACT_ITEM {
  /**
   * List of Folders and content items in this Folder.
   */
  items;
};
var EXTRACT_MANIFEST = class {
  /**
   * List of entity manifests uids of items included in the Extract; for openEHR data, these are uids identifying the version containers.
   */
  entities;
};
var EXTRACT_PARTICIPATION = class {
  /**
   * The time interval during which the participation took place, if it is used in an observational context (i.e. recording facts about the past); or the intended time interval of the participation when used in future contexts, such as EHR Instructions.
   */
  time;
  /**
   * The function of the Party in this participation (note that a given party might participate in more than one way in a particular activity). This attribute should be coded, but cannot be limited to the HL7v3:ParticipationFunction vocabulary, since it is too limited and hospital-oriented.
   */
  function;
  /**
   * The mode of the performer / activity interaction, e.g. present, by telephone, by email etc.
   */
  mode;
  /**
   * Internal storage for performer
   * @protected
   */
  _performer;
  /**
   * Uid of demographic entity within Extract who performed this participation.
   */
  get performer() {
    return this._performer?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for performer.
   * Use this to access openehr_base.String methods.
   */
  get $performer() {
    return this._performer;
  }
  /**
   * Sets performer from either a primitive value or openehr_base.String wrapper.
   */
  set performer(val) {
    if (val === void 0 || val === null) {
      this._performer = void 0;
    } else if (typeof val === "string") {
      this._performer = String2.from(val);
    } else {
      this._performer = val;
    }
  }
};
var EXTRACT_REQUEST = class extends LOCATABLE {
  /**
   * Specification details of the request.
   */
  extract_spec;
  /**
   * Update details of the request.
   */
  update_spec;
  /**
   * Identifier of this Request, generated by requestor.
   */
  uid = void 0;
};
var EXTRACT_SPEC = class {
  /**
   * Specification of which versions of information items to include in the Extract. If Void, the default is latest versions only (which is reasonable for non-versioning systems as well).
   */
  version_spec;
  /**
   * Specification of entities (e.g. records) to include in the Extract.
   */
  manifest;
  /**
   * Coded term indicating the type of content required, e.g.
   *
   * * \`|openehr-ehr|\`
   * * \`|openehr-demographic|\`
   * * \`|generic-emr|\`
   * * \`|other|\`
   *
   * Coded by openEHR Terminology group \`'extract content type'\`.
   */
  extract_type;
  /**
   * Internal storage for include_multimedia
   * @protected
   */
  _include_multimedia;
  /**
   * Indicates whether in-line instances of \`DV_MULTIMEDIA\` in the source data are included or not.
   */
  get include_multimedia() {
    return this._include_multimedia?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for include_multimedia.
   * Use this to access openehr_base.Boolean methods.
   */
  get $include_multimedia() {
    return this._include_multimedia;
  }
  /**
   * Sets include_multimedia from either a primitive value or openehr_base.Boolean wrapper.
   */
  set include_multimedia(val) {
    if (val === void 0 || val === null) {
      this._include_multimedia = void 0;
    } else if (typeof val === "boolean") {
      this._include_multimedia = Boolean2.from(val);
    } else {
      this._include_multimedia = val;
    }
  }
  /**
   * Internal storage for priority
   * @protected
   */
  _priority;
  /**
   * Requested priority of this request to be handled by server. Priority schemes are likely to be local, and use values agreed by both ends.
   *
   * TBD: alternative is standard coded terms
   */
  get priority() {
    return this._priority?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for priority.
   * Use this to access openehr_base.Integer methods.
   */
  get $priority() {
    return this._priority;
  }
  /**
   * Sets priority from either a primitive value or openehr_base.Integer wrapper.
   */
  set priority(val) {
    if (val === void 0 || val === null) {
      this._priority = void 0;
    } else if (typeof val === "number") {
      this._priority = Integer.from(val);
    } else {
      this._priority = val;
    }
  }
  /**
   * Internal storage for link_depth
   * @protected
   */
  _link_depth;
  /**
   * Degree of links to follow emanating from content items specified for inclusion. The kind of links to follow is dependent on the type of Extract.
   *
   * All items at the target end of followed links at the given depth are also included in the extract; \`EXTRACT_CONTENT_ITEM._is_primary_\` is used to differentiate.
   *
   * * 0 = don't follow;
   * * 1 = follow first degree links;
   * * 2 = follow 2nd degree links;
   * * ....
   * * n = follow nth degree links
   */
  get link_depth() {
    return this._link_depth?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for link_depth.
   * Use this to access openehr_base.Integer methods.
   */
  get $link_depth() {
    return this._link_depth;
  }
  /**
   * Sets link_depth from either a primitive value or openehr_base.Integer wrapper.
   */
  set link_depth(val) {
    if (val === void 0 || val === null) {
      this._link_depth = void 0;
    } else if (typeof val === "number") {
      this._link_depth = Integer.from(val);
    } else {
      this._link_depth = val;
    }
  }
  /**
   * Queries specifying the contents of this Extract.
   */
  criteria;
  /**
   * Other specification items. Archetypable.
   */
  other_details;
};
var EXTRACT_UPDATE_SPEC = class {
  /**
   * Internal storage for persist_in_server
   * @protected
   */
  _persist_in_server;
  /**
   * If True, this Request is persisted in the server until further notice.
   */
  get persist_in_server() {
    return this._persist_in_server?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for persist_in_server.
   * Use this to access openehr_base.Boolean methods.
   */
  get $persist_in_server() {
    return this._persist_in_server;
  }
  /**
   * Sets persist_in_server from either a primitive value or openehr_base.Boolean wrapper.
   */
  set persist_in_server(val) {
    if (val === void 0 || val === null) {
      this._persist_in_server = void 0;
    } else if (typeof val === "boolean") {
      this._persist_in_server = Boolean2.from(val);
    } else {
      this._persist_in_server = val;
    }
  }
  /**
   * Period for resending update Extracts in response to original Request.
   */
  repeat_period;
  /**
   * Set of Event names that will cause sending of update Extracts. Event types include:
   *
   * * \`|any_change|\` - any change in content items matched by content specification, e.g. new versions of persistent compositions. If the content list allows matching of any, or a wide range of archetypes, this event type will match any additions to the record.
   * * \`|correction|\` - match error corrections only, including deletions.
   * * \`|update|\` - match updates (i.e. new versions) of included content items.
   *
   * Coded by openEHR Terminology group 'extract update trigger event type'.
   */
  trigger_events;
  /**
   * Indicate mode of update. Can be: send only items that are changed (including logical deletions) or new since last send. For \`_persist_in_server_\` Requests only.
   */
  update_method;
};
var EXTRACT_VERSION_SPEC = class {
  /**
   * Internal storage for include_all_versions
   * @protected
   */
  _include_all_versions;
  /**
   * True if all versions of each item in the Extract are included.
   */
  get include_all_versions() {
    return this._include_all_versions?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for include_all_versions.
   * Use this to access openehr_base.Boolean methods.
   */
  get $include_all_versions() {
    return this._include_all_versions;
  }
  /**
   * Sets include_all_versions from either a primitive value or openehr_base.Boolean wrapper.
   */
  set include_all_versions(val) {
    if (val === void 0 || val === null) {
      this._include_all_versions = void 0;
    } else if (typeof val === "boolean") {
      this._include_all_versions = Boolean2.from(val);
    } else {
      this._include_all_versions = val;
    }
  }
  /**
   * Specifies commit time interval of items to source repository to include in Extract. By default, only latest versions whose commit times fall in the range are included. If include_all_versions is True, then the range includes all versions committed within the interval.
   */
  commit_time_interval;
  /**
   * Internal storage for include_revision_history
   * @protected
   */
  _include_revision_history;
  /**
   * True if revision histories of the items in the Extract are included. If included, it is always the full revision history.
   */
  get include_revision_history() {
    return this._include_revision_history?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for include_revision_history.
   * Use this to access openehr_base.Boolean methods.
   */
  get $include_revision_history() {
    return this._include_revision_history;
  }
  /**
   * Sets include_revision_history from either a primitive value or openehr_base.Boolean wrapper.
   */
  set include_revision_history(val) {
    if (val === void 0 || val === null) {
      this._include_revision_history = void 0;
    } else if (typeof val === "boolean") {
      this._include_revision_history = Boolean2.from(val);
    } else {
      this._include_revision_history = val;
    }
  }
  /**
   * Internal storage for include_data
   * @protected
   */
  _include_data;
  /**
   * \`True\` if the data of items matched by the content spec should be included. This is the default. If \`False\`, only revision history is included in serialised versions. Turning this option on in openEHR systems causes \`X_VERSIONED_OBJECTs\` to have \`_revision_history_\` set, but versions Void. Useful for interrogating a server without having to look at any content data. In other systems it may or may not have a sensible meaning.
   */
  get include_data() {
    return this._include_data?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for include_data.
   * Use this to access openehr_base.Boolean methods.
   */
  get $include_data() {
    return this._include_data;
  }
  /**
   * Sets include_data from either a primitive value or openehr_base.Boolean wrapper.
   */
  set include_data(val) {
    if (val === void 0 || val === null) {
      this._include_data = void 0;
    } else if (typeof val === "boolean") {
      this._include_data = Boolean2.from(val);
    } else {
      this._include_data = val;
    }
  }
};
var OPENEHR_CONTENT_ITEM = class extends EXTRACT_CONTENT_ITEM {
  /**
   * Content object.
   */
  item = void 0;
};
var X_VERSIONED_OBJECT = class {
  /**
   * Uid of original \`VERSIONED_OBJECT\`.
   */
  uid;
  /**
   * Owner_id from original \`VERSIONED_OBJECT\`, which identifies source EHR.
   */
  owner_id;
  /**
   * Creation time of original \`VERSIONED_OBJECT\`.
   */
  time_created;
  /**
   * Internal storage for total_version_count
   * @protected
   */
  _total_version_count;
  /**
   * Total number of versions in original \`VERSIONED_OBJECT\` at time of creation of this \`X_VERSIONED_OBJECT\`.
   */
  get total_version_count() {
    return this._total_version_count?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for total_version_count.
   * Use this to access openehr_base.Integer methods.
   */
  get $total_version_count() {
    return this._total_version_count;
  }
  /**
   * Sets total_version_count from either a primitive value or openehr_base.Integer wrapper.
   */
  set total_version_count(val) {
    if (val === void 0 || val === null) {
      this._total_version_count = void 0;
    } else if (typeof val === "number") {
      this._total_version_count = Integer.from(val);
    } else {
      this._total_version_count = val;
    }
  }
  /**
   * Internal storage for extract_version_count
   * @protected
   */
  _extract_version_count;
  /**
   * The number of Versions in this extract for this Versioned object, i.e. the count of items in the versions attribute. May be 0 if only revision history is requested.
   */
  get extract_version_count() {
    return this._extract_version_count?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for extract_version_count.
   * Use this to access openehr_base.Integer methods.
   */
  get $extract_version_count() {
    return this._extract_version_count;
  }
  /**
   * Sets extract_version_count from either a primitive value or openehr_base.Integer wrapper.
   */
  set extract_version_count(val) {
    if (val === void 0 || val === null) {
      this._extract_version_count = void 0;
    } else if (typeof val === "number") {
      this._extract_version_count = Integer.from(val);
    } else {
      this._extract_version_count = val;
    }
  }
  /**
   * Optional revision history of the original \`VERSIONED_OBJECT\`. If included, it is the complete revision history.
   */
  revision_history;
  /**
   * 0 or more Versions from the original \`VERSIONED_OBJECT\`, according to the Extract specification.
   */
  versions;
};
var X_VERSIONED_EHR_ACCESS = class extends X_VERSIONED_OBJECT {
};
var X_VERSIONED_EHR_STATUS = class extends X_VERSIONED_OBJECT {
};
var X_VERSIONED_COMPOSITION = class extends X_VERSIONED_OBJECT {
};
var X_VERSIONED_FOLDER = class extends X_VERSIONED_OBJECT {
};
var X_VERSIONED_PARTY = class extends X_VERSIONED_OBJECT {
};
var GENERIC_CONTENT_ITEM = class extends EXTRACT_CONTENT_ITEM {
  /**
   * Identifier of model or schema used to create the content.
   */
  item_type;
  /**
   * Internal storage for item_type_version
   * @protected
   */
  _item_type_version;
  /**
   * Version of model or schema used to create the content item.
   */
  get item_type_version() {
    return this._item_type_version?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for item_type_version.
   * Use this to access openehr_base.String methods.
   */
  get $item_type_version() {
    return this._item_type_version;
  }
  /**
   * Sets item_type_version from either a primitive value or openehr_base.String wrapper.
   */
  set item_type_version(val) {
    if (val === void 0 || val === null) {
      this._item_type_version = void 0;
    } else if (typeof val === "string") {
      this._item_type_version = String2.from(val);
    } else {
      this._item_type_version = val;
    }
  }
  /**
   * Internal storage for author
   * @protected
   */
  _author;
  /**
   * Reference to a demographic entity elsewhere in this Extract representing the author of the item version. The reference should be a UID corresponding to the UID of a \`GENERIC_CONTENT_ITEM\` containing the demographic information.
   */
  get author() {
    return this._author?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for author.
   * Use this to access openehr_base.String methods.
   */
  get $author() {
    return this._author;
  }
  /**
   * Sets author from either a primitive value or openehr_base.String wrapper.
   */
  set author(val) {
    if (val === void 0 || val === null) {
      this._author = void 0;
    } else if (typeof val === "string") {
      this._author = String2.from(val);
    } else {
      this._author = val;
    }
  }
  /**
   * Time of creation of this item version on the original system. This may be an earlier commit time, or it may be the time at which the item was created during the Extract generation process.
   */
  creation_time;
  /**
   * Internal storage for authoriser
   * @protected
   */
  _authoriser;
  /**
   * Reference to a demographic entity elsewhere in this Extract representing an authoriser of the item version, if relevant. The reference should be a UID corresponding to the UID of a \`GENERIC_CONTENT_ITEM\` containing the demographic information.
   */
  get authoriser() {
    return this._authoriser?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for authoriser.
   * Use this to access openehr_base.String methods.
   */
  get $authoriser() {
    return this._authoriser;
  }
  /**
   * Sets authoriser from either a primitive value or openehr_base.String wrapper.
   */
  set authoriser(val) {
    if (val === void 0 || val === null) {
      this._authoriser = void 0;
    } else if (typeof val === "string") {
      this._authoriser = String2.from(val);
    } else {
      this._authoriser = val;
    }
  }
  /**
   * Time of authorisation of this item version on the original system where relevant.
   */
  authorisation_time;
  /**
   * Coded lifecycle status of the item.
   */
  item_status;
  /**
   * Internal storage for version_id
   * @protected
   */
  _version_id;
  /**
   * Version id of this item in original system.
   */
  get version_id() {
    return this._version_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for version_id.
   * Use this to access openehr_base.String methods.
   */
  get $version_id() {
    return this._version_id;
  }
  /**
   * Sets version_id from either a primitive value or openehr_base.String wrapper.
   */
  set version_id(val) {
    if (val === void 0 || val === null) {
      this._version_id = void 0;
    } else if (typeof val === "string") {
      this._version_id = String2.from(val);
    } else {
      this._version_id = val;
    }
  }
  /**
   * Internal storage for version_set_id
   * @protected
   */
  _version_set_id;
  /**
   * Version set id of this item in original system, where applicable.
   */
  get version_set_id() {
    return this._version_set_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for version_set_id.
   * Use this to access openehr_base.String methods.
   */
  get $version_set_id() {
    return this._version_set_id;
  }
  /**
   * Sets version_set_id from either a primitive value or openehr_base.String wrapper.
   */
  set version_set_id(val) {
    if (val === void 0 || val === null) {
      this._version_set_id = void 0;
    } else if (typeof val === "string") {
      this._version_set_id = String2.from(val);
    } else {
      this._version_set_id = val;
    }
  }
  /**
   * Internal storage for system_id
   * @protected
   */
  _system_id;
  /**
   * Identifier of EMR or other system from which the item was created / extracted. Typically in the form of a domain name.
   */
  get system_id() {
    return this._system_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for system_id.
   * Use this to access openehr_base.String methods.
   */
  get $system_id() {
    return this._system_id;
  }
  /**
   * Sets system_id from either a primitive value or openehr_base.String wrapper.
   */
  set system_id(val) {
    if (val === void 0 || val === null) {
      this._system_id = void 0;
    } else if (typeof val === "string") {
      this._system_id = String2.from(val);
    } else {
      this._system_id = val;
    }
  }
  /**
   * Other details about the content item.
   */
  other_details;
  /**
   * Content object.
   */
  item = void 0;
};
var MESSAGE_CONTENT = class {
};
var SYNC_EXTRACT_REQUEST = class extends MESSAGE_CONTENT {
  /**
   * Details of specification of synchronisation request.
   */
  specification;
};
var SYNC_EXTRACT = class extends MESSAGE_CONTENT {
  /**
   * Details of specification of this Extract.
   */
  specification;
  /**
   * Content, in the form of a serialised Contributions.
   */
  items;
};
var X_CONTRIBUTION = class {
  /**
   * Uid of Contribution in source system.
   */
  uid;
  /**
   * Audit of Contribution in source system.
   */
  audit;
  /**
   * Serialised Versions from Contribution in source system.
   */
  versions;
};
var SYNC_EXTRACT_SPEC = class {
  /**
   * Internal storage for includes_versions
   * @protected
   */
  _includes_versions;
  /**
   * True if the Versions from the Contribution are included; False if just the Contribution and its Audit are included.
   */
  get includes_versions() {
    return this._includes_versions?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for includes_versions.
   * Use this to access openehr_base.Boolean methods.
   */
  get $includes_versions() {
    return this._includes_versions;
  }
  /**
   * Sets includes_versions from either a primitive value or openehr_base.Boolean wrapper.
   */
  set includes_versions(val) {
    if (val === void 0 || val === null) {
      this._includes_versions = void 0;
    } else if (typeof val === "boolean") {
      this._includes_versions = Boolean2.from(val);
    } else {
      this._includes_versions = val;
    }
  }
  /**
   * List of Contributions to include / that are included in the Extract.
   */
  contribution_list;
  /**
   * Specify Contributions included in Extract by threshold date.
   */
  contributions_since;
  /**
   * Internal storage for all_contributions
   * @protected
   */
  _all_contributions;
  /**
   * True if all Contributions in the record are included.
   */
  get all_contributions() {
    return this._all_contributions?.value;
  }
  /**
   * Gets the openehr_base.Boolean wrapper object for all_contributions.
   * Use this to access openehr_base.Boolean methods.
   */
  get $all_contributions() {
    return this._all_contributions;
  }
  /**
   * Sets all_contributions from either a primitive value or openehr_base.Boolean wrapper.
   */
  set all_contributions(val) {
    if (val === void 0 || val === null) {
      this._all_contributions = void 0;
    } else if (typeof val === "boolean") {
      this._all_contributions = Boolean2.from(val);
    } else {
      this._all_contributions = val;
    }
  }
};
var MESSAGE = class {
  /**
   * Details of who actually created the message and when. This is the person who entered the data or otherwise caused the message to be created, or might be a piece of software.
   */
  audit;
  /**
   * Party responsible for the message content, who may or may not be technically responsible for its creation (e.g. by data entry etc).
   */
  author;
  /**
   * Content of the message.
   */
  content;
  /**
   * Internal storage for signature
   * @protected
   */
  _signature;
  /**
   * Optional signature by the author of message content in openPGP format. The signature is created as a Hash and optional signing of the serialisation of this message object with this signature field Void.
   */
  get signature() {
    return this._signature?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for signature.
   * Use this to access openehr_base.String methods.
   */
  get $signature() {
    return this._signature;
  }
  /**
   * Sets signature from either a primitive value or openehr_base.String wrapper.
   */
  set signature(val) {
    if (val === void 0 || val === null) {
      this._signature = void 0;
    } else if (typeof val === "string") {
      this._signature = String2.from(val);
    } else {
      this._signature = val;
    }
  }
};
var ADDRESSED_MESSAGE = class {
  /**
   * Internal storage for sender
   * @protected
   */
  _sender;
  /**
   * Party sending the message.
   */
  get sender() {
    return this._sender?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for sender.
   * Use this to access openehr_base.String methods.
   */
  get $sender() {
    return this._sender;
  }
  /**
   * Sets sender from either a primitive value or openehr_base.String wrapper.
   */
  set sender(val) {
    if (val === void 0 || val === null) {
      this._sender = void 0;
    } else if (typeof val === "string") {
      this._sender = String2.from(val);
    } else {
      this._sender = val;
    }
  }
  /**
   * Internal storage for sender_reference
   * @protected
   */
  _sender_reference;
  /**
   * Identification of message used by sender. This will be the same no matter how many times this message is sent to these recipients.
   */
  get sender_reference() {
    return this._sender_reference?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for sender_reference.
   * Use this to access openehr_base.String methods.
   */
  get $sender_reference() {
    return this._sender_reference;
  }
  /**
   * Sets sender_reference from either a primitive value or openehr_base.String wrapper.
   */
  set sender_reference(val) {
    if (val === void 0 || val === null) {
      this._sender_reference = void 0;
    } else if (typeof val === "string") {
      this._sender_reference = String2.from(val);
    } else {
      this._sender_reference = val;
    }
  }
  /**
   * Intended recipients, in the form of internet addresses.
   */
  addressees;
  /**
   * Internal storage for urgency
   * @protected
   */
  _urgency;
  /**
   * Urgency with which destination should deal with message:
   *
   * * -1 - low
   * * 0 - normal
   * * 1 - high
   */
  get urgency() {
    return this._urgency?.value;
  }
  /**
   * Gets the openehr_base.Integer wrapper object for urgency.
   * Use this to access openehr_base.Integer methods.
   */
  get $urgency() {
    return this._urgency;
  }
  /**
   * Sets urgency from either a primitive value or openehr_base.Integer wrapper.
   */
  set urgency(val) {
    if (val === void 0 || val === null) {
      this._urgency = void 0;
    } else if (typeof val === "number") {
      this._urgency = Integer.from(val);
    } else {
      this._urgency = val;
    }
  }
  /**
   * The content of the message.
   */
  message;
};
var PARTY = class extends LOCATABLE {
  /**
   * Identities used by the party to identify itself, such as legal name, stage names, aliases, nicknames and so on.
   */
  identities;
  /**
   * Contacts for this party.
   */
  contacts;
  /**
   * All other details for this Party.
   */
  details;
  /**
   * References to relationships in which this Party takes part as target.
   */
  reverse_relationships;
  /**
   * Relationships in which this Party takes part as source.
   */
  relationships;
  /**
   * Type of party, such as  \`PERSON\`,  \`ORGANISATION\`, etc. Role name, e.g.  general practitioner ,  nurse ,  private citizen . Taken from inherited \`_name_\` attribute.
   * @returns Result value
   */
  type() {
    if (!this.name) {
      throw new Error("PARTY name is required but not set");
    }
    return this.name;
  }
};
var CONTACT = class extends LOCATABLE {
  /**
   * A set of address alternatives for this contact purpose and time validity combination.
   */
  addresses;
  /**
   * Valid time interval for this contact descriptor.
   */
  time_validity;
  /**
   * Purpose for which this contact is used, e.g. mail,  daytime phone, etc. Taken from value of inherited \`_name_\` attribute.
   * @returns Result value
   */
  purpose() {
    if (!this.name) {
      throw new Error("CONTACT name is required but not set");
    }
    return this.name;
  }
};
var ADDRESS = class extends LOCATABLE {
  /**
   * Archetypable structured address.
   */
  details;
  /**
   * Type of address, e.g. electronic,  locality. Taken from value of inherited \`_name_\` attribute.
   * @returns Result value
   */
  type() {
    if (!this.name) {
      throw new Error("ADDRESS name is required but not set");
    }
    return this.name;
  }
};
var PARTY_IDENTITY = class extends LOCATABLE {
  /**
   * The value of the identity. This will often taken the form of a parseable string or a small structure of strings.
   */
  details;
  /**
   * Purpose of identity, e.g. legal ,  stagename,  nickname,  tribal name,  trading name. Taken from value of inherited \`_name_\` attribute.
   * @returns Result value
   */
  purpose() {
    if (!this.name) {
      throw new Error("PARTY_IDENTITY name is required but not set");
    }
    return this.name;
  }
};
var ROLE = class extends PARTY {
  /**
   * Valid time interval for this role.
   */
  time_validity;
  /**
   * Reference to Version container of Actor playing the role.
   */
  performer;
  /**
   * The capabilities of this role.
   */
  capabilities;
};
var ACTOR = class extends PARTY {
  /**
   * Languages which can be used to communicate with this actor, in preferred order of use (if known, else order irrelevant).
   */
  languages;
  /**
   * Identifiers of the Version container for each Role played by this Party.
   */
  roles;
};
var CAPABILITY = class extends LOCATABLE {
  /**
   * The qualifications of the performer of the role for this capability. This might include professional qualifications and official identifications such as provider numbers etc.
   */
  credentials;
  /**
   * Valid time interval for the credentials of this capability.
   */
  time_validity;
};
var AGENT = class extends ACTOR {
};
var ORGANISATION = class extends ACTOR {
};
var GROUP = class extends ACTOR {
};
var PERSON = class extends ACTOR {
};
var PARTY_RELATIONSHIP = class extends LOCATABLE {
  /**
   * The detailed description of the relationship.
   */
  details;
  /**
   * Target of relationship.
   */
  target;
  /**
   * Valid time interval for this relationship.
   */
  time_validity;
  /**
   * Source of relationship.
   */
  source;
  /**
   * Type of relationship, such as  employment,  authority,  health provision
   * @returns Result value
   */
  type() {
    if (!this.name) {
      throw new Error("PARTY_RELATIONSHIP name is required but not set");
    }
    return this.name;
  }
};
var VERSIONED_PARTY = class extends VERSIONED_OBJECT {
};
var CONTENT_ITEM = class extends LOCATABLE {
};
var GENERIC_ENTRY = class extends CONTENT_ITEM {
  /**
   * The data from the source message or record. May be recorded in any structural openEHR representation.
   */
  data;
};
var COMPOSITION = class extends LOCATABLE {
  /**
   * Constructor supports partial initialization via spread syntax.
   * Accepts primitives, objects, and terse strings where appropriate.
   * 
   * @param init - Optional initialization object
   * 
   * @example
   * ```typescript
   * // Compact creation with terse format
   * const composition = new COMPOSITION({
   *   archetype_node_id: "openEHR-EHR-COMPOSITION.encounter.v1",
   *   name: "Blood Pressure Reading",
   *   language: "ISO_639-1::en",
   *   territory: "ISO_3166-1::GB",
   *   category: "openehr::433|event|",
   *   composer: { name: "Dr. Smith" }
   * });
   * ```
   */
  constructor(init3) {
    super();
    if (init3) {
      this._applyInit(init3);
    }
  }
  /**
   * Internal helper to process initialization data.
   * @private
   */
  _applyInit(init3) {
    if (init3.archetype_node_id !== void 0) {
      this.archetype_node_id = init3.archetype_node_id;
    }
    if (init3.name !== void 0) {
      this.name = initDvText(init3.name);
    }
    if (init3.uid !== void 0) {
      this.uid = initObjectVersionId(init3.uid);
    }
    if (init3.archetype_details !== void 0) {
      this.archetype_details = initArchetyped(init3.archetype_details);
    }
    if (init3.feeder_audit !== void 0) {
      this.feeder_audit = init3.feeder_audit;
    }
    if (init3.links !== void 0) {
      this.links = init3.links;
    }
    if (init3.language !== void 0) {
      this.language = initCodePhrase(init3.language);
    }
    if (init3.territory !== void 0) {
      this.territory = initCodePhrase(init3.territory);
    }
    if (init3.category !== void 0) {
      this.category = initDvCodedText(init3.category);
    }
    if (init3.context !== void 0) {
      this.context = initEventContext(init3.context);
    }
    if (init3.composer !== void 0) {
      this.composer = initPartyProxy(init3.composer);
    }
    if (init3.content !== void 0) {
      this.content = init3.content;
    }
  }
  /**
   * Mandatory indicator of the localised language in which this Composition is written. Coded from openEHR Code Set  \`languages\`. The language of an Entry if different from the Composition is indicated in \`ENTRY._language_\`.
   */
  language;
  /**
   * Name of territory in which this Composition was written. Coded from openEHR  countries  code set, which is an expression of the ISO 3166 standard.
   */
  territory;
  /**
   * Temporal category of this Composition, i.e.
   *
   * * \`431|persistent|\` - of potential life-time validity;
   * * \`451|episodic|\` - valid over the life of a care episode;
   * * \`433|event|\` - valid at the time of recording (long-term validity requires subsequent clinical assessment).
   *
   * or any other code defined in the openEHR terminology group 'category'.
   */
  category;
  /**
   * The clinical session context of this Composition, i.e. the contextual attributes of the clinical session.
   */
  context;
  /**
   * The person primarily responsible for the content of the Composition (but not necessarily its committal into the EHR system). This is the identifier which should appear on the screen. It may or may not be the person who entered the data. When it is the patient, the special self  instance of \`PARTY_PROXY\` will be used.
   */
  composer;
  /**
   * The content of this Composition.
   */
  content;
  /**
   * True if category is \`431|persistent|\`, False otherwise. Useful for finding Compositions in an EHR which are guaranteed to be of interest to most users.
   * @returns Result value
   */
  is_persistent() {
    if (!this.category || !this.category.defining_code) {
      return Boolean2.from(false);
    }
    return Boolean2.from(this.category.defining_code.code_string === "431");
  }
};
var EVENT_CONTEXT = class extends PATHABLE {
  /**
   * Start time of the clinical session or other kind of event during which a provider performs a service of any kind for the patient.
   */
  start_time;
  /**
   * Optional end time of the clinical session.
   */
  end_time;
  /**
   * Internal storage for location
   * @protected
   */
  _location;
  /**
   * The actual location where the session occurred, e.g. 'microbiology lab 2', 'home', 'ward A3'  and so on.
   */
  get location() {
    return this._location?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for location.
   * Use this to access openehr_base.String methods.
   */
  get $location() {
    return this._location;
  }
  /**
   * Sets location from either a primitive value or openehr_base.String wrapper.
   */
  set location(val) {
    if (val === void 0 || val === null) {
      this._location = void 0;
    } else if (typeof val === "string") {
      this._location = String2.from(val);
    } else {
      this._location = val;
    }
  }
  /**
   * The setting in which the clinical session took place. Coded using the openEHR Terminology,  setting  group.
   */
  setting;
  /**
   * Other optional context which will be archetyped.
   */
  other_context;
  /**
   * The health care facility under whose care the event took place. This is the most specific workgroup or delivery unit within a care delivery enterprise that has an official identifier in the health system, and can be used to ensure medico-legal accountability.
   */
  health_care_facility;
  /**
   * Parties involved in the healthcare event. These would normally include the physician(s) and often the patient (but not the latter if the clinical session is a pathology test for example).
   */
  participations;
};
var SECTION = class extends CONTENT_ITEM {
  /**
   * Ordered list of content items under this section, which may include:
   *
   * * more \`SECTIONs\`;
   * * \`ENTRYs\`.
   */
  items;
};
var ENTRY = class extends CONTENT_ITEM {
  /**
   * Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set  languages .
   */
  language;
  /**
   * Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set  character sets.
   */
  encoding;
  /**
   * Other participations at \`ENTRY\` level.
   */
  other_participations;
  /**
   * Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
   */
  workflow_id;
  /**
   * Id of human subject of this \`ENTRY\`, e.g.:
   *
   * * organ donor
   * * foetus
   * * a family member
   * * another clinically relevant person.
   */
  subject;
  /**
   * Optional identification of provider of the information in this \`ENTRY\`, which might be:
   *
   * * the patient
   * * a patient agent, e.g. parent, guardian
   * * the clinician
   * * a device or software
   *
   * Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
   */
  provider;
  /**
   * Returns True if this Entry is about the subject of the EHR, in which case the subject attribute is of type PARTY_SELF.
   * @returns Result value
   */
  subject_is_self() {
    return Boolean2.from(this.subject instanceof PARTY_SELF);
  }
};
var ADMIN_ENTRY = class extends ENTRY {
  /**
   * Content of the Admin Entry.
   */
  data;
};
var CARE_ENTRY = class extends ENTRY {
  /**
   * Description of the method (i.e. how) the information in this entry was arrived at. For \`OBSERVATIONs\`, this is a description of the method or instrument used. For \`EVALUATIONs\`, how the evaluation was arrived at. For \`INSTRUCTIONs\`, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process.
   */
  protocol;
  /**
   * Optional external identifier of guideline creating this Entry if relevant.
   */
  guideline_id;
};
var OBSERVATION = class extends CARE_ENTRY {
  /**
   * The data of this observation, in the form of a history of values which may be of any complexity.
   */
  data;
  /**
   * Optional recording of the state of subject of this observation during the observation process, in the form of a separate history of values which may be of any complexity. State may also be recorded within the History of the data attribute.
   */
  state;
};
var EVALUATION = class extends CARE_ENTRY {
  /**
   * The data of this evaluation, in the form of a spatial data structure.
   */
  data;
};
var ACTION = class extends CARE_ENTRY {
  /**
   * Point in time at which this action completed. To indicate an unknown time, use a \`DV_DATE_TIME\` instance with \`_value_\` set to the time of creation (or some other known time before which the Action is known to have occurred, e.g. data accession timestamp from integration engine), and \`_magnitude_status_\` set to \`<\`.
   */
  time;
  /**
   * Details of transition in the Instruction state machine caused by this Action.
   */
  ism_transition;
  /**
   * Details of the Instruction that caused this Action to be performed, if there was one.
   */
  instruction_details;
  /**
   * Description of the action that has been performed, in the form of an archetyped structure.
   */
  description;
};
var ACTIVITY = class extends LOCATABLE {
  /**
   * Timing of the activity, in the form of a parsable string. If used, the preferred syntax is ISO8601 'R' format, but other formats may be used including HL7 GTS.
   *
   * May be omitted if:
   *
   * * timing is represented structurally in the \`_description_\` attribute (e.g. via archetyped elements), or
   * * unavailable, e.g. imported legacy data; in such cases, the \`INSTRUCTION._narrative_\` should carry text that indicates the timing of its \`_activities_\`.
   */
  timing;
  /**
   * Internal storage for action_archetype_id
   * @protected
   */
  _action_archetype_id;
  /**
   * Perl-compliant regular expression pattern, enclosed in  '//' delimiters, indicating the valid identifiers of archetypes for Actions corresponding to this Activity specification.
   *
   * Defaults to  \`/.*\/\`, meaning any archetype.
   */
  get action_archetype_id() {
    return this._action_archetype_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for action_archetype_id.
   * Use this to access openehr_base.String methods.
   */
  get $action_archetype_id() {
    return this._action_archetype_id;
  }
  /**
   * Sets action_archetype_id from either a primitive value or openehr_base.String wrapper.
   */
  set action_archetype_id(val) {
    if (val === void 0 || val === null) {
      this._action_archetype_id = void 0;
    } else if (typeof val === "string") {
      this._action_archetype_id = String2.from(val);
    } else {
      this._action_archetype_id = val;
    }
  }
  /**
   * Description of the activity, in the form of an archetyped structure.
   */
  description;
};
var ISM_TRANSITION = class extends PATHABLE {
  /**
   * The ISM current state. Coded by openEHR terminology group Instruction states.
   */
  current_state;
  /**
   * The ISM transition which occurred to arrive in the current_state. Coded by openEHR terminology group  Instruction transitions.
   */
  transition;
  /**
   * The step in the careflow process which occurred as part of generating this action, e.g.  dispense ,  start_administration. This attribute represents the clinical  label for the activity, as  opposed to current_state which represents  the state machine (ISM)  computable form. Defined in archetype.
   */
  careflow_step;
  /**
   * Optional possibility of adding one or more reasons for this careflow step having been taken. Multiple reasons may occur in medication management for example.
   */
  reason;
};
var INSTRUCTION_DETAILS = class extends PATHABLE {
  /**
   * Reference to causing Instruction.
   */
  instruction_id;
  /**
   * Internal storage for activity_id
   * @protected
   */
  _activity_id;
  /**
   * Identifier of Activity within Instruction, in the form of its archetype path.
   */
  get activity_id() {
    return this._activity_id?.value;
  }
  /**
   * Gets the openehr_base.String wrapper object for activity_id.
   * Use this to access openehr_base.String methods.
   */
  get $activity_id() {
    return this._activity_id;
  }
  /**
   * Sets activity_id from either a primitive value or openehr_base.String wrapper.
   */
  set activity_id(val) {
    if (val === void 0 || val === null) {
      this._activity_id = void 0;
    } else if (typeof val === "string") {
      this._activity_id = String2.from(val);
    } else {
      this._activity_id = val;
    }
  }
  /**
   * Various workflow engine state details, potentially including such things as:
   *
   * * condition that fired to cause this Action to be done (with actual variables substituted);
   * * list of notifications which actually occurred (with all variables substituted);
   * * other workflow engine state.
   *
   * This specification does not currently define the actual structure or semantics of this field.
   */
  wf_details;
};
var INSTRUCTION = class extends CARE_ENTRY {
  /**
   * Mandatory human-readable version of what the Instruction is about.
   */
  narrative;
  /**
   * Optional expiry date/time to assist determination of when an Instruction can be assumed to have expired. This helps prevent false listing of Instructions as Active when they clearly must have been terminated in some way or other.
   */
  expiry_time;
  /**
   * Optional workflow engine executable expression of the Instruction.
   */
  wf_definition;
  /**
   * List of all activities in Instruction.
   */
  activities;
};

// ../../enhanced/terse_format.ts
function parseTerseCodePhrase(terse) {
  if (!terse || typeof terse !== "string") {
    return null;
  }
  const match = terse.match(/^([^:]+)::([^|]+)$/);
  if (!match) {
    return null;
  }
  const codePhrase = new CODE_PHRASE2();
  const termId = new TERMINOLOGY_ID();
  termId.value = match[1].trim();
  codePhrase.terminology_id = termId;
  codePhrase.code_string = match[2].trim();
  return codePhrase;
}
function toTerseCodePhrase(codePhrase) {
  const termId = codePhrase.terminology_id?.value || "";
  const code = codePhrase.code_string || "";
  return `${termId}::${code}`;
}
function parseTerseDvCodedText(terse) {
  if (!terse || typeof terse !== "string") {
    return null;
  }
  const match = terse.match(/^([^:]+)::([^|]+)\|([^|]*)\|$/);
  if (!match) {
    return null;
  }
  const codedText = new DV_CODED_TEXT();
  codedText.value = match[3];
  const definingCode = new CODE_PHRASE2();
  const termId = new TERMINOLOGY_ID();
  termId.value = match[1].trim();
  definingCode.terminology_id = termId;
  definingCode.code_string = match[2].trim();
  codedText.defining_code = definingCode;
  return codedText;
}
function toTerseDvCodedText(codedText) {
  const termId = codedText.defining_code?.terminology_id?.value || "";
  const code = codedText.defining_code?.code_string || "";
  const value = codedText.value || "";
  return `${termId}::${code}|${value}|`;
}
function isTerseCodePhrase(str) {
  if (!str || typeof str !== "string") {
    return false;
  }
  return /^[^:]+::[^|]+$/.test(str);
}
function isTerseDvCodedText(str) {
  if (!str || typeof str !== "string") {
    return false;
  }
  return /^[^:]+::[^|]+\|[^|]*\|$/.test(str);
}

// ../../enhanced/serialization/json/json_config.ts
init_define_BUILD_INFO();
var DEFAULT_JSON_SERIALIZATION_CONFIG = {
  typePropertyName: "_type",
  alwaysIncludeType: true,
  // Changed to true for canonical compliance by default
  includeNullValues: false,
  includeEmptyCollections: true,
  prettyPrint: true,
  // Changed to true for readability by default
  indent: 2,
  useTerseFormat: false,
  useHybridStyle: false,
  maxInlineProperties: 3,
  archetypeNodeIdLocation: "after_name"
};
var DEFAULT_JSON_DESERIALIZATION_CONFIG = {
  typePropertyName: "_type",
  strict: false,
  allowIncomplete: false,
  parseTerseFormat: false
};
var CANONICAL_JSON_CONFIG = {
  typePropertyName: "_type",
  alwaysIncludeType: true,
  includeNullValues: false,
  includeEmptyCollections: true,
  prettyPrint: true,
  indent: 2,
  useTerseFormat: false,
  useHybridStyle: false,
  archetypeNodeIdLocation: "after_name"
};
var CANONICAL_JSON_DESERIALIZE_CONFIG = {
  typePropertyName: "_type",
  strict: true,
  // Strict mode for canonical compliance
  allowIncomplete: false,
  parseTerseFormat: false
};
var COMPACT_JSON_CONFIG = {
  typePropertyName: "_type",
  alwaysIncludeType: false,
  // Use type inference
  includeNullValues: false,
  includeEmptyCollections: false,
  prettyPrint: false,
  useTerseFormat: false,
  useHybridStyle: false
};
var COMPACT_JSON_DESERIALIZE_CONFIG = {
  typePropertyName: "_type",
  strict: false,
  allowIncomplete: false,
  parseTerseFormat: false
};
var HYBRID_JSON_CONFIG = {
  typePropertyName: "_type",
  alwaysIncludeType: false,
  includeNullValues: false,
  includeEmptyCollections: true,
  prettyPrint: true,
  indent: 2,
  useTerseFormat: false,
  useHybridStyle: true,
  // Note: Hybrid formatting is not fully implemented
  maxInlineProperties: 3
};
var HYBRID_JSON_DESERIALIZE_CONFIG = {
  typePropertyName: "_type",
  strict: false,
  allowIncomplete: true,
  parseTerseFormat: false
};
var NON_STANDARD_VERY_COMPACT_JSON_CONFIG = {
  typePropertyName: "_type",
  alwaysIncludeType: false,
  includeNullValues: false,
  includeEmptyCollections: false,
  prettyPrint: false,
  useTerseFormat: true,
  // Non-standard!
  useHybridStyle: false
};

// ../../enhanced/serialization/json/json_configurable_serializer.ts
var JsonConfigurableSerializer = class _JsonConfigurableSerializer {
  config;
  /**
   * Create a JSON serializer with the given configuration
   * 
   * @param config - Serialization configuration
   */
  constructor(config = {}) {
    this.config = { ...DEFAULT_JSON_SERIALIZATION_CONFIG, ...config };
  }
  /**
   * Serialize an RM object to JSON string
   * 
   * @param obj - The object to serialize
   * @returns JSON string
   * @throws SerializationError if serialization fails
   */
  serialize(obj) {
    try {
      const jsonObj = this.toJsonObject(obj);
      if (this.config.prettyPrint) {
        return JSON.stringify(jsonObj, null, this.config.indent);
      } else {
        return JSON.stringify(jsonObj);
      }
    } catch (error) {
      throw new SerializationError(
        `Failed to serialize object: ${error instanceof Error ? error.message : String(error)}`,
        obj,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Convert an RM object to a plain JSON object
   * 
   * @param obj - The object to convert
   * @param parentType - Type of the parent object (for type inference)
   * @param propertyName - Name of the property holding this object
   * @returns Plain JSON object
   */
  toJsonObject(obj, parentType, propertyName) {
    if (obj === null || obj === void 0) {
      return this.config.includeNullValues ? null : void 0;
    }
    if (typeof obj !== "object") {
      return obj;
    }
    if (Array.isArray(obj)) {
      const result3 = obj.map((item) => this.toJsonObject(item, parentType, propertyName));
      if (result3.length === 0 && !this.config.includeEmptyCollections) {
        return void 0;
      }
      return result3;
    }
    if (this.config.useTerseFormat && this.canUseTerseFormat(obj)) {
      return this.toTerseFormat(obj);
    }
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    const result2 = {};
    if (this.shouldIncludeType(obj, typeName, parentType, propertyName)) {
      result2[this.config.typePropertyName] = typeName || obj.constructor.name.toUpperCase();
    }
    const allProperties = /* @__PURE__ */ new Set();
    Object.keys(obj).forEach((key) => allProperties.add(key));
    let proto = Object.getPrototypeOf(obj);
    while (proto && proto !== Object.prototype) {
      Object.getOwnPropertyNames(proto).forEach((key) => {
        if (key !== "constructor") {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          if (descriptor && descriptor.get) {
            allProperties.add(key);
          }
        }
      });
      proto = Object.getPrototypeOf(proto);
    }
    const props = Array.from(allProperties).filter((key) => {
      if (key.startsWith("_") || key.startsWith("$"))
        return false;
      if (typeof obj[key] === "function")
        return false;
      if ((obj[key] === null || obj[key] === void 0) && !this.config.includeNullValues)
        return false;
      return true;
    });
    let orderedKeys = [];
    const archIdLocation = this.config.archetypeNodeIdLocation;
    const hasArchId = props.includes("archetype_node_id");
    const hasName = props.includes("name");
    if (hasArchId) {
      const rest = props.filter((k2) => k2 !== "archetype_node_id");
      if (archIdLocation === "beginning") {
        orderedKeys = ["archetype_node_id", ...rest];
      } else if (archIdLocation === "after_name" && hasName) {
        for (const key of rest) {
          orderedKeys.push(key);
          if (key === "name")
            orderedKeys.push("archetype_node_id");
        }
      } else if (archIdLocation === "end") {
        orderedKeys = [...rest, "archetype_node_id"];
      } else {
        orderedKeys = [...rest, "archetype_node_id"];
      }
    } else {
      orderedKeys = props;
    }
    for (const key of orderedKeys) {
      const value = obj[key];
      const jsonValue = this.toJsonObject(value, typeName, key);
      if (jsonValue !== void 0) {
        result2[key] = jsonValue;
      }
    }
    const hasProperties = Object.keys(result2).some((k2) => k2 !== this.config.typePropertyName);
    if (!hasProperties && !this.config.includeEmptyCollections) {
      return void 0;
    }
    return result2;
  }
  /**
   * Serialize with a specific configuration (one-time use)
   * 
   * @param obj - The object to serialize
   * @param config - Configuration for this serialization
   * @returns JSON string
   */
  static serializeWith(obj, config) {
    const serializer = new _JsonConfigurableSerializer(config);
    return serializer.serialize(obj);
  }
  /**
   * Determine if type property should be included
   */
  shouldIncludeType(obj, typeName, parentType, propertyName) {
    if (this.config.alwaysIncludeType) {
      return true;
    }
    if (!typeName) {
      return false;
    }
    if (!parentType || !propertyName) {
      return true;
    }
    return !TypeInferenceEngine.canOmitType(propertyName, parentType, obj);
  }
  /**
   * Check if an object can use terse format
   */
  canUseTerseFormat(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    return typeName === "CODE_PHRASE" || typeName === "DV_CODED_TEXT";
  }
  /**
   * Convert object to terse format string
   */
  toTerseFormat(obj) {
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    if (typeName === "CODE_PHRASE") {
      return toTerseCodePhrase(obj);
    }
    if (typeName === "DV_CODED_TEXT") {
      return toTerseDvCodedText(obj);
    }
    throw new SerializationError(`Cannot convert ${typeName} to terse format`, obj);
  }
};

// ../../enhanced/serialization/json/json_configurable_deserializer.ts
init_define_BUILD_INFO();
var JsonConfigurableDeserializer = class {
  config;
  /**
   * Create a JSON deserializer with the given configuration
   * 
   * @param config - Deserialization configuration
   */
  constructor(config = {}) {
    this.config = { ...DEFAULT_JSON_DESERIALIZATION_CONFIG, ...config };
  }
  /**
   * Deserialize a JSON string to an RM object
   * 
   * @param json - JSON string to deserialize
   * @returns Deserialized object
   * @throws DeserializationError if deserialization fails
   */
  deserialize(json) {
    try {
      const parsed = JSON.parse(json);
      if (this.config.parseTerseFormat && typeof parsed === "string") {
        const terseResult = this.parseTerseString(parsed);
        if (terseResult) {
          return terseResult;
        }
      }
      return this.fromJsonObject(parsed);
    } catch (error) {
      if (error instanceof DeserializationError) {
        throw error;
      }
      throw new DeserializationError(
        `Failed to parse JSON: ${error instanceof Error ? error.message : String(error)}`,
        json,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Deserialize a JSON string to a specific type
   * 
   * @param json - JSON string to deserialize
   * @param type - Expected type constructor
   * @returns Deserialized object of the specified type
   * @throws DeserializationError if deserialization fails
   */
  deserializeAs(json, type) {
    try {
      const parsed = JSON.parse(json);
      if (this.config.parseTerseFormat && typeof parsed === "string") {
        const terseResult = this.parseTerseString(parsed);
        if (terseResult) {
          return terseResult;
        }
      }
      const typeName = TypeRegistry.getTypeName(type);
      return this.fromJsonObject(parsed, typeName);
    } catch (error) {
      if (error instanceof DeserializationError) {
        throw error;
      }
      throw new DeserializationError(
        `Failed to deserialize as ${type.name}: ${error instanceof Error ? error.message : String(error)}`,
        json,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Convert a plain JSON object to an RM object
   * 
   * @param obj - Plain JSON object
   * @param expectedType - Expected type name (optional)
   * @param parentType - Type of parent object (for inference)
   * @param propertyName - Name of property holding this object
   * @returns Deserialized RM object
   */
  fromJsonObject(obj, expectedType, parentType, propertyName) {
    if (obj === null || obj === void 0) {
      return obj;
    }
    if (typeof obj !== "object") {
      return obj;
    }
    if (this.config.parseTerseFormat && typeof obj === "string") {
      const parsed = this.parseTerseString(obj);
      if (parsed) {
        return parsed;
      }
    }
    if (Array.isArray(obj)) {
      return obj.map(
        (item) => this.fromJsonObject(item, expectedType, parentType, propertyName)
      );
    }
    const typeName = this.resolveType(obj, expectedType, parentType, propertyName);
    if (!typeName) {
      if (this.config.strict) {
        throw new DeserializationError(
          "Cannot determine type for object (strict mode enabled)",
          JSON.stringify(obj)
        );
      }
      return obj;
    }
    const constructor = TypeRegistry.getConstructor(typeName);
    if (!constructor) {
      if (this.config.strict) {
        throw new TypeNotFoundError(typeName, JSON.stringify(obj) + " (strict mode enabled)");
      }
      return obj;
    }
    const instance = new constructor();
    for (const [key, value] of Object.entries(obj)) {
      if (key === this.config.typePropertyName) {
        continue;
      }
      try {
        instance[key] = this.fromJsonObject(value, void 0, typeName, key);
      } catch (error) {
        if (this.config.strict) {
          throw new DeserializationError(
            `Failed to deserialize property '${key}' of ${typeName}: ${error instanceof Error ? error.message : String(error)}`,
            JSON.stringify(obj),
            error instanceof Error ? error : void 0
          );
        }
        instance[key] = value;
      }
    }
    return instance;
  }
  /**
   * Resolve the type name for an object using multiple strategies
   * 
   * Priority:
   * 1. Explicit _type field
   * 2. Expected type parameter
   * 3. Type inference from property name and parent
   * 4. Type inference from structure
   */
  resolveType(obj, expectedType, parentType, propertyName) {
    if (obj[this.config.typePropertyName]) {
      return obj[this.config.typePropertyName];
    }
    if (expectedType) {
      return expectedType;
    }
    if (parentType && propertyName) {
      const inferred = TypeInferenceEngine.inferType(propertyName, parentType, obj);
      if (inferred) {
        return inferred;
      }
    }
    const structureInferred = TypeInferenceEngine.inferFromStructure(obj);
    if (structureInferred) {
      return structureInferred;
    }
    return void 0;
  }
  /**
   * Try to parse a string as terse format
   */
  parseTerseString(str) {
    if (!str || typeof str !== "string") {
      return null;
    }
    if (isTerseDvCodedText(str)) {
      const result2 = parseTerseDvCodedText(str);
      if (result2) {
        return result2;
      }
    }
    if (isTerseCodePhrase(str)) {
      const result2 = parseTerseCodePhrase(str);
      if (result2) {
        return result2;
      }
    }
    return null;
  }
  /**
   * Deserialize with a specific configuration (one-time use)
   * 
   * @param json - JSON string to deserialize
   * @param config - Configuration for this deserialization
   * @returns Deserialized object
   */
  static deserializeWith(json, config) {
    const deserializer = new JsonDeserializer(config);
    return deserializer.deserialize(json);
  }
};

// ../../enhanced/serialization/yaml/mod.ts
init_define_BUILD_INFO();

// ../../enhanced/serialization/yaml/yaml_serializer.ts
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/index.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/index.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/composer.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/doc/directives.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/identity.js
init_define_BUILD_INFO();
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/visit.js
init_define_BUILD_INFO();
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i3 = 0; i3 < node.items.length; ++i3) {
        const ci2 = visit_(i3, node.items[i3], visitor, path);
        if (typeof ci2 === "number")
          i3 = ci2 - 1;
        else if (ci2 === BREAK)
          return BREAK;
        else if (ci2 === REMOVE) {
          node.items.splice(i3, 1);
          i3 -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i3 = 0; i3 < node.items.length; ++i3) {
        const ci2 = await visitAsync_(i3, node.items[i3], visitor, path);
        if (typeof ci2 === "number")
          i3 = ci2 - 1;
        else if (ci2 === BREAK)
          return BREAK;
        else if (ci2 === REMOVE) {
          node.items.splice(i3, 1);
          i3 -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return visitor.Map?.(key, node, path);
  if (isSeq(node))
    return visitor.Seq?.(key, node, path);
  if (isPair(node))
    return visitor.Pair?.(key, node, path);
  if (isScalar(node))
    return visitor.Scalar?.(key, node, path);
  if (isAlias(node))
    return visitor.Alias?.(key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt2 = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt2} parent`);
  }
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn2) => tn2.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class _Directives {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, _Directives.defaultTags, tags);
  }
  clone() {
    const copy = new _Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new _Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: _Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, _Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, _Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn2) => tn2.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/doc/Document.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Alias.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/doc/anchors.js
init_define_BUILD_INFO();
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa2 = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa2}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i3 = 1; true; ++i3) {
    const name = `${prefix}${i3}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      prevAnchors ?? (prevAnchors = anchorNames(doc));
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Node.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/doc/applyReviver.js
init_define_BUILD_INFO();
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i3 = 0, len = val.length; i3 < len; ++i3) {
        const v0 = val[i3];
        const v1 = applyReviver(reviver, val, String(i3), v0);
        if (v1 === void 0)
          delete val[i3];
        else if (v1 !== v0)
          val[i3] = v1;
      }
    } else if (val instanceof Map) {
      for (const k2 of Array.from(val.keys())) {
        const v0 = val.get(k2);
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          val.delete(k2);
        else if (v1 !== v0)
          val.set(k2, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k2, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          delete val[k2];
        else if (v1 !== v0)
          val[k2] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/toJS.js
init_define_BUILD_INFO();
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v2, i3) => toJS(v2, String(i3), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc, ctx) {
    let nodes;
    if (ctx?.aliasResolveCache) {
      nodes = ctx.aliasResolveCache;
    } else {
      nodes = [];
      visit(doc, {
        Node: (_key, node) => {
          if (isAlias(node) || hasAnchor(node))
            nodes.push(node);
        }
      });
      if (ctx)
        ctx.aliasResolveCache = nodes;
    }
    let found = void 0;
    for (const node of nodes) {
      if (node === this)
        break;
      if (node.anchor === this.source)
        found = node;
    }
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc, ctx);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source);
    if (!data) {
      toJS(source, null, ctx);
      data = anchors.get(source);
    }
    if (data?.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c2 = getAliasCount(doc, item, anchors);
      if (c2 > count)
        count = c2;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Collection.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/doc/createNode.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Scalar.js
init_define_BUILD_INFO();
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t2) => t2.tag === tagName);
    const tagObj = match.find((t2) => !t2.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t2) => t2.identify?.(value) && !t2.format);
}
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      ref.anchor ?? (ref.anchor = onAnchor(value));
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v2 = value;
  for (let i3 = path.length - 1; i3 >= 0; --i3) {
    const k2 = path[i3];
    if (typeof k2 === "number" && Number.isInteger(k2) && k2 >= 0) {
      const a2 = [];
      a2[k2] = v2;
      v2 = a2;
    } else {
      v2 = /* @__PURE__ */ new Map([[k2, v2]]);
    }
  }
  return createNode(v2, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it2) => isNode(it2) || isPair(it2) ? it2.clone(schema4) : it2);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n2 = node.value;
      return n2 == null || allowScalar && isScalar(n2) && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Pair.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyPair.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringify.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyComment.js
init_define_BUILD_INFO();
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyString.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/foldFlowLines.js
init_define_BUILD_INFO();
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i3 = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i3 = consumeMoreIndentedLines(text, i3, indent.length);
    if (i3 !== -1)
      end = i3 + endStep;
  }
  for (let ch; ch = text[i3 += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i3;
      switch (text[i3 + 1]) {
        case "x":
          i3 += 3;
          break;
        case "u":
          i3 += 5;
          break;
        case "U":
          i3 += 9;
          break;
        default:
          i3 += 1;
      }
      escEnd = i3;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i3 = consumeMoreIndentedLines(text, i3, indent.length);
      end = i3 + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i3 + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i3;
      }
      if (i3 >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i3 += 1];
            overflow = true;
          }
          const j2 = i3 > escEnd + 1 ? i3 - 2 : escStart - 1;
          if (escapedFolds[j2])
            return text;
          folds.push(j2);
          escapedFolds[j2] = true;
          end = j2 + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i4 = 0; i4 < folds.length; ++i4) {
    const fold = folds[i4];
    const end2 = folds[i4 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i3, indent) {
  let end = i3;
  let start = i3 + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i3 < start + indent) {
      ch = text[++i3];
    } else {
      do {
        ch = text[++i3];
      } while (ch && ch !== "\n");
      end = i3;
      start = i3 + 1;
      ch = text[start];
    }
  }
  return end;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i3 = 0, start = 0; i3 < strLen; ++i3) {
    if (str[i3] === "\n") {
      if (i3 - start > limit)
        return true;
      start = i3 + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i3 = 0, ch = json[i3]; ch; ch = json[++i3]) {
    if (ch === " " && json[i3 + 1] === "\\" && json[i3 + 2] === "n") {
      str += json.slice(start, i3) + "\\ ";
      i3 += 1;
      start = i3;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i3 + 1]) {
        case "u":
          {
            str += json.slice(start, i3);
            const code = json.substr(i3 + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i3, 6);
            }
            i3 += 5;
            start = i3 + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i3 + 2] === '"' || json.length < minMultiLineLength) {
            i3 += 1;
          } else {
            str += json.slice(start, i3) + "\n\n";
            while (json[i3 + 2] === "\\" && json[i3 + 3] === "n" && json[i3 + 4] !== '"') {
              str += "\n";
              i3 += 2;
            }
            str += indent;
            if (json[i3 + 2] === " ")
              str += "\\";
            i3 += 1;
            start = i3 + 1;
          }
          break;
        default:
          i3 += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss2 = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss2.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss2.value, ctx) : blockString(ss2, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss2.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss2.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss2, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t2 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t2);
    if (res === null)
      throw new Error(`Unsupported default string type ${t2}`);
  }
  return res;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t2) => t2.tag === item.tag);
    if (match.length > 0)
      return match.find((t2) => t2.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match = tags.filter((t2) => t2.identify?.(obj));
    if (match.length > 1) {
      const testMatch = match.filter((t2) => t2.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = match.find((t2) => t2.format === item.format) ?? match.find((t2) => !t2.format);
  } else {
    obj = item;
    tagObj = tags.find((t2) => t2.nodeClass && obj instanceof t2.nodeClass);
  }
  if (!tagObj) {
    const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o2) => tagObj = o2 });
  tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs2 = commentString(vcb);
      ws += `
${indentComment(cs2, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n" && valueComment)
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/log.js
init_define_BUILD_INFO();
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
init_define_BUILD_INFO();
var MERGE_KEY = "<<";
var merge = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
var isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it2 of value.items)
      mergeValue(ctx, map2, it2);
  else if (Array.isArray(value))
    for (const it2 of value)
      mergeValue(ctx, map2, it2);
  else
    mergeValue(ctx, map2, value);
}
function mergeValue(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k2 = createNode(key, void 0, ctx);
  const v2 = createNode(value, void 0, ctx);
  return new Pair(k2, v2);
}
var Pair = class _Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new _Pair(key, value);
  }
  toJSON(_2, ctx) {
    const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/Schema.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/map.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLMap.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyCollection.js
init_define_BUILD_INFO();
function stringifyCollection(collection, ctx, options) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i3 = 0; i3 < items.length; ++i3) {
    const item = items[i3];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i3 = 1; i3 < lines.length; ++i3) {
      const line = lines[i3];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i3 = 0; i3 < items.length; ++i3) {
    const item = items[i3];
    let comment = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment = ik.comment;
      }
    }
    if (comment)
      reqNewline = true;
    let str = stringify(item, itemCtx, () => comment = null);
    if (i3 < items.length - 1)
      str += ",";
    if (comment)
      str += lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k2 = isScalar(key) ? key.value : key;
  for (const it2 of items) {
    if (isPair(it2)) {
      if (it2.key === key || it2.key === k2)
        return it2;
      if (isScalar(it2.key) && it2.key.value === k2)
        return it2;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema4, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema4);
    const add = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema4.sortMapEntries === "function") {
      map2.items.sort(schema4.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair?.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema?.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i3 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i3 === -1)
        this.items.push(_pair);
      else
        this.items.splice(i3, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it2 = findPair(this.items, key);
    if (!it2)
      return false;
    const del = this.items.splice(this.items.indexOf(it2), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it2 = findPair(this.items, key);
    const node = it2?.value;
    return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_2, ctx, Type) {
    const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/map.js
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/seq.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLSeq.js
init_define_BUILD_INFO();
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it2 = this.items[idx];
    return !keepScalar && isScalar(it2) ? it2.value : it2;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_2, ctx) {
    const seq2 = [];
    if (ctx?.onCreate)
      ctx.onCreate(seq2);
    let i3 = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i3++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema4, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema4);
    if (obj && Symbol.iterator in Object(obj)) {
      let i3 = 0;
      for (let it2 of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it2 : String(i3++);
          it2 = replacer.call(obj, key, it2);
        }
        seq2.items.push(createNode(it2, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/seq.js
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/string.js
init_define_BUILD_INFO();
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/tags.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/null.js
init_define_BUILD_INFO();
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/bool.js
init_define_BUILD_INFO();
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/float.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyNumber.js
init_define_BUILD_INFO();
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n2 = Object.is(value, -0) ? "-0" : JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    let i3 = n2.indexOf(".");
    if (i3 < 0) {
      i3 = n2.length;
      n2 += ".";
    }
    let d2 = minFractionDigits - (n2.length - i3 - 1);
    while (d2-- > 0)
      n2 += "0";
  }
  return n2;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/int.js
init_define_BUILD_INFO();
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/schema.js
init_define_BUILD_INFO();
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/json/schema.js
init_define_BUILD_INFO();
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
init_define_BUILD_INFO();
var binary = {
  identify: (value) => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i3 = 0; i3 < str.length; ++i3)
        buffer[i3] = str.charCodeAt(i3);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    if (!value)
      return "";
    const buf = value;
    let str;
    if (typeof btoa === "function") {
      let s2 = "";
      for (let i3 = 0; i3 < buf.length; ++i3)
        s2 += String.fromCharCode(buf[i3]);
      str = btoa(s2);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    type ?? (type = Scalar.BLOCK_LITERAL);
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n2 = Math.ceil(str.length / lineWidth);
      const lines = new Array(n2);
      for (let i3 = 0, o2 = 0; i3 < n2; ++i3, o2 += lineWidth) {
        lines[i3] = str.substr(o2, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
init_define_BUILD_INFO();
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i3 = 0; i3 < seq2.items.length; ++i3) {
      let item = seq2.items[i3];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn2 = pair.value ?? pair.key;
          cn2.comment = cn2.comment ? `${item.comment}
${cn2.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i3] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i3 = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it2 of iterable) {
      if (typeof replacer === "function")
        it2 = replacer.call(iterable, String(i3++), it2);
      let key, value;
      if (Array.isArray(it2)) {
        if (it2.length === 2) {
          key = it2[0];
          value = it2[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it2}`);
      } else if (it2 && it2 instanceof Object) {
        const keys = Object.keys(it2);
        if (keys.length === 1) {
          key = keys[0];
          value = it2[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it2;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class _YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = _YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_2, ctx) {
    if (!ctx)
      return super.toJSON(_2);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
init_define_BUILD_INFO();
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
init_define_BUILD_INFO();
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f2 = str.substring(dot + 1).replace(/_/g, "");
      if (f2[f2.length - 1] === "0")
        node.minFractionDigits = f2.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
init_define_BUILD_INFO();
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n3 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n3 : n3;
  }
  const n2 = parseInt(str, radix);
  return sign === "-" ? -1 * n2 : n2;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
init_define_BUILD_INFO();
var YAMLSet = class _YAMLSet extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = _YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_2, ctx) {
    return super.toJSON(_2, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
init_define_BUILD_INFO();
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n2) => asBigInt ? BigInt(n2) : Number(n2);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p2) => res2 * num(60) + num(p2), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n2) => n2;
  if (typeof value === "bigint")
    num = (n2) => BigInt(n2);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n2) => String(n2).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d2 = parseSexagesimal(tz, false);
      if (Math.abs(d2) < 30)
        d2 *= 60;
      date -= 6e4 * d2;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a2, b2) => a2.key < b2.key ? -1 : a2.key > b2.key ? 1 : 0;
var Schema = class _Schema {
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyDocument.js
init_define_BUILD_INFO();
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs2 = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs2, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs2 = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs2, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs2 = commentString(doc.comment);
      if (cs2.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs2, ""));
      } else {
        lines.push(`... ${cs2}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/doc/Document.js
var Document3 = class _Document {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options?._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(_Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v2) => typeof v2 === "number" || v2 instanceof String || v2 instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k2 = this.createNode(key, null, options);
    const v2 = this.createNode(value, null, options);
    return new Pair(k2, v2);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (isEmptyPath(path)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg ?? "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s2 = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s2}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/errors.js
init_define_BUILD_INFO();
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci2 = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci2 >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci2 - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci2 -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci2))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end?.line === line && end.col > col) {
      count = Math.max(1, Math.min(end.col - col, 80 - ci2));
    }
    const pointer = " ".repeat(ci2) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-doc.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-node.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-collection.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-map.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-props.js
init_define_BUILD_INFO();
function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        start ?? (start = token.offset);
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        start ?? (start = token.offset);
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end,
    start: start ?? end
  };
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-contains-newline.js
init_define_BUILD_INFO();
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st2 of key.end)
          if (st2.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it2 of key.items) {
        for (const st2 of it2.start)
          if (st2.type === "newline")
            return true;
        if (it2.sep) {
          for (const st2 of it2.sep)
            if (st2.type === "newline")
              return true;
        }
        if (containsNewline(it2.key) || containsNewline(it2.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
init_define_BUILD_INFO();
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-map-includes.js
init_define_BUILD_INFO();
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a2, b2) => a2 === b2 || isScalar(a2) && isScalar(b2) && a2.value === b2.value;
  return items.some((pair) => isEqual(pair.key, search));
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd ?? offset];
  return map2;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-seq.js
init_define_BUILD_INFO();
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value?.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-end.js
init_define_BUILD_INFO();
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i3 = 0; i3 < fc.items.length; ++i3) {
    const collItem = fc.items[i3];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i3 === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i3 < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i3 === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st2 of start) {
            switch (st2.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st2.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st2 of sep) {
              if (st2 === valueProps.found)
                break;
              if (st2.type === "newline") {
                onError(st2, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source?.[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode ?? keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce2, ...ee2] = fc.end;
  let cePos = offset;
  if (ce2?.source === expectedEnd)
    cePos = ce2.offset + ce2.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce2 && ce2.source.length !== 1)
      ee2.unshift(ce2);
  }
  if (ee2.length > 0) {
    const end = resolveEnd(ee2, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t2) => t2.tag === tagName && t2.collection === expType);
  if (!tag) {
    const kt2 = ctx.schema.knownTags[tagName];
    if (kt2?.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt2, { default: false }));
      tag = kt2;
    } else {
      if (kt2) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt2.tag} used for ${expType} collection, but expects ${kt2.collection ?? "scalar"}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag?.format)
    node.format = tag.format;
  return node;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-scalar.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
init_define_BUILD_INFO();
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i3 = lines.length - 1; i3 >= 0; --i3) {
    const content = lines[i3][1];
    if (content === "" || content === "\r")
      chompStart = i3;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i3 = 0; i3 < chompStart; ++i3) {
    const [indent, content] = lines[i3];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i3;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i3 = lines.length - 1; i3 >= chompStart; --i3) {
    if (lines[i3][0].length > trimIndent)
      chompStart = i3 + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i3 = 0; i3 < contentStart; ++i3)
    value += lines[i3][0].slice(trimIndent) + "\n";
  for (let i3 = contentStart; i3 < chompStart; ++i3) {
    let [indent, content] = lines[i3];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i3 = chompStart; i3 < lines.length; ++i3)
        value += "\n" + lines[i3][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i3 = 1; i3 < source.length; ++i3) {
    const ch = source[i3];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n2 = Number(ch);
      if (!indent && n2)
        indent = n2;
      else if (error === -1)
        error = offset + i3;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i3 = 1; i3 < props.length; ++i3) {
    const token = props[i3];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts2 = token.source;
        if (ts2 && typeof ts2 === "string")
          length += ts2.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m2 = first.match(/^( *)/);
  const line0 = m2?.[1] ? [m2[1], first.slice(m2[1].length)] : ["", first];
  const lines = [line0];
  for (let i3 = 1; i3 < split.length; i3 += 2)
    lines.push([split[i3], split[i3 + 1]]);
  return lines;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
init_define_BUILD_INFO();
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re2 = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re2.comment,
    range: [offset, valueEnd, re2.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + (match?.[1] ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i3 = 1; i3 < source.length - 1; ++i3) {
    const ch = source[i3];
    if (ch === "\r" && source[i3 + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i3);
      res += fold;
      i3 = offset;
    } else if (ch === "\\") {
      let next = source[++i3];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i3 + 1];
        while (next === " " || next === "	")
          next = source[++i3 + 1];
      } else if (next === "\r" && source[i3 + 1] === "\n") {
        next = source[++i3 + 1];
        while (next === " " || next === "	")
          next = source[++i3 + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i3 + 1, length, onError);
        i3 += length;
      } else {
        const raw = source.substr(i3 - 1, 2);
        onError(i3 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i3;
      let next = source[i3 + 1];
      while (next === " " || next === "	")
        next = source[++i3 + 1];
      if (next !== "\n" && !(next === "\r" && source[i3 + 2] === "\n"))
        res += i3 > wsStart ? source.slice(wsStart, i3 + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "\x85",
  // Unicode next line
  _: "\xA0",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token, onError);
  else
    tag = ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if (tag.test?.test(value))
      return tag;
  const kt2 = schema4.knownTags[tagName];
  if (kt2 && !kt2.collection) {
    schema4.tags.push(Object.assign({}, kt2, { default: false, test: void 0 }));
    return kt2;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
  const tag = schema4.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts2 = directives.tagString(tag.tag);
      const cs2 = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts2} or ${cs2}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
init_define_BUILD_INFO();
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    pos ?? (pos = before.length);
    for (let i3 = pos - 1; i3 >= 0; --i3) {
      let st2 = before[i3];
      switch (st2.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st2.source.length;
          continue;
      }
      st2 = before[++i3];
      while (st2?.type === "space") {
        offset += st2.source.length;
        st2 = before[++i3];
      }
      break;
    }
  }
  return offset;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag ?? token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re2 = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re2.offset];
  if (re2.comment)
    alias.comment = re2.comment;
  return alias;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document3(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? end?.[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re2 = resolveEnd(end, contentEnd, false, onError);
  if (re2.comment)
    doc.comment = re2.comment;
  doc.range = [offset, contentEnd, re2.offset];
  return doc;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i3 = 0; i3 < prelude.length; ++i3) {
    const source = prelude[i3];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i3 + 1]?.[0] !== "#")
          i3 += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it2 = dc.items[0];
        if (isPair(it2))
          it2 = it2.key;
        const cb = it2.commentBefore;
        it2.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document3(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-scalar.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-stringify.js
init_define_BUILD_INFO();

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-visit.js
init_define_BUILD_INFO();
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index] of path) {
    const tok = item?.[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent?.[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i3 = 0; i3 < token.items.length; ++i3) {
        const ci2 = _visit(Object.freeze(path.concat([[field, i3]])), token.items[i3], visitor);
        if (typeof ci2 === "number")
          i3 = ci2 - 1;
        else if (ci2 === BREAK2)
          return BREAK2;
        else if (ci2 === REMOVE2) {
          token.items.splice(i3, 1);
          i3 -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/parse/lexer.js
init_define_BUILD_INFO();
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      if (typeof source !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next ?? "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i3 = this.pos;
    let ch = this.buffer[i3];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i3];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i3 + 1] === "\n";
    return false;
  }
  charAt(n2) {
    return this.buffer[this.pos + n2];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt2 = this.buffer.substr(offset, 3);
      if ((dt2 === "---" || dt2 === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n2) {
    return this.pos + n2 <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n2) {
    return this.buffer.substr(this.pos, n2);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs2 = line.indexOf("#");
      while (cs2 !== -1) {
        const ch = line[cs2 - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs2 - 1;
          break;
        } else {
          cs2 = line.indexOf("#", cs2 + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n2 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n2);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s2 = this.peek(3);
      if ((s2 === "---" || s2 === "...") && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s2 === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n2 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n2;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n2 = yield* this.pushIndicators();
    switch (line[n2]) {
      case "#":
        yield* this.pushCount(line.length - n2);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n2 += yield* this.parseBlockScalarHeader();
        n2 += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n2);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n2 = 0;
    while (line[n2] === ",") {
      n2 += yield* this.pushCount(1);
      n2 += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n2 += yield* this.pushIndicators();
    switch (line[n2]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n2);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n2 = 0;
        while (this.buffer[end - 1 - n2] === "\\")
          n2 += 1;
        if (n2 % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs2 = this.continueScalar(nl + 1);
        if (cs2 === -1)
          break;
        nl = qb.indexOf("\n", cs2);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i3 = this.pos;
    while (true) {
      const ch = this.buffer[++i3];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i4 = this.pos; ch = this.buffer[i4]; ++i4) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i4;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i4 + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs2 = this.continueScalar(nl + 1);
        if (cs2 === -1)
          break;
        nl = this.buffer.indexOf("\n", cs2);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i3 = nl + 1;
    ch = this.buffer[i3];
    while (ch === " ")
      ch = this.buffer[++i3];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i3];
      nl = i3 - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i4 = nl - 1;
        let ch2 = this.buffer[i4];
        if (ch2 === "\r")
          ch2 = this.buffer[--i4];
        const lastChar = i4;
        while (ch2 === " ")
          ch2 = this.buffer[--i4];
        if (ch2 === "\n" && i4 >= this.pos && i4 + 1 + indent > lastChar)
          nl = i4;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i3 = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i3]) {
      if (ch === ":") {
        const next = this.buffer[i3 + 1];
        if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
          break;
        end = i3;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i3 + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i3 += 1;
            ch = "\n";
            next = this.buffer[i3 + 1];
          } else
            end = i3;
        }
        if (next === "#" || inFlow && flowIndicatorChars.has(next))
          break;
        if (ch === "\n") {
          const cs2 = this.continueScalar(i3 + 1);
          if (cs2 === -1)
            break;
          i3 = Math.max(i3, cs2 - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i3;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n2) {
    if (n2 > 0) {
      yield this.buffer.substr(this.pos, n2);
      this.pos += n2;
      return n2;
    }
    return 0;
  }
  *pushToIndex(i3, allowEmpty) {
    const s2 = this.buffer.slice(this.pos, i3);
    if (s2) {
      yield s2;
      this.pos += s2.length;
      return s2.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i3 = this.pos + 2;
      let ch = this.buffer[i3];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i3];
      return yield* this.pushToIndex(ch === ">" ? i3 + 1 : i3, false);
    } else {
      let i3 = this.pos + 1;
      let ch = this.buffer[i3];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i3];
        else if (ch === "%" && hexDigits.has(this.buffer[i3 + 1]) && hexDigits.has(this.buffer[i3 + 2])) {
          ch = this.buffer[i3 += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i3, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i3 = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i3];
    } while (ch === " " || allowTabs && ch === "	");
    const n2 = i3 - this.pos;
    if (n2 > 0) {
      yield this.buffer.substr(this.pos, n2);
      this.pos = i3;
    }
    return n2;
  }
  *pushUntil(test) {
    let i3 = this.pos;
    let ch = this.buffer[i3];
    while (!test(ch))
      ch = this.buffer[++i3];
    return yield* this.pushToIndex(i3, false);
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/parse/line-counter.js
init_define_BUILD_INFO();
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/parse/parser.js
init_define_BUILD_INFO();
function includesToken(list, type) {
  for (let i3 = 0; i3 < list.length; ++i3)
    if (list[i3].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i3 = 0; i3 < list.length; ++i3) {
    switch (list[i3].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i3;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it2 = parent.items[parent.items.length - 1];
      return it2.sep ?? it2.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i3 = prev.length;
  loop:
    while (--i3 >= 0) {
      switch (prev[i3].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (prev[++i3]?.type === "space") {
  }
  return prev.splice(i3, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it2 of fc.items) {
      if (it2.sep && !it2.value && !includesToken(it2.start, "explicit-key-ind") && !includesToken(it2.sep, "map-value-ind")) {
        if (it2.key)
          it2.value = it2.key;
        delete it2.key;
        if (isFlowToken(it2.value)) {
          if (it2.value.end)
            Array.prototype.push.apply(it2.value.end, it2.sep);
          else
            it2.value.end = it2.sep;
        } else
          Array.prototype.push.apply(it2.start, it2.sep);
        delete it2.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st2 = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st2;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && top?.type !== "doc-end") {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n2) {
    return this.stack[this.stack.length - n2];
  }
  *pop(error) {
    const token = error ?? this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it2 = top.items[top.items.length - 1];
          if (it2.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it2.sep) {
            it2.value = token;
          } else {
            Object.assign(it2, { key: token, sep: [] });
            this.onKeyLine = !it2.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it2 = top.items[top.items.length - 1];
          if (it2.value)
            top.items.push({ start: [], value: token });
          else
            it2.value = token;
          break;
        }
        case "flow-collection": {
          const it2 = top.items[top.items.length - 1];
          if (!it2 || it2.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it2.sep)
            it2.value = token;
          else
            Object.assign(it2, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st2) => st2.type !== "comment" || st2.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    const it2 = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it2.value) {
          const end = "end" in it2.value ? it2.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it2.sep) {
          it2.sep.push(this.sourceToken);
        } else {
          it2.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it2.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it2.sep) {
          it2.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it2.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it2.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it2.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it2.sep || it2.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it2.sep && !it2.value) {
        const nl = [];
        for (let i3 = 0; i3 < it2.sep.length; ++i3) {
          const st2 = it2.sep[i3];
          switch (st2.type) {
            case "newline":
              nl.push(i3);
              break;
            case "space":
              break;
            case "comment":
              if (st2.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it2.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it2.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it2.sep) {
            it2.sep.push(this.sourceToken);
          } else {
            it2.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it2.sep && !it2.explicitKey) {
            it2.start.push(this.sourceToken);
            it2.explicitKey = true;
          } else if (atNextItem || it2.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it2.explicitKey) {
            if (!it2.sep) {
              if (includesToken(it2.start, "newline")) {
                Object.assign(it2, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it2.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it2.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it2.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it2.key) && !includesToken(it2.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it2.start);
              const key = it2.key;
              const sep = it2.sep;
              sep.push(this.sourceToken);
              delete it2.key;
              delete it2.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep }]
              });
            } else if (start.length > 0) {
              it2.sep = it2.sep.concat(start, this.sourceToken);
            } else {
              it2.sep.push(this.sourceToken);
            }
          } else {
            if (!it2.sep) {
              Object.assign(it2, { key: null, sep: [this.sourceToken] });
            } else if (it2.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it2.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it2.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs2 = this.flowScalar(this.type);
          if (atNextItem || it2.value) {
            map2.items.push({ start, key: fs2, sep: [] });
            this.onKeyLine = true;
          } else if (it2.sep) {
            this.stack.push(fs2);
          } else {
            Object.assign(it2, { key: fs2, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (bv.type === "block-seq") {
              if (!it2.explicitKey && it2.sep && !includesToken(it2.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else if (atMapIndent) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    const it2 = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it2.value) {
          const end = "end" in it2.value ? it2.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it2.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it2.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it2.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it2.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it2.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it2.value || this.indent <= seq2.indent)
          break;
        it2.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it2.value || includesToken(it2.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it2.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it2 = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top?.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it2 || it2.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it2.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it2 || it2.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it2.sep)
            it2.sep.push(this.sourceToken);
          else
            Object.assign(it2, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it2 || it2.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it2.sep)
            it2.sep.push(this.sourceToken);
          else
            it2.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs2 = this.flowScalar(this.type);
          if (!it2 || it2.value)
            fc.items.push({ start: [], key: fs2, sep: [] });
          else if (it2.sep)
            this.stack.push(fs2);
          else
            Object.assign(it2, { key: fs2, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st2) => st2.type === "newline" || st2.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// ../../../../../Users/fbpf/AppData/Local/deno/deno_esbuild/yaml@2.8.2/node_modules/yaml/browser/dist/public-api.js
init_define_BUILD_INFO();
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse3(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify3(value, replacer, options) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options === void 0 && replacer) {
    options = replacer;
  }
  if (typeof options === "string")
    options = options.length;
  if (typeof options === "number") {
    const indent = Math.round(options);
    options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  if (isDocument(value) && !_replacer)
    return value.toString(options);
  return new Document3(value, _replacer, options).toString(options);
}

// ../../enhanced/serialization/yaml/yaml_config.ts
init_define_BUILD_INFO();
var DEFAULT_YAML_SERIALIZATION_CONFIG = {
  mainStyle: "hybrid",
  includeType: false,
  useTypeInference: true,
  // Changed to true - omit types when safe for smaller output
  indent: 2,
  lineWidth: 80,
  useTerseFormat: true,
  // Changed to true - terse format recommended for YAML
  includeNullValues: false,
  includeEmptyCollections: false,
  // Changed to false for more compact output
  maxInlineProperties: 3,
  archetypeNodeIdLocation: "after_name",
  keepArchetypeDetailsInline: false
  // Only works with flow style
};
var DEFAULT_YAML_DESERIALIZATION_CONFIG = {
  strict: true,
  allowDuplicateKeys: false,
  parseTerseFormat: true
  // Changed to true to match default serialization
};
var VERBOSE_YAML_CONFIG = {
  mainStyle: "block",
  includeType: true,
  useTypeInference: false,
  indent: 2,
  lineWidth: 80,
  useTerseFormat: false,
  archetypeNodeIdLocation: "after_name",
  keepArchetypeDetailsInline: false
};
var HYBRID_YAML_CONFIG = {
  mainStyle: "hybrid",
  includeType: false,
  useTypeInference: true,
  indent: 2,
  lineWidth: 0,
  useTerseFormat: true,
  includeNullValues: false,
  includeEmptyCollections: true,
  maxInlineProperties: 3,
  keepArchetypeDetailsInline: false,
  // Not applicable in hybrid mode
  archetypeNodeIdLocation: "after_name"
};
var FLOW_YAML_CONFIG = {
  mainStyle: "flow",
  includeType: false,
  useTypeInference: true,
  indent: 2,
  lineWidth: 0,
  // Disable wrapping for better control
  useTerseFormat: true,
  keepArchetypeDetailsInline: true,
  // Enable archetype inline in flow mode
  archetypeNodeIdLocation: "after_name"
};
var BLOCK_YAML_CONFIG = {
  mainStyle: "block",
  includeType: false,
  useTypeInference: true,
  indent: 2,
  lineWidth: 80,
  useTerseFormat: true,
  keepArchetypeDetailsInline: false,
  // Not applicable in block mode
  archetypeNodeIdLocation: "after_name"
};

// ../../enhanced/serialization/yaml/yaml_serializer.ts
var YamlSerializer = class _YamlSerializer {
  config;
  /**
   * Create a YAML serializer with the given configuration
   * 
   * @param config - Serialization configuration
   */
  constructor(config = {}) {
    this.config = { ...DEFAULT_YAML_SERIALIZATION_CONFIG, ...config };
  }
  /**
   * Serialize an RM object to YAML string
   * 
   * @param obj - The object to serialize
   * @returns YAML string
   * @throws SerializationError if serialization fails
   */
  serialize(obj) {
    try {
      const plainObj = this.toPlainObject(obj);
      const mainStyle = this.getEffectiveMainStyle();
      if (mainStyle === "hybrid") {
        return this.serializeHybrid(plainObj);
      } else if (mainStyle === "flow") {
        return this.serializeFlow(plainObj);
      } else {
        const options = this.getYamlOptions();
        return stringify3(plainObj, options);
      }
    } catch (error) {
      throw new SerializationError(
        `Failed to serialize to YAML: ${error instanceof Error ? error.message : String(error)}`,
        obj,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Determine the effective main style based on configuration
   */
  getEffectiveMainStyle() {
    return this.config.mainStyle || "hybrid";
  }
  /**
   * Serialize with hybrid formatting using Document API
   * This allows fine-grained control over flow vs block style
   * Simple objects are inline, complex objects use block style
   * 
   * @param obj - The plain object to serialize
   * @returns YAML string
   */
  serializeHybrid(obj) {
    const doc = new Document3(obj);
    this.applyHybridFormattingToNode(doc.contents, 0);
    const yaml = doc.toString({
      indent: this.config.indent,
      lineWidth: this.config.lineWidth
    });
    return yaml;
  }
  /**
   * Serialize with flow formatting using Document API
   * Uses flow style with strategic line breaks for archetype metadata
   * 
   * @param obj - The plain object to serialize
   * @returns YAML string
   */
  serializeFlow(obj) {
    const doc = new Document3(obj);
    this.applyFlowFormattingToNode(doc.contents);
    let yaml = doc.toString({
      indent: this.config.indent,
      lineWidth: this.config.lineWidth || 0
    });
    if (this.config.keepArchetypeDetailsInline) {
      yaml = this.addStrategicLineBreaks(yaml);
    }
    return yaml;
  }
  /**
   * Add strategic line breaks to flow-style YAML for better readability.
   * Adds line breaks after archetype metadata and before 'items' and 'value' properties.
   * This creates valid YAML with improved structure visibility.
   * 
   * @param yaml - Flow-style YAML string
   * @returns YAML string with strategic line breaks
   */
  addStrategicLineBreaks(yaml) {
    const indentSize = this.config.indent || 2;
    let input = "";
    let inQuotes = false;
    let quoteChar = "";
    for (let i4 = 0; i4 < yaml.length; i4++) {
      const c2 = yaml[i4];
      if ((c2 === '"' || c2 === "'") && (i4 === 0 || yaml[i4 - 1] !== "\\")) {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = c2;
        } else if (c2 === quoteChar)
          inQuotes = false;
        input += c2;
      } else if (inQuotes) {
        input += c2;
      } else if (c2 === "\n" || c2 === "\r") {
        input += " ";
      } else {
        input += c2;
      }
    }
    input = input.replace(/\s+/g, " ");
    const getIndent = (d2) => "\n" + " ".repeat(Math.max(0, d2) * indentSize);
    const metadataFields = ["name", "archetype_node_id", "archetype_details", "_type"];
    let result2 = "";
    let depth = 0;
    let i3 = 0;
    const fieldStack = [[]];
    while (i3 < input.length) {
      const char = input[i3];
      if ((char === '"' || char === "'") && (i3 === 0 || input[i3 - 1] !== "\\")) {
        const q2 = char;
        result2 += input[i3++];
        while (i3 < input.length && input[i3] !== q2) {
          if (input[i3] === "\\")
            result2 += input[i3++];
          result2 += input[i3++];
        }
        if (i3 < input.length)
          result2 += input[i3++];
        continue;
      }
      if (char === "{") {
        const prev = input.substring(Math.max(0, i3 - 30), i3);
        const prevNorm = prev.replace(/\s+/g, "");
        const isMajorProp = !!prevNorm.match(/(?:context|other_context|data|items|content|activities|description|protocol|state):\[?$/);
        result2 += char;
        fieldStack.push([]);
        depth++;
        if (isMajorProp || depth === 1 && result2.trim() === "{") {
          result2 += getIndent(depth);
        }
      } else if (char === "[") {
        result2 += char;
        fieldStack.push([]);
        depth++;
      } else if (char === "}" || char === "]") {
        if (fieldStack.length > 0)
          fieldStack.pop();
        depth--;
        result2 += char;
      } else if (char === ":") {
        let k2 = result2.length - 1;
        while (k2 >= 0 && /[\w_]/.test(result2[k2]))
          k2--;
        const fieldName = result2.substring(k2 + 1);
        if (fieldStack[depth]) {
          fieldStack[depth].push(fieldName);
        }
        result2 += char;
      } else if (char === ",") {
        result2 += char;
        let j2 = i3 + 1;
        while (j2 < input.length && /\s/.test(input[j2]))
          j2++;
        const remaining = input.substring(j2);
        const nextFieldMatch = remaining.match(/^(\w+):/);
        const nextField = nextFieldMatch ? nextFieldMatch[1] : "";
        const nextIsMetadata = metadataFields.includes(nextField);
        if (nextField !== "" && !nextIsMetadata) {
          result2 += getIndent(depth);
          i3 = j2 - 1;
        } else if (remaining.startsWith("{")) {
          result2 += getIndent(depth);
          i3 = j2 - 1;
        }
      } else if (char === " " && result2.endsWith(" ")) {
      } else {
        result2 += char;
      }
      i3++;
    }
    return result2.replace(/[ \t]+\n/g, "\n").trim();
  }
  /**
   * Apply flow formatting to a YAML node
   * Sets all nodes to use flow style
   * 
   * @param node - The YAML node to format
   */
  applyFlowFormattingToNode(node) {
    if (!node)
      return;
    if (isMap(node)) {
      node.flow = true;
      if (node.items && Array.isArray(node.items)) {
        for (const pair of node.items) {
          if (pair.value) {
            this.applyFlowFormattingToNode(pair.value);
          }
        }
      }
    } else if (isSeq(node)) {
      node.flow = true;
      if (node.items && Array.isArray(node.items)) {
        for (const item of node.items) {
          this.applyFlowFormattingToNode(item);
        }
      }
    }
  }
  /**
  * Apply hybrid formatting to a YAML node
  * Simple objects get flow style, complex objects get block style
  * 
  * @param node - The YAML node to format
  * @param depth - Current depth in the tree
  */
  applyHybridFormattingToNode(node, depth) {
    if (!node)
      return;
    if (isMap(node)) {
      const shouldBeInline = this.shouldNodeBeInline(node);
      if (shouldBeInline) {
        node.flow = true;
      } else {
        node.flow = false;
      }
      if (node.items && Array.isArray(node.items)) {
        for (const pair of node.items) {
          if (pair.value) {
            this.applyHybridFormattingToNode(pair.value, depth + 1);
          }
        }
      }
    } else if (isSeq(node)) {
      node.flow = false;
      if (node.items && Array.isArray(node.items)) {
        for (const item of node.items) {
          this.applyHybridFormattingToNode(item, depth + 1);
        }
      }
    }
  }
  /**
   * Determine if a YAML node should be formatted inline
   * 
   * @param node - The YAML node
   * @returns true if the node should use flow style
   */
  shouldNodeBeInline(node) {
    if (isScalar(node)) {
      return true;
    }
    if (isMap(node)) {
      if (!node.items || !Array.isArray(node.items)) {
        return true;
      }
      const numProps = node.items.length;
      const maxProps = this.config.maxInlineProperties ?? 3;
      if (numProps > maxProps) {
        return false;
      }
      for (const pair of node.items) {
        if (this.isNodeComplex(pair.value)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Check if a YAML node is complex (contains nested objects/arrays)
   * 
   * @param node - The YAML node
   * @returns true if the node is complex
   */
  isNodeComplex(node) {
    if (!node)
      return false;
    if (isScalar(node)) {
      return false;
    }
    if (isMap(node) || isSeq(node)) {
      return true;
    }
    return false;
  }
  /**
   * Convert an RM object to a plain object suitable for YAML serialization
   * 
   * @param obj - The object to convert
   * @param parentType - Type of the parent object (for type inference)
   * @param propertyName - Name of the property holding this object
   * @returns Plain object
   */
  toPlainObject(obj, parentType, propertyName) {
    if (obj === null || obj === void 0) {
      return this.config.includeNullValues ? null : void 0;
    }
    if (typeof obj !== "object") {
      return obj;
    }
    if (Array.isArray(obj)) {
      const result3 = obj.map((item) => this.toPlainObject(item, parentType, propertyName));
      if (result3.length === 0 && !this.config.includeEmptyCollections) {
        return void 0;
      }
      return result3;
    }
    if (this.config.useTerseFormat && this.canUseTerseFormat(obj)) {
      return this.toTerseFormat(obj);
    }
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    const result2 = {};
    if (this.shouldIncludeType(obj, typeName, parentType, propertyName)) {
      result2._type = typeName || obj.constructor.name.toUpperCase();
    }
    const allProperties = /* @__PURE__ */ new Set();
    Object.keys(obj).forEach((key) => allProperties.add(key));
    let proto = Object.getPrototypeOf(obj);
    while (proto && proto !== Object.prototype) {
      Object.getOwnPropertyNames(proto).forEach((key) => {
        if (key !== "constructor") {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          if (descriptor && descriptor.get) {
            allProperties.add(key);
          }
        }
      });
      proto = Object.getPrototypeOf(proto);
    }
    const props = Array.from(allProperties).filter((key) => {
      if (key.startsWith("_") || key.startsWith("$"))
        return false;
      if (typeof obj[key] === "function")
        return false;
      if ((obj[key] === null || obj[key] === void 0) && !this.config.includeNullValues)
        return false;
      return true;
    });
    let orderedKeys = [];
    const archIdLocation = this.config.archetypeNodeIdLocation;
    const hasArchId = props.includes("archetype_node_id");
    const hasName = props.includes("name");
    if (hasArchId) {
      const rest = props.filter((k2) => k2 !== "archetype_node_id");
      if (archIdLocation === "beginning") {
        orderedKeys = ["archetype_node_id", ...rest];
      } else if (archIdLocation === "after_name" && hasName) {
        for (const key of rest) {
          orderedKeys.push(key);
          if (key === "name")
            orderedKeys.push("archetype_node_id");
        }
      } else if (archIdLocation === "end") {
        orderedKeys = [...rest, "archetype_node_id"];
      } else {
        orderedKeys = [...rest, "archetype_node_id"];
      }
    } else {
      orderedKeys = props;
    }
    for (const key of orderedKeys) {
      const value = obj[key];
      const plainValue2 = this.toPlainObject(value, typeName, key);
      if (plainValue2 !== void 0) {
        result2[key] = plainValue2;
      }
    }
    const hasProperties = Object.keys(result2).some((k2) => k2 !== "_type");
    if (!hasProperties && !this.config.includeEmptyCollections) {
      return void 0;
    }
    return result2;
  }
  /**
   * Serialize with a specific configuration (one-time use)
   * 
   * @param obj - The object to serialize
   * @param config - Configuration for this serialization
   * @returns YAML string
   */
  static serializeWith(obj, config) {
    const serializer = new _YamlSerializer(config);
    return serializer.serialize(obj);
  }
  /**
   * Get YAML library options based on configuration
   */
  getYamlOptions() {
    const options = {
      indent: this.config.indent,
      lineWidth: this.config.lineWidth,
      minContentWidth: 20
    };
    const mainStyle = this.getEffectiveMainStyle();
    if (mainStyle === "flow") {
      options.flowLevel = 0;
    } else {
      options.flowLevel = -1;
    }
    return options;
  }
  /**
   * Determine if type property should be included
   */
  shouldIncludeType(obj, typeName, parentType, propertyName) {
    if (!this.config.includeType) {
      return false;
    }
    if (this.config.useTypeInference && parentType && propertyName && typeName) {
      return !TypeInferenceEngine.canOmitType(propertyName, parentType, obj);
    }
    return true;
  }
  /**
   * Check if an object can use terse format
   */
  canUseTerseFormat(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    return typeName === "CODE_PHRASE" || typeName === "DV_CODED_TEXT";
  }
  /**
   * Convert object to terse format string
   */
  toTerseFormat(obj) {
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    if (typeName === "CODE_PHRASE") {
      return toTerseCodePhrase(obj);
    }
    if (typeName === "DV_CODED_TEXT") {
      return toTerseDvCodedText(obj);
    }
    throw new SerializationError(`Cannot convert ${typeName} to terse format`, obj);
  }
};

// ../../enhanced/serialization/yaml/yaml_deserializer.ts
init_define_BUILD_INFO();
var YamlDeserializer = class _YamlDeserializer {
  config;
  /**
   * Create a YAML deserializer with the given configuration
   * 
   * @param config - Deserialization configuration
   */
  constructor(config = {}) {
    this.config = { ...DEFAULT_YAML_DESERIALIZATION_CONFIG, ...config };
  }
  /**
   * Deserialize a YAML string to an RM object
   * 
   * @param yaml - YAML string to deserialize
   * @returns Deserialized object
   * @throws DeserializationError if deserialization fails
   */
  deserialize(yaml) {
    try {
      const parsed = parse3(yaml, {
        strict: this.config.strict,
        uniqueKeys: !this.config.allowDuplicateKeys
      });
      return this.fromPlainObject(parsed);
    } catch (error) {
      if (error instanceof DeserializationError) {
        throw error;
      }
      throw new DeserializationError(
        `Failed to parse YAML: ${error instanceof Error ? error.message : String(error)}`,
        yaml,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Deserialize a YAML string to a specific type
   * 
   * @param yaml - YAML string to deserialize
   * @param type - Expected type constructor
   * @returns Deserialized object of the specified type
   * @throws DeserializationError if deserialization fails
   */
  deserializeAs(yaml, type) {
    try {
      const parsed = parse3(yaml, {
        strict: this.config.strict,
        uniqueKeys: !this.config.allowDuplicateKeys
      });
      const typeName = TypeRegistry.getTypeName(type);
      return this.fromPlainObject(parsed, typeName);
    } catch (error) {
      if (error instanceof DeserializationError) {
        throw error;
      }
      throw new DeserializationError(
        `Failed to deserialize as ${type.name}: ${error instanceof Error ? error.message : String(error)}`,
        yaml,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Convert a plain object (from YAML) to an RM object
   * 
   * @param obj - Plain object from YAML
   * @param expectedType - Expected type name (optional)
   * @param parentType - Type of parent object (for inference)
   * @param propertyName - Name of property holding this object
   * @returns Deserialized RM object
   */
  fromPlainObject(obj, expectedType, parentType, propertyName) {
    if (obj === null || obj === void 0) {
      return obj;
    }
    if (typeof obj !== "object") {
      if (this.config.parseTerseFormat && typeof obj === "string") {
        const parsed = this.parseTerseString(obj);
        if (parsed) {
          return parsed;
        }
      }
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map(
        (item) => this.fromPlainObject(item, expectedType, parentType, propertyName)
      );
    }
    const typeName = this.resolveType(obj, expectedType, parentType, propertyName);
    if (!typeName) {
      if (this.config.strict) {
        throw new DeserializationError(
          "Cannot determine type for object",
          JSON.stringify(obj)
        );
      }
      return obj;
    }
    const constructor = TypeRegistry.getConstructor(typeName);
    if (!constructor) {
      if (this.config.strict) {
        throw new TypeNotFoundError(typeName, JSON.stringify(obj));
      }
      return obj;
    }
    const instance = new constructor();
    for (const [key, value] of Object.entries(obj)) {
      if (key === "_type") {
        continue;
      }
      try {
        instance[key] = this.fromPlainObject(value, void 0, typeName, key);
      } catch (error) {
        if (this.config.strict) {
          throw new DeserializationError(
            `Failed to deserialize property '${key}' of ${typeName}: ${error instanceof Error ? error.message : String(error)}`,
            JSON.stringify(obj),
            error instanceof Error ? error : void 0
          );
        }
        instance[key] = value;
      }
    }
    return instance;
  }
  /**
   * Resolve the type name for an object using multiple strategies
   * 
   * Priority:
   * 1. Explicit _type field
   * 2. Expected type parameter
   * 3. Type inference from property name and parent
   * 4. Type inference from structure
   */
  resolveType(obj, expectedType, parentType, propertyName) {
    if (obj._type) {
      return obj._type;
    }
    if (expectedType) {
      return expectedType;
    }
    if (parentType && propertyName) {
      const inferred = TypeInferenceEngine.inferType(propertyName, parentType, obj);
      if (inferred) {
        return inferred;
      }
    }
    const structureInferred = TypeInferenceEngine.inferFromStructure(obj);
    if (structureInferred) {
      return structureInferred;
    }
    return void 0;
  }
  /**
   * Try to parse a string as terse format
   */
  parseTerseString(str) {
    if (!str || typeof str !== "string") {
      return null;
    }
    if (isTerseDvCodedText(str)) {
      const result2 = parseTerseDvCodedText(str);
      if (result2) {
        return result2;
      }
    }
    if (isTerseCodePhrase(str)) {
      const result2 = parseTerseCodePhrase(str);
      if (result2) {
        return result2;
      }
    }
    return null;
  }
  /**
   * Deserialize with a specific configuration (one-time use)
   * 
   * @param yaml - YAML string to deserialize
   * @param config - Configuration for this deserialization
   * @returns Deserialized object
   */
  static deserializeWith(yaml, config) {
    const deserializer = new _YamlDeserializer(config);
    return deserializer.deserialize(yaml);
  }
};

// ../../enhanced/serialization/xml/mod.ts
init_define_BUILD_INFO();

// ../../enhanced/serialization/xml/xml_serializer.ts
init_define_BUILD_INFO();
var import_fast_xml_parser = __toESM(require_fxp());

// ../../enhanced/serialization/xml/xml_config.ts
init_define_BUILD_INFO();
var DEFAULT_XML_SERIALIZATION_CONFIG = {
  rootElement: "",
  includeDeclaration: true,
  version: "1.0",
  encoding: "UTF-8",
  useNamespaces: true,
  namespace: "http://schemas.openehr.org/v1",
  prettyPrint: false,
  indent: "  "
};
var DEFAULT_XML_DESERIALIZATION_CONFIG = {
  strict: true,
  preserveOrder: false,
  ignoreAttributes: false
};

// ../../enhanced/serialization/xml/xml_serializer.ts
var XmlSerializer = class {
  config;
  /**
   * Create a new XML serializer
   * @param config - Serialization configuration options
   */
  constructor(config) {
    this.config = {
      ...DEFAULT_XML_SERIALIZATION_CONFIG,
      ...config
    };
  }
  /**
   * Serialize an RM object to XML string
   * @param obj - The object to serialize
   * @returns XML string representation
   */
  serialize(obj) {
    return this.serializeWith(obj, this.config);
  }
  /**
   * Serialize with custom configuration (one-time use)
   * @param obj - The object to serialize
   * @param config - Custom configuration for this serialization
   * @returns XML string representation
   */
  serializeWith(obj, config) {
    const mergedConfig = {
      ...this.config,
      ...config
    };
    try {
      const xmlObj = this.objectToXml(obj, mergedConfig);
      const builder = new import_fast_xml_parser.XMLBuilder({
        ignoreAttributes: false,
        attributeNamePrefix: "@_",
        format: mergedConfig.prettyPrint,
        indentBy: mergedConfig.indent,
        suppressEmptyNode: true,
        suppressBooleanAttributes: false
      });
      let xml = builder.build(xmlObj);
      if (mergedConfig.includeDeclaration) {
        const declaration = `<?xml version="${mergedConfig.version}" encoding="${mergedConfig.encoding}"?>`;
        xml = mergedConfig.prettyPrint ? `${declaration}
${xml}` : `${declaration}${xml}`;
      }
      return xml;
    } catch (error) {
      throw new SerializationError(
        `Failed to serialize object to XML: ${error.message}`,
        obj,
        error
      );
    }
  }
  /**
   * Convert an object to XML-friendly structure
   */
  objectToXml(obj, config) {
    if (obj === null || obj === void 0) {
      return null;
    }
    if (typeof obj !== "object") {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.objectToXml(item, config));
    }
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    const rootElement = config.rootElement || typeName?.toLowerCase() || "object";
    const xmlObj = {};
    const rootContent = {};
    if (config.useNamespaces) {
      rootContent["@_xmlns"] = config.namespace;
      rootContent["@_xmlns:xsi"] = "http://www.w3.org/2001/XMLSchema-instance";
    }
    if (typeName) {
      rootContent["@_xsi:type"] = typeName;
    }
    for (const [key, value] of Object.entries(obj)) {
      if (key.startsWith("_")) {
        continue;
      }
      if (value === null || value === void 0) {
        continue;
      }
      if (key === "archetype_node_id") {
        rootContent[`@_${key}`] = value;
        continue;
      }
      if (typeof value === "object" && !Array.isArray(value)) {
        rootContent[key] = this.convertNestedObject(value, config);
      } else if (Array.isArray(value)) {
        rootContent[key] = value.map(
          (item) => typeof item === "object" ? this.convertNestedObject(item, config) : typeof item === "number" ? this.formatNumber(item) : item
        );
      } else {
        rootContent[key] = typeof value === "number" ? this.formatNumber(value) : value;
      }
    }
    xmlObj[rootElement] = rootContent;
    return xmlObj;
  }
  /**
   * Helper to format numbers with dot separator
   */
  formatNumber(value) {
    if (Number.isInteger(value)) {
      return value;
    }
    const str = value.toString();
    if (str.includes(",")) {
      return str.replace(",", ".");
    }
    return str;
  }
  /**
   * Convert a nested object to XML structure
   */
  convertNestedObject(obj, config) {
    if (obj === null || obj === void 0) {
      return null;
    }
    if (typeof obj !== "object") {
      return typeof obj === "number" ? this.formatNumber(obj) : obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.convertNestedObject(item, config));
    }
    const result2 = {};
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    if (typeName) {
      result2["@_xsi:type"] = typeName;
    }
    for (const [key, value] of Object.entries(obj)) {
      if (key.startsWith("_")) {
        continue;
      }
      if (value === null || value === void 0) {
        continue;
      }
      if (typeof value === "object") {
        result2[key] = this.convertNestedObject(value, config);
      } else {
        result2[key] = typeof value === "number" ? this.formatNumber(value) : value;
      }
    }
    return result2;
  }
};

// ../../enhanced/serialization/xml/xml_deserializer.ts
init_define_BUILD_INFO();
var import_fast_xml_parser2 = __toESM(require_fxp());
var XmlDeserializer = class {
  config;
  /**
   * Create a new XML deserializer
   * @param config - Deserialization configuration options
   */
  constructor(config) {
    this.config = {
      ...DEFAULT_XML_DESERIALIZATION_CONFIG,
      ...config
    };
  }
  /**
   * Deserialize XML string to RM object
   * Type is inferred from root element or xsi:type attribute
   * @param xml - The XML string to deserialize
   * @returns The deserialized object
   */
  deserialize(xml) {
    try {
      const parser = new import_fast_xml_parser2.XMLParser({
        ignoreAttributes: this.config.ignoreAttributes,
        attributeNamePrefix: "@_",
        parseAttributeValue: false,
        parseTagValue: true,
        trimValues: true,
        isArray: (name, jpath, isLeafNode, isAttribute) => {
          return false;
        }
      });
      const parsed = parser.parse(xml);
      const rootKey = Object.keys(parsed)[0];
      const rootData = parsed[rootKey];
      return this.reconstructObject(rootData, rootKey);
    } catch (error) {
      throw new DeserializationError(
        `Failed to deserialize XML: ${error.message}`,
        xml,
        error
      );
    }
  }
  /**
   * Deserialize with explicit type (when type info is missing or ambiguous)
   * @param xml - The XML string to deserialize
   * @param type - The class constructor to use
   * @returns The deserialized object
   */
  deserializeAs(xml, type) {
    try {
      const parser = new import_fast_xml_parser2.XMLParser({
        ignoreAttributes: this.config.ignoreAttributes,
        attributeNamePrefix: "@_",
        parseAttributeValue: false,
        parseTagValue: true,
        trimValues: true
      });
      const parsed = parser.parse(xml);
      const rootKey = Object.keys(parsed)[0];
      const rootData = parsed[rootKey];
      const typeName = TypeRegistry.getTypeName(type);
      if (!typeName) {
        throw new TypeNotFoundError(type.name, xml);
      }
      return this.reconstructObject(rootData, rootKey, typeName);
    } catch (error) {
      if (error instanceof DeserializationError) {
        throw error;
      }
      throw new DeserializationError(
        `Failed to deserialize XML as ${type.name}: ${error.message}`,
        xml,
        error
      );
    }
  }
  /**
   * Reconstruct an object from parsed XML data
   */
  reconstructObject(data, elementName, explicitType) {
    if (data === null || data === void 0) {
      return null;
    }
    if (typeof data !== "object") {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map(
        (item) => typeof item === "object" ? this.reconstructObject(item, elementName) : item
      );
    }
    let typeName = explicitType;
    if (!typeName && data["@_xsi:type"]) {
      typeName = data["@_xsi:type"];
    }
    if (!typeName) {
      typeName = elementName.toUpperCase();
    }
    const Constructor = TypeRegistry.getConstructor(typeName);
    if (!Constructor) {
      if (this.config.strict) {
        throw new TypeNotFoundError(typeName, JSON.stringify(data));
      }
      return this.reconstructPlainObject(data);
    }
    const instance = new Constructor();
    for (const [key, value] of Object.entries(data)) {
      if (key.startsWith("@_")) {
        if (key === "@_archetype_node_id") {
          instance.archetype_node_id = value;
        } else if (key === "@_xsi:type") {
          continue;
        }
        continue;
      }
      if (typeof value === "object" && value !== null) {
        if (Array.isArray(value)) {
          instance[key] = value.map(
            (item) => typeof item === "object" ? this.reconstructObject(item, key) : item
          );
        } else {
          instance[key] = this.reconstructObject(value, key);
        }
      } else {
        instance[key] = value;
      }
    }
    return instance;
  }
  /**
   * Reconstruct as plain object (when type is not found and not in strict mode)
   */
  reconstructPlainObject(data) {
    if (typeof data !== "object" || data === null) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((item) => this.reconstructPlainObject(item));
    }
    const result2 = {};
    for (const [key, value] of Object.entries(data)) {
      if (key.startsWith("@_")) {
        const propName = key.substring(2);
        result2[propName] = value;
      } else if (typeof value === "object") {
        result2[key] = this.reconstructPlainObject(value);
      } else {
        result2[key] = value;
      }
    }
    return result2;
  }
};

// ../../enhanced/serialization/typescript/mod.ts
init_define_BUILD_INFO();

// ../../enhanced/serialization/typescript/typescript_constructor_serializer.ts
init_define_BUILD_INFO();
var DEFAULT_TYPESCRIPT_CONSTRUCTOR_CONFIG = {
  useTerseFormat: true,
  usePrimitiveConstructors: true,
  includeComments: false,
  includeUndefinedAttributes: false,
  indent: 2,
  archetypeNodeIdLocation: "after_name"
};
var TypeScriptConstructorSerializer = class {
  config;
  usedTypes = /* @__PURE__ */ new Set();
  /**
   * Create a TypeScript constructor serializer
   * @param config - Serialization configuration
   */
  constructor(config = {}) {
    this.config = { ...DEFAULT_TYPESCRIPT_CONSTRUCTOR_CONFIG, ...config };
  }
  /**
   * Serialize an RM object to TypeScript constructor code
   * 
   * @param obj - The object to serialize
   * @param variableName - Optional variable name (default: inferred from type)
   * @returns TypeScript code string
   * @throws SerializationError if serialization fails
   */
  serialize(obj, variableName) {
    try {
      this.usedTypes = /* @__PURE__ */ new Set();
      const typeName = TypeRegistry.getTypeNameFromInstance(obj);
      if (!typeName) {
        throw new SerializationError("Cannot serialize object without type information", obj);
      }
      const varName = variableName || this.getDefaultVariableName(typeName);
      const constructorCode = this.generateConstructorCall(obj, 0);
      const rmTypes = [];
      const baseTypes = [];
      for (const type of this.usedTypes) {
        if (this.isBaseType(type)) {
          baseTypes.push(type);
        } else {
          rmTypes.push(type);
        }
      }
      let code = "";
      if (rmTypes.length > 0) {
        code += `import { ${rmTypes.sort().join(", ")} } from './enhanced/openehr_rm.ts';
`;
      }
      if (baseTypes.length > 0) {
        code += `import { ${baseTypes.sort().join(", ")} } from './enhanced/openehr_base.ts';
`;
      }
      if (code) {
        code += "\n";
      }
      code += `const ${varName} = ${constructorCode};
`;
      return code;
    } catch (error) {
      throw new SerializationError(
        `Failed to serialize to TypeScript: ${error instanceof Error ? error.message : String(error)}`,
        obj,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Generate a constructor call for an object
   */
  generateConstructorCall(obj, depth) {
    if (obj === null || obj === void 0) {
      return "undefined";
    }
    if (typeof obj === "string") {
      return JSON.stringify(obj);
    }
    if (typeof obj === "number" || typeof obj === "boolean") {
      return String(obj);
    }
    if (Array.isArray(obj)) {
      return this.generateArrayCode(obj, depth);
    }
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    if (!typeName) {
      return this.generatePlainObjectCode(obj, depth);
    }
    this.usedTypes.add(typeName);
    if (this.config.useTerseFormat) {
      const terseForm = this.getTerseForm(obj, typeName);
      if (terseForm !== null) {
        return JSON.stringify(terseForm);
      }
    }
    if (this.config.usePrimitiveConstructors && this.isPrimitiveWrapper(typeName)) {
      const keys = this.getAllPropertyNames(obj).filter((k2) => !k2.startsWith("_") && !k2.startsWith("$") && k2 !== "constructor");
      const keysWithValues = keys.filter((k2) => obj[k2] !== void 0);
      if (keysWithValues.length === 1 && keysWithValues[0] === "value" && (typeof obj.value === "string" || typeof obj.value === "number" || typeof obj.value === "boolean")) {
        return this.generateConstructorCall(obj.value, depth);
      }
    }
    return `new ${typeName}(${this.generateInitializationObject(obj, depth + 1)})`;
  }
  /**
   * Generate array code
   */
  generateArrayCode(arr, depth) {
    if (arr.length === 0) {
      return "[]";
    }
    const indentStr = " ".repeat(this.config.indent * (depth + 1));
    const items = arr.map(
      (item) => indentStr + this.generateConstructorCall(item, depth + 1)
    ).join(",\n");
    return `[
${items}
${" ".repeat(this.config.indent * depth)}]`;
  }
  /**
   * Generate plain object code
   */
  generatePlainObjectCode(obj, depth) {
    const indentStr = " ".repeat(this.config.indent * (depth + 1));
    const properties = [];
    for (const [key, value] of Object.entries(obj)) {
      if (key.startsWith("_") || key === "constructor") {
        continue;
      }
      const valueCode = this.generateConstructorCall(value, depth + 1);
      properties.push(`${indentStr}${key}: ${valueCode}`);
    }
    if (properties.length === 0) {
      return "{}";
    }
    return `{
${properties.join(",\n")}
${" ".repeat(this.config.indent * depth)}}`;
  }
  /**
   * Generate initialization object for a constructor
   */
  generateInitializationObject(obj, depth) {
    const indentStr = " ".repeat(this.config.indent * depth);
    const properties = [];
    const typeName = TypeRegistry.getTypeNameFromInstance(obj);
    let keys = this.getAllPropertyNames(obj);
    if (this.config.includeUndefinedAttributes && typeName) {
      keys = this.getAllPossibleKeys(typeName, keys);
    }
    const hasArchetypeNodeId = keys.includes("archetype_node_id");
    const hasName = keys.includes("name");
    let orderedKeys = [];
    if (hasArchetypeNodeId && hasName) {
      const location = this.config.archetypeNodeIdLocation;
      const otherKeys = keys.filter((k2) => k2 !== "archetype_node_id" && k2 !== "name");
      if (location === "beginning") {
        orderedKeys = ["archetype_node_id", "name", ...otherKeys];
      } else if (location === "after_name") {
        orderedKeys = ["name", "archetype_node_id", ...otherKeys];
      } else {
        orderedKeys = ["name", ...otherKeys, "archetype_node_id"];
      }
    } else {
      orderedKeys = keys;
    }
    for (const key of orderedKeys) {
      if (key.startsWith("_") || key === "constructor") {
        continue;
      }
      const value = obj[key];
      if (value === void 0) {
        if (this.config.includeUndefinedAttributes) {
          if (this.config.includeComments) {
            properties.push(`${indentStr}${key}: undefined  // TODO: Set value`);
          } else {
            properties.push(`${indentStr}${key}: undefined`);
          }
        }
        continue;
      }
      const valueCode = this.generateConstructorCall(value, depth);
      let propertyLine = `${indentStr}${key}: ${valueCode}`;
      if (this.config.includeComments) {
        const comment = this.getPropertyComment(typeName, key, value);
        if (comment) {
          propertyLine += `  // ${comment}`;
        }
      }
      properties.push(propertyLine);
    }
    if (properties.length === 0) {
      return "{}";
    }
    return `{
${properties.join(",\n")}
${" ".repeat(this.config.indent * (depth - 1))}}`;
  }
  /**
   * Get all property names from an object, including getters
   */
  getAllPropertyNames(obj) {
    if (!obj || typeof obj !== "object")
      return [];
    const allProperties = /* @__PURE__ */ new Set();
    Object.keys(obj).forEach((key) => {
      if (!key.startsWith("_") && !key.startsWith("$")) {
        allProperties.add(key);
      }
    });
    let proto = Object.getPrototypeOf(obj);
    while (proto && proto !== Object.prototype) {
      Object.getOwnPropertyNames(proto).forEach((key) => {
        if (key !== "constructor" && !key.startsWith("_") && !key.startsWith("$")) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          if (descriptor && descriptor.get) {
            allProperties.add(key);
          }
        }
      });
      proto = Object.getPrototypeOf(proto);
    }
    return Array.from(allProperties);
  }
  /**
   * Get all possible keys for a type (including undefined ones)
   */
  getAllPossibleKeys(typeName, existingKeys) {
    return existingKeys;
  }
  /**
   * Get terse form for CODE_PHRASE or DV_CODED_TEXT
   */
  getTerseForm(obj, typeName) {
    if (typeName === "CODE_PHRASE") {
      const terminologyId = obj.terminology_id?.value;
      const codeString = obj.code_string;
      if (terminologyId && codeString) {
        return `${terminologyId}::${codeString}`;
      }
    } else if (typeName === "DV_CODED_TEXT") {
      const value = obj.value;
      const definingCode = obj.defining_code;
      if (definingCode) {
        const terminologyId = definingCode.terminology_id?.value;
        const codeString = definingCode.code_string;
        if (terminologyId && codeString) {
          return `${terminologyId}::${codeString}|${value || ""}|`;
        }
      }
    }
    return null;
  }
  /**
   * Check if a type is a primitive wrapper
   */
  isPrimitiveWrapper(typeName) {
    const primitiveWrappers = [
      "DV_TEXT",
      "DV_CODED_TEXT",
      "TERMINOLOGY_ID",
      "OBJECT_VERSION_ID",
      "ARCHETYPE_ID",
      "TEMPLATE_ID",
      "HIER_OBJECT_ID",
      "GENERIC_ID"
    ];
    return primitiveWrappers.includes(typeName);
  }
  /**
   * Check if a type belongs to the BASE package
   */
  isBaseType(typeName) {
    const baseTypes = [
      "TERMINOLOGY_ID",
      "CODE_PHRASE",
      "ARCHETYPE_ID",
      "OBJECT_VERSION_ID",
      "TEMPLATE_ID",
      "GENERIC_ID",
      "OBJECT_ID",
      "UID_BASED_ID",
      "HIER_OBJECT_ID",
      "PARTY_REF",
      "OBJECT_REF",
      "LOCATABLE_REF",
      "ACCESS_GROUP_REF",
      "VERSIONED_OBJECT_REF",
      "Boolean",
      "Integer",
      "Integer64",
      "Real",
      "Any",
      "Ordered",
      "Ordered_Numeric"
    ];
    return baseTypes.includes(typeName);
  }
  /**
   * Get default variable name from type name
   */
  getDefaultVariableName(typeName) {
    const name = typeName.toLowerCase();
    if (name.includes("_")) {
      return name.split("_").map(
        (word, i3) => i3 === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1)
      ).join("");
    }
    return name;
  }
  /**
   * Get a comment for a property (for includeComments mode)
   */
  getPropertyComment(typeName, key, value) {
    return null;
  }
};

// src/converter.ts
var typeRegistryInitialized = false;
function initializeTypeRegistry() {
  if (typeRegistryInitialized) {
    return;
  }
  try {
    TypeRegistry.registerModule(openehr_rm_exports);
    TypeRegistry.registerModule(openehr_base_exports);
    typeRegistryInitialized = true;
    console.log("\u2713 TypeRegistry initialized with", TypeRegistry.getAllTypeNames().length, "types");
  } catch (error) {
    console.error("Failed to initialize TypeRegistry:", error);
    throw error;
  }
}
async function convert(input, options) {
  if (!typeRegistryInitialized) {
    initializeTypeRegistry();
  }
  try {
    const rmObject = await deserializeInput(input, options.inputFormat, options.inputDeserializerConfig);
    const outputs = {};
    for (const format of options.outputFormats) {
      try {
        switch (format) {
          case "xml":
            outputs.xml = serializeToXml(rmObject, options.xmlConfig);
            break;
          case "json":
            outputs.json = serializeToJson(rmObject, options.jsonSerializerType, options.jsonConfig);
            break;
          case "yaml":
            outputs.yaml = serializeToYaml(rmObject, options.yamlConfig);
            break;
          case "typescript":
            outputs.typescript = generateTypeScriptCode(rmObject, options.typescriptConfig);
            break;
        }
      } catch (error) {
        console.error(`Failed to serialize to ${format}:`, error);
        throw new Error(`Failed to convert to ${format}: ${error.message}`);
      }
    }
    return {
      success: true,
      outputs
    };
  } catch (error) {
    console.error("Conversion error:", error);
    return {
      success: false,
      error: error.message,
      errorDetails: error
    };
  }
}
async function deserializeInput(input, format, config) {
  switch (format) {
    case "json": {
      const deserializer = new JsonConfigurableDeserializer(config);
      return deserializer.deserialize(input);
    }
    case "yaml": {
      const deserializer = new YamlDeserializer(config);
      return deserializer.deserialize(input);
    }
    case "xml": {
      const deserializer = new XmlDeserializer();
      return deserializer.deserialize(input);
    }
    default:
      throw new Error(`Unsupported input format: ${format}`);
  }
}
function serializeToJson(obj, serializerType, config) {
  if (serializerType === "canonical") {
    const serializer = new JsonCanonicalSerializer();
    return serializer.serialize(obj, {
      prettyPrint: config.prettyPrint,
      indent: config.indent,
      archetypeNodeIdLocation: config.archetypeNodeIdLocation
    });
  } else {
    const serializer = new JsonConfigurableSerializer(config);
    return serializer.serialize(obj);
  }
}
function serializeToYaml(obj, config) {
  const serializer = new YamlSerializer(config);
  return serializer.serialize(obj);
}
function serializeToXml(obj, config) {
  const serializer = new XmlSerializer({
    prettyPrint: config.prettyPrint,
    indent: " ".repeat(config.indent),
    // Convert number to string of spaces
    includeDeclaration: config.includeDeclaration,
    useNamespaces: config.includeNamespaces
  });
  return serializer.serialize(obj);
}
function generateTypeScriptCode(obj, config) {
  const serializer = new TypeScriptConstructorSerializer(config);
  return serializer.serialize(obj);
}
function getJsonConfigPreset(preset) {
  switch (preset) {
    case "canonical":
      return CANONICAL_JSON_CONFIG;
    case "compact":
      return COMPACT_JSON_CONFIG;
    case "hybrid":
      return HYBRID_JSON_CONFIG;
    case "very-compact":
      return NON_STANDARD_VERY_COMPACT_JSON_CONFIG;
    default:
      return DEFAULT_JSON_SERIALIZATION_CONFIG;
  }
}
function getJsonDeserializeConfigPreset(preset) {
  switch (preset) {
    case "canonical":
      return CANONICAL_JSON_DESERIALIZE_CONFIG;
    case "compact":
      return COMPACT_JSON_DESERIALIZE_CONFIG;
    case "hybrid":
      return HYBRID_JSON_DESERIALIZE_CONFIG;
    default:
      return DEFAULT_JSON_DESERIALIZATION_CONFIG;
  }
}
function getYamlConfigPreset(preset) {
  switch (preset) {
    case "verbose":
      return VERBOSE_YAML_CONFIG;
    case "hybrid":
      return HYBRID_YAML_CONFIG;
    case "flow":
      return FLOW_YAML_CONFIG;
    case "block":
      return BLOCK_YAML_CONFIG;
    default:
      return DEFAULT_YAML_SERIALIZATION_CONFIG;
  }
}

// src/main.ts
var currentInputFormat = "json";
function init2() {
  console.log("\u{1F680} ehrtslib Format Converter initialized");
  try {
    initializeTypeRegistry();
  } catch (error) {
    console.error("Failed to initialize TypeRegistry:", error);
    showError("Failed to initialize application. Please refresh the page.");
    return;
  }
  displayBuildInfo();
  setupEventListeners();
  loadExample("section");
  setTimeout(() => {
    handleConvert();
  }, 100);
  console.log("\u2713 Application ready");
}
function setupEventListeners() {
  const inputFormatSelect = document.getElementById("input-format");
  if (inputFormatSelect) {
    inputFormatSelect.addEventListener("change", handleInputFormatChange);
  }
  const loadExampleBtn = document.getElementById("load-example");
  const exampleMenu = document.getElementById("example-menu");
  if (loadExampleBtn && exampleMenu) {
    loadExampleBtn.addEventListener("click", () => {
      exampleMenu.classList.toggle("hidden");
    });
    const exampleItems = exampleMenu.querySelectorAll(".example-item");
    exampleItems.forEach((item) => {
      item.addEventListener("click", (e2) => {
        const exampleKey = e2.target.getAttribute("data-example");
        if (exampleKey) {
          loadExample(exampleKey);
          exampleMenu.classList.add("hidden");
        }
      });
    });
  }
  const uploadBtn = document.getElementById("upload-file");
  const fileInput = document.getElementById("file-input");
  if (uploadBtn && fileInput) {
    uploadBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", handleFileUpload);
  }
  const clearBtn = document.getElementById("clear-input");
  if (clearBtn) {
    clearBtn.addEventListener("click", clearInput);
  }
  const inputTextarea = document.getElementById("input-text");
  if (inputTextarea) {
    inputTextarea.addEventListener("input", handleInputChange);
  }
  const inputDisableLinebreaks = document.getElementById("input-disable-linebreaks");
  if (inputDisableLinebreaks) {
    applyInputLineWrap(!!inputDisableLinebreaks.checked);
    inputDisableLinebreaks.addEventListener("change", () => {
      applyInputLineWrap(!!inputDisableLinebreaks.checked);
      handleInputChange();
    });
  }
  const convertBtn = document.getElementById("convert-btn");
  if (convertBtn) {
    convertBtn.addEventListener("click", handleConvert);
  }
  setupPresetListeners();
  setupOutputTabs();
  setupSplitters();
  setupCopyDownloadButtons();
  const dismissErrorBtn = document.getElementById("dismiss-error");
  if (dismissErrorBtn) {
    dismissErrorBtn.addEventListener("click", hideError);
  }
  setupOutputVisibilityListeners();
  setupCollapsibleSections();
}
function setupOutputVisibilityListeners() {
  const formats = ["xml", "json", "yaml", "typescript"];
  formats.forEach((format) => {
    const checkbox = document.getElementById(`output-${format}`);
    if (checkbox) {
      toggleOutputTab(format, checkbox.checked);
      checkbox.addEventListener("change", () => {
        toggleOutputTab(format, checkbox.checked);
      });
    }
  });
}
function toggleOutputTab(format, visible) {
  const tabs = document.querySelectorAll(".tab");
  let tabBtn = null;
  tabs.forEach((t2) => {
    if (t2.getAttribute("data-tab") === format) {
      tabBtn = t2;
    }
  });
  const optionsSection = document.getElementById(`${format}-options`);
  if (!tabBtn)
    return;
  if (visible) {
    tabBtn.classList.remove("hidden");
    if (optionsSection) {
      optionsSection.classList.remove("hidden");
    }
  } else {
    tabBtn.classList.add("hidden");
    if (optionsSection) {
      optionsSection.classList.add("hidden");
    }
    if (tabBtn.classList.contains("active")) {
      const visibleTab = Array.from(document.querySelectorAll(".tab")).find((t2) => !t2.classList.contains("hidden"));
      if (visibleTab) {
        const targetFormat = visibleTab.getAttribute("data-tab");
        if (targetFormat) {
          switchOutputTab(targetFormat);
        }
      }
    }
  }
}
function setupSplitters() {
  const splitterO1 = document.getElementById("splitter-1");
  const splitterO2 = document.getElementById("splitter-2");
  if (splitterO1) {
    setupSplitter(splitterO1, "input-panel", "options-panel");
  }
  if (splitterO2) {
    setupSplitter(splitterO2, "options-panel", "output-panel");
  }
}
function setupSplitter(splitter, leftClass, rightClass) {
  let isDragging = false;
  let startX;
  let leftWidth;
  let rightWidth;
  const mainContent = document.querySelector(".main-content");
  splitter.addEventListener("mousedown", (e2) => {
    isDragging = true;
    startX = e2.clientX;
    splitter.classList.add("active");
    const panels = Array.from(document.querySelectorAll(".panel"));
    e2.preventDefault();
    document.body.style.cursor = "col-resize";
  });
  document.addEventListener("mousemove", (e2) => {
    if (!isDragging)
      return;
    const deltaX = e2.clientX - startX;
    startX = e2.clientX;
    const prev = splitter.previousElementSibling;
    const next = splitter.nextElementSibling;
    if (prev && next) {
      const prevRect = prev.getBoundingClientRect();
      const nextRect = next.getBoundingClientRect();
      const newPrevWidth = prevRect.width + deltaX;
      const newNextWidth = nextRect.width - deltaX;
      if (newPrevWidth > 200 && newNextWidth > 200) {
        prev.style.flex = `0 0 ${newPrevWidth}px`;
        next.style.flex = `0 0 ${newNextWidth}px`;
        prev.style.width = `${newPrevWidth}px`;
        next.style.width = `${newNextWidth}px`;
      }
      startX = e2.clientX;
    }
  });
  document.addEventListener("mouseup", () => {
    if (isDragging) {
      isDragging = false;
      splitter.classList.remove("active");
      document.body.style.cursor = "";
    }
  });
}
function setupPresetListeners() {
  const inputDeserializerPreset = document.getElementById("input-deserializer-preset");
  if (inputDeserializerPreset) {
    inputDeserializerPreset.addEventListener("change", (e2) => {
      const preset = e2.target.value;
      updateInputDeserializerOptions(preset);
    });
  }
  const jsonConfigPreset = document.getElementById("json-config-preset");
  if (jsonConfigPreset) {
    jsonConfigPreset.addEventListener("change", (e2) => {
      const preset = e2.target.value;
      updateJsonOptions(preset);
    });
  }
  const jsonSerializerType = document.getElementById("json-serializer-type");
  if (jsonSerializerType) {
    jsonSerializerType.addEventListener("change", () => {
      const preset = jsonConfigPreset?.value || "custom";
      updateJsonOptions(preset);
    });
  }
  const yamlConfigPreset = document.getElementById("yaml-config-preset");
  if (yamlConfigPreset) {
    yamlConfigPreset.addEventListener("change", (e2) => {
      const preset = e2.target.value;
      updateYamlOptions(preset);
    });
  }
  const xmlConfigPreset = document.getElementById("xml-config-preset");
  if (xmlConfigPreset) {
    xmlConfigPreset.addEventListener("change", (e2) => {
      const preset = e2.target.value;
      updateXmlOptions(preset);
    });
  }
}
function setupOutputTabs() {
  const tabs = document.querySelectorAll(".tab");
  tabs.forEach((tab) => {
    tab.addEventListener("click", (e2) => {
      const tabName = e2.target.getAttribute("data-tab");
      if (tabName) {
        switchOutputTab(tabName);
      }
    });
  });
}
function setupCopyDownloadButtons() {
  const formats = ["xml", "json", "yaml", "typescript"];
  formats.forEach((format) => {
    const copyBtn = document.getElementById(`copy-${format}`);
    const downloadBtn = document.getElementById(`download-${format}`);
    if (copyBtn) {
      copyBtn.addEventListener("click", () => copyToClipboard(format));
    }
    if (downloadBtn) {
      downloadBtn.addEventListener("click", () => downloadOutput(format));
    }
  });
}
function handleInputFormatChange(e2) {
  currentInputFormat = e2.target.value;
  validateInput();
}
function loadExample(exampleKey) {
  const example = EXAMPLES[exampleKey];
  if (!example) {
    console.error("Example not found:", exampleKey);
    return;
  }
  const inputTextarea = document.getElementById("input-text");
  const formatSelect = document.getElementById("input-format");
  if (inputTextarea && formatSelect) {
    const format = formatSelect.value;
    inputTextarea.value = example[format] || example.json;
    currentInputFormat = format;
    handleInputChange();
  }
}
async function handleFileUpload(e2) {
  const file = e2.target.files?.[0];
  if (!file)
    return;
  try {
    const text = await file.text();
    const inputTextarea = document.getElementById("input-text");
    if (inputTextarea) {
      inputTextarea.value = text;
      handleInputChange();
      const ext = file.name.split(".").pop()?.toLowerCase();
      if (ext === "xml" || ext === "json" || ext === "yaml" || ext === "yml") {
        const formatSelect = document.getElementById("input-format");
        if (formatSelect) {
          formatSelect.value = ext === "yml" ? "yaml" : ext;
          currentInputFormat = formatSelect.value;
        }
      }
    }
  } catch (error) {
    console.error("Error reading file:", error);
    showError("Failed to read file: " + error.message);
  }
}
function clearInput() {
  const inputTextarea = document.getElementById("input-text");
  if (inputTextarea) {
    inputTextarea.value = "";
    handleInputChange();
  }
}
function handleInputChange() {
  const inputTextarea = document.getElementById("input-text");
  if (!inputTextarea)
    return;
  const text = inputTextarea.value;
  const charCount = document.getElementById("char-count");
  if (charCount) {
    charCount.textContent = text.length.toString();
  }
  const lineCount = document.getElementById("line-count");
  if (lineCount) {
    lineCount.textContent = text.split("\n").length.toString();
  }
  validateInput();
}
function validateInput() {
  const inputTextarea = document.getElementById("input-text");
  const validationIcon = document.getElementById("validation-icon");
  const validationText = document.getElementById("validation-text");
  if (!inputTextarea || !validationIcon || !validationText)
    return;
  const text = inputTextarea.value.trim();
  if (!text) {
    validationIcon.textContent = "\u25CB";
    validationIcon.className = "status-icon";
    validationText.textContent = "Empty";
    return;
  }
  try {
    if (currentInputFormat === "json") {
      JSON.parse(text);
      validationIcon.textContent = "\u2713";
      validationIcon.className = "status-icon valid";
      validationText.textContent = "Valid JSON";
    } else if (currentInputFormat === "xml") {
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, "text/xml");
      const parseError = doc.querySelector("parsererror");
      if (parseError) {
        throw new Error("XML parse error");
      }
      validationIcon.textContent = "\u2713";
      validationIcon.className = "status-icon valid";
      validationText.textContent = "Valid XML";
    } else if (currentInputFormat === "yaml") {
      validationIcon.textContent = "\u2713";
      validationIcon.className = "status-icon valid";
      validationText.textContent = "Assumed valid YAML";
    }
  } catch (error) {
    validationIcon.textContent = "\u2717";
    validationIcon.className = "status-icon invalid";
    validationText.textContent = `Invalid ${currentInputFormat.toUpperCase()}`;
  }
}
async function handleConvert() {
  console.log("\u{1F504} Converting...");
  showLoading();
  hideError();
  try {
    const inputTextarea = document.getElementById("input-text");
    if (!inputTextarea)
      throw new Error("Input textarea not found");
    const inputText = inputTextarea.value.trim();
    if (!inputText)
      throw new Error("Input is empty");
    const options = gatherConversionOptions();
    const result2 = await convert(inputText, options);
    hideLoading();
    if (!result2.success) {
      showError(result2.error || "Conversion failed");
      return;
    }
    if (result2.outputs) {
      updateOutputs(result2.outputs);
    }
    console.log("\u2705 Conversion successful");
  } catch (error) {
    hideLoading();
    console.error("Conversion error:", error);
    showError(error.message);
  }
}
function gatherConversionOptions() {
  const inputFormatSelect = document.getElementById("input-format");
  const inputFormat = inputFormatSelect?.value || "json";
  const inputDeserializerPreset = document.getElementById("input-deserializer-preset")?.value || "default";
  const inputDeserializerConfig = getJsonDeserializeConfigPreset(inputDeserializerPreset);
  const outputFormats = [];
  if (document.getElementById("output-xml")?.checked) {
    outputFormats.push("xml");
  }
  if (document.getElementById("output-json")?.checked) {
    outputFormats.push("json");
  }
  if (document.getElementById("output-yaml")?.checked) {
    outputFormats.push("yaml");
  }
  if (document.getElementById("output-typescript")?.checked) {
    outputFormats.push("typescript");
  }
  const jsonSerializerType = document.getElementById("json-serializer-type")?.value || "configurable";
  const jsonConfigPreset = document.getElementById("json-config-preset")?.value || "canonical";
  const jsonConfig = getJsonConfigPreset(jsonConfigPreset);
  const jsonArchIdLoc = document.getElementById("json-arch-id-location")?.value;
  if (jsonArchIdLoc)
    jsonConfig.archetypeNodeIdLocation = jsonArchIdLoc;
  if (jsonConfigPreset === "custom") {
    const indent = parseInt(document.getElementById("json-indent")?.value || "2");
    jsonConfig.indent = indent;
    jsonConfig.useTerseFormat = document.getElementById("json-terse")?.checked || false;
    jsonConfig.useHybridStyle = document.getElementById("json-hybrid")?.checked || false;
  }
  const yamlConfigPreset = document.getElementById("yaml-config-preset")?.value || "default";
  const yamlConfig = getYamlConfigPreset(yamlConfigPreset);
  const yamlArchIdLoc = document.getElementById("yaml-arch-id-location")?.value;
  if (yamlArchIdLoc)
    yamlConfig.archetypeNodeIdLocation = yamlArchIdLoc;
  if (yamlConfigPreset === "custom") {
    const indent = parseInt(document.getElementById("yaml-indent")?.value || "2");
    const maxInlineProps = parseInt(document.getElementById("yaml-max-inline-props")?.value || "3");
    const mainStyle = document.getElementById("yaml-main-style")?.value;
    yamlConfig.indent = indent;
    yamlConfig.maxInlineProperties = maxInlineProps;
    yamlConfig.mainStyle = mainStyle || "hybrid";
    yamlConfig.useTerseFormat = document.getElementById("yaml-terse")?.checked !== false;
    yamlConfig.useTypeInference = document.getElementById("yaml-type-inference")?.checked !== false;
    if (mainStyle === "flow") {
      yamlConfig.keepArchetypeDetailsInline = document.getElementById("yaml-archetype-inline")?.checked !== false;
    } else {
      yamlConfig.keepArchetypeDetailsInline = false;
    }
  }
  const xmlConfigPreset = document.getElementById("xml-config-preset")?.value || "default";
  const xmlIndent = parseInt(document.getElementById("xml-indent")?.value || "2");
  const xmlConfig = {
    prettyPrint: document.getElementById("xml-pretty")?.checked !== false,
    indent: xmlIndent,
    includeDeclaration: document.getElementById("xml-declaration")?.checked !== false,
    includeNamespaces: document.getElementById("xml-namespaces")?.checked !== false
  };
  const tsIndent = parseInt(document.getElementById("ts-indent")?.value || "2");
  const typescriptConfig = {
    useTerseFormat: document.getElementById("ts-terse")?.checked !== false,
    usePrimitiveConstructors: document.getElementById("ts-compact")?.checked !== false,
    includeComments: document.getElementById("ts-comments")?.checked || false,
    indent: tsIndent,
    includeUndefinedAttributes: document.getElementById("ts-include-undefined")?.checked || false,
    archetypeNodeIdLocation: document.getElementById("ts-arch-id-location")?.value || "after_name"
  };
  return {
    inputFormat,
    inputDeserializerConfig,
    outputFormats,
    jsonSerializerType,
    jsonConfig,
    yamlConfig,
    xmlConfig,
    typescriptConfig
  };
}
function updateOutputs(outputs) {
  if (outputs.xml) {
    const xmlContent = document.getElementById("output-xml-content");
    if (xmlContent) {
      xmlContent.textContent = outputs.xml;
    }
  }
  if (outputs.json) {
    const jsonContent = document.getElementById("output-json-content");
    if (jsonContent) {
      jsonContent.textContent = outputs.json;
    }
  }
  if (outputs.yaml) {
    const yamlContent = document.getElementById("output-yaml-content");
    if (yamlContent) {
      yamlContent.textContent = outputs.yaml;
    }
  }
  if (outputs.typescript) {
    const tsContent = document.getElementById("output-typescript-content");
    if (tsContent) {
      tsContent.textContent = outputs.typescript;
    }
  }
  updateOutputInfo();
}
function updateInputDeserializerOptions(preset) {
  const strictCheckbox = document.getElementById("input-strict");
  const terseCheckbox = document.getElementById("input-parse-terse");
  const incompleteCheckbox = document.getElementById("input-allow-incomplete");
  const isCustom = preset === "custom";
  [strictCheckbox, terseCheckbox, incompleteCheckbox].forEach((checkbox) => {
    if (checkbox)
      checkbox.disabled = !isCustom;
  });
  if (!isCustom && strictCheckbox && terseCheckbox && incompleteCheckbox) {
    switch (preset) {
      case "canonical":
        strictCheckbox.checked = true;
        terseCheckbox.checked = false;
        incompleteCheckbox.checked = false;
        break;
      case "compact":
        strictCheckbox.checked = false;
        terseCheckbox.checked = true;
        incompleteCheckbox.checked = false;
        break;
      case "hybrid":
        strictCheckbox.checked = false;
        terseCheckbox.checked = true;
        incompleteCheckbox.checked = true;
        break;
      default:
        strictCheckbox.checked = false;
        terseCheckbox.checked = false;
        incompleteCheckbox.checked = false;
    }
  }
}
function updateJsonOptions(preset) {
  const prettyCheckbox = document.getElementById("json-pretty");
  const indentInput = document.getElementById("json-indent");
  const terseCheckbox = document.getElementById("json-terse");
  const hybridCheckbox = document.getElementById("json-hybrid");
  const typeInferenceCheckbox = document.getElementById("json-type-inference");
  const includeNullCheckbox = document.getElementById("json-include-null");
  const includeEmptyCheckbox = document.getElementById("json-include-empty");
  const configPresetSelect = document.getElementById("json-config-preset");
  const archIdLocSelect = document.getElementById("json-arch-id-location");
  const serializerType = document.getElementById("json-serializer-type")?.value || "configurable";
  const isCanonicalSerializer = serializerType === "canonical";
  if (isCanonicalSerializer) {
    if (configPresetSelect)
      configPresetSelect.disabled = true;
    if (prettyCheckbox)
      prettyCheckbox.disabled = false;
    if (indentInput)
      indentInput.disabled = false;
    if (archIdLocSelect)
      archIdLocSelect.disabled = false;
    [terseCheckbox, hybridCheckbox, typeInferenceCheckbox, includeNullCheckbox, includeEmptyCheckbox].forEach((elem) => {
      if (elem)
        elem.disabled = true;
    });
  } else {
    if (configPresetSelect)
      configPresetSelect.disabled = false;
    const isCustom = preset === "custom";
    [prettyCheckbox, indentInput, terseCheckbox, hybridCheckbox, typeInferenceCheckbox, includeNullCheckbox, includeEmptyCheckbox, archIdLocSelect].forEach((elem) => {
      if (elem)
        elem.disabled = !isCustom;
    });
    if (!isCustom) {
      switch (preset) {
        case "canonical":
          if (prettyCheckbox)
            prettyCheckbox.checked = true;
          if (terseCheckbox)
            terseCheckbox.checked = false;
          if (hybridCheckbox)
            hybridCheckbox.checked = false;
          if (typeInferenceCheckbox)
            typeInferenceCheckbox.checked = false;
          if (includeEmptyCheckbox)
            includeEmptyCheckbox.checked = true;
          break;
        case "compact":
          if (prettyCheckbox)
            prettyCheckbox.checked = true;
          if (terseCheckbox)
            terseCheckbox.checked = false;
          if (hybridCheckbox)
            hybridCheckbox.checked = false;
          if (typeInferenceCheckbox)
            typeInferenceCheckbox.checked = true;
          if (includeEmptyCheckbox)
            includeEmptyCheckbox.checked = false;
          break;
        case "hybrid":
          if (prettyCheckbox)
            prettyCheckbox.checked = true;
          if (terseCheckbox)
            terseCheckbox.checked = true;
          if (hybridCheckbox)
            hybridCheckbox.checked = true;
          if (typeInferenceCheckbox)
            typeInferenceCheckbox.checked = true;
          if (includeEmptyCheckbox)
            includeEmptyCheckbox.checked = false;
          break;
        case "very-compact":
          if (prettyCheckbox)
            prettyCheckbox.checked = true;
          if (terseCheckbox)
            terseCheckbox.checked = true;
          if (hybridCheckbox)
            hybridCheckbox.checked = false;
          if (typeInferenceCheckbox)
            typeInferenceCheckbox.checked = true;
          if (includeEmptyCheckbox)
            includeEmptyCheckbox.checked = false;
          break;
      }
    }
  }
}
function updateYamlOptions(preset) {
  const mainStyleSelect = document.getElementById("yaml-main-style");
  const terseCheckbox = document.getElementById("yaml-terse");
  const typeInferenceCheckbox = document.getElementById("yaml-type-inference");
  const indentInput = document.getElementById("yaml-indent");
  const maxInlinePropsInput = document.getElementById("yaml-max-inline-props");
  const archetypeInlineCheckbox = document.getElementById("yaml-archetype-inline");
  const archIdLocSelect = document.getElementById("yaml-arch-id-location");
  const isCustom = preset === "custom";
  [mainStyleSelect, terseCheckbox, typeInferenceCheckbox, indentInput, maxInlinePropsInput, archetypeInlineCheckbox, archIdLocSelect].forEach((elem) => {
    if (elem)
      elem.disabled = !isCustom;
  });
  const updateArchetypeInlineVisibility = () => {
    const mainStyle = mainStyleSelect?.value || "hybrid";
    const archetypeInlineGroup = document.getElementById("yaml-archetype-inline-group");
    if (archetypeInlineGroup) {
      if (mainStyle === "flow") {
        archetypeInlineGroup.style.display = "";
      } else {
        archetypeInlineGroup.style.display = "none";
      }
    }
  };
  if (!isCustom) {
    switch (preset) {
      case "default":
        if (mainStyleSelect)
          mainStyleSelect.value = "hybrid";
        if (terseCheckbox)
          terseCheckbox.checked = true;
        if (typeInferenceCheckbox)
          typeInferenceCheckbox.checked = true;
        if (archetypeInlineCheckbox)
          archetypeInlineCheckbox.checked = false;
        break;
      case "verbose":
        if (mainStyleSelect)
          mainStyleSelect.value = "block";
        if (terseCheckbox)
          terseCheckbox.checked = false;
        if (typeInferenceCheckbox)
          typeInferenceCheckbox.checked = false;
        if (archetypeInlineCheckbox)
          archetypeInlineCheckbox.checked = false;
        break;
      case "hybrid":
        if (mainStyleSelect)
          mainStyleSelect.value = "hybrid";
        if (terseCheckbox)
          terseCheckbox.checked = true;
        if (typeInferenceCheckbox)
          typeInferenceCheckbox.checked = true;
        if (archetypeInlineCheckbox)
          archetypeInlineCheckbox.checked = false;
        break;
      case "flow":
        if (mainStyleSelect)
          mainStyleSelect.value = "flow";
        if (terseCheckbox)
          terseCheckbox.checked = true;
        if (typeInferenceCheckbox)
          typeInferenceCheckbox.checked = true;
        if (archetypeInlineCheckbox)
          archetypeInlineCheckbox.checked = true;
        break;
      case "block":
        if (mainStyleSelect)
          mainStyleSelect.value = "block";
        if (terseCheckbox)
          terseCheckbox.checked = true;
        if (typeInferenceCheckbox)
          typeInferenceCheckbox.checked = true;
        if (archetypeInlineCheckbox)
          archetypeInlineCheckbox.checked = false;
        break;
    }
  }
  updateArchetypeInlineVisibility();
  if (mainStyleSelect && !mainStyleSelect.dataset.listenerAttached) {
    mainStyleSelect.addEventListener("change", updateArchetypeInlineVisibility);
    mainStyleSelect.dataset.listenerAttached = "true";
  }
}
function updateXmlOptions(preset) {
  const prettyCheckbox = document.getElementById("xml-pretty");
  const namespacesCheckbox = document.getElementById("xml-namespaces");
  const declarationCheckbox = document.getElementById("xml-declaration");
  const indentInput = document.getElementById("xml-indent");
  const isCustom = preset === "custom";
  [prettyCheckbox, namespacesCheckbox, declarationCheckbox, indentInput].forEach((elem) => {
    if (elem)
      elem.disabled = !isCustom;
  });
  if (!isCustom && prettyCheckbox && namespacesCheckbox && declarationCheckbox) {
    prettyCheckbox.checked = true;
    namespacesCheckbox.checked = true;
    declarationCheckbox.checked = true;
  }
}
function switchOutputTab(tabName) {
  const tabs = document.querySelectorAll(".tab");
  tabs.forEach((tab) => {
    if (tab.getAttribute("data-tab") === tabName) {
      tab.classList.add("active");
    } else {
      tab.classList.remove("active");
    }
  });
  const panes = document.querySelectorAll(".tab-pane");
  panes.forEach((pane) => {
    if (pane.id === `tab-${tabName}`) {
      pane.classList.add("active");
    } else {
      pane.classList.remove("active");
    }
  });
  updateOutputInfo();
}
function applyInputLineWrap(disable) {
  const inputTextarea = document.getElementById("input-text");
  if (!inputTextarea)
    return;
  if (disable) {
    inputTextarea.classList.add("no-linebreak");
    inputTextarea.setAttribute("wrap", "off");
    inputTextarea.style.whiteSpace = "pre";
  } else {
    inputTextarea.classList.remove("no-linebreak");
    inputTextarea.setAttribute("wrap", "soft");
    inputTextarea.style.whiteSpace = "";
  }
}
function applyOutputLineWrap(disable) {
  const outputs = document.querySelectorAll(".output-content");
  outputs.forEach((o2) => {
    const el = o2;
    if (disable) {
      el.classList.add("no-linebreak");
      el.style.whiteSpace = "pre";
      el.style.wordWrap = "normal";
    } else {
      el.classList.remove("no-linebreak");
      el.style.whiteSpace = "";
      el.style.wordWrap = "";
    }
  });
}
function updateOutputInfo() {
  const activeTab = document.querySelector(".tab.active");
  const outputChar = document.getElementById("output-char-count");
  const outputLine = document.getElementById("output-line-count");
  const outputDisable = document.getElementById("output-disable-linebreaks");
  if (!activeTab || !outputChar || !outputLine)
    return;
  const tabName = activeTab.getAttribute("data-tab") || "json";
  const contentElem = document.getElementById(`output-${tabName}-content`);
  if (!contentElem)
    return;
  const text = contentElem.textContent || "";
  outputChar.textContent = String(text.length);
  outputLine.textContent = String(text.split("\n").length);
  if (outputDisable) {
    applyOutputLineWrap(!!outputDisable.checked);
  }
}
var outputDisableCheckbox = document.getElementById("output-disable-linebreaks");
if (outputDisableCheckbox) {
  applyOutputLineWrap(!!outputDisableCheckbox.checked);
  outputDisableCheckbox.addEventListener("change", () => {
    applyOutputLineWrap(!!outputDisableCheckbox.checked);
    updateOutputInfo();
  });
}
async function copyToClipboard(format) {
  const outputElement = document.getElementById(`output-${format}-content`);
  if (!outputElement) {
    console.error("Output element not found:", format);
    return;
  }
  const text = outputElement.textContent || "";
  try {
    await navigator.clipboard.writeText(text);
    showSuccessMessage(format);
  } catch (error) {
    console.error("Failed to copy:", error);
    showError("Failed to copy to clipboard");
  }
}
function downloadOutput(format) {
  const outputElement = document.getElementById(`output-${format}-content`);
  if (!outputElement) {
    console.error("Output element not found:", format);
    return;
  }
  const text = outputElement.textContent || "";
  const extensions = {
    xml: "xml",
    json: "json",
    yaml: "yaml",
    typescript: "ts"
  };
  const ext = extensions[format] || "txt";
  const filename = `openehr_output.${ext}`;
  const blob = new Blob([text], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a2 = document.createElement("a");
  a2.href = url;
  a2.download = filename;
  document.body.appendChild(a2);
  a2.click();
  document.body.removeChild(a2);
  URL.revokeObjectURL(url);
}
function showSuccessMessage(format) {
  const successElement = document.getElementById(`success-${format}`);
  if (successElement) {
    successElement.classList.remove("hidden");
    setTimeout(() => {
      successElement.classList.add("hidden");
    }, 2e3);
  }
}
function showLoading() {
  const loadingState = document.getElementById("loading-state");
  if (loadingState) {
    loadingState.classList.remove("hidden");
  }
}
function hideLoading() {
  const loadingState = document.getElementById("loading-state");
  if (loadingState) {
    loadingState.classList.add("hidden");
  }
}
function showError(message) {
  const errorState = document.getElementById("error-state");
  const errorText = document.getElementById("error-text");
  if (errorState && errorText) {
    errorText.textContent = message;
    errorState.classList.remove("hidden");
  }
}
function hideError() {
  const errorState = document.getElementById("error-state");
  if (errorState) {
    errorState.classList.add("hidden");
  }
}
function setupCollapsibleSections() {
  const collapsibleSections = document.querySelectorAll(".option-section.collapsible");
  collapsibleSections.forEach((section) => {
    const header = section.querySelector(".section-header");
    if (header) {
      header.addEventListener("click", () => {
        section.classList.toggle("collapsed");
      });
    }
  });
}
function displayBuildInfo() {
  const buildInfoElem = document.getElementById("build-info");
  if (buildInfoElem && typeof define_BUILD_INFO_default !== "undefined") {
    const date = new Date(define_BUILD_INFO_default.timestamp);
    const dateStr = date.toLocaleDateString();
    const timeStr = date.toLocaleTimeString();
    buildInfoElem.textContent = `Build: ${define_BUILD_INFO_default.buildId} (${dateStr} ${timeStr})`;
  }
}
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", init2);
} else {
  init2();
}
/*!
 * Sizzle CSS Selector Engine v2.3.7-pre
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2022-04-02
 *
 * git commit hash for Deno DOM: ede0e97563c8473b8cfa4045c7c2cd6129ecc1aa
 */
//# sourceMappingURL=bundle.js.map
