// Generated from BMM schema: lang v1.1.0
// BMM Version: 2.4
// Schema Revision: 1.1.0.2
// Description: lang
// Source: https://raw.githubusercontent.com/sebastian-iancu/code-generator/master/code/BMM-JSON/openehr_lang_1.1.0.bmm.json
// Generated: 2025-11-10T12:36:29.656Z
// 
// This file was automatically generated from openEHR BMM (Basic Meta-Model) specifications.
// Do not edit manually - regenerate using: deno run --allow-read --allow-net --allow-write tasks/generate_ts_libs.ts
//
// For more information about openEHR specifications, visit: https://specifications.openehr.org/

// Unknown types - defined as 'any' for now
type BMM_CLASS = any;
type BMM_CONTAINER_TYPE = any;
type BMM_ENUMERATION = any;
type BMM_ENUMERATION_INTEGER = any;
type BMM_ENUMERATION_STRING = any;
type BMM_GENERIC_TYPE = any;
type BMM_INDEXED_CONTAINER_TYPE = any;
type BMM_PARAMETER_TYPE = any;
type BMM_SIMPLE_TYPE = any;
type BMM_STATUS_TYPE = any;
type BMM_TUPLE_TYPE = any;
type BMM_TYPE = any;
type BMM_UNITARY_TYPE = any;
type C_OBJECT = any;
type Iso8601_date = any;
type Iso8601_date_time = any;
type Iso8601_duration = any;
type Iso8601_time = any;
type Multiplicity_interval = any;
type T = any;
type Terminology_code = any;

/**
 * Definitions used by all BMM packages.
 */
export class BMM_DEFINITIONS {
}

/**
 * Access to BMM models that have been loaded and validated from one or more schema sets.
 */
export class BMM_MODEL_ACCESS {
    /**
     * List of directories where all the schemas loaded here are found.
     */
    schema_directories?: undefined;
    /**
     * All schemas found and loaded from \`_schema_directory_\`. Keyed by \`_schema_id_\`.
     */
    all_schemas?: undefined;
    /**
     * Top-level (root) models in use, keyed by \`_model_id_\`.
     */
    bmm_models?: undefined;
    /**
     * Validated models, keyed by \`_model_id()_\` and any shorter forms of id, with some or no versioning information. For example, the keys \`"openEHR_EHR_1.0.4"\`, \`"openEHR_EHR_1.0"\`, \`"openEHR_EHR_1"\`, and \`"openEHR_EHR"\` will all match the \`"openEHR_EHR_1.0.4"\` model, assuming it is the most recent version available.
     */
    matching_bmm_models?: undefined;
}

/**
 * Descriptor for a BMM schema. Contains a meta-data table of attributes obtained from a mini-ODIN parse of the  schema file.
 */
export class BMM_SCHEMA_DESCRIPTOR {
    /**
     * Persistent form of model.
     */
    bmm_schema?: BMM_SCHEMA;
    /**
     * Computable form of model.
     */
    bmm_model?: BMM_MODEL;
    /**
     * Schema id, formed by 
     * 
     * \`{BMM_DEFINITIONS}.create_schema_id(
     *   meta_data.item({BMM_DEFINITIONS}.Metadata_model_publisher),
     *   meta_data.item({BMM_DEFINITIONS}.Metadata_schema_name),
     *   meta_data.item({BMM_DEFINITIONS}.Metadata_model_release)\`
     * 
     * e.g. \`openehr_rm_1.0.3\`, \`openehr_test_1.0.1\`, \`iso_13606_1_2008_2.1.2\`.
     */
    schema_id?: string;
    /**
     * Table of \`{key, value}\` of schema meta-data, keys are string values defined by \`{BMM_DEFINITIONS}.Metadata_*\` constants.
     */
    meta_data?: undefined;
    /**
     * Identifiers of schemas included by this schema.
     */
    includes?: undefined;
}

/**
 * Abstract parent of any persistable form of a BMM model, e.g. \`P_BMM_SCHEMA\`.
 */
export class BMM_SCHEMA {
    /**
     * Version of BMM model, enabling schema evolution reasoning. Persisted attribute.
     */
    bmm_version?: string;
    /**
     * Inclusion list of any form of BMM model, in the form of a hash of individual include specifications, each of which at least specifies the id of another schema, and may specify a namespace via which types from the included schemas are known in this schema.
     * Persisted attribute.
     */
    includes?: undefined;
    /**
     * Generated by \`_create_bmm_model_\` from persisted elements.
     */
    bmm_model?: BMM_MODEL;
    /**
     * Current processing state.
     */
    state?: BMM_SCHEMA_STATE;
    /**
     * Name of this model, if this schema is a model root point. Not set for sub-schemas that are not considered models on their own.
     */
    model_name?: string;
    /**
     * Name of model expressed in schema; a 'schema' usually contains all of the packages of one 'model' of a publisher. A publisher with more than one model can have multiple schemas. 
     */
    schema_name?: string;
    /**
     * Revision of schema.
     */
    schema_revision?: string;
    /**
     * Schema development lifecycle state. 
     */
    schema_lifecycle_state?: string;
    /**
     * Primary author of schema. 
     */
    schema_author?: string;
    /**
     * Description of schema. 
     */
    schema_description?: string;
    /**
     * Contributing authors of schema. 
     */
    schema_contributors?: undefined;
}

/**
 * Schema inclusion structure.
 */
export class BMM_INCLUDE_SPEC {
    /**
     * Full identifier of the included schema, e.g. \`"openehr_primitive_types_1.0.2"\`.
     */
    id?: string;
}

export class BMM_SCHEMA_METADATA_KEY {
}

/**
 * Enumeration of processing states of a \`BMM_SCHEMA\` used by creation and validation routines in \`BMM_SCHEMA\`.
 */
export class BMM_SCHEMA_STATE {
}

/**
 * Abstract meta-type of BMM declared model elements. A _declaration_ is a an element of a model within a context, which defines the _scope_ of the element. Thus, a class definition and its property and routine definitions are model elements, but Types are not, since they are derived from model elements.
 */
export class BMM_MODEL_ELEMENT {
    /**
     * Name of this model element.
     */
    name?: string;
    /**
     * Optional documentation of this element, as a keyed list.
     * 
     * It is strongly recommended to use the following key /type combinations for the relevant purposes:
     * 
     * * \`"purpose": String\`
     * * \`"keywords": List<String>\`
     * * \`"use": String\`
     * * \`"misuse": String\`
     * * \`"references": String\`
     * 
     * Other keys and value types may be freely added.
     */
    documentation?: undefined;
    /**
     * Model element within which an element is declared.
     */
    scope?: BMM_MODEL_ELEMENT;
    /**
     * Optional meta-data of this element, as a keyed list. May be used to extend the meta-model.
     */
    extensions?: undefined;
}

/**
 * A formal element having a name, type and a type-based signature.
 */
export class BMM_FORMAL_ELEMENT {
    /**
     * Declared or inferred static type of the entity.
     */
    type?: BMM_TYPE;
    /**
     * True if this element can be null (Void) at execution time. May be interpreted as optionality in subtypes..
     */
    is_nullable?: boolean;
}

/**
 * An immutable, static value-returning element scoped to a class. The \`_value_\` is the result of the evaluation of the \`_generator_\`, which may be as simple as a literal value, or may be any expression, including a function call.
 */
export class BMM_CONSTANT {
    /**
     * Literal value of the constant.
     */
    generator?: BMM_LITERAL_VALUE;
}

/**
 * Meta-type of for properties of linear container type, such as List<T> etc.
 */
export class BMM_CONTAINER_PROPERTY {
    /**
     * Cardinality of this container.
     */
    cardinality?: Multiplicity_interval;
    /**
     * Declared or inferred static type of the entity.
     */
    type?: BMM_CONTAINER_TYPE;
}

/**
 * A formal element with signature of the form: \`name ({arg:TArg}*):TResult\`. A function is a computed (rather than data) element, generally assumed to be non-state-changing.
 */
export class BMM_FUNCTION {
    /**
     * Optional details enabling a function to be represented as an operator in a syntactic representation.
     */
    operator_definition?: BMM_OPERATOR;
    /**
     * Automatically created Result variable, usable in body and post-condition.
     */
    result?: BMM_RESULT;
}

/**
 * A routine local variable (writable).
 */
export class BMM_LOCAL {
}

/**
 * Definition of a symbolic operator associated with a function.
 */
export class BMM_OPERATOR {
    /**
     * Position of operator in syntactic representation.
     */
    position?: BMM_OPERATOR_POSITION;
    /**
     * Set of \`String\` symbols that may be used to represent this operator in a textual representation of a BMM model.
     */
    symbols?: undefined;
    /**
     * Formal name of the operator, e.g. 'minus' etc.
     */
    name?: string;
}

/**
 * Meta-type of a writable property definition within a class definition of an object model. The \`_is_composition_\` attribute indicates whether the property has sub-part or an association semantics with respect to the owning class.
 */
export class BMM_PROPERTY {
    /**
     * True if this property is marked with info model \`_im_runtime_\` property.
     */
    is_im_runtime?: boolean;
    /**
     * True if this property was marked with info model \`_im_infrastructure_\` flag.
     */
    is_im_infrastructure?: boolean;
    /**
     * True if this property instance is a compositional sub-part of the owning class instance. Equivalent to 'composition' in UML associations (but missing from UML properties without associations) and also 'cascade-delete' semantics in ER schemas.
     */
    is_composition?: boolean;
}

/**
 * A feature defining a routine, scoped to a class.
 */
export class BMM_ROUTINE {
    /**
     * Formal parameters of the routine.
     */
    parameters?: undefined;
    /**
     * Boolean conditions that must evaluate to True for the routine to execute correctly, May be used to generate exceptions if included in run-time build.
     * 
     * A False pre-condition implies an error in the passed parameters.
     */
    pre_conditions?: undefined;
    /**
     * Boolean conditions that will evaluate to True if the routine executed correctly, May be used to generate exceptions if included in run-time build.
     * 
     * A False post-condition implies an error (i.e. bug) in routine code.
     */
    post_conditions?: undefined;
    /**
     * Body of a routine, i.e. executable program.
     */
    definition?: BMM_ROUTINE_DEFINITION;
}

/**
 * A routine parameter variable (read-only).
 */
export class BMM_PARAMETER {
    /**
     * Optional read/write direction of the parameter. If none-supplied, the parameter is treated as \`in\`, i.e. readable.
     */
    direction?: BMM_PARAMETER_DIRECTION;
}

/**
 * A routine-scoped formal element.
 */
export class BMM_VARIABLE {
    /**
     * Routine within which variable is defined.
     */
    scope?: BMM_ROUTINE;
}

/**
 * A formal element with signature of the form: \`name ({arg:TArg}*):TStatus\`, where \`TStatus\` is the built-in type \`BMM_STATUS_TYPE\`.. A procedure is a computed (rather than data) element, generally assumed to be state-changing, and is usually called in the form \`name ({arg:TArg}*)\`.
 */
export class BMM_PROCEDURE {
    /**
     * Declared or inferred static type of the entity.
     */
    type?: BMM_STATUS_TYPE;
}

/**
 * Meta-type of for properties of unitary type.
 */
export class BMM_UNITARY_PROPERTY {
    /**
     * Declared or inferred static type of the entity.
     */
    type?: BMM_UNITARY_TYPE;
}

/**
 * Meta-type of for properties of linear container type, such as \`Hash<Index_type, T>\` etc.
 */
export class BMM_INDEXED_CONTAINER_PROPERTY {
    /**
     * Declared or inferred static type of the entity.
     */
    type?: BMM_INDEXED_CONTAINER_TYPE;
}

/**
 * Meta-type representing instantiable features, i.e. features that are created as value objects.
 */
export class BMM_INSTANTIABLE_FEATURE {
}

/**
 * Automatically declared variable representing result of a Function call (writable).
 */
export class BMM_RESULT {
    /**
     * Name of this model element.
     */
    name?: string;
}

/**
 * Abstract parent of feature extensions.
 */
export class BMM_FEATURE_EXTENSION {
}

/**
 * Abstract ancestor of routine body meta-types.
 */
export class BMM_ROUTINE_DEFINITION {
}

/**
 * External routine meta-type, containing sufficient meta-data to enable a routine in an external library to be called.
 */
export class BMM_EXTERNAL_ROUTINE {
    /**
     * External call general meta-data, including target routine name, type mapping etc.
     */
    meta_data?: undefined;
    /**
     * Optional argument-mapping meta-data.
     */
    argument_mapping?: undefined;
}

/**
 * A logical group of features, with a name and set of properties that applies to the group. 
 */
export class BMM_FEATURE_GROUP {
    /**
     * Name of this feature group; defaults to 'feature'.
     */
    name?: string;
    /**
     * Set of properties of this group, represented as name/value pairs. These are understood to apply logically to all of the features contained within the group.
     */
    properties?: undefined;
    /**
     * Set of features in this group.
     */
    features?: undefined;
    /**
     * Optional visibility to apply to all features in this group.
     */
    visibility?: BMM_VISIBILITY;
}

/**
 * Abstract parent of visibility representation.
 * 
 * TODO: define schemes; probably need to support C++/Java scheme as well as better type-based schemes.
 */
export class BMM_VISIBILITY {
}

/**
 * A module-scoped formal element.
 */
export class BMM_FEATURE {
    /**
     * True if this feature was synthesised due to generic substitution in an inherited type, or further constraining of a formal generic parameter.
     */
    is_synthesised_generic?: boolean;
    /**
     * Extensions to feature-level meta-types.
     */
    feature_extensions?: undefined;
    /**
     * Group containing this feature.
     */
    group?: BMM_FEATURE_GROUP;
    /**
     * Model element within which an element is declared.
     */
    scope?: BMM_CLASS;
}

/**
 * Meta-type for an automatically created variable referencing the current instance. Typically called 'self' or 'this' in programming languages. Read-only.
 */
export class BMM_SELF {
    /**
     * Name of this model element.
     */
    name?: string;
}

/**
 * Meta-type for writable variables, including the special variable \`Result\`.
 */
export class BMM_WRITABLE_VARIABLE {
}

/**
 * Meta-type for writable variables, including routine parameters and the special variable \`Self\`.
 */
export class BMM_READONLY_VARIABLE {
}

/**
 * Meta-type for static value properties computed once by a function invocation.
 */
export class BMM_SINGLETON {
    /**
     * Generator of the value of this static property.
     */
    generator?: BMM_ROUTINE_DEFINITION;
}

/**
 * Meta-type for static (i.e. read-only) properties.
 */
export class BMM_STATIC {
}

/**
 * Meta-type for locally declared routine body.
 */
export class BMM_LOCAL_ROUTINE {
    /**
     * Local variables of the routine, if there is a body defined.
     */
    locals?: undefined;
    /**
     * Body of routine declaration.
     */
    body?: BMM_STATEMENT_BLOCK;
}

/**
 * Enumeration of possible position of operator in a syntactic representation for operators associated with 1- and 2- degree functions.
 */
export class BMM_OPERATOR_POSITION {
}

/**
 * Enumeration of parameter read/write direction values.
 */
export class BMM_PARAMETER_DIRECTION {
}

/**
 * Meta-type for a literal Integer value, for which \`_type_\` is fixed to the \`BMM_TYPE\` representing \`Integer\` and \`_value_\` is of type \`Integer\`.
 */
export class BMM_INTEGER_VALUE {
    /**
     * Native Integer value.
     */
    value?: number;
}

/**
 * Meta-type for a literal String value, for which \`_type_\` is fixed to the \`BMM_TYPE\` representing \`String\` and \`_value_\` is of type \`String\`.
 */
export class BMM_STRING_VALUE {
    /**
     * Native String value.
     */
    value?: string;
}

/**
 * Meta-type for literal instance values declared in a model. Instance values may be inline values of primitive types in the usual fashion or complex objects in syntax form, e.g. JSON.
 */
export class BMM_LITERAL_VALUE {
    /**
     * A serial representation of the value.
     */
    value_literal?: string;
    /**
     * A native representation of the value, possibly derived by deserialising \`_value_literal_\`.
     */
    value?: any;
    /**
     * Optional specification of formalism of the \`_value_literal_\` attribute for complex values. Value may be any of \`json | json5 | yawl | xml | odin | rdf\` or another value agreed by the user community. If not set, \`json\` is assumed.
     */
    syntax?: string;
    /**
     * Concrete type of this literal.
     */
    type?: T;
}

/**
 * Meta-type for a literal Boolean value, for which \`_type_\` is fixed to the \`BMM_TYPE\` representing \`Boolean\` and \`_value_\` is of type \`Boolean\`.
 */
export class BMM_BOOLEAN_VALUE {
    /**
     * Native Boolean value.
     */
    value?: boolean;
}

/**
 * Meta-type for literals whose concrete type is a primitive type.
 */
export class BMM_PRIMITIVE_VALUE {
    /**
     * Concrete type of this literal.
     */
    type?: BMM_SIMPLE_TYPE;
}

/**
 * Meta-type for literals whose concrete type is a linear container type, i.e. array, list or set.
 */
export class BMM_CONTAINER_VALUE {
}

/**
 * Meta-type for literals whose concrete type is a unitary type in the BMM sense.
 */
export class BMM_UNITARY_VALUE {
}

/**
 * Meta-type for literals whose concrete type is an indexed container, i.e. Hash table, Map etc.
 */
export class BMM_INDEXED_CONTAINER_VALUE {
}

/**
 * Meta-type for literal intervals of type \`Interval<Ordered>\`.
 */
export class BMM_INTERVAL_VALUE {
}

/**
 * Definition of the root of a BMM model (along with what is inherited from \`BMM_SCHEMA_CORE\`).
 */
export class BMM_MODEL {
    /**
     * All classes in this model, keyed by type name.
     */
    class_definitions?: undefined;
    /**
     * List of other models 'used' (i.e. 'imported' by this model). Classes in the current model may refer to classes in a used model by specifying the other class's \`_scope_\` meta-attribute.
     */
    used_models?: undefined;
    /**
     * All classes in this model, keyed by type name.
     */
    modules?: undefined;
}

/**
 * Core properties of \`BMM_MODEL\`, may be used in a serial representation as well, such as \`P_BMM_SCHEMA\`.
 */
export class BMM_MODEL_METADATA {
    /**
     * Publisher of model expressed in the schema.
     */
    rm_publisher?: string;
    /**
     * Release of model expressed in the schema as a 3-part numeric, e.g. "3.1.0" .
     */
    rm_release?: string;
}

/**
 * Abstraction of a package as a tree structure whose nodes can contain other packages and classes.
 *
 * The \`_name_\` may be qualified if it is a top-level package.
 */
export class BMM_PACKAGE {
    /**
     * Member modules in this package.
     */
    members?: undefined;
}

/**
 * A BMM model component that contains packages and classes.
 */
export class BMM_PACKAGE_CONTAINER {
    /**
     * Child packages; keys all in upper case for guaranteed matching.
     */
    packages?: undefined;
    /**
     * Model element within which a referenceable element is known.
     */
    scope?: BMM_PACKAGE_CONTAINER;
}

/**
 * Binary operator expression node.
 */
export class EL_BINARY_OPERATOR {
    /**
     * Left operand node.
     */
    left_operand?: EL_EXPRESSION;
    /**
     * Right operand node.
     */
    right_operand?: EL_EXPRESSION;
}

/**
 * Abstract parent of all typed expression meta-types.
 */
export class EL_EXPRESSION {
}

/**
 * Literal value of any type known in the model, including primitive types. Defined via a \`BMM_LITERAL_VALUE\`.
 */
export class EL_LITERAL {
    /**
     * The reference item from which the value of this node can be computed.
     */
    value?: undefined;
}

/**
 * Abstract parent of operator types.
 */
export class EL_OPERATOR {
    /**
     * True if the natural precedence of operators is overridden in the expression represented by this node of the expression tree. If True, parentheses should be introduced around the totality of the syntax expression corresponding to this operator node and its operands.
     */
    precedence_overridden?: boolean;
    /**
     * The symbol actually used in the expression, or intended to be used for serialisation. Must be a member of \`OPERATOR_DEF._symbols_\`.
     */
    symbol?: string;
    /**
     * Function call equivalent to this operator expression, inferred by matching operator against functions defined in interface of principal operand.
     */
    call?: EL_FUNCTION_CALL;
}

/**
 * Unary operator expression node.
 */
export class EL_UNARY_OPERATOR {
    /**
     * Operand node.
     */
    operand?: EL_EXPRESSION;
}

/**
 * Reference to a writable property.
 */
export class EL_PROPERTY_REF {
    /**
     * Property definition (within class).
     */
    definition?: BMM_PROPERTY;
    /**
     * Defined to return True.
     */
    is_writable?: boolean;
}

/**
 * Parent type of predicate of any object reference.
 */
export class EL_PREDICATE {
    /**
     * The target instance of this predicate.
     */
    operand?: EL_VALUE_GENERATOR;
}

/**
 * A predicate taking one external variable reference argument, that returns true if the reference is resolvable, i.e. the external value is obtainable.
 * 
 * NOTE: probably to be removed.
 */
export class EL_DEFINED {
}

/**
 * A call made on a closed function agent, returning a result. Equivalent to an 'application' of a function in Lambda calculus.
 */
export class EL_FUNCTION_CALL {
    /**
     * The function agent being called.
     */
    agent?: EL_FUNCTION_AGENT;
    /**
     * Defined to return False.
     */
    is_writable?: boolean;
}

/**
 * A call made to a 'closed' agent, i.e. one with no remaining open arguments.
 */
export class EL_AGENT_CALL {
    /**
     * The agent being called.
     */
    agent?: EL_AGENT;
}

/**
 * A delayed routine call, whose arguments may be open, partially closed or closed. Generated by special reference to a routine, usually via a dedicated keyword, such as 'lambda' or 'agent', or other special syntax.
 * 
 * Instances may include closed delayed calls like \`calculate_age (dob="1987-09-13", today="2019-06-03")\` but also partially open calls such as \`format_structure (struct=?, style=3)\`, where \`struct\` is an open argument.
 * 
 * Evaluation type (i.e. type of runtime evaluated form) is \`BMM_SIGNATURE\`.
 */
export class EL_AGENT {
    /**
     * Name of the routine being called.
     */
    name?: string;
    /**
     * Closed arguments of a routine call as a tuple of objects.
     */
    closed_args?: EL_TUPLE;
    /**
     * Optional list of names of open arguments of the call. If not provided, and the \`_name_\` refers to a routine with more arguments than supplied in \`_closed_args_\`, the missing arguments are inferred from the \`_definition_\`.
     */
    open_args?: undefined;
    /**
     * Reference to definition of a routine for which this is an agent, if one exists. 
     */
    definition?: BMM_ROUTINE;
    is_writable?: boolean;
}

/**
 * A single tuple item, with an optional name.
 */
export class EL_TUPLE_ITEM {
    /**
     * Reference to value entity. If Void, this indicates that the item in this position is Void, e.g. within a routine call parameter list.
     */
    item?: EL_EXPRESSION;
    /**
     * Optional name of tuple item.
     */
    name?: string;
}

/**
 * An agent whose signature is of a procedure, i.e. has no result type.
 */
export class EL_PROCEDURE_AGENT {
    /**
     * Reference to definition of routine for which this is a call instance.
     */
    definition?: BMM_PROCEDURE;
}

/**
 * Defines an array of optionally named items each of any type.
 */
export class EL_TUPLE {
    /**
     * Items in the tuple, potentially with names. Typical use is to represent an argument list to routine call.
     */
    items?: undefined;
    /**
     * Static type inferred from literal value.
     */
    type?: BMM_TUPLE_TYPE;
}

/**
 * An agent whose signature is of a function, i.e. has a result type.
 */
export class EL_FUNCTION_AGENT {
    /**
     * Reference to definition of a routine for which this is a direct call instance, if one exists. 
     */
    definition?: BMM_FUNCTION;
}

/**
 * A predicate on any object reference (including function call) that returns True if the reference is attached, i.e. non-Void.
 */
export class EL_ATTACHED {
}

/**
 * Meta-type representing a value-generating simple expression.
 */
export class EL_VALUE_GENERATOR {
    is_writable?: boolean;
    /**
     * Name used to represent the reference or other entity.
     */
    name?: string;
}

/**
 * Boolean-returning expression.
 */
export class EL_BOOLEAN_EXPRESSION {
}

/**
 * Meta-type for reference to a non-abstract type as an object. Assumed to be accessible at run-time. Typically represented syntactically as \`TypeName\` or \`{TypeName}\`.
 * 
 * May be used as a value, or as the qualifier for a function or constant access.
 */
export class EL_TYPE_REF {
    /**
     * Type, directly from the name of the reference, e.g. \`{SOME_TYPE}\`.
     */
    type?: BMM_TYPE;
    is_mutable?: boolean;
}

/**
 * A reference that is scoped by a containing entity and requires a context qualifier if it is not the currently scoping entity.
 */
export class EL_FEATURE_REF {
    /**
     * Scoping expression, which must be a \`EL_VALUE_GENERATOR\`.
     */
    scoper?: EL_VALUE_GENERATOR;
}

/**
 * Conditional structure used in condition chain expressions. Evaluated by evaluating its \`_condition_\`, which is a Boolean-returning expression, and if this returns True, the result is the evaluation result of \`_expression_\`.
 */
export class EL_CONDITIONAL_EXPRESSION {
    /**
     * Boolean expression defining the condition of this decision branch.
     */
    condition?: EL_EXPRESSION;
}

/**
 * Compound expression consisting of a chain of condition-gated expressions, and an ungated \`_else_\` member that as a whole, represents an if/then/elseif/else chains.
 *
 * Evaluated by iterating through \`_items_\` and for each one, evaluating its \`_condition_\`, which if True, causes the evaluation result of the chain to be that item's \`_result_\` evaluation result.
 *
 * If no member of \`_items_\` has a True-returning \`_condition_\`, the evaluation result is the result of evaluating the \`_else_\` expression.
 */
export class EL_CONDITION_CHAIN {
    /**
     * Members of the chain, equivalent to branches in an if/then/else chain and cases in a case statement.
     */
    items?: undefined;
}

/**
 * Abstract parent for second-order constrained forms of first-order expression meta-types.
 */
export class EL_CONSTRAINED {
    /**
     * The base expression of this constrained form.
     */
    base_expression?: EL_EXPRESSION;
}

/**
 * Compound expression consisting of a list of value-range / expression pairs, and an  \`_else_\` member that as a whole, represents a case statement flavour of decision table.
 * 
 * Evaluated by iterating through \`_items_\` and for each one, comparing \`_input_\` to the item \`_value_range_\`. If the \`_input_\` is in the range, the evaluation result of the table is that item's \`_result_\` evaluation result.
 * 
 * If no member of \`_items_\` has a True-returning \`_condition_\`, the evaluation result is the result of evaluating the \`_else_\` expression.
 */
export class EL_CASE_TABLE {
    /**
     * Members of the chain, equivalent to branches in an if/then/else chain and cases in a case statement.
     */
    items?: undefined;
    /**
     * Expressing generating the input value for the case table.
     */
    test_value?: EL_VALUE_GENERATOR;
}

/**
 * One branch of a Case table, consisting of a value constraint (the match criterion) and a result, of the generic parameter type T.
 */
export class EL_CASE {
    /**
     * Constraint on
     */
    value_constraint?: C_OBJECT;
}

/**
 * Meta-type for decision tables. Generic on the meta-type of the \`_result_\` attribute of the branches, to allow specialised forms of if/else and case structures to be created.
 */
export class EL_DECISION_TABLE {
    /**
     * Members of the chain, equivalent to branches in an if/then/else chain and cases in a case statement.
     */
    items?: undefined;
    /**
     * Result expression of conditional, if its \`_condition_\` evaluates to True.
     */
    else?: T;
}

/**
 * Abstract parent of meta-types representing a branch of some kind of decision structure. Defines \`result\` as being of the generic type \`T\`.
 */
export class EL_DECISION_BRANCH {
    /**
     * Result expression of conditional, if its \`_condition_\` evaluates to True.
     */
    result?: T;
}

/**
 * Abstract meta-type of any kind of symbolic variable.
 */
export class EL_VARIABLE {
}

/**
 * Expression entities that are terminals (i.e. leaves) within operator expressions or tuples.
 */
export class EL_TERMINAL {
}

/**
 * Simple terminal i.e. logically atomic expression element.
 */
export class EL_SIMPLE {
}

/**
 * Reference to a writable property, either a constant or computed.
 */
export class EL_STATIC_REF {
    /**
     * Constant definition (within class).
     */
    definition?: BMM_STATIC;
    /**
     * Defined to return False.
     */
    is_writable?: boolean;
}

/**
 * Meta-type of writable variables, including routine locals and the special variable 'Result'.
 */
export class EL_WRITABLE_VARIABLE {
    /**
     * Variable definition to which this reference refers.
     */
    definition?: BMM_WRITABLE_VARIABLE;
    /**
     * Defined to return True in all cases.
     */
    is_writable?: boolean;
}

/**
 * Meta-type of read-only variables, including routine parameter and the special variable 'Self'.
 */
export class EL_READONLY_VARIABLE {
    /**
     * Variable definition to which this reference refers.
     */
    definition?: BMM_READONLY_VARIABLE;
    /**
     * Defined to return False in all cases.
     */
    is_writable?: boolean;
}

/**
 * Specialised form of Decision Table that allows only procedure call agents (lambdas) as the result of branches.
 */
export class BMM_ACTION_DECISION_TABLE {
}

/**
 * Multi-branch conditional statement structure
 */
export class BMM_ACTION_TABLE {
    /**
     * A specialised decision table whose outputs can only be procedure agents. In execution, the matched agent will be invoked.
     */
    decision_table?: BMM_ACTION_DECISION_TABLE;
}

/**
 * Statement type representing an assignment from a value-generating source to a writable entity, i.e. a variable reference or property.
 * 
 * At the meta-model level, may be understood as an initialisation of an existing meta-model instance.
 */
export class BMM_ASSIGNMENT {
    /**
     * The target variable on the notional left-hand side of this assignment.
     */
    target?: EL_VALUE_GENERATOR;
    /**
     * Source right hand side) of the assignment.
     */
    source?: EL_EXPRESSION;
}

/**
 * A statement that asserts the truth of its expression. If the expression evaluates to False the execution generates an exception (depending on run-time settings).
 * 
 * May be rendered in syntax as \`assert condition\` or similar.
 */
export class BMM_ASSERTION {
    /**
     * Boolean-valued expression of the assertion.
     */
    expression?: EL_BOOLEAN_EXPRESSION;
    /**
     * Optional tag, typically used to designate design intention of the assertion, e.g. \`"Inv_all_members_valid"\`.
     */
    tag?: string;
}

/**
 * A call made on a closed procedure agent. The method in BMM via which external actions are achieved from within a program.
 */
export class BMM_PROCEDURE_CALL {
    /**
     * The procedure agent being called.
     */
    agent?: EL_PROCEDURE_AGENT;
}

/**
 * Abstract parent of statement types representing a locally defined routine body.
 */
export class BMM_STATEMENT_ITEM {
}

/**
 * Abstract parent of 'statement' types that may be defined to implement BMM Routines.
 */
export class BMM_STATEMENT {
}

/**
 * A statement 'block' corresponding to the programming language concept of the same name. May be used to establish scope in specific languages.
 */
export class BMM_STATEMENT_BLOCK {
    /**
     * Child blocks of the current block.
     */
    items?: undefined;
}

/**
 * Simple statement, i.e. statement with one logical element - a single expression, procedure call etc.
 */
export class BMM_SIMPLE_STATEMENT {
}

/**
 * Declaration of a writable variable, associating a name with a type.
 */
export class BMM_DECLARATION {
    name?: string;
    result?: EL_WRITABLE_VARIABLE;
    /**
     * The declared type of the variable.
     */
    type?: BMM_TYPE;
}

/**
 * Definition of persistent form of \`BMM_CLASS\` for serialisation to ODIN, JSON, XML etc.
 */
export class P_BMM_CLASS {
    /**
     * Name of the class. Persisted attribute.
     */
    name?: string;
    /**
     * List of immediate inheritance parents. If there are generic ancestors, use \`_ancestor_defs_\` instead. Persisted attribute.
     */
    ancestors?: undefined;
    /**
     * List of attributes defined in this class. Persistent attribute.
     */
    properties?: undefined;
    /**
     * True if this is an abstract type. Persisted attribute.
     */
    is_abstract?: boolean;
    /**
     * True if this class definition overrides one found in an included schema.
     */
    is_override?: boolean;
    /**
     * List of generic parameter definitions. Persisted attribute.
     */
    generic_parameter_defs?: undefined;
    /**
     * Reference to original source schema defining this class. Set during \`BMM_SCHEMA\` materialise. Useful for GUI tools to enable user to edit the schema file containing a given class (i.e. taking into account that a class may be in any of the schemas in a schema inclusion hierarchy).
     */
    source_schema_id?: string;
    /**
     * \`BMM_CLASS\` object built by \`_create_bmm_class_definition_\` and \`_populate_bmm_class_definition_\`.
     */
    bmm_class?: BMM_CLASS;
    /**
     * Unique id generated for later comparison during merging, in order to detect if two classes are the same. Assigned in post-load processing.
     */
    uid?: number;
    /**
     * List of structured inheritance ancestors, used only in the case of generic inheritance. Persisted attribute.
     */
    ancestor_defs?: undefined;
}

/**
 * Persistent form of \`BMM_ENUMERATION\` attributes.
 */
export class P_BMM_ENUMERATION {
    item_names?: undefined;
    item_values?: undefined;
    /**
     * \`BMM_CLASS\` object build by \`_create_bmm_class_definition_\` and \`_populate_bmm_class_definition_\`.
     */
    bmm_class?: BMM_ENUMERATION;
}

/**
 * Persisted form of \`BMM_SCHEMA\`.
 */
export class P_BMM_SCHEMA {
    /**
     * Primitive type definitions. Persisted attribute.
     */
    primitive_types?: undefined;
    /**
     * Class definitions. Persisted attribute.
     */
    class_definitions?: undefined;
}

/**
 * Persistent form of \`BMM_PROPERTY\`.
 */
export class P_BMM_PROPERTY {
    /**
     * Name of this property within its class. Persisted attribute.
     */
    name?: string;
    /**
     * True if this property is mandatory in its class. Persisted attribute.
     */
    is_mandatory?: boolean;
    /**
     * True if this property is computed rather than stored in objects of this class. Persisted Attribute.
     */
    is_computed?: boolean;
    /**
     * True if this property is info model 'infrastructure' rather than 'data'. Persisted attribute.
     */
    is_im_infrastructure?: boolean;
    /**
     * True if this property is info model 'runtime' settable property. Persisted attribute.
     */
    is_im_runtime?: boolean;
    /**
     * Type definition of this property, if not a simple String type reference. Persisted attribute.
     */
    type_def?: P_BMM_TYPE;
    /**
     * BMM_PROPERTY created by create_bmm_property_definition.
     */
    bmm_property?: BMM_PROPERTY;
}

/**
 * Persistent form of \`BMM_GENERIC_PARAMETER\`.
 */
export class P_BMM_GENERIC_PARAMETER {
    /**
     * Name of the parameter, e.g. 'T' etc. Persisted attribute. Name is limited to 1 character, upper case.
     */
    name?: string;
    /**
     * Optional conformance constraint - the name of a type to which a concrete substitution of this generic parameter must conform. Persisted attribute.
     */
    conforms_to_type?: string;
    /**
     * \`BMM_GENERIC_PARAMETER\` created by \`_create_bmm_generic_parameter_\`.
     */
    bmm_generic_parameter?: BMM_PARAMETER_TYPE;
}

/**
 * Persistent form of \`BMM_TYPE\`.
 */
export class P_BMM_TYPE {
    /**
     * Result of \`_create_bmm_type()_\` call.
     */
    bmm_type?: BMM_TYPE;
}

/**
 * Persistent form of \`BMM_CONTAINER_TYPE\`.
 */
export class P_BMM_CONTAINER_TYPE {
    /**
     * The type of the container. This converts to the \`_root_type_\` in \`BMM_GENERIC_TYPE\`. Persisted attribute.
     */
    container_type?: string;
    /**
     * Type definition of \`_type_\`, if not a simple String type reference. Persisted attribute.
     */
    type_def?: P_BMM_BASE_TYPE;
    /**
     * The target type; this converts to the first parameter in \`_generic_parameters_\` in \`BMM_GENERIC_TYPE\`. Persisted attribute.
     */
    type?: string;
    /**
     * Result of \`_create_bmm_type()_\` call.
     */
    bmm_type?: BMM_CONTAINER_TYPE;
}

/**
 * Persistent form of \`BMM_SIMPLE_TYPE\`.
 */
export class P_BMM_SIMPLE_TYPE {
    /**
     * Name of type - must be a simple class name.
     */
    type?: string;
    /**
     * Result of \`_create_bmm_type()_\` call.
     */
    bmm_type?: BMM_SIMPLE_TYPE;
}

/**
 * Persistent form of \`BMM_PARAMETER_TYPE\`.
 */
export class P_BMM_OPEN_TYPE {
    /**
     * Simple type parameter as a single letter like 'T', 'G' etc.
     */
    type?: string;
    /**
     * Result of \`_create_bmm_type()_\` call.
     */
    bmm_type?: any;
}

/**
 * Persistent form of \`BMM_GENERIC_TYPE\`.
 */
export class P_BMM_GENERIC_TYPE {
    /**
     * Root type of this generic type, e.g. \`Interval\` in \`Interval<Integer>\`.
     */
    root_type?: string;
    /**
     * Generic parameters of the root_type in this type specifier if non-simple types. The order must match the order of the owning class's formal generic parameter declarations. Persistent attribute.
     */
    generic_parameter_defs?: undefined;
    /**
     * Generic parameters of the \`_root_type_\` in this type specifier, if simple types. The order must match the order of the owning class's formal generic parameter declarations. Persistent attribute.
     */
    generic_parameters?: undefined;
    /**
     * Result of \`_create_bmm_type()_\` call.
     */
    bmm_type?: BMM_GENERIC_TYPE;
}

/**
 * Persisted form of a package as a tree structure whose nodes can contain more packages and/or classes.
 */
export class P_BMM_PACKAGE {
    /**
     * Name of the package from schema; this name may be qualified if it is a top-level package within the schema, or unqualified. Persistent attribute.
     */
    name?: string;
    /**
     * List of classes in this package. Persistent attribute.
     */
    classes?: undefined;
    /**
     * \`BMM_PACKAGE\` created by \`_create_bmm_package_definition_\`.
     */
    bmm_package_definition?: BMM_PACKAGE;
}

/**
 * Persisted form of a model component that contains packages.
 */
export class P_BMM_PACKAGE_CONTAINER {
    /**
     * Package structure as a hierarchy of packages each potentially containing names of classes in that package in the original model.
     */
    packages?: undefined;
}

/**
 * Persistent form of \`BMM_CONTAINER_PROPERTY\`.
 */
export class P_BMM_CONTAINER_PROPERTY {
    /**
     * Cardinality of this property in its class. Persistent attribute.
     */
    cardinality?: undefined;
    /**
     * Type definition of this property, if not a simple String type reference. Persistent attribute.
     */
    type_def?: P_BMM_CONTAINER_TYPE;
    /**
     * \`BMM_PROPERTY\` created by \`_create_bmm_property_\`.
     */
    bmm_property?: BMM_CONTAINER_PROPERTY;
}

/**
 * Persistent form of \`BMM_SINGLE_PROPERTY\`.
 */
export class P_BMM_SINGLE_PROPERTY {
    /**
     * If the type is a simple type, then this attribute will hold the type name. If the type is a container or generic, then type_ref will hold the type definition. The resulting type is generated in type_def.
     */
    type?: string;
    /**
     * Type definition of this property computed from \`_type_\` for later use in \`_bmm_property_\`.
     */
    type_ref?: P_BMM_SIMPLE_TYPE;
    /**
     * \`BMM_PROPERTY\` created by \`_create_bmm_property_definition_\`.
     */
    bmm_property?: BMM_UNITARY_PROPERTY;
}

/**
 * Persistent form of a \`BMM_SINGLE_PROPERTY_OPEN\`.
 */
export class P_BMM_SINGLE_PROPERTY_OPEN {
    /**
     * Type definition of this property computed from \`_type_\` for later use in \`_bmm_property_\`.
     */
    type_ref?: P_BMM_OPEN_TYPE;
    /**
     * Type definition of this property, if a simple String type reference. Really we should use \`_type_def_\` to be regular in the schema, but that makes the schema more wordy and less clear. So we use this persisted String value, and compute the \`_type_def_\` on the fly. Persisted attribute.
     */
    type?: string;
    /**
     * \`BMM_PROPERTY\` created by \`_create_bmm_property_definition_\`.
     */
    bmm_property?: BMM_UNITARY_PROPERTY;
}

/**
 * Persistent form of \`BMM_GENERIC_PROPERTY\`.
 */
export class P_BMM_GENERIC_PROPERTY {
    /**
     * Type definition of this property, if not a simple String type reference. Persistent attribute.
     */
    type_def?: P_BMM_GENERIC_TYPE;
    /**
     * \`BMM_PROPERTY\` created by \`_create_bmm_property_definition_\`.
     */
    bmm_property?: BMM_UNITARY_PROPERTY;
}

/**
 * Persistent form of an instance of \`BMM_ENUMERATION_INTEGER\`.
 */
export class P_BMM_ENUMERATION_INTEGER {
    /**
     * \`BMM_CLASS\` object build by \`_create_bmm_class_definition_\` and \`_populate_bmm_class_definition_\`.
     */
    bmm_class?: BMM_ENUMERATION_INTEGER;
}

/**
 * Persistent form of \`BMM_ENUMERATION_STRING\`.
 */
export class P_BMM_ENUMERATION_STRING {
    /**
     * \`BMM_CLASS\` object build by \`_create_bmm_class_definition_\` and \`_populate_bmm_class_definition_\`.
     */
    bmm_class?: BMM_ENUMERATION_STRING;
}

/**
 * Persistent form of \`BMM_MODEL_ELEMENT\`.
 */
export class P_BMM_MODEL_ELEMENT {
    /**
     * Optional documentation of this element.
     */
    documentation?: string;
}

/**
 * Persistent form of \`BMM_PROPER_TYPE\`.
 */
export class P_BMM_BASE_TYPE {
    value_constraint?: string;
}

/**
 * Concrete descendant of \`BMM_SCHEMA_DESCRIPTOR\` that provides a way to read an ODIN or other similarly encoded P_BMM schema file.
 */
export class P_BMM_SCHEMA_DESCRIPTOR {
    /**
     * Persistent form of model.
     */
    bmm_schema?: P_BMM_SCHEMA;
}

export class P_BMM_INDEXED_CONTAINER_PROPERTY {
    /**
     * Type definition of this property, if not a simple String type reference. Persistent attribute.
     */
    type_def?: P_BMM_INDEXED_CONTAINER_TYPE;
    /**
     * \`BMM_PROPERTY\` created by \`_create_bmm_property_\`.
     */
    bmm_property?: BMM_INDEXED_CONTAINER_PROPERTY;
}

export class P_BMM_INDEXED_CONTAINER_TYPE {
    index_type?: string;
    /**
     * Result of \`_create_bmm_type()_\` call.
     */
    bmm_type?: BMM_INDEXED_CONTAINER_TYPE;
}

/**
 * Meta-type for a first order predicate logic expression with a Boolean result.
 */
export class ASSERTION {
    /**
     * Expression tag, used for differentiating multiple assertions.
     */
    tag?: string;
    /**
     * String form of expression, in case an expression evaluator taking String expressions is used for evaluation.
     */
    string_expression?: string;
    /**
     * Root of expression tree.
     */
    expression?: EXPRESSION;
}

/**
 * Meta-type representing the assignment statement, which associates a named variable with an expression, and produces no value.
 */
export class ASSIGNMENT {
    /**
     * The target variable on the notional left-hand side of this assignment.
     */
    target?: VARIABLE_DECLARATION;
    /**
     * Source right hand side) of the assignment.
     */
    source?: EXPR_VALUE;
}

/**
 * Binary operator expression node.
 */
export class EXPR_BINARY_OPERATOR {
    /**
     * Left operand node.
     */
    left_operand?: EXPRESSION;
    /**
     * Right operand node.
     */
    right_operand?: EXPRESSION;
}

/**
 * Node representing a function call with 0 or more arguments.
 */
export class EXPR_FUNCTION_CALL {
    /**
     * Arguments of this function, which can be from 0 to any number. Functions with no arguments are typically used to represent real world varying values like 'current time' and so on.
     */
    arguments?: undefined;
}

/**
 * Abstract parent of all expression meta-types.
 */
export class EXPRESSION {
}

/**
 * Meta-type representing one of:
 * 
 * * a manifest constant of any primitive type;
 * * a path referring to a value in the archetype;
 * * a constraint;
 * * a variable reference.
 * 
 */
export class EXPR_LEAF {
    /**
     * The reference item from which the value of this node can be computed.
     */
    item?: any;
}

/**
 * Literal value expression tree leaf item. This can represent a literal value of any primitive type included in the \`PRIMITIVE_TYPE\` enumeration.
 */
export class EXPR_LITERAL {
    /**
     * A statically set constant value of a primitive type.
     */
    item?: any;
}

/**
 * Abstract parent of operator types.
 */
export class EXPR_OPERATOR {
    /**
     * True if the natural precedence of operators is overridden in the expression represented by this node of the expression tree. If True, parentheses should be introduced around the totality of the syntax expression corresponding to this operator node and its operands.
     */
    precedence_overridden?: boolean;
    /**
     * Operator definition.
     */
    operator?: OPERATOR_KIND;
    /**
     * The symbol actually used in the rule, or intended to be used for serialisation. Must be a member of \`operator_def.symbols\`.
     */
    symbol?: string;
}

/**
 * Unary operator expression node.
 */
export class EXPR_UNARY_OPERATOR {
    /**
     * Operand node.
     */
    operand?: EXPRESSION;
}

/**
 * Expression tree leaf item representing a reference to a declared variable.
 */
export class EXPR_VARIABLE_REF {
    /**
     * The variable referred to.
     */
    item?: VARIABLE_DECLARATION;
}

/**
 * Definition of a variable whose value is derived from a query run on a data context in the operational environment. Typical uses of this kind of variable are to obtain values like the patient date of birth, sex, weight, and so on. It could also be used to obtain items from a knowledge context, such as a drug database.
 */
export class EXTERNAL_QUERY {
    /**
     * Optional name of context. This allows a basic separation of query types to be done in more sophisticated environments. Possible values might be “patient”, “medications” and so on.
     * Not yet standardised.
     * 
     */
    context?: string;
    /**
     * Identifier of query in the external context, e.g. “date_of_birth”.
     * Not yet standardised.
     * 
     */
    query_id?: string;
    /**
     * Optional arguments to query.
     * Not yet standardised.
     * 
     */
    query_args?: undefined;
}

/**
 * Any kind of statement element that can be evaluated. The type will either be supplied in descendant types or else will be inferred by an assignment statement linked to a typed variable.
 */
export class EXPR_VALUE {
}

/**
 * A container for a specific set of statements intended to be used together.
 */
export class STATEMENT_SET {
    /**
     * The member statements of this statement set.
     */
    statement?: undefined;
    /**
     * Optional name of this rule set.
     */
    name?: string;
}

/**
 * Meta-type for the notion of statement, which is a non-value-returning entity.
 */
export class STATEMENT {
}

/**
 * Meta-type for the declaration of a named variable that can be used in an expression.
 */
export class VARIABLE_DECLARATION {
    /**
     * Name of the variable.
     */
    name?: string;
    /**
     * Primitive type of the variable, enabling its use to be type-checked in expressions.
     */
    type?: EXPR_TYPE_DEF;
}

/**
 * Path-based reference to a value in a data structure.
 */
export class EXPR_VALUE_REF {
}

/**
 * Universal quantification operator, usually known as \`for_all\`, whose operand is a collection of items referenced by an \`EXPR_VALUE_REF\`. The \`_condition_\` attribute represents an assertion that is applied to every member of the collection at runtime to determine the result.
 */
export class EXPR_FOR_ALL {
    /**
     * Boolean condition that returns True or False when applied to a member of the operand of a \`for_all\` operator.
     */
    condition?: ASSERTION;
    /**
     * Reference to collection / container object to which the \`for_all\` operator is to be applied.
     */
    operand?: EXPR_VALUE_REF;
}

/**
 * Enumeration representing operators.
 */
export class OPERATOR_KIND {
}

/**
 * Ancestor class for type definitions known in the openEHR Expression formalism.
 */
export class EXPR_TYPE_DEF {
    /**
     * Natural language type name of this type as used in abstract rules syntax variable declarations.
     */
    type_name?: string;
    /**
     * Attribute of the openEHR primitive type (or Any) corresponding to this type definition meta-type.
     */
    type_anchor?: any;
}

/**
 * Rules meta-type representing the primitive type Boolean.
 */
export class TYPE_DEF_BOOLEAN {
    type_name?: string;
    type_anchor?: boolean;
}

/**
 * Rules meta-type representing the primitive type Date.
 */
export class TYPE_DEF_DATE {
    type_name?: string;
    type_anchor?: Iso8601_date;
}

/**
 * Rules meta-type representing the primitive type Date_time.
 */
export class TYPE_DEF_DATE_TIME {
    type_name?: string;
    type_anchor?: Iso8601_date_time;
}

/**
 * Rules meta-type representing the primitive type Duration.
 */
export class TYPE_DEF_DURATION {
    type_name?: string;
    type_anchor?: Iso8601_duration;
}

/**
 * Rules meta-type representing the primitive type Integer.
 */
export class TYPE_DEF_INTEGER {
    type_name?: string;
    type_anchor?: number;
}

/**
 * Rules meta-type representing the type Object_ref, which is assumed to by the type of any non-primitive reference target within a rule.
 */
export class TYPE_DEF_OBJECT_REF {
    type_name?: string;
}

/**
 * Rules meta-type representing the primitive type Real.
 */
export class TYPE_DEF_REAL {
    type_name?: string;
    type_anchor?: number;
}

/**
 * Rules meta-type representing the primitive type String.
 */
export class TYPE_DEF_STRING {
    type_name?: string;
    type_anchor?: string;
}

/**
 * Rules meta-type representing the primitive type Terminology_code.
 */
export class TYPE_DEF_TERMINOLOGY_CODE {
    type_name?: string;
    type_anchor?: Terminology_code;
}

/**
 * Rules meta-type representing the primitive type Time.
 */
export class TYPE_DEF_TIME {
    type_name?: string;
    type_anchor?: Iso8601_time;
}

/**
 * Rules meta-type representing the primitive type Uri.
 */
export class TYPE_DEF_URI {
    type_name?: string;
    type_anchor?: string;
}

